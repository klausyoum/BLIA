<?xml version="1.0" encoding="ISO-8859-1"?>
<bugrepository>
<bug id="28919" transactionid="71719">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="27"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="28"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-break K-catch K-for K-if K-instanceof K-null K-true K-try K-while M O-&lt; O-== O-|| O-!= O-() O-++ O-instanceof T V Y Z-for Z-if Z-vardecl Z-while</fullfingerprint>
<bugreport>If you don't find the exception below in a bug, please add a new bug
To make the bug a priority, please include a test program
that can reproduce this exception.
bad non-abstract method with no code: private native int 
nativeMessagePumpInitialize() on public class 
plc.comm.pvi.PviCom$LinkEventHandlerImpl
bad non-abstract method with no code: private native int 
nativeMessagePumpInitialize() on public class 
plc.comm.pvi.PviCom$LinkEventHandlerImpl
java.lang.RuntimeException: bad non-abstract method with no code: private 
native int nativeMessagePumpInitialize() on public class 
plc.comm.pvi.PviCom$LinkEventHandlerImpl
        at org.aspectj.weaver.bcel.LazyMethodGen.&lt;init&gt;(Unknown Source)
        at org.aspectj.weaver.bcel.LazyClassGen.&lt;init&gt;(Unknown Source)
        at org.aspectj.weaver.bcel.BcelObjectType.getLazyClassGen(Unknown 
Source)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles
(Unknown Source)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(Unknown Source)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source)
        at org.aspectj.tools.ajc.Main.run(Unknown Source)
        at org.aspectj.tools.ajc.Main.runMain(Unknown Source)
        at org.aspectj.tools.ajc.Main.main(Unknown Source)</bugreport>
<pre-fix-testcases failing="25" file="output/28919/pre-fix/testresults.xml" passing="670" size="695"/>
<post-fix-testcases failing="25" file="output/28919/post-fix/testresults.xml" passing="670" size="695"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java" revision="1.6" state="changed">103c103
&lt;         if (!m.isAbstract() &amp;&amp; m.getCode() == null) {
---
&gt;         if (!(m.isAbstract() || m.isNative()) &amp;&amp; m.getCode() == null) {
350a351
&gt;         	killNops();
409a411
&gt; 
636a639
&gt;     	//killNops();
670c673
&lt;          * a 1:1 mapping.  
---
&gt;          * a 1:1 mapping.
806a810
&gt; 
808a813,835
&gt; 
&gt; 	public void killNops() {
&gt;     	InstructionHandle curr = body.getStart();
&gt;     	while (true) {
&gt; 			if (curr == null) break;
&gt; 			InstructionHandle next = curr.getNext();
&gt;     		if (curr.getInstruction() instanceof NOP) {
&gt;     			InstructionTargeter[] targeters = curr.getTargeters();
&gt;     			if (targeters != null) {
&gt;     				for (int i = 0, len = targeters.length; i &lt; len; i++) {
&gt; 						InstructionTargeter targeter = targeters[i];
&gt; 						targeter.updateTarget(curr, next);
&gt;     				}
&gt;     			}
&gt; 				try {
&gt; 					body.delete(curr);
&gt; 				} catch (TargetLostException e) {
&gt; 				}
&gt;     		}
&gt; 			curr = next;
&gt;     	}
&gt; 	}
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="28974" transactionid="72606">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M O-~</fullfingerprint>
<bugreport>The aspect below fails to compile with 1.1b2, producing the compilation error: 
--------------------
$ ajc com/ibm/amc/*.java com/ibm/amc/ejb/*.java
d:/eclipse/runtime-workspace-ajsamples/Mock EJBs/com/ibm/amc/DemoBeanEJB.java:1:
 Cannot assign a value to the final field com.ibm.amc.DemoBean.ajc$interField$co
m_ibm_amc$verbose

!! no source information available !!

1 error
---------------------------


package com.ibm.amc;

import com.ibm.amc.ejb.SessionBean;
/**
 * @author colyer
 *
 * To change this generated comment edit the template variable "typecomment":
 * Window&gt;Preferences&gt;Java&gt;Templates.
 * To enable and disable the creation of type comments go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation.
 */
public aspect DemoBeanEJB {

	declare parents: DemoBean implements SessionBean;
	
        // THIS NEXT LINE IS THE CULPRIT
	static final boolean DemoBean.verbose = true;
	
	private transient String DemoBean.ctx;
	
	public void DemoBean.ejbActivate( ) {
		if ( verbose ) {
			System.out.println( "ejbActivate Called" );	
		}	
	}
}


-------------------
Making the inter-type declaration non-final solves the problem...</bugreport>
<pre-fix-testcases failing="29" file="output/28974/pre-fix/testresults.xml" passing="666" size="695"/>
<post-fix-testcases failing="25" file="output/28974/post-fix/testresults.xml" passing="670" size="695"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AjcMemberMaker.java" revision="1.5" state="changed">335,337c335,339
&lt; 	
&lt; 	private static int makePublic(int modifiers) {
&lt; 		return (modifiers &amp; ~VISIBILITY) | Modifier.PUBLIC;
---
&gt; 	/**
&gt; 	 * Makes public and non-final
&gt; 	 */
&gt; 	private static int makePublicNonFinal(int modifiers) {
&gt; 		return (modifiers &amp; ~VISIBILITY &amp; ~Modifier.FINAL) | Modifier.PUBLIC;
379c381
&lt; 			makePublic(field.getModifiers()),
---
&gt; 			makePublicNonFinal(field.getModifiers()),
392c394
&lt; 		return new ResolvedMember(Member.FIELD, onClass, makePublic(field.getModifiers()),
---
&gt; 		return new ResolvedMember(Member.FIELD, onClass, makePublicNonFinal(field.getModifiers()),
438c440
&lt; 		int modifiers = makePublic(meth.getModifiers());
---
&gt; 		int modifiers = makePublicNonFinal(meth.getModifiers());
</file>
</fixedFiles>
</bug>
<bug id="29186" transactionid="72486">
<property name="files-churned" value="8"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="7"/>
<property name="hunks" value="17"/>
<property name="lines-added" value="99"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="12"/>
<property name="lines-churned" value="111"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-for K-if K-instanceof K-new K-null K-return K-this K-true M O-== O-&gt;= O-- O--- O-!= O-&amp;&amp; O-+ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>This works fine without -emacssym, but dies with it:

aspect Foo {
  before() : call(void foo()) { }
  void Bar.bar() { foo(); }
}
class Bar {
  void foo() { }
}

munger: (before: (persingleton(Foo) &amp;&amp; call(ExactTypePattern(void) foo()))-&gt;void Foo.ajc$before$Foo$f()) on method-call(void Bar.foo())
trouble in: 
public class Foo extends java.lang.Object:
  TypeMungers: [(BcelTypeMunger ResolvedTypeMunger(Method, void Bar.bar()))]
  public static final Foo ajc$perSingletonInstance
  static void &lt;clinit&gt;():
                    INVOKESTATIC Foo.ajc$clinit ()V   (line 1)
    staticinitialization(void Foo.&lt;clinit&gt;())
    |               RETURN
    staticinitialization(void Foo.&lt;clinit&gt;())
  end static void &lt;clinit&gt;()

  void &lt;init&gt;():
                    ALOAD_0     // Foo this   (line 1)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void Foo.&lt;init&gt;())
    |               RETURN
    constructor-execution(void Foo.&lt;init&gt;())
  end void &lt;init&gt;()

  public void ajc$before$Foo$f()    AdviceAttribute(before, call(ExactTypePattern(void) foo()), 0, 15)
:
    advice-execution(void Foo.ajc$before$Foo$f())
    |               RETURN   (line 2)
    advice-execution(void Foo.ajc$before$Foo$f())
  end public void ajc$before$Foo$f()

  public static void ajc$interMethod$Foo$Bar$bar(Bar)    EffectiveSignatureAttribute(void Bar.bar(), method-execution)
:
    method-execution(void Bar.bar())
    |               ALOAD_0     // Bar arg0   (line 3)
    | method-call(void Bar.foo())
    | |             GETSTATIC Foo.ajc$perSingletonInstance LFoo;
    | |             INVOKEVIRTUAL Foo.ajc$before$Foo$f ()V
    | |             INVOKEVIRTUAL Bar.foo ()V
    | method-call(void Bar.foo())
    |               RETURN
    method-execution(void Bar.bar())
  end public static void ajc$interMethod$Foo$Bar$bar(Bar)

  public static void ajc$interMethodDispatch1$Foo$Bar$bar(Bar)    EffectiveSignatureAttribute(void Bar.bar(), method-call)
:
                    ALOAD_0     // Bar arg0
                    INVOKEVIRTUAL Bar.ajc$interMethodDispatch2$$bar ()V
                    RETURN
  end public static void ajc$interMethodDispatch1$Foo$Bar$bar(Bar)

  public static Foo aspectOf()    org.aspectj.weaver.AjAttribute$AjSynthetic@f8f7db
:
                    GETSTATIC Foo.ajc$perSingletonInstance LFoo;
                    ARETURN
  end public static Foo aspectOf()

  public static boolean hasAspect()    org.aspectj.weaver.AjAttribute$AjSynthetic@5856a5
:
                    GETSTATIC Foo.ajc$perSingletonInstance LFoo;
                    IFNULL L0
                    ICONST_1
                    IRETURN
                L0: ICONST_0
                    IRETURN
  end public static boolean hasAspect()

  private static void ajc$clinit()    org.aspectj.weaver.AjAttribute$AjSynthetic@c39a20
:
                    NEW Foo
                    DUP
                    INVOKESPECIAL Foo.&lt;init&gt; ()V
                    PUTSTATIC Foo.ajc$perSingletonInstance LFoo;
                    RETURN
  end private static void ajc$clinit()
end public class Foo
Exception thrown from AspectJ 1.1b2

This might be logged as a bug already -- see the bug database at
  http://dev.eclipse.org (product: AspectJ, component: compiler)

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
	at org.aspectj.weaver.AsmAdaptor.findOrCreateBodyNode(Unknown Source)
	at org.aspectj.weaver.AsmAdaptor.getNode(Unknown Source)
	at org.aspectj.weaver.AsmAdaptor.noteMunger(Unknown Source)
	at org.aspectj.weaver.Shadow.implementMungers(Unknown Source)
	at org.aspectj.weaver.Shadow.implement(Unknown Source)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(Unknown Source)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(Unknown Source)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(Unknown Source)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(Unknown Source)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(Unknown Source)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source)
	at org.aspectj.tools.ajc.Main.run(Unknown Source)
	at org.aspectj.tools.ajc.Main.runMain(Unknown Source)
	at org.aspectj.tools.ajc.Main.main(Unknown Source)


1 fail|abort</bugreport>
<pre-fix-testcases failing="25" file="output/29186/pre-fix/testresults.xml" passing="670" size="695"/>
<post-fix-testcases failing="25" file="output/29186/post-fix/testresults.xml" passing="670" size="695"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Lint.java" revision="1.5" state="changed">39a40,42
&gt; 	public final Kind shadowNotInStructure = 
&gt; 		new Kind("shadowNotInStructure", "the shadow for this join point is not exposed in the structure model: {0}");
&gt; 		
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java" revision="1.3" state="changed">103a104
&gt; 		//System.err.println("type with name: " + name);
126a128,129
&gt; 		//System.err.println("member type with name: " + name);
&gt; 		
146a150,197
&gt; 	public boolean visit(LocalTypeDeclaration memberTypeDeclaration, BlockScope scope) {
&gt; 		String name = new String(memberTypeDeclaration.name);
&gt; 		String fullName = new String(memberTypeDeclaration.binding.constantPoolName());
&gt; 		int dollar = fullName.indexOf('$');
&gt; 		fullName = fullName.substring(dollar+1);
&gt; //		
&gt; //		System.err.println("member type with name: " + name + ", " + 
&gt; //				new String(fullName));
&gt; 		
&gt; 		ProgramElementNode.Kind kind = ProgramElementNode.Kind.CLASS;
&gt; 		if (memberTypeDeclaration.isInterface()) kind = ProgramElementNode.Kind.INTERFACE;
&gt; 
&gt; 		ProgramElementNode peNode = new ProgramElementNode(
&gt; 			fullName,
&gt; 			kind,
&gt; 			makeLocation(memberTypeDeclaration),
&gt; 			memberTypeDeclaration.modifiers,
&gt; 			"",
&gt; 			new ArrayList());
&gt; 		
&gt; 		//??? we add this to the compilation unit
&gt; 		findEnclosingClass(stack).addChild(peNode);
&gt; 		stack.push(peNode);
&gt; 		return true;
&gt; 	}
&gt; 	public void endVisit(LocalTypeDeclaration memberTypeDeclaration, BlockScope scope) {
&gt; 		stack.pop();
&gt; 	}
&gt; 	
&gt; 	public boolean visit(AnonymousLocalTypeDeclaration memberTypeDeclaration, BlockScope scope) {
&gt; 		return visit((LocalTypeDeclaration)memberTypeDeclaration, scope);
&gt; 	}
&gt; 
&gt; 	public void endVisit(AnonymousLocalTypeDeclaration memberTypeDeclaration, BlockScope scope) {
&gt; 		stack.pop();
&gt; 	}
&gt; 	
&gt; 	private StructureNode findEnclosingClass(Stack stack) {
&gt; 		for (int i = stack.size()-1; i &gt;= 0; i--) {
&gt; 			ProgramElementNode pe = (ProgramElementNode)stack.get(i);
&gt; 			if (pe.getProgramElementKind() == ProgramElementNode.Kind.CLASS) {
&gt; 				return pe;
&gt; 			}
&gt; 			
&gt; 		}
&gt; 		return (StructureNode)stack.peek();
&gt; 	}	
&gt; 	
174,177c225,229
&lt; 			
&lt; 		Member member = EclipseWorld.makeResolvedMember(methodDeclaration.binding);
&lt; 		peNode.setBytecodeName(member.getName());
&lt; 		peNode.setBytecodeSignature(member.getSignature());
---
&gt; 		if (methodDeclaration.binding != null) {
&gt; 			Member member = EclipseWorld.makeResolvedMember(methodDeclaration.binding);
&gt; 			peNode.setBytecodeName(member.getName());
&gt; 			peNode.setBytecodeSignature(member.getSignature());
&gt; 		}
</file>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/StructureModel.java" revision="1.2" state="changed">73c73,74
&lt; 		// !!! this searches each file for a class
---
&gt; 		
&gt; 		// this searches each file for a class
76,80c77,105
&lt; 			for (Iterator j = fileNode.getChildren().iterator(); j.hasNext(); ) {
&lt; 				ProgramElementNode classNode = (ProgramElementNode)j.next();	
&lt; 				if (classNode instanceof ProgramElementNode &amp;&amp; className.equals(classNode.getName())) {
&lt; 					return (ProgramElementNode)classNode;
&lt; 				}
---
&gt; 			ProgramElementNode ret = findClassInNodes(fileNode.getChildren(), className);
&gt; 			if (ret != null) return ret;
&gt; 		}
&gt; 		
&gt; 		return null;
&gt; 	}
&gt; 	
&gt; 	private ProgramElementNode findClassInNodes(Collection nodes, String name) {
&gt; 		String baseName;
&gt; 		String innerName;
&gt; 		int dollar = name.indexOf('$');
&gt; 		if (dollar == -1) {
&gt; 			baseName = name;
&gt; 			innerName = null;
&gt; 		} else {
&gt; 			baseName = name.substring(0, dollar);
&gt; 			innerName = name.substring(dollar+1);
&gt; 		}
&gt; 		
&gt; 		
&gt; 		for (Iterator j = nodes.iterator(); j.hasNext(); ) {
&gt; 			ProgramElementNode classNode = (ProgramElementNode)j.next();
&gt; //			System.err.println("checking: " + classNode + " for " + baseName);	
&gt; //			System.err.println("children: " + classNode.getChildren());
&gt; 			if (baseName.equals(classNode.getName())) {
&gt; 				if (innerName == null) return classNode;
&gt; 				else return findClassInNodes(classNode.getChildren(), innerName);
&gt; 			} else if (name.equals(classNode.getName())) {
&gt; 				return classNode;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AsmAdaptor.java" revision="1.3" state="changed">79a80
&gt; 		if (a.getSignature() == null) return null;
86a88,94
&gt; 		if (enclosingNode == null) {
&gt; 			Lint.Kind err = shadow.getIWorld().getLint().shadowNotInStructure;
&gt; 			if (err.isEnabled()) {
&gt; 				err.signal(shadow.toString(), shadow.getSourceLocation());
&gt; 			}
&gt; 			return null;
&gt; 		}
120c128
&lt; 		System.err.println(peNode.getSourceLocation());
---
&gt; 		//System.err.println(peNode.getSourceLocation());
144a153
&gt; 			//System.err.println("checking: " + member.getName() + " with " + node.getBytecodeName() + ", " + node.getBytecodeSignature());
151c160,162
&lt; 		return null;
---
&gt; 	 	// if we can't find the member, we'll just put it in the class
&gt; 	 	//??? is this what the IDEs want
&gt; 		return classNode;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/XlintDefault.properties" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java" revision="1.6" state="changed">296a297,301
&gt; 		if (classType.isSynthetic()) {
&gt; 			dumpUnchanged(classFile);
&gt; 			return null;
&gt; 		}
&gt; 		
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.11" state="changed">438a439,442
&gt;     public boolean isSynthetic() {
&gt;     	return signature.indexOf("$ajc") != -1;
&gt;     }
&gt;     
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Shadow.java" revision="1.6" state="changed">308c308
&lt; 				System.err.println("munger: " + munger + " on " + this);
---
&gt; 				//System.err.println("munger: " + munger + " on " + this);
</file>
</fixedFiles>
</bug>
<bug id="29769" transactionid="74152">
<property name="files-churned" value="8"/>
<property name="java-files-churned" value="8"/>
<property name="classes-churned" value="8"/>
<property name="methods-churned" value="9"/>
<property name="hunks" value="57"/>
<property name="lines-added" value="601"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="58"/>
<property name="lines-churned" value="661"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-new K-null K-return K-while M O-== O-&gt; O-|| O-! O-!= O-() O-&amp; O-&amp;&amp; O-+ O-++ O-cast T V Y Z-cast Z-for Z-if Z-while</fullfingerprint>
<bugreport>The org.aspectj.ajde.BuildOptionsAdapter interface does not yet support the new 
AspectJ 1.1 compiler options. These need to be added to the interface, any old 
or renamed options deprecated, and then the correct processing needs to happen 
within Ajde to pass these options to the compiler.

This enhancement is needed by the various IDE projects for there AspectJ 1.1
support.</bugreport>
<testsforfix ID="29769" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java">
      <test NAME="testCharacterEncoding"/>
      <test NAME="testComplianceLevel"/>
      <test NAME="testSourceCompatibilityLevel"/>
      <test NAME="testSourceIncompatibilityLevel"/>
      <test NAME="testNullWarnings"/>
      <test NAME="testEmptyWarnings"/>
      <test NAME="testSetOfWarnings"/>
      <test NAME="testNoDebugOptions"/>
      <test NAME="testEmptyDebugOptions"/>
      <test NAME="testDebugAll"/>
      <test NAME="testDebugSet"/>
      <test NAME="testNoImport"/>
      <test NAME="testPreserveAllLocals"/>
      <test NAME="testNonStandardOptions"/>
      <test NAME="testSourceRoots"/>
      <test NAME="testInJars"/>
      <test NAME="testAspectPath"/>
      <test NAME="testOutJar"/>
    </file>
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.java">
      <test NAME="testVerboseMode"/>
      <test NAME="testNonStandardOptions"/>
      <test NAME="testComplianceLevel"/>
      <test NAME="testSourceCompatibilityLevel"/>
      <test NAME="testWarnings"/>
      <test NAME="testDebugLevel"/>
      <test NAME="testNoImportError"/>
      <test NAME="testPreserveLocals"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="25" file="output/29769/pre-fix/testresults.xml" passing="673" size="698"/>
<post-fix-testcases failing="24" file="output/29769/post-fix/testresults.xml" passing="674" size="698"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.4" state="changed">358c358,360
&lt; 			} else if (arg.equals("-noweave")) {
---
&gt; 			//AMC - added -XnoWeave to options that match, in line with
&gt; 			// AspectJ 1.1 release notes documentation.	
&gt; 			} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
</file>
<file name="org.aspectj/modules/ajde/testdata/examples/figures-coverage/figures/Figure.java" revision="1.2" state="changed">4c4
&lt; //import figures.primitives.planar.Point;
---
&gt; import figures.primitives.planar.Point;
76c76,78
&lt;     declare soft: Point: call(* *(..));
---
&gt; 	// AMC - this next line doesn't make sense!! Can these tests ever
&gt; 	// have been run???
&gt;     //declare soft: Point: call(* *(..));
</file>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java" revision="1.2" state="changed">11c11,12
&lt;  *     Xerox/PARC     initial implementation 
---
&gt;  *     Xerox/PARC     	initial implementation 
&gt;  *     AMC	01.20.2003  extended for AspectJ 1.1 compiler options
17a19,20
&gt; import java.util.Set;
&gt; 
22a26,47
&gt; 	// Version constants
&gt; 	public static final String VERSION_13 = "1.3";
&gt; 	public static final String VERSION_14 = "1.4";
&gt; 		
&gt; 	// Warning constants
&gt; 	public static final String WARN_CONSTRUCTOR_NAME   	 = "constructorName";
&gt; 	public static final String WARN_PACKAGE_DEFAULT_METHOD = "packageDefaultMethod";	
&gt; 	public static final String WARN_DEPRECATION 		   	 = "deprecation";	
&gt; 	public static final String WARN_MASKED_CATCH_BLOCKS 	 = "maskedCatchBlocks";	
&gt; 	public static final String WARN_UNUSED_LOCALS 		 = "unusedLocals";	
&gt; 	public static final String WARN_UNUSED_ARGUMENTS 		 = "unusedArguments";	
&gt; 	public static final String WARN_UNUSED_IMPORTS 		 = "unusedImports";	
&gt; 	public static final String WARN_SYNTHETIC_ACCESS 		 = "syntheticAccess";	
&gt; 	public static final String WARN_ASSERT_IDENITIFIER 	 = "assertIdentifier";	
&gt; 	public static final String WARN_NLS					 = "nonExternalisedString";
&gt; 	
&gt; 	// Debug constants	
&gt; 	public static final String DEBUG_SOURCE = "source";
&gt; 	public static final String DEBUG_LINES  = "lines";
&gt; 	public static final String DEBUG_VARS   = "vars";
&gt; 	public static final String DEBUG_ALL    = "all";
&gt; 	
24a50,51
&gt; 	 * From -usejavac
&gt; 	 * @deprecated Not supported from AspectJ 1.1 onwards
30a58,59
&gt; 	 * From -workingdir
&gt; 	 * @deprecated Not supported from AspectJ 1.1 onwards
36a66,67
&gt; 	 * From -source
&gt; 	 * @deprecated Not supported from AspectJ 1.1 onwards
42a74
&gt; 	 * From -encoding
47a80
&gt; 	 * @deprecated Use getComplianceLevel instead
53a87,88
&gt; 	 * From -lenient
&gt; 	 * @deprecated Not supported from AspectJ 1.1 onwards
59a95,96
&gt; 	 * From -strict
&gt; 	 * @deprecated Not supported from AspectJ 1.1 onwards
65a103,104
&gt; 	 * From -porting
&gt; 	 * @deprecated Not supported from AspectJ 1.1 onwards
73a113,156
&gt; 	
&gt; 	// ----------------------------------
&gt; 	// New options added for AspectJ 1.1 from this point onwards
&gt; 	
&gt; 	/**
&gt; 	 * JDK Compliance level to be used by the compiler, either 
&gt; 	 * VERSION_13 or VERSION_14.
&gt; 	 * From -1.3 / -1.4
&gt; 	 */
&gt; 	public String getComplianceLevel();
&gt; 	
&gt; 	/**
&gt; 	 * Source compatibility level, either VERSION_13 or VERSION_14.
&gt; 	 * From -source (eclipse option)
&gt; 	 */
&gt; 	public String getSourceCompatibilityLevel();
&gt; 	
&gt; 	/**
&gt; 	 * Optional warnings, empty List is equivalent to -warn:none,
&gt; 	 * returning null uses eclipse compiler default settings
&gt; 	 * From -warn:xxx,yyy
&gt; 	 */
&gt; 	public Set getWarnings();
&gt; 	
&gt; 	/**
&gt; 	 * Debug level. DEBUG_ALL == {SOURCE, LINES, VARS}.
&gt; 	 * Empty list is equivalent to -g:none, returning
&gt; 	 * non uses eclipse compiler default settings
&gt; 	 * From -g:xxx
&gt; 	 */
&gt; 	public Set getDebugLevel();
&gt; 	
&gt; 	/**
&gt; 	 * No errors generated for unresolved imports
&gt; 	 * From -noImportError
&gt; 	 */
&gt; 	public boolean getNoImportError();
&gt; 	
&gt; 	/**
&gt; 	 * Preserve all unused local variables (for debug)
&gt; 	 * From -preserveAllLocals
&gt; 	 */
&gt; 	public boolean getPreserveAllLocals();
&gt; 	
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java" revision="1.4" state="changed">10a11,13
&gt;  *     Adrian Colyer  added constructor to populate javaOptions with
&gt;  * 					  default settings - 01.20.2003
&gt;  * 					  Bugzilla #29768, 29769
18a22,23
&gt; import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
&gt; 
24c29
&lt; 	public static final String AJLINT_INGORE = "ignore";
---
&gt; 	public static final String AJLINT_IGNORE = "ignore";
47a53,118
&gt; 	 * Intialises the javaOptions Map to hold the default 
&gt; 	 * JDT Compiler settings. Added by AMC 01.20.2003 in reponse
&gt; 	 * to bug #29768 and enh. 29769.
&gt; 	 * The settings here are duplicated from those set in
&gt; 	 * org.eclipse.jdt.internal.compiler.batch.Main, but I've elected to
&gt; 	 * copy them rather than refactor the JDT class since this keeps
&gt; 	 * integration with future JDT releases easier (?).
&gt; 	 */
&gt; 	public AjBuildConfig( ) {
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_LocalVariableAttribute,
&gt; 			CompilerOptions.DO_NOT_GENERATE);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_LineNumberAttribute,
&gt; 			CompilerOptions.DO_NOT_GENERATE);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_SourceFileAttribute,
&gt; 			CompilerOptions.DO_NOT_GENERATE);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_PreserveUnusedLocal,
&gt; 			CompilerOptions.OPTIMIZE_OUT);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportUnreachableCode,
&gt; 			CompilerOptions.ERROR);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportInvalidImport, 
&gt; 			CompilerOptions.ERROR);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod,
&gt; 			CompilerOptions.WARNING);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportMethodWithConstructorName,
&gt; 			CompilerOptions.WARNING);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportDeprecation, 
&gt; 				CompilerOptions.WARNING);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportHiddenCatchBlock,
&gt; 			CompilerOptions.WARNING);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportUnusedLocal, 
&gt; 			CompilerOptions.IGNORE);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportUnusedParameter,
&gt; 			CompilerOptions.IGNORE);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportSyntheticAccessEmulation,
&gt; 			CompilerOptions.IGNORE);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportNonExternalizedStringLiteral,
&gt; 			CompilerOptions.IGNORE);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_ReportAssertIdentifier,
&gt; 			CompilerOptions.IGNORE);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_Compliance,
&gt; 			CompilerOptions.VERSION_1_3);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_Source,
&gt; 			CompilerOptions.VERSION_1_3);
&gt; 		javaOptions.put(
&gt; 			CompilerOptions.OPTION_TargetPlatform,
&gt; 			CompilerOptions.VERSION_1_1);				
&gt; 	}
&gt; 
&gt; 	/**
</file>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java" revision="1.3" state="changed">10c10,12
&lt;  *     Xerox/PARC     initial implementation 
---
&gt;  *     Xerox/PARC      initial implementation 
&gt;  *     AMC 01.20.2003  extended to support new AspectJ 1.1 options,
&gt;  * 				       bugzilla #29769
19a22
&gt; import org.aspectj.ajdt.ajc.BuildArgParser;
23a27
&gt; import org.aspectj.util.LangUtil;
101a106,317
&gt; 		// AMC refactored into two methods to populate buildConfig from buildOptions and
&gt; 		// project properties - bugzilla 29769.
&gt; 		configureBuildOptions(buildConfig, Ajde.getDefault().getBuildManager().getBuildOptions());
&gt; 		configureProjectOptions(buildConfig, Ajde.getDefault().getProjectProperties());
&gt; 		
&gt; 		buildConfig.setGenerateModelMode(true);		
&gt; 		return buildConfig;
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * Populate options in a build configuration, using the Ajde BuildOptionsAdapter.
&gt; 	 * Added by AMC 01.20.2003, bugzilla #29769
&gt; 	 */
&gt; 	private void configureBuildOptions( AjBuildConfig config, BuildOptionsAdapter options ) {
&gt; 
&gt; 		Map javaOptions = config.getJavaOptions();
&gt; 
&gt; 		if (options.getSourceOnePointFourMode()) {
&gt; 			javaOptions.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);	 
&gt; 			javaOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_4);
&gt; 		} 
&gt; 		
&gt; 		String enc = options.getCharacterEncoding();
&gt; 		if ( enc != null &amp; (enc.length() &gt; 0)) {
&gt; 			javaOptions.put(CompilerOptions.OPTION_Encoding, enc );
&gt; 		}
&gt; 
&gt; 		String compliance = options.getComplianceLevel();
&gt; 		if ( compliance != null &amp;&amp; (compliance.length() &gt; 0) ) {
&gt; 			String version = CompilerOptions.VERSION_1_4;
&gt; 			if ( compliance.equals( BuildOptionsAdapter.VERSION_13 ) ) {
&gt; 				version = CompilerOptions.VERSION_1_3;
&gt; 			}
&gt; 			javaOptions.put(CompilerOptions.OPTION_Compliance, version );	
&gt; 			javaOptions.put(CompilerOptions.OPTION_Source, version );
&gt; 		}
&gt; 				
&gt; 		String sourceLevel = options.getSourceCompatibilityLevel();
&gt; 		if ( null != sourceLevel &amp;&amp; ( sourceLevel.length() &gt; 0 )) {
&gt; 			String slVersion = CompilerOptions.VERSION_1_4;
&gt; 			if ( sourceLevel.equals( BuildOptionsAdapter.VERSION_13 ) ) {
&gt; 				slVersion = CompilerOptions.VERSION_1_3;
&gt; 			}
&gt; 			// never set a lower source level than compliance level
&gt; 			String setCompliance = (String) javaOptions.get( CompilerOptions.OPTION_Compliance);
&gt; 			if ( ! (setCompliance.equals( CompilerOptions.VERSION_1_4 )
&gt; 			         &amp;&amp; slVersion.equals(CompilerOptions.VERSION_1_3)) ) {
&gt; 				javaOptions.put(CompilerOptions.OPTION_Source, slVersion);							
&gt; 			}
&gt; 		}
&gt; 	
&gt; 		Set warnings = options.getWarnings();
&gt; 		if ( warnings != null ) {
&gt; 			// turn off all warnings	
&gt; 			disableWarnings( javaOptions );
&gt; 			// then selectively enable those in the set
&gt; 			enableWarnings( javaOptions, warnings );
&gt; 		}
&gt; 
&gt; 		Set debugOptions = options.getDebugLevel();
&gt; 		if ( debugOptions != null ) {
&gt; 			// default is all options off, so just need to selectively
&gt; 			// enable
&gt; 			Iterator it = debugOptions.iterator();
&gt; 			while (it.hasNext()){
&gt; 				String debug = (String) it.next();
&gt; 				if ( debug.equals( BuildOptionsAdapter.DEBUG_ALL )) {
&gt; 					javaOptions.put( CompilerOptions.OPTION_LineNumberAttribute,
&gt; 									 CompilerOptions.GENERATE);
&gt; 					javaOptions.put( CompilerOptions.OPTION_SourceFileAttribute,
&gt; 									 CompilerOptions.GENERATE);
&gt; 					javaOptions.put( CompilerOptions.OPTION_LocalVariableAttribute,
&gt; 									 CompilerOptions.GENERATE);									 
&gt; 				} else if ( debug.equals( BuildOptionsAdapter.DEBUG_LINES )) {
&gt; 					javaOptions.put( CompilerOptions.OPTION_LineNumberAttribute,
&gt; 									 CompilerOptions.GENERATE);					
&gt; 				}  else if ( debug.equals( BuildOptionsAdapter.DEBUG_SOURCE )) {
&gt; 					javaOptions.put( CompilerOptions.OPTION_SourceFileAttribute,
&gt; 									 CompilerOptions.GENERATE);					
&gt; 				}  else if ( debug.equals( BuildOptionsAdapter.DEBUG_VARS)) {
&gt; 					javaOptions.put( CompilerOptions.OPTION_LocalVariableAttribute,
&gt; 									 CompilerOptions.GENERATE);					
&gt; 				}
&gt; 			}
&gt; 		}
&gt; 
&gt; 		if ( options.getNoImportError() ) {
&gt; 			javaOptions.put( CompilerOptions.OPTION_ReportInvalidImport,
&gt; 				CompilerOptions.WARNING);	
&gt; 		}
&gt; 				
&gt; 		if ( options.getPreserveAllLocals() ) {
&gt; 			javaOptions.put( CompilerOptions.OPTION_PreserveUnusedLocal,
&gt; 				CompilerOptions.PRESERVE);		
&gt; 		}
&gt; 				
&gt; 		config.setJavaOptions( javaOptions );
&gt; 		
&gt; 		configureNonStandardOptions( config, options );
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Helper method for configureBuildOptions
&gt; 	 */
&gt; 	private void disableWarnings( Map options ) {
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod,
&gt; 			CompilerOptions.IGNORE);
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportMethodWithConstructorName,
&gt; 			CompilerOptions.IGNORE);
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportDeprecation, 
&gt; 			CompilerOptions.IGNORE);
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportHiddenCatchBlock,
&gt; 			CompilerOptions.IGNORE);
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportUnusedLocal, 
&gt; 			CompilerOptions.IGNORE);
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportUnusedParameter,
&gt; 			CompilerOptions.IGNORE);
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportSyntheticAccessEmulation,
&gt; 			CompilerOptions.IGNORE);
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportNonExternalizedStringLiteral,
&gt; 			CompilerOptions.IGNORE);
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportAssertIdentifier,
&gt; 			CompilerOptions.IGNORE);
&gt; 		options.put(
&gt; 			CompilerOptions.OPTION_ReportUnusedImport,
&gt; 			CompilerOptions.IGNORE);		
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * Helper method for configureBuildOptions
&gt; 	 */
&gt; 	private void enableWarnings( Map options, Set warnings ) {
&gt; 		Iterator it = warnings.iterator();
&gt; 		while (it.hasNext() ) {
&gt; 			String thisWarning = (String) it.next();
&gt; 			if ( thisWarning.equals( BuildOptionsAdapter.WARN_ASSERT_IDENITIFIER )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportAssertIdentifier,
&gt; 							 CompilerOptions.WARNING );				
&gt; 			} else if ( thisWarning.equals( BuildOptionsAdapter.WARN_CONSTRUCTOR_NAME )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportMethodWithConstructorName,
&gt; 							 CompilerOptions.WARNING );								
&gt; 			} else if ( thisWarning.equals( BuildOptionsAdapter.WARN_DEPRECATION )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportDeprecation,
&gt; 							 CompilerOptions.WARNING );					
&gt; 			} else if ( thisWarning.equals( BuildOptionsAdapter.WARN_MASKED_CATCH_BLOCKS )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportHiddenCatchBlock,
&gt; 							 CompilerOptions.WARNING );	
&gt; 			} else if ( thisWarning.equals( BuildOptionsAdapter.WARN_PACKAGE_DEFAULT_METHOD )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod,
&gt; 							 CompilerOptions.WARNING );					
&gt; 			} else if ( thisWarning.equals( BuildOptionsAdapter.WARN_SYNTHETIC_ACCESS )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportSyntheticAccessEmulation,
&gt; 							 CompilerOptions.WARNING );					
&gt; 			} else if ( thisWarning.equals( BuildOptionsAdapter.WARN_UNUSED_ARGUMENTS )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportUnusedParameter,
&gt; 							 CompilerOptions.WARNING );					
&gt; 			} else if ( thisWarning.equals( BuildOptionsAdapter.WARN_UNUSED_IMPORTS )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportUnusedImport,
&gt; 							 CompilerOptions.WARNING );					
&gt; 			} else if ( thisWarning.equals( BuildOptionsAdapter.WARN_UNUSED_LOCALS )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportUnusedLocal,
&gt; 							 CompilerOptions.WARNING );					
&gt; 			}  else if ( thisWarning.equals( BuildOptionsAdapter.WARN_NLS )) {
&gt; 				options.put( CompilerOptions.OPTION_ReportNonExternalizedStringLiteral,
&gt; 							 CompilerOptions.WARNING );					
&gt; 			}
&gt; 		}		
&gt; 	}
&gt; 
&gt; 
&gt; 	/**
&gt; 	 * Helper method for configure build options
&gt; 	 */
&gt; 	private void configureNonStandardOptions( AjBuildConfig config, BuildOptionsAdapter options ) {
&gt; 		String nonStdOptions = options.getNonStandardOptions();
&gt; 		if ( null == nonStdOptions || (nonStdOptions.length() == 0)) return;
&gt; 		
&gt; 		StringTokenizer tok = new StringTokenizer( nonStdOptions );
&gt; 		String[] args = new String[ tok.countTokens() ];
&gt; 		int argCount = 0;
&gt; 		while ( tok.hasMoreTokens() ) {
&gt; 			args[argCount++] = tok.nextToken();	
&gt; 		}
&gt; 
&gt; 		// set the non-standard options in an alternate build config
&gt; 		// (we don't want to lose the settings we already have)
&gt; 		BuildArgParser argParser = new BuildArgParser();
&gt; 		AjBuildConfig altConfig = argParser.genBuildConfig( args, messageHandler );
&gt; 		
&gt; 		// copy the answers across
&gt; 		config.setNoWeave( altConfig.isNoWeave() );
&gt; 		config.setXnoInline( altConfig.isXnoInline() );
&gt; 		config.setXserializableAspects( altConfig.isXserializableAspects());
&gt; 		config.setLintMode( altConfig.getLintMode() );
&gt; 		config.setLintSpecFile( altConfig.getLintSpecFile() );		
&gt; 	}
&gt; 	/**
&gt; 	 * Populate options in a build configuration, using the ProjectPropertiesAdapter.
&gt; 	 * Added by AMC 01.20.2003, bugzilla #29769
&gt; 	 */
&gt; 	private void configureProjectOptions( AjBuildConfig config, ProjectPropertiesAdapter properties ) {
&gt; 
&gt; 		// set the classpath
103c319
&lt; 			Ajde.getDefault().getProjectProperties().getBootClasspath()
---
&gt; 			properties.getBootClasspath()
105c321
&lt; 			+ Ajde.getDefault().getProjectProperties().getClasspath();
---
&gt; 			+ properties.getClasspath();
110a327
&gt; 		
113c330
&lt; 		buildConfig.setClasspath(classpath);  
---
&gt; 		config.setClasspath(classpath);  
116,118c333,335
&lt; 		if (Ajde.getDefault().getBuildManager().getBuildOptions().getSourceOnePointFourMode()) {
&lt; 			buildConfig.getJavaOptions().put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);	 
&lt; 		} 
---
&gt; 		config.setOutputDir(
&gt; 			new File(properties.getOutputPath())
&gt; 		);
120,123c337
&lt; 		// XXX problematic restriction, support multiple source roots
&lt; 		List sourceRoots = new ArrayList();
&lt; 		sourceRoots.add(new File(configFile).getParentFile());
&lt; 		buildConfig.setSourceRoots(sourceRoots);
---
&gt; 		// new 1.1 options added by AMC
125,127c339,343
&lt; 		buildConfig.setOutputDir(
&lt; 			new File(Ajde.getDefault().getProjectProperties().getOutputPath())
&lt; 		);
---
&gt; 		Set roots = properties.getSourceRoots();
&gt; 		if ( null != roots &amp;&amp; !roots.isEmpty() ) {		
&gt; 			List sourceRoots = new ArrayList( roots );
&gt; 			config.setSourceRoots(sourceRoots);
&gt; 		}
129c345,349
&lt; 		buildConfig.setGenerateModelMode(true);
---
&gt; 		Set jars = properties.getInJars();
&gt; 		if ( null != jars &amp;&amp; !jars.isEmpty() ) {		
&gt; 			List inJars = new ArrayList( jars );
&gt; 			config.setInJars(inJars);
&gt; 		}
131c351,362
&lt; 		return buildConfig;
---
&gt; 		String outJar = properties.getOutJar();
&gt; 		if ( null != outJar &amp;&amp; (outJar.length() &gt; 0) ) {
&gt; 			config.setOutputJar( new File( outJar ) );	
&gt; 		}
&gt; 
&gt; 		Set aspects = properties.getAspectPath();
&gt; 		if ( null != aspects &amp;&amp; !aspects.isEmpty() ) {		
&gt; 			List aPath = new ArrayList( aspects );
&gt; 			config.setAspectpath( aPath);
&gt; 		}
&gt; 
&gt; 					
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java" revision="1.2" state="changed">10a11
&gt;  * 	   AMC 01.20.2003 extended to support AspectJ 1.1 options
26a28,32
&gt; 	private Set inJars;
&gt; 	private Set sourceRoots;
&gt; 	private Set aspectPath;
&gt; 	private String outJar;
&gt; 
61c67,70
&lt;     	return testProjectPath + System.getProperty("sun.boot.class.path") + File.pathSeparator +  "../../../runtime/bin";	
---
&gt;     	// AMC - added in path separator since absence was causing
&gt;     	// build failures with invalid classpath
&gt;     	return testProjectPath + File.pathSeparator +
&gt;     		System.getProperty("sun.boot.class.path") + File.pathSeparator +  "../runtime/bin";	
86a96,119
&gt;     
&gt;     public void setInJars( Set jars ) { this.inJars = jars; }
&gt;     
&gt;     public Set getInJars( ) {
&gt;     	return inJars;
&gt;     }
&gt; 
&gt; 	public void setOutJar( String jar ){ this.outJar = jar; }
&gt; 
&gt;     public String getOutJar() {
&gt;     	return outJar;
&gt;     }
&gt;     
&gt;     public void setSourceRoots( Set roots ) { this.sourceRoots = roots; }
&gt; 
&gt;     public Set getSourceRoots() {
&gt;     	return sourceRoots;
&gt;     }
&gt; 
&gt; 	public void setAspectPath( Set path ) { this.aspectPath = path; }
&gt; 	    
&gt;     public Set getAspectPath() {
&gt;     	return aspectPath;
&gt;     }
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/NullIdeManager.java" revision="1.2" state="changed">46a47,48
&gt; 				
&gt; 			//Ajde.getDefault().enableLogging( System.out );
</file>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java" revision="1.2" state="changed">240a241
&gt;   		// AMC - updated for AspectJ 1.1 options
245a247,256
&gt; 				+ "\n-&gt; -injars " + formatSet(properties.getInJars())
&gt; 				+ "\n-&gt; -outjar " + formatOptionalString(properties.getOutJar())
&gt; 				+ "\n-&gt; -sourceroots " + formatSet(properties.getSourceRoots())
&gt; 				+ "\n-&gt; -aspectpath " + formatSet(properties.getAspectPath())
&gt; 				+ "\n-&gt; -" + buildOptions.getComplianceLevel()
&gt; 				+ "\n-&gt; -source " + buildOptions.getSourceCompatibilityLevel()
&gt; 				+ "\n-&gt; -g:" + formatSet(buildOptions.getDebugLevel())
&gt; 				+ "\n-&gt; -warn:" + formatSet(buildOptions.getWarnings())
&gt; 				+ "\n-&gt; noImportError: " + buildOptions.getNoImportError()
&gt; 				+ "\n-&gt; preserveAllLocals:" + buildOptions.getPreserveAllLocals()
247,253c258,283
&lt; 				+ "\n-&gt; porting mode: " + buildOptions.getPortingMode()
&lt; 				+ "\n-&gt; source 1.4 mode: " + buildOptions.getSourceOnePointFourMode()
&lt; 				+ "\n-&gt; strict spec mode: " + buildOptions.getStrictSpecMode()
&lt; 				+ "\n-&gt; lenient spec mode: " + buildOptions.getLenientSpecMode()
&lt; 				+ "\n-&gt; use javac mode: " + buildOptions.getUseJavacMode()
&lt; 				+ "\n-&gt; preprocess mode: " + buildOptions.getPreprocessMode()
&lt; 				+ "\n-&gt; working dir: " + buildOptions.getWorkingOutputPath();
---
&gt; 				+ "\n-&gt; [ignored-deprecated in AspectJ1.1] porting mode: " + buildOptions.getPortingMode()
&gt; 				+ "\n-&gt; [ignored-deprecated in AspectJ1.1] source 1.4 mode: " + buildOptions.getSourceOnePointFourMode()
&gt; 				+ "\n-&gt; [ignored-deprecated in AspectJ1.1] strict spec mode: " + buildOptions.getStrictSpecMode()
&gt; 				+ "\n-&gt; [ignored-deprecated in AspectJ1.1] lenient spec mode: " + buildOptions.getLenientSpecMode()
&gt; 				+ "\n-&gt; [ignored-deprecated in AspectJ1.1] use javac mode: " + buildOptions.getUseJavacMode()
&gt; 				+ "\n-&gt; [ignored-deprecated in AspectJ1.1] preprocess mode: " + buildOptions.getPreprocessMode()
&gt; 				+ "\n-&gt; [ignored-deprecated in AspectJ1.1] working dir: " + buildOptions.getWorkingOutputPath();
&gt; 		}
&gt; 		
&gt; 		private String formatSet( Set options ) {
&gt; 			if ( options == null ) return "&lt;default&gt;";
&gt; 			if ( options.isEmpty() ) return "none";
&gt; 			
&gt; 			StringBuffer formattedOptions = new StringBuffer();
&gt; 			Iterator it = options.iterator();
&gt; 			while (it.hasNext()) {
&gt; 				String o = it.next().toString();
&gt; 				if (formattedOptions.length() &gt; 0) formattedOptions.append(", ");
&gt; 				formattedOptions.append( o );
&gt; 			}
&gt; 			return formattedOptions.toString();
&gt; 		}
&gt; 		
&gt; 		private String formatOptionalString( String s ) {
&gt; 			if ( s == null ) { return ""	; }
&gt; 			else { return s; }
</file>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java" revision="1.2" state="changed">11a12,13
&gt;  *     AMC 01.20.2003 extended to support AspectJ 1.1 options,
&gt;  * 					  bugzilla #29769
17a20,24
&gt; import java.util.HashSet;
&gt; import java.util.Iterator;
&gt; import java.util.Set;
&gt; import java.util.StringTokenizer;
&gt; 
35a43,51
&gt; 	// 1.1 constants added by AMC
&gt; 	private static final String COMPLIANCE_LEVEL = AJC + ".complianceLevel";
&gt; 	private static final String SOURCE_LEVEL = AJC + ".sourceLevel";
&gt; 	private static final String WARNINGS = AJC + ".warnings";
&gt; 	private static final String DEBUG_OPTIONS = AJC + ".debugOptions";
&gt; 	private static final String NO_IMPORT_ERROR = AJC + ".noImportError";
&gt; 	private static final String PRESERVE_LOCALS = AJC + ".preserveLocals";
&gt; 	private static final String DEFAULT = "default";
&gt; 	
40c56,57
&lt; 	
---
&gt; 
&gt; 	/** @deprecated */	
44a62
&gt; 	/** @deprecated */
48a67
&gt; 	/** @deprecated */
52a72
&gt; 	/** @deprecated */
56a77
&gt; 	/** @deprecated */
60a82
&gt; 	/** @deprecated */
72a95
&gt; 	/** @deprecated */
76a100
&gt; 	/** @deprecated */
80a105
&gt; 	/** @deprecated */
84a110
&gt; 	/** @deprecated */
88a115
&gt; 	/** @deprecated */
92a120
&gt; 	/** @deprecated */
96a125
&gt; 	/** @deprecated */
100a130
&gt; 	/** @deprecated */
119a150,232
&gt; 
&gt; 	// -------------
&gt; 	// new 1.1 compiler options start here...
&gt; 	
&gt; 	/**
&gt; 	 * JDK Compliance level to be used by the compiler, either 
&gt; 	 * VERSION_13 or VERSION_14.
&gt; 	 * From -1.3 / -1.4
&gt; 	 */
&gt; 	public String getComplianceLevel() {
&gt; 		return preferencesAdapter.getProjectPreference(COMPLIANCE_LEVEL);		
&gt; 	}
&gt; 	
&gt; 	public void setComplianceLevel( String value ) {
&gt; 		preferencesAdapter.setProjectPreference(COMPLIANCE_LEVEL,value);	
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Source compatibility level, either VERSION_13 or VERSION_14.
&gt; 	 * From -source (eclipse option)
&gt; 	 */
&gt; 	public String getSourceCompatibilityLevel() {
&gt; 		return preferencesAdapter.getProjectPreference(SOURCE_LEVEL);		
&gt; 	}
&gt; 
&gt; 	public void setSourceCompatibilityLevel(String value) {
&gt; 		preferencesAdapter.setProjectPreference(SOURCE_LEVEL, value);		
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Optional warnings, empty List is equivalent to -warn:none,
&gt; 	 * returning null uses eclipse compiler default settings
&gt; 	 * From -warn:xxx,yyy
&gt; 	 */
&gt; 	public Set getWarnings() {
&gt; 		String warnings = preferencesAdapter.getProjectPreference(WARNINGS);
&gt; 		return toWarningSet( warnings );
&gt; 	}
&gt; 	
&gt; 	public void setWarnings( Set warningSet ) {
&gt; 		String warnings = fromWarningSet( warningSet );
&gt; 		preferencesAdapter.setProjectPreference(WARNINGS, warnings); 
&gt; 	}	
&gt; 	
&gt; 	/**
&gt; 	 * Debug level. DEBUG_ALL == {SOURCE, LINES, VARS}.
&gt; 	 * Empty list is equivalent to -g:none, returning
&gt; 	 * non uses eclipse compiler default settings
&gt; 	 * From -g:xxx
&gt; 	 */
&gt; 	public Set getDebugLevel() {
&gt; 		String debug = preferencesAdapter.getProjectPreference(DEBUG_OPTIONS);
&gt; 		return toDebugSet( debug );
&gt; 	}
&gt; 
&gt; 	public void setDebugLevel( Set debugSet ) {
&gt; 		String debug = fromDebugSet( debugSet );
&gt; 		preferencesAdapter.setProjectPreference(DEBUG_OPTIONS, debug); 
&gt; 	}	
&gt; 	
&gt; 	/**
&gt; 	 * No errors generated for unresolved imports
&gt; 	 * From -noImportError
&gt; 	 */
&gt; 	public boolean getNoImportError() {
&gt; 		return getBooleanOptionVal(NO_IMPORT_ERROR);
&gt; 	}
&gt; 	
&gt; 	public void setNoImportError(boolean value) {
&gt; 		setBooleanOptionVal(NO_IMPORT_ERROR, value);	
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Preserve all unused local variables (for debug)
&gt; 	 * From -preserveAllLocals
&gt; 	 */
&gt; 	public boolean getPreserveAllLocals() {
&gt; 		return getBooleanOptionVal(PRESERVE_LOCALS);
&gt; 	}
&gt; 	
&gt; 	public void setPreserveAllLocals(boolean value) {
&gt; 		setBooleanOptionVal(PRESERVE_LOCALS, value);	
&gt; 	}
135a249,300
&gt; 	
&gt; 	private Set toWarningSet( String warnings ) {
&gt; 		if ( null == warnings ) return null;
&gt; 		if ( warnings.equals(DEFAULT) ) return null;
&gt; 		
&gt; 		Set warningSet = new HashSet();	
&gt; 		StringTokenizer tok = new StringTokenizer( warnings, "," );
&gt; 		while ( tok.hasMoreTokens() ) {
&gt; 			String warning = tok.nextToken();
&gt; 			warningSet.add( warning );	
&gt; 		}
&gt; 		return warningSet;
&gt; 	}
&gt; 	
&gt; 	private String fromWarningSet( Set warningSet ) {
&gt; 		if ( warningSet == null ) return DEFAULT;
&gt; 		
&gt; 		StringBuffer warnings = new StringBuffer();
&gt; 		Iterator it = warningSet.iterator();
&gt; 		while ( it.hasNext() ) {
&gt; 			String w = (String) it.next();	
&gt; 			if (warnings.length() &gt; 0 ) warnings.append(',');
&gt; 			warnings.append( w );
&gt; 		}
&gt; 		return warnings.toString();
&gt; 	}
&gt; 
&gt; 	private Set toDebugSet( String debugOptions ) {
&gt; 		if ( null == debugOptions ) return null;
&gt; 		if ( debugOptions.equals(DEFAULT) ) return null;
&gt; 		
&gt; 		Set debugSet = new HashSet();	
&gt; 		StringTokenizer tok = new StringTokenizer( debugOptions, "," );
&gt; 		while ( tok.hasMoreTokens() ) {
&gt; 			String debug = tok.nextToken();
&gt; 			debugSet.add( debug );	
&gt; 		}
&gt; 		return debugSet;	}
&gt; 	
&gt; 	private String fromDebugSet( Set debugSet ) {
&gt; 		if ( debugSet == null ) return DEFAULT;
&gt; 		
&gt; 		StringBuffer debugOptions = new StringBuffer();
&gt; 		Iterator it = debugSet.iterator();
&gt; 		while ( it.hasNext() ) {
&gt; 			String d = (String) it.next();	
&gt; 			if (debugOptions.length() &gt; 0 ) debugOptions.append(',');
&gt; 			debugOptions.append( d );
&gt; 		}
&gt; 		return debugOptions.toString();
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.java" revision="1.2" state="changed">11a12
&gt;  * 	   AMC 01.20.2003 extended for new AspectJ 1.1 project options
145a147,163
&gt;     
&gt;     // 1.1 options
&gt;     public Set getInJars( ) {
&gt;     	return null;
&gt;     }
&gt;     
&gt;     public String getOutJar( ) {
&gt;     	return null;
&gt;     }
&gt;     
&gt; 	public Set getSourceRoots( ) {
&gt; 		return null;
&gt; 	}    
&gt; 	
&gt; 	public Set getAspectPath( ) {
&gt; 		return null;
&gt; 	}
</file>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.java" revision="1.2" state="changed">11c11,12
&lt;  *     Xerox/PARC     initial implementation 
---
&gt;  *     Xerox/PARC       initial implementation 
&gt;  *     AMC  01.20.2003  extended for AspectJ 1.1 compiler options
17a19
&gt; import java.util.Set;
57a60,93
&gt;     
&gt;     // following methods added for AspectJ 1.1
&gt; 	//-----------------------------------------
&gt; 	
&gt; 	/**
&gt; 	 * Get the set of input jar files for this compilation.
&gt; 	 * Set members should be of type java.io.File.
&gt; 	 * An empty set or null is acceptable for this option.
&gt; 	 * From -injars.
&gt; 	 */
&gt; 	public Set getInJars();
&gt; 	
&gt; 	/**
&gt; 	 * Get the output jar file for the compilation results.
&gt; 	 * Return null to leave classfiles unjar'd in output directory
&gt; 	 * From -outjar
&gt; 	 */
&gt; 	public String getOutJar();
&gt; 	
&gt; 	/**
&gt; 	 * Get a set of root source directories for the compilation.
&gt; 	 * Set members should be of type java.io.File
&gt; 	 * Returning null or an empty set disables the option.
&gt; 	 * From -sourceroots
&gt; 	 */
&gt; 	public Set getSourceRoots();
&gt; 	
&gt; 	/**
&gt; 	 * Get the set of aspect jar files to be used for the compilation.
&gt; 	 * Returning null or an empty set disables this option. Set members
&gt; 	 * should be of type java.io.File.
&gt; 	 * From -aspectpath
&gt; 	 */
&gt; 	public Set getAspectPath();
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/StructureModelTest.java" revision="1.2" state="changed">10a11
&gt;  *     AMC 21.01.2003 fixed for new source location in eclipse.org
46c47
&lt; 		File testFile = createFile("../examples/figures-coverage/figures/Figure.java");	
---
&gt; 		File testFile = createFile("testdata/examples/figures-coverage/figures/Figure.java");	
68c69
&lt; 		File pointFile = createFile("../examples/figures-coverage/figures/primitives/planar/Point.java");	
---
&gt; 		File pointFile = createFile("testdata/examples/figures-coverage/figures/primitives/planar/Point.java");	
77c78
&lt; 		File testFile = createFile("../examples/figures-coverage/figures/Main.java");	
---
&gt; 		File testFile = createFile("testdata/examples/figures-coverage/figures/Main.java");	
90c91
&lt; 		File testFile = createFile("../examples/figures-coverage/figures/Main.java");	
---
&gt; 		File testFile = createFile("testdata/examples/figures-coverage/figures/Main.java");	
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.java" revision="1.2" state="changed">10a11
&gt;  * 	   AMC 01.21.2003 extended to cover new AspectJ1.1 options
15a17,20
&gt; import java.util.HashSet;
&gt; import java.util.Iterator;
&gt; import java.util.Set;
&gt; 
49a55,145
&gt; 
&gt; 	public void testVerboseMode() {
&gt; 		buildOptions.setVerboseMode(true);
&gt; 		assertTrue("verbose mode", buildOptions.getVerboseMode());	
&gt; 	}		
&gt; 	
&gt; 	public void testNonStandardOptions() {
&gt; 		buildOptions.setNonStandardOptions( "-Xlint" );
&gt; 		assertEquals( "non std options", "-Xlint", 
&gt; 			buildOptions.getNonStandardOptions());
&gt; 	}
&gt; 	
&gt; 	public void testComplianceLevel() {
&gt; 		buildOptions.setComplianceLevel( BuildOptionsAdapter.VERSION_14 );
&gt; 		assertEquals( "compliance level",
&gt; 					  BuildOptionsAdapter.VERSION_14,
&gt; 					  buildOptions.getComplianceLevel());	
&gt; 	}
&gt; 	
&gt; 	public void testSourceCompatibilityLevel() {
&gt; 		buildOptions.setSourceCompatibilityLevel(BuildOptionsAdapter.VERSION_13);
&gt; 		assertEquals( "source level",
&gt; 					  BuildOptionsAdapter.VERSION_13,
&gt; 					  buildOptions.getSourceCompatibilityLevel());				
&gt; 	}
&gt; 	
&gt; 	public void testWarnings() {
&gt; 		buildOptions.setWarnings( null );
&gt; 		assertNull( "null warning set", buildOptions.getWarnings());
&gt; 		HashSet s = new HashSet();
&gt; 		buildOptions.setWarnings( s );
&gt; 		Set s2 = buildOptions.getWarnings();
&gt; 		assertTrue( "empty warning set", s2.isEmpty() );
&gt; 		s.add( BuildOptionsAdapter.WARN_ASSERT_IDENITIFIER );
&gt; 		s.add( BuildOptionsAdapter.WARN_MASKED_CATCH_BLOCKS );
&gt; 		buildOptions.setWarnings( s );
&gt; 		s2 = buildOptions.getWarnings();
&gt; 		assertTrue( "two warnings", s2.size() == 2 );
&gt; 		boolean warn_assert_found = false;
&gt; 		boolean warn_catch_found = false;
&gt; 		Iterator it = s2.iterator();
&gt; 		while (it.hasNext()) {
&gt; 			String option = (String) it.next();
&gt; 			if ( option.equals( BuildOptionsAdapter.WARN_ASSERT_IDENITIFIER ) ) {
&gt; 				warn_assert_found = true;
&gt; 			}					
&gt; 			if ( option.equals( BuildOptionsAdapter.WARN_MASKED_CATCH_BLOCKS ) ) {
&gt; 				warn_catch_found = true;
&gt; 			}					
&gt; 		}
&gt; 		assertTrue( "assert warning found", warn_assert_found );	
&gt; 		assertTrue( "catch waning found", warn_catch_found );
&gt; 	}
&gt; 	
&gt; 	public void testDebugLevel() {
&gt; 		buildOptions.setDebugLevel( null );
&gt; 		assertNull( "null debug set", buildOptions.getDebugLevel());
&gt; 		HashSet s = new HashSet();
&gt; 		buildOptions.setDebugLevel( s );
&gt; 		Set s2 = buildOptions.getDebugLevel();
&gt; 		assertTrue( "empty debug set", s2.isEmpty() );
&gt; 		s.add( BuildOptionsAdapter.DEBUG_LINES );
&gt; 		s.add( BuildOptionsAdapter.DEBUG_SOURCE );
&gt; 		buildOptions.setDebugLevel( s );
&gt; 		s2 = buildOptions.getDebugLevel();
&gt; 		assertTrue( "two warnings", s2.size() == 2 );
&gt; 		boolean debug_lines_found = false;
&gt; 		boolean debug_source_found = false;
&gt; 		Iterator it = s2.iterator();
&gt; 		while (it.hasNext()) {
&gt; 			String option = (String) it.next();
&gt; 			if ( option.equals( BuildOptionsAdapter.DEBUG_LINES ) ) {
&gt; 				debug_lines_found = true;
&gt; 			}					
&gt; 			if ( option.equals( BuildOptionsAdapter.DEBUG_SOURCE ) ) {
&gt; 				debug_source_found = true;
&gt; 			}					
&gt; 		}
&gt; 		assertTrue( "debug lines found", debug_lines_found );	
&gt; 		assertTrue( "debug source found", debug_source_found );				
&gt; 	}
&gt; 
&gt; 	public void testNoImportError() {
&gt; 		buildOptions.setNoImportError(true);
&gt; 		assertTrue("no import error", buildOptions.getNoImportError());			
&gt; 	}
&gt; 	
&gt; 	public void testPreserveLocals() {
&gt; 		buildOptions.setPreserveAllLocals(true);
&gt; 		assertTrue("preserve all locals", buildOptions.getPreserveAllLocals());					
&gt; 	}
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java" revision="1.1" state="new">/**********************************************************************
Copyright (c) 2003 IBM Corporation and others.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Common Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/cpl-v10.html
Contributors:
Adrian Colyer - initial version
...
**********************************************************************/
package org.aspectj.ajde;

import java.io.File;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.JFrame;

import junit.framework.TestSuite;

import org.aspectj.ajde.internal.CompilerAdapter;
import org.aspectj.ajde.ui.IdeUIAdapter;
import org.aspectj.ajde.ui.UserPreferencesAdapter;
import org.aspectj.ajde.ui.internal.AjcBuildOptions;
import org.aspectj.ajde.ui.internal.UserPreferencesStore;
import org.aspectj.ajde.ui.swing.AjdeUIManager;
import org.aspectj.ajde.ui.swing.BasicEditor;
import org.aspectj.ajde.ui.swing.IconRegistry;
import org.aspectj.ajdt.internal.core.builder.AjBuildConfig;
import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;

/**
 * Tests that a correctly populated AjBuildConfig object is created
 * in reponse to the setting in BuildOptionsAdapter and 
 * ProjectPropretiesAdapter
 */
public class BuildConfigurationTests extends AjdeTestCase {

	private CompilerAdapter compilerAdapter;
	private AjBuildConfig buildConfig = null;
	private AjcBuildOptions buildOptions = null;
	private UserPreferencesAdapter preferencesAdapter = null;
	private NullIdeProperties projectProperties = null;
	private static final String configFile = 
		"testdata/examples/figures-coverage/all.lst";
	

	public BuildConfigurationTests( String name ) {
		super( name );	
	}

	public static void main(String[] args) {
		junit.swingui.TestRunner.run(BuildConfigurationTests.class);
	}

	public static TestSuite suite() {
		TestSuite result = new TestSuite();
		result.addTestSuite(BuildConfigurationTests.class);	
		return result;
	}


	// The tests...
	public void testCharacterEncoding() {
		buildOptions.setCharacterEncoding( "12345" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		String encoding = (String) options.get( CompilerOptions.OPTION_Encoding );
		assertEquals( "character encoding", "12345", encoding );
	}
	
	public void testComplianceLevel() {
		buildOptions.setComplianceLevel( BuildOptionsAdapter.VERSION_14 );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		String compliance = (String) options.get(CompilerOptions.OPTION_Compliance);
		String sourceLevel = (String) options.get(CompilerOptions.OPTION_Source);		
		assertEquals( "compliance level", CompilerOptions.VERSION_1_4, compliance);
		assertEquals( "source level", CompilerOptions.VERSION_1_4, sourceLevel );
	}
	
	public void testSourceCompatibilityLevel() {
		buildOptions.setComplianceLevel( BuildOptionsAdapter.VERSION_13);
		buildOptions.setSourceCompatibilityLevel( BuildOptionsAdapter.VERSION_14);
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		String compliance = (String) options.get(CompilerOptions.OPTION_Compliance);
		String sourceLevel = (String) options.get(CompilerOptions.OPTION_Source);		
		assertEquals( "compliance level", CompilerOptions.VERSION_1_3, compliance);
		assertEquals( "source level", CompilerOptions.VERSION_1_4, sourceLevel );		
	}
	
	public void testSourceIncompatibilityLevel() {
		// this config should "fail" and leave source level at 1.4
		buildOptions.setComplianceLevel( BuildOptionsAdapter.VERSION_14);
		buildOptions.setSourceCompatibilityLevel( BuildOptionsAdapter.VERSION_13);
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		String compliance = (String) options.get(CompilerOptions.OPTION_Compliance);
		String sourceLevel = (String) options.get(CompilerOptions.OPTION_Source);		
		assertEquals( "compliance level", CompilerOptions.VERSION_1_4, compliance);
		assertEquals( "source level", CompilerOptions.VERSION_1_4, sourceLevel );		
	}
	
	
	public void testNullWarnings() {
		buildOptions.setWarnings( null );	
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		
		// this should leave us with the default warnings
		assertOptionEquals( "report overriding package default",
							options, 
						    CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report method with cons name",
							options, 
						    CompilerOptions.OPTION_ReportMethodWithConstructorName,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report deprecation",
							options, 
						    CompilerOptions.OPTION_ReportDeprecation,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report hidden catch block",
							options, 
						    CompilerOptions.OPTION_ReportHiddenCatchBlock,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report unused local",
							options, 
						    CompilerOptions.OPTION_ReportUnusedLocal,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report unused param",
							options, 
						    CompilerOptions.OPTION_ReportUnusedParameter,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report synthectic access",
							options, 
						    CompilerOptions.OPTION_ReportSyntheticAccessEmulation,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report non-externalized string literal",
							options, 
						    CompilerOptions.OPTION_ReportNonExternalizedStringLiteral,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report assert identifer",
							options, 
						    CompilerOptions.OPTION_ReportAssertIdentifier,
						    CompilerOptions.IGNORE);						    
	}
	
	public void testEmptyWarnings() {
		buildOptions.setWarnings( new HashSet() );	
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		
		// this should leave us with the user specifiable warnings
		// turned off
		assertOptionEquals( "report overriding package default",
							options, 
						    CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report method with cons name",
							options, 
						    CompilerOptions.OPTION_ReportMethodWithConstructorName,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report deprecation",
							options, 
						    CompilerOptions.OPTION_ReportDeprecation,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report hidden catch block",
							options, 
						    CompilerOptions.OPTION_ReportHiddenCatchBlock,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report unused local",
							options, 
						    CompilerOptions.OPTION_ReportUnusedLocal,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report unused param",
							options, 
						    CompilerOptions.OPTION_ReportUnusedParameter,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report synthectic access",
							options, 
						    CompilerOptions.OPTION_ReportSyntheticAccessEmulation,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report non-externalized string literal",
							options, 
						    CompilerOptions.OPTION_ReportNonExternalizedStringLiteral,
						    CompilerOptions.IGNORE);
		assertOptionEquals( "report assert identifer",
							options, 
						    CompilerOptions.OPTION_ReportAssertIdentifier,
						    CompilerOptions.IGNORE);						    		
	}
	
	public void testSetOfWarnings() {
		HashSet warnings = new HashSet();
		warnings.add( BuildOptionsAdapter.WARN_ASSERT_IDENITIFIER );		
		warnings.add( BuildOptionsAdapter.WARN_CONSTRUCTOR_NAME );		
		warnings.add( BuildOptionsAdapter.WARN_DEPRECATION );		
		warnings.add( BuildOptionsAdapter.WARN_MASKED_CATCH_BLOCKS );		
		warnings.add( BuildOptionsAdapter.WARN_PACKAGE_DEFAULT_METHOD );		
		warnings.add( BuildOptionsAdapter.WARN_SYNTHETIC_ACCESS );		
		warnings.add( BuildOptionsAdapter.WARN_UNUSED_ARGUMENTS );		
		warnings.add( BuildOptionsAdapter.WARN_UNUSED_IMPORTS );		
		warnings.add( BuildOptionsAdapter.WARN_UNUSED_LOCALS );		
		warnings.add( BuildOptionsAdapter.WARN_NLS );

		buildOptions.setWarnings( warnings );	
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		
		// this should leave us with all the user specifiable warnings
		// turned on
		assertOptionEquals( "report overriding package default",
							options, 
						    CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report method with cons name",
							options, 
						    CompilerOptions.OPTION_ReportMethodWithConstructorName,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report deprecation",
							options, 
						    CompilerOptions.OPTION_ReportDeprecation,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report hidden catch block",
							options, 
						    CompilerOptions.OPTION_ReportHiddenCatchBlock,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report unused local",
							options, 
						    CompilerOptions.OPTION_ReportUnusedLocal,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report unused param",
							options, 
						    CompilerOptions.OPTION_ReportUnusedParameter,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report synthectic access",
							options, 
						    CompilerOptions.OPTION_ReportSyntheticAccessEmulation,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report non-externalized string literal",
							options, 
						    CompilerOptions.OPTION_ReportNonExternalizedStringLiteral,
						    CompilerOptions.WARNING);
		assertOptionEquals( "report assert identifer",
							options, 
						    CompilerOptions.OPTION_ReportAssertIdentifier,
						    CompilerOptions.WARNING);						    		
	}
	
	public void testNoDebugOptions() {
		buildOptions.setDebugLevel( null );	
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		
		// this should leave us with the default debug settings
		assertOptionEquals( "debug source",
							options, 
						    CompilerOptions.OPTION_SourceFileAttribute,
						    CompilerOptions.DO_NOT_GENERATE);
		assertOptionEquals( "debug lines",
							options, 
						    CompilerOptions.OPTION_LineNumberAttribute,
						    CompilerOptions.DO_NOT_GENERATE);
		assertOptionEquals( "debug vars",
							options, 
						    CompilerOptions.OPTION_LocalVariableAttribute,
						    CompilerOptions.DO_NOT_GENERATE);						    						
	}
	
	public void testEmptyDebugOptions() {
		buildOptions.setDebugLevel( new HashSet() );	
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		
		// this should leave us with the debug off
		assertOptionEquals( "debug source",
							options, 
						    CompilerOptions.OPTION_SourceFileAttribute,
						    CompilerOptions.DO_NOT_GENERATE);
		assertOptionEquals( "debug lines",
							options, 
						    CompilerOptions.OPTION_LineNumberAttribute,
						    CompilerOptions.DO_NOT_GENERATE);
		assertOptionEquals( "debug vars",
							options, 
						    CompilerOptions.OPTION_LocalVariableAttribute,
						    CompilerOptions.DO_NOT_GENERATE);						    								
	}
	
	public void testDebugAll() {
		HashSet debugOpts = new HashSet();
		debugOpts.add( BuildOptionsAdapter.DEBUG_ALL );
		buildOptions.setDebugLevel( debugOpts );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		
		// this should leave us with all debug on
		assertOptionEquals( "debug source",
							options, 
						    CompilerOptions.OPTION_SourceFileAttribute,
						    CompilerOptions.GENERATE);
		assertOptionEquals( "debug lines",
							options, 
						    CompilerOptions.OPTION_LineNumberAttribute,
						    CompilerOptions.GENERATE);
		assertOptionEquals( "debug vars",
							options, 
						    CompilerOptions.OPTION_LocalVariableAttribute,
						    CompilerOptions.GENERATE);						    								
		
	}
	
	public void testDebugSet() {
		HashSet debugOpts = new HashSet();
		debugOpts.add( BuildOptionsAdapter.DEBUG_SOURCE );
		debugOpts.add( BuildOptionsAdapter.DEBUG_VARS );
		buildOptions.setDebugLevel( debugOpts );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		
		// this should leave us with all debug on
		assertOptionEquals( "debug source",
							options, 
						    CompilerOptions.OPTION_SourceFileAttribute,
						    CompilerOptions.GENERATE);
		assertOptionEquals( "debug lines",
							options, 
						    CompilerOptions.OPTION_LineNumberAttribute,
						    CompilerOptions.DO_NOT_GENERATE);
		assertOptionEquals( "debug vars",
							options, 
						    CompilerOptions.OPTION_LocalVariableAttribute,
						    CompilerOptions.GENERATE);						    											
	}
	
	public void testNoImport() {
		buildOptions.setNoImportError( true );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		String noImport = (String) options.get( CompilerOptions.OPTION_ReportInvalidImport );
		assertEquals( "no import", CompilerOptions.WARNING, noImport );
		buildOptions.setNoImportError( false );
	}
	
	public void testPreserveAllLocals() {
		buildOptions.setPreserveAllLocals( true );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		Map options = buildConfig.getJavaOptions();
		String preserve = (String) options.get( CompilerOptions.OPTION_PreserveUnusedLocal );
		assertEquals( "preserve unused", CompilerOptions.PRESERVE, preserve );
	}	

	public void testNonStandardOptions() {
		buildOptions.setNonStandardOptions( "-XnoWeave" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertTrue( "XnoWeave", buildConfig.isNoWeave() );
		buildOptions.setNonStandardOptions( "-XserializableAspects" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertTrue( "XserializableAspects", buildConfig.isXserializableAspects() );
		buildOptions.setNonStandardOptions( "-XnoInline" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertTrue( "XnoInline", buildConfig.isXnoInline());
		buildOptions.setNonStandardOptions( "-Xlint" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertEquals( "Xlint", AjBuildConfig.AJLINT_DEFAULT, 
		                       buildConfig.getLintMode());
		buildOptions.setNonStandardOptions( "-Xlint:error" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertEquals( "Xlint", AjBuildConfig.AJLINT_ERROR, 
		                       buildConfig.getLintMode());
		buildOptions.setNonStandardOptions( "-Xlintfile testdata/AspectJBuildManagerTest/lint.properties" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertEquals( "Xlintfile", new File( "testdata/AspectJBuildManagerTest/lint.properties" ).getAbsolutePath(), 
		                       buildConfig.getLintSpecFile().toString());
		// and a few options thrown in at once
		buildOptions.setNonStandardOptions( "-Xlint -XnoInline -XserializableAspects" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertEquals( "Xlint", AjBuildConfig.AJLINT_DEFAULT, 
		                       buildConfig.getLintMode());
		assertTrue( "XnoInline", buildConfig.isXnoInline());
		assertTrue( "XserializableAspects", buildConfig.isXserializableAspects() );			                       						
	}

	public void testSourceRoots() {
		Set roots = new HashSet();
		projectProperties.setSourceRoots( roots );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		List configRoots = buildConfig.getSourceRoots();	
		assertTrue( "no source dirs", configRoots.isEmpty() );
		
		File f = new File( "testdata/examples/figures/figures-coverage" );
		roots.add( f );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		List configRoots2 = buildConfig.getSourceRoots();	
		assertTrue( "one source dir", configRoots2.size() == 1 );
		assertTrue( "source dir", configRoots2.contains(f) );

		
		File f2 = new File( "testdata/examples/figures/figures-demo" );
		roots.add( f2 );		
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		List configRoots3 = buildConfig.getSourceRoots();	
		assertTrue( "two source dirs", configRoots3.size() == 2 );
		assertTrue( "source dir 1", configRoots3.contains(f) );
		assertTrue( "source dir 2", configRoots3.contains(f2) );
	}
	
	public void testInJars() {
		Set jars = new HashSet();
		projectProperties.setInJars( jars );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		List inJars = buildConfig.getInJars();	
		assertTrue( "no in jars", inJars.isEmpty() );
		
		File f = new File( "jarone.jar" );
		jars.add( f );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		List inJars2 = buildConfig.getInJars();
		assertTrue( "one in jar", inJars2.size() == 1 );
		assertTrue( "in jar", inJars2.contains(f) );

		
		File f2 = new File( "jartwo.jar" );
		jars.add( f2 );		
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		List inJars3 = buildConfig.getInJars();	
		assertTrue( "two in jars", inJars3.size() == 2 );
		assertTrue( "in jar 1", inJars3.contains(f) );
		assertTrue( "in jar 2", inJars3.contains(f2) );		
	}
	
	public void testAspectPath() {
		Set aspects = new HashSet();
		projectProperties.setAspectPath( aspects );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		List aPath = buildConfig.getAspectpath();	
		assertTrue( "no aspect path", aPath.isEmpty() );
		
		File f = new File( "jarone.jar" );
		aspects.add( f );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		List aPath2 = buildConfig.getAspectpath();	
		assertTrue( "one jar in path", aPath2.size() == 1 );
		assertTrue( "1 aspectpath", aPath2.contains(f) );

		
		File f2 = new File( "jartwo.jar" );
		aspects.add( f2 );		
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		List aPath3 = buildConfig.getAspectpath();	
		assertTrue( "two jars in path", aPath3.size() == 2 );
		assertTrue( "1 aspectpath", aPath3.contains(f) );
		assertTrue( "2 aspectpath", aPath3.contains(f2) );		
	}
	
	public void testOutJar() {
		String outJar = "mybuild.jar";
		projectProperties.setOutJar( outJar );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertEquals( "out jar", outJar, buildConfig.getOutputJar().toString() );				
	}

	protected void setUp() throws Exception {
		preferencesAdapter = new UserPreferencesStore();
		buildOptions = new AjcBuildOptions(preferencesAdapter);
		compilerAdapter = new CompilerAdapter();
		projectProperties = new NullIdeProperties( "" );
		init();
	}
	
		protected void tearDown() throws Exception {
		super.tearDown();
		buildOptions.setCharacterEncoding("");
	}

	public void init() {
		try {
			Ajde.init(
				null,
				null,
				null,
				projectProperties,  
				buildOptions,
				null,
				null,
				null);	
				
			//Ajde.getDefault().enableLogging( System.out );
		} catch (Throwable t) {
			t.printStackTrace();
			Ajde.getDefault().getErrorHandler().handleError(
				"Ajde failed to initialize.",
				t);
		}
	}
	
	private void assertOptionEquals( String reason, Map options, String optionName, String value) {
		String mapValue = (String) options.get(optionName);
		assertEquals( reason, value, mapValue );
	}
	
}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java" revision="1.4" state="changed">338c338
&lt; 		assertTrue("", config.getLintMode().equals(AjBuildConfig.AJLINT_INGORE));
---
&gt; 		assertTrue("", config.getLintMode().equals(AjBuildConfig.AJLINT_IGNORE));
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AjdeTests.java" revision="1.2" state="changed">24a25
&gt;         suite.addTestSuite(BuildConfigurationTests.class);
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java" revision="1.2" state="changed">85a86
&gt; 		StructureNode n = currentView.getRootNode().getStructureNode();
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java" revision="1.2" state="changed">16a17
&gt; import java.util.List;
20a22
&gt; import org.aspectj.asm.StructureNode;
39c41
&lt; 		String testLstFile = "StructureModelRegressionTest/example.lst";
---
&gt; 		String testLstFile = "testdata/StructureModelRegressionTest/example.lst";
55c57,64
&lt; 			return savedModel.getRoot().equals(model.getRoot());
---
&gt; 			// AMC This test will not pass as written until StructureNode defines
&gt; 			// equals. The equals loic is commented out in the StructureNode
&gt; 			// class - adding it back in could have unforeseen system-wide
&gt; 			// consequences, so I've defined a structureNodesEqual( ) helper
&gt; 			// method here instead.
&gt; 			StructureNode rootNode = model.getRoot();
&gt; 			StructureNode savedRootNode = savedModel.getRoot();
&gt; 			return structureNodesEqual( rootNode, savedRootNode );
62a72,95
&gt; 	private boolean structureNodesEqual( StructureNode s1, StructureNode s2 ) {
&gt; 	  final boolean equal = true;
&gt; 	  	if ( s1 == s2 ) return equal;
&gt; 	  	if ( null == s1 || null == s2 ) return !equal;
&gt; 
&gt; 		if (!s1.getName( ).equals(s2.getName())) return !equal;
&gt; 		if (!s1.getKind( ).equals(s2.getKind())) return !equal;
&gt; 		
&gt; 		// check child nodes
&gt; 		List s1Kids = s1.getChildren();
&gt; 		List s2Kids = s2.getChildren();
&gt; 		
&gt; 		if ( s1Kids != null &amp;&amp; s2Kids != null ) {
&gt; 			if (s1Kids == null || s2Kids == null) return !equal;			
&gt; 			if (s1Kids.size() != s2Kids.size() ) return !equal;
&gt; 			for ( int k=0; k&lt;s1Kids.size(); k++ ) {
&gt; 				StructureNode k1 = (StructureNode) s1Kids.get(k);
&gt; 				StructureNode k2 = (StructureNode) s2Kids.get(k);	
&gt; 				if (!structureNodesEqual( k1, k2 )) return !equal;
&gt; 			}
&gt; 		}
&gt; 	  return equal;		
&gt; 	}
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="29934" transactionid="72556">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-false M T V</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>When the program below is run, it produces a NullPointerException...
java.lang.NullPointerException
	at A2.ajc$around$A2$3b6proceed(CflowCycles.java)
	at A2.ajc$around$A2$3b6_aroundBody3(CflowCycles.java:35)
	at Target.run(CflowCycles.java:24)
	at CflowCycles.run_aroundBody4(CflowCycles.java:8)
	at CflowCycles.main_aroundBody6(CflowCycles.java:24)
	at CflowCycles.main(CflowCycles.java:24)

---(in new/CflowCycles.java and in ajcTestsFailing.xml)

import org.aspectj.testing.Tester; 

/** @testcase cflow cycles in advice from different aspects */
public class CflowCycles {
  public static void main( String args[] ) {
        Tester.expectEvent("target A1");
        Tester.expectEvent("target A2");
        new Target().run();
        Tester.checkAllEventsIgnoreDups();
  }
}

class Target {
    public void run(){ }
}

aspect A1 {
    pointcut TargetRunFlow () 
        // ok if no cflow: within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within
(A1+);
        : !within(A1+) &amp;&amp; !preinitialization(new(..)) &amp;&amp; !initialization(new
(..))//cflow(within(Target) &amp;&amp; execution(* *(..))) &amp;&amp; !within(A1+)
        ;
    Object around () : TargetRunFlow() {
        Tester.event("target A1");
        return proceed();
    }
    // ok if in the same class
}

aspect A2 {
    pointcut TargetRun () 
        : within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within(A2+);
        ;
    Object around () : TargetRun() {
        Tester.event("target A2");
        return proceed();
    }
}</bugreport>
<testsforfix ID="29934" type="new">
    <file LOCATION="org.aspectj/modules/tests/jimTests.xml">
      <test NAME="can't apply around advice to the execution of around advice"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="can't apply around advice to the execution of around advice"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="24" file="output/29934/pre-fix/testresults.xml" passing="687" size="711"/>
<post-fix-testcases failing="25" file="output/29934/post-fix/testresults.xml" passing="686" size="711"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.16" state="changed">1208a1209,1212
&gt; 		// We can't inline around methods if they have around advice on them, this
&gt; 		// is because the weaving will extract the body and hence the proceed call.
&gt; 		//??? should consider optimizations to recognize simple cases that don't require body extraction
&gt; 		enclosingMethod.setCanInline(false);
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.38" state="changed">5661a5662,5668
&gt;     
&gt;     &lt;ajc-test dir="new" pr="29934"
&gt;       title="can't apply around advice to the execution of around advice"
&gt;       keywords="from-resolved_10x"&gt;
&gt;         &lt;compile files="CflowCycles.java"/&gt;
&gt;         &lt;run class="CflowCycles"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/ajcTestsFailing.xml" revision="1.20" state="changed">16,22d15
&lt;     
&lt;     &lt;ajc-test dir="new" pr="29934"
&lt;       title="can't apply around advice to the execution of around advice"
&lt;       keywords="from-resolved_10x"&gt;
&lt;         &lt;compile files="CflowCycles.java"/&gt;
&lt;         &lt;run class="CflowCycles"/&gt;
&lt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/jimTests.xml" revision="1.15" state="changed">3c3,8
&lt; 
---
&gt;     &lt;ajc-test dir="new" pr="29934"
&gt;       title="can't apply around advice to the execution of around advice"
&gt;       keywords="from-resolved_10x"&gt;
&gt;         &lt;compile files="CflowCycles.java"/&gt;
&gt;         &lt;run class="CflowCycles"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="29959" transactionid="72467">
<property name="files-churned" value="7"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="7"/>
<property name="hunks" value="14"/>
<property name="lines-added" value="15"/>
<property name="lines-deleted" value="29"/>
<property name="lines-modified" value="10"/>
<property name="lines-churned" value="54"/>
<property name="priority" value="P3"/>
<property name="severity" value="blocker"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-instanceof K-return K-true M O-instanceof T V Z-if</fullfingerprint>
<bugreport>AspectJ Compiler 1.1beta4
This program:

aspect Foo {
  void A.foo() { }
  void B.foo() { super.foo(); }
}

class A { }
class B extends A { }

class Main {
  public static void main(String[] args) {
    new B();
  }
}

causes this error at runtime:

Exception in thread "main" java.lang.VerifyError: (class: B, method: ajc$superDispatch$B$foo signature: ()V) Illegal use of nonvirtual function call
	at Main.main(Foo.java:11)

Note that foo is never even called; the error happens at load time when the new B() expression causes class B to be loaded.  There's no error if either one of the foo methods is declared in its class directly.

This is kind of a showstopper...

--Doug</bugreport>
<testsforfix ID="29959" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="super call in intertype method declaration body causes VerifyError"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/ajcTestsFailing.xml">
      <test NAME="super call in intertype method declaration body causes VerifyError"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="25" file="output/29959/pre-fix/testresults.xml" passing="673" size="698"/>
<post-fix-testcases failing="24" file="output/29959/post-fix/testresults.xml" passing="674" size="698"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java" revision="1.7" state="changed">113c113
&lt; 				explicitConstructor = explicitConstructor.getAccessMethod();
---
&gt; 				explicitConstructor = explicitConstructor.getAccessMethod(true);
229c229
&lt; 				explicitConstructor = explicitConstructor.getAccessMethod();
---
&gt; 				explicitConstructor = explicitConstructor.getAccessMethod(true);
</file>
<file name="org.aspectj/modules/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java" revision="1.3" state="changed">145c145
&lt; 		syntheticAccessor = binding.getAccessMethod();
---
&gt; 		syntheticAccessor = binding.getAccessMethod(isSuperAccess());
</file>
<file name="org.aspectj/modules/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java" revision="1.2" state="changed">158c158
&lt; 			syntheticAccessor = binding.getAccessMethod();
---
&gt; 			syntheticAccessor = binding.getAccessMethod(true);
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java" revision="1.3" state="changed">21d20
&lt; 	//private ReferenceBinding withinType;
25c24
&lt; 	//public MethodBinding introducedMethod;
---
&gt; 	public MethodBinding postDispatchMethod;
40a40,41
&gt; 			postDispatchMethod = 
&gt; 				world.makeMethodBinding(AjcMemberMaker.interMethodBody(signature, withinType));
44a46
&gt; 			postDispatchMethod = syntheticMethod;
49,76d50
&lt; 		
&lt; //		
&lt; //		this.declaringClass = 
&lt; //		
&lt; //		
&lt; //		
&lt; //		char[] dispatch2Name;
&lt; //		if (Modifier.isPublic(modifiers)) {
&lt; //			dispatch2Name = name;
&lt; //		} else if (Modifier.isPrivate(modifiers)) {
&lt; //			dispatch2Name = 
&lt; //			AstUtil.makeAjcMangledName("dispatch2".toCharArray(), withinType, selector);
&lt; //		} else {
&lt; //			// package visible
&lt; //			//??? optimize both in same package
&lt; //			dispatch2Name = 
&lt; //				AstUtil.makeAjcMangledName("dispatch2".toCharArray(), 
&lt; //								withinType.qualifiedPackageName(), selector);
&lt; //		}
&lt; //		
&lt; //		introducedMethod =
&lt; //			new MethodBinding(AstUtil.makePublic(modifiers), dispatch2Name, 
&lt; //							type, args, exceptions, declaringClass);
&lt; //		
&lt; //		this.dispatchMethod =
&lt; //				new DispatchMethodBinding(introducedMethod, withinType, mangledParams);
&lt; //	}
&lt; 
130,131c104,106
&lt; 	public MethodBinding getAccessMethod() {
&lt; 		return syntheticMethod;
---
&gt; 	public MethodBinding getAccessMethod(boolean staticReference) {
&gt; 		if (staticReference) return postDispatchMethod;
&gt; 		else return syntheticMethod;
</file>
<file name="org.aspectj/modules/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java" revision="1.5" state="changed">424c424
&lt; 	public MethodBinding getAccessMethod() {
---
&gt; 	public MethodBinding getAccessMethod(boolean staticReference) {
</file>
<file name="org.aspectj/modules/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java" revision="1.2" state="changed">184c184
&lt; 			syntheticAccessor = binding.getAccessMethod();
---
&gt; 			syntheticAccessor = binding.getAccessMethod(true);
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java" revision="1.6" state="changed">18a19
&gt; import org.aspectj.ajdt.internal.compiler.lookup.*;
51a53,63
&gt; 		// InterTypeMethodBindings are always statically bound, so there's no
&gt; 		// need to treat super calls specially here
&gt; 		if (superBinding instanceof InterTypeMethodBinding) {
&gt; 			return;
&gt; //			InterTypeMethodBinding m = (InterTypeMethodBinding)superBinding;
&gt; //			if (m.postDispatchMethod != null) {
&gt; //				call.binding = m.postDispatchMethod;
&gt; //			}
&gt; //			return;
&gt; 		}
&gt; 		
</file>
<file name="org.aspectj/modules/tests/jimTests.xml" revision="1.8" state="changed">3,7c3,5
&lt;     &lt;ajc-test dir="bugs" pr="29691"
&lt;     		title="Static inner aspects cannot reference user defined pointcuts"&gt;
&lt;         &lt;compile files="PcdLookup.java" /&gt;
&lt;         &lt;run class="PcdLookup"/&gt;
&lt;     &lt;/ajc-test&gt;
---
&gt; 
&gt; 
&gt; 
11,16c9
&lt;     &lt;ajc-test dir="new"
&lt;       title="work nicely with inner class method look-up rules and call-site advice"
&lt;       keywords="from-resolved_10x"&gt;
&lt;         &lt;compile files="InnerMethods.java"/&gt;
&lt;         &lt;run class="InnerMethods"/&gt;
&lt;     &lt;/ajc-test&gt;
---
&gt; 
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.30" state="changed">5562a5563,5568
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="29959"
&gt;             title="super call in intertype method declaration body causes VerifyError"&gt;
&gt;         &lt;compile files="SuperToIntro.java"/&gt;
&gt;         &lt;run class="SuperToIntro"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/ajcTestsFailing.xml" revision="1.11" state="changed">53a54,60
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="29959"
&gt;             title="super call in intertype method declaration body causes VerifyError"&gt;
&gt;         &lt;compile files="SuperToIntro.java"/&gt;
&gt;         &lt;run class="SuperToIntro"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs/SuperToIntro.java" revision="1.1" state="new">// from Bug#:  29959
import org.aspectj.testing.Tester;

aspect Foo {
    String A.onlyA() { return "onlyA"; }
    String A.foo() { return "Afoo"; }
    String B.foo() { return super.foo() + ":" + onlyA() + ":" + super.getName(); }
}

class A {
	String getName() { return "A"; }
}
class B extends A {
	String getName() { return "B"; }
	
	String onB1() { return foo() + ":" + onlyA() + ":" + getName(); }
	String onB2() { return super.foo() + ":" + super.onlyA() + ":" + super.getName(); }
}

public class SuperToIntro {
  public static void main(String[] args) {
  	B b = new B();
  	Tester.checkEqual(b.foo(), "Afoo:onlyA:A");
  	Tester.checkEqual(b.onB1(), "Afoo:onlyA:A:onlyA:B");
  	Tester.checkEqual(b.onB2(), "Afoo:onlyA:A");
  }
}
</file>
</fixedFiles>
</bug>
<bug id="30168" transactionid="72390">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="11"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="22"/>
<property name="lines-churned" value="28"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-return M T V Z-cast</fullfingerprint>
<bugreport>This program causes the java VM to crash. It is a minimal example -- if you remove anything in the aspects it works. 

1. PROGRAM CODE

package test;
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;

public class Test3 {
   public static void main(String[] args) throws Exception {
      Test3 a = new Test3();
      a.foo(-3);
   }
   public void foo(int i) {
      this.x=i;
   }
   int x;
   

}

aspect Log {
   pointcut assign(Object newval, Object targ):
      set(* test..*)  &amp;&amp; args(newval) &amp;&amp; target(targ);

   before(Object newval, Object targ): assign(newval,targ) {
      Signature sign = thisJoinPoint.getSignature();
      System.out.println(targ.toString() + "." + sign.getName() + ":=" + newval);
   }
   /*
}
// Different error message if you divide into two aspects
aspect Tracing {
   */
   pointcut tracedCall():
      call(* test..*(..))/* &amp;&amp; !within(Tracing)*/ &amp;&amp; !within(Log);

   after() returning (Object o):  tracedCall() {
      // Works if you comment out either of these two lines
      thisJoinPoint.getSignature();
      System.out.println(thisJoinPoint);
   }
} 

2. RESULTS ON SOLARIS

[erik@oden test] java test.Test3 
test.Test3@b8df17.x:=-3
 
Unexpected Signal : 11 occurred at PC=0xFA415A00
Function=[Unknown.]
Library=(N/A)
 
NOTE: We are unable to locate the function name symbol for the error
      just occurred. Please refer to release documentation for possible
      reason and solutions.
 
 
Current Java thread:
 
Dynamic libraries:
0x10000         java
0xff350000      /usr/lib/libthread.so.1
0xff390000      /usr/lib/libdl.so.1
0xff200000      /usr/lib/libc.so.1
0xff330000      /usr/platform/SUNW,Ultra-250/lib/libc_psr.so.1
0xfe000000      /usr/j2se/jre/lib/sparc/client/libjvm.so
0xff2e0000      /usr/lib/libCrun.so.1
0xff1e0000      /usr/lib/libsocket.so.1
0xff100000      /usr/lib/libnsl.so.1
0xff0d0000      /usr/lib/libm.so.1
0xff310000      /usr/lib/libw.so.1
0xff0b0000      /usr/lib/libmp.so.2
0xff080000      /usr/j2se/jre/lib/sparc/native_threads/libhpi.so
0xff050000      /usr/j2se/jre/lib/sparc/libverify.so
0xff020000      /usr/j2se/jre/lib/sparc/libjava.so
0xfe7e0000      /usr/j2se/jre/lib/sparc/libzip.so
0xfe5b0000      /usr/lib/locale/sv_SE/sv_SE.so.2
 
Local Time = Fri Jan 24 13:38:29 2003
Elapsed Time = 2
#
# HotSpot Virtual Machine Error : 11
# Error ID : 4F530E43505002D3 01
# Please report this error at
# http://java.sun.com/cgi-bin/bugreport.cgi
#
# Java VM: Java HotSpot(TM) Client VM (1.4.0-b92 mixed mode)
#
# An error report file has been saved as hs_err_pid15099.log.
# Please refer to the file for further information.
#
Abort
[erik@oden test] 
[erik@oden test] /usr/j2se.old/bin/java test.Test3
test.Test3@1afa3.x:=-3
 
Unexpected Signal : 11 occurred at PC=0x85c24
Function name=(N/A)
Library=(N/A)
 
NOTE: We are unable to locate the function name symbol for the error
      just occurred. Please refer to release documentation for possible
      reason and solutions.
 
 
 
Current Java thread:
 
Dynamic libraries:
0x10000         /usr/j2se.old/bin/../bin/sparc/native_threads/java
0xff350000      /usr/lib/libthread.so.1
0xff390000      /usr/lib/libdl.so.1
0xff200000      /usr/lib/libc.so.1
0xff330000      /usr/platform/SUNW,Ultra-250/lib/libc_psr.so.1
0xfe480000      /usr/j2se.old/jre/lib/sparc/client/libjvm.so
0xff2e0000      /usr/lib/libCrun.so.1
0xff1e0000      /usr/lib/libsocket.so.1
0xff100000      /usr/lib/libnsl.so.1
0xff0d0000      /usr/lib/libm.so.1
0xff310000      /usr/lib/libw.so.1
0xff0b0000      /usr/lib/libmp.so.2
0xff080000      /usr/j2se.old/jre/lib/sparc/native_threads/libhpi.so
0xff050000      /usr/j2se.old/jre/lib/sparc/libverify.so
0xfe440000      /usr/j2se.old/jre/lib/sparc/libjava.so
0xff020000      /usr/j2se.old/jre/lib/sparc/libzip.so
0xfe260000      /usr/lib/locale/sv_SE/sv_SE.so.2
 
Local Time = Fri Jan 24 13:39:20 2003
Elapsed Time = 2
#
# HotSpot Virtual Machine Error : 11
# Error ID : 4F530E43505002C4 01
# Please report this error at
# http://java.sun.com/cgi-bin/bugreport.cgi
#
# Java VM: Java HotSpot(TM) Client VM (1.3.1_02-b02 mixed mode)
#
# An error report file has been saved as hs_err_pid15100.log.
# Please refer to the file for further information.
#
Abort
[erik@oden test] 

3. RESULTS ON WINDOWS 2000

Results on Windows 2000 (If I have copied it correctly)
&gt;java -classpath ..\..\aspectj1.1\lib\aspectjrt.jar;. test.Test3
test.Test3@1a8c4e7.x:=-3
Exception in thread "main" java.lang.NullPointerException
        at test.Log.ajc$afterReturning$test_Log$30d(Test3.java:37)
        at test.Test3.main(Test3.java:8)
&gt;java -version
java version "1.4.1_01"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_01-b01)
Java HotSpot(TM) Client VM (build 1.4.1_01-b01, mixed mode)
java</bugreport>
<testsforfix ID="30168" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Error with certain combination of advice"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="24" file="output/30168/pre-fix/testresults.xml" passing="674" size="698"/>
<post-fix-testcases failing="24" file="output/30168/post-fix/testresults.xml" passing="676" size="700"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java" revision="1.3" state="changed">63a64
&gt; 		//System.err.println("walked: " + method);
70a72
&gt; 		//System.err.println("done: " + method);
73a76
&gt; 		//System.err.println("check ref: " + ref + " is " + System.identityHashCode(ref));
78d80
&lt; 		//System.err.println("isRef: " + expr + ", " + binding);
85c87
&lt; 		if (isRef(ref, thisJoinPointDec))
---
&gt; 		if (isRef(ref, thisJoinPointDec)) {
87c89
&lt; 		else if (isRef(ref, thisJoinPointStaticPartDec))
---
&gt; 		} else if (isRef(ref, thisJoinPointStaticPartDec)) {
89c91
&lt; 		else if (isRef(ref, thisEnclosingJoinPointStaticPartDec))
---
&gt; 		} else if (isRef(ref, thisEnclosingJoinPointStaticPartDec)) {
90a93
&gt; 		}
93,105d95
&lt; 	//        public void checkAndFix(ASTObject body) {
&lt; 	//            this.process(body);
&lt; 	//            if (needsFakeStatic &amp;&amp; !needsDynamic) {
&lt; 	//                if (!this.getCompiler().getOptions().noMetaJoinPointOptimization) {
&lt; 	//                    makeFakeStatics = true;
&lt; 	//                    needsStatic = true;
&lt; 	//                    this.process(body);
&lt; 	//                } else {
&lt; 	//                    needsDynamic = true;
&lt; 	//                }
&lt; 	//            }
&lt; 	//        }
&lt; 
161d150
&lt; 		//System.err.println("replace static ref");
162a152
&gt; 		//System.err.println("replace static ref: " + receiver + " is " + System.identityHashCode(receiver));
166,167c156,161
&lt; 		call.binding.declaringClass =
&lt; 			(ReferenceBinding) thisJoinPointStaticPartDec.type;
---
&gt; 		call.binding = call.codegenBinding = getEquivalentStaticBinding(call.binding);
&gt; 	}
&gt; 	
&gt; 	private MethodBinding getEquivalentStaticBinding(MethodBinding template) {
&gt; 		ReferenceBinding b = (ReferenceBinding)thisJoinPointStaticPartDec.type;
&gt; 		return b.getExactMethod(template.selector, template.parameters);
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.31" state="changed">5568a5569,5575
&gt;     
&gt;     &lt;ajc-test dir="bugs/crashes" pr="30168" 
&gt;     		title="Error with certain combination of advice"&gt;
&gt;         &lt;compile files="test/Test3.java"/&gt;
&gt;         &lt;run class="test.Test3"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs/crashes/test/Test3.java" revision="1.1" state="new">package test;
import org.aspectj.lang.*;
import org.aspectj.lang.reflect.*;

public class Test3 {
   public static void main(String[] args) throws Exception {
      Test3 a = new Test3();
      a.foo(-3);
   }
   public void foo(int i) {
      this.x=i;
   }
   int x;
}

aspect Log {
   pointcut assign(Object newval, Object targ):
      set(* test..*)  &amp;&amp; args(newval) &amp;&amp; target(targ);

	
   before(Object newval, Object targ): assign(newval,targ) {
      Signature sign = thisJoinPoint.getSignature();
      System.out.println(targ.toString() + "." + sign.getName() + ":=" + newval);
   }
   /*
}
// Different error message if you divide into two aspects
aspect Tracing {
   */
   pointcut tracedCall():
      call(* test..*(..))/* &amp;&amp; !within(Tracing)*/ &amp;&amp; !within(Log);

   after() returning (Object o):  tracedCall() {
      // Works if you comment out either of these two lines
      thisJoinPoint.getSignature();
      System.out.println(thisJoinPoint);
   }
} 
</file>
<file name="org.aspectj/modules/tests/ajcTestsFailing.xml" revision="1.12" state="changed">54,59d53
&lt;     
&lt;     &lt;ajc-test dir="bugs" pr="29959"
&lt;             title="super call in intertype method declaration body causes VerifyError"&gt;
&lt;         &lt;compile files="SuperToIntro.java"/&gt;
&lt;         &lt;run class="SuperToIntro"/&gt;
&lt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/jimTests.xml" revision="1.9" state="changed">4,6d3
&lt; 
&lt; 
&lt; 
</file>
</fixedFiles>
</bug>
<bug id="30439" transactionid="70968">
<property name="files-churned" value="25"/>
<property name="java-files-churned" value="24"/>
<property name="classes-churned" value="24"/>
<property name="methods-churned" value="27"/>
<property name="hunks" value="79"/>
<property name="lines-added" value="128"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="109"/>
<property name="lines-churned" value="237"/>
<property name="priority" value="P4"/>
<property name="severity" value="minor"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-class K-import K-new K-package K-return M O-() O-+ T V Y</fullfingerprint>
<bugreport>AspectJ Compiler 1.1beta4
This program:

aspect Foo { 
  pointcut p1(): execution(void f()) &amp;&amp; cflow(execution(void f1()));
  pointcut p2(): execution(void f()) &amp;&amp; cflow(execution(void f2()));

  before(): p1() { }
  after():  p1() { }
  before(): p2() { }
  after():  p2() { }
}

class A {
  void f1() { f(); }
  void f2() { f(); }
  void f() { }
}

results in these errors:

circular dependency at method-execution(void A.f())
circular dependency at method-execution(void A.f())
circular dependency at method-execution(void A.f())
circular dependency at method-execution(void A.f())

4 errors

If I comment out any one of the four pieces of advice, all the errors go away.
Also, assuming that there is a valid reason for printing this error sometimes, how come there's no line number?

--Doug</bugreport>
<testsforfix ID="30439" type="new">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/WeaverMessagesTestCase.java">
      <test NAME="testAllMessagesDefined"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="106" file="output/30439/pre-fix/testresults.xml" passing="1209" size="1315"/>
<post-fix-testcases failing="105" file="output/30439/post-fix/testresults.xml" passing="1210" size="1315"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java" revision="1.7" state="changed">29a30
&gt; import org.aspectj.weaver.WeaverMessages;
51c52
&lt; 			MessageUtil.info(handler, "zipfile classpath entry does not exist: " + name);
---
&gt; 			MessageUtil.info(handler, WeaverMessages.format(WeaverMessages.ZIPFILE_ENTRY_MISSING,name));
57c58
&lt; 			MessageUtil.warn(handler, "zipfile classpath entry is invalid: " + name + "&lt;" + ioe.getMessage() + "&gt;");
---
&gt; 			MessageUtil.warn(handler, WeaverMessages.format(WeaverMessages.ZIPFILE_ENTRY_INVALID,name,ioe.getMessage()));
62c63
&lt; 			MessageUtil.info(handler, "directory classpath entry does not exist: " + name);
---
&gt; 			MessageUtil.info(handler, WeaverMessages.format(WeaverMessages.DIRECTORY_ENTRY_MISSING,name));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java" revision="1.6" state="changed">82,83c82,84
&lt; 			world.showMessage(IMessage.ERROR, "can't declare constructor on an aspect",
&lt; 						getSignature().getSourceLocation(), null);
---
&gt; 			world.showMessage(IMessage.ERROR, 
&gt; 					WeaverMessages.format(WeaverMessages.ITD_CONS_ON_ASPECT),
&gt; 					getSignature().getSourceLocation(), null);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Shadow.java" revision="1.19" state="changed">297,299c297,299
&lt; 			getIWorld().showMessage(IMessage.ERROR, "can't throw checked exception \'" + resolvedTypeX +
&lt; 							"\' at this join point \'" + this +"\'", // from advice in \'" + munger. + "\'",
&lt; 							getSourceLocation(), munger.getSourceLocation());
---
&gt; 			getIWorld().showMessage(IMessage.ERROR,
&gt; 					WeaverMessages.format(WeaverMessages.CANT_THROW_CHECKED,resolvedTypeX,this), // from advice in \'" + munger. + "\'",
&gt; 					getSourceLocation(), munger.getSourceLocation());
335c335,336
&lt; 					MessageUtil.error("circular advice dependency at " + this, m.getSourceLocation()));
---
&gt; 					MessageUtil.error(
&gt; 							WeaverMessages.format(WeaverMessages.CIRCULAR_DEPENDENCY,this), m.getSourceLocation()));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Lint.java" revision="1.13" state="changed">86,87c86,87
&lt; 			MessageUtil.error(world.getMessageHandler(), "problem loading Xlint properties file: " + 
&lt; 					file.getPath() + ", " + ioe.getMessage());
---
&gt; 			MessageUtil.error(world.getMessageHandler(),
&gt; 					WeaverMessages.format(WeaverMessages.XLINT_LOAD_ERROR,file.getPath(),ioe.getMessage()));
94c94,95
&lt; 			MessageUtil.warn(world.getMessageHandler(), "couldn't load XlintDefault.properties");
---
&gt; 			MessageUtil.warn(world.getMessageHandler(), 
&gt; 					WeaverMessages.format(WeaverMessages.XLINTDEFAULT_LOAD_ERROR));
100,101c101,102
&lt; 			MessageUtil.error(world.getMessageHandler(), "problem loading XlintDefault.properties, " +
&lt; 					ioe.getMessage());
---
&gt; 			MessageUtil.error(world.getMessageHandler(),
&gt; 					WeaverMessages.format(WeaverMessages.XLINTDEFAULT_LOAD_PROBLEM,ioe.getMessage()));
119c120,121
&lt; 				MessageUtil.error(world.getMessageHandler(), "invalid Xlint key: " + entry.getKey());
---
&gt; 				MessageUtil.error(world.getMessageHandler(),
&gt; 						WeaverMessages.format(WeaverMessages.XLINT_KEY_ERROR,entry.getKey()));
132c134
&lt; 			"invalid Xlint message kind (must be one of ignore, warning, error): " + v);
---
&gt; 				WeaverMessages.format(WeaverMessages.XLINT_VALUE_ERROR,v));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.18" state="changed">85c85,86
&lt;                 MessageUtil.error(messageHandler, "can't find type " + ty.getName());
---
&gt;                 MessageUtil.error(messageHandler, 
&gt;                 		WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName()));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/IfPointcut.java" revision="1.16" state="changed">32a33
&gt; import org.aspectj.weaver.WeaverMessages;
156,158c157,159
&lt; 			  "if() pointcut designator cannot be used in declare statement",
&lt; 			  bindings.getEnclosingAdvice().getSourceLocation(),
&lt; 			  null);
---
&gt; 					WeaverMessages.format(WeaverMessages.IF_IN_DECLARE),
&gt; 					bindings.getEnclosingAdvice().getSourceLocation(),
&gt; 					null);
177,178c178,179
&lt; 				"if() pointcut designator cannot be used directly in a per clause (compiler limitation).  Create a named pointcut containing the if() and refer to it",
&lt; 				this.getSourceLocation(),null);
---
&gt; 					WeaverMessages.format(WeaverMessages.IF_IN_PERCLAUSE),
&gt; 					this.getSourceLocation(),null);
194,195c195,196
&lt; 					"if not supported lexically within cflow (compiler limitation)",
&lt; 					getSourceLocation(), null);
---
&gt; 						WeaverMessages.format(WeaverMessages.IF_LEXICALLY_IN_CFLOW),
&gt; 						getSourceLocation(), null);
253c254
&lt; 				  "if() pointcut designator cannot be used in declare statement",
---
&gt; 				  WeaverMessages.format(WeaverMessages.IF_IN_DECLARE),
319,321c320,322
&lt; 				  "if() pointcut designator cannot be used in declare statement",
&lt; 				  bindings.getEnclosingAdvice().getSourceLocation(),
&lt; 				  null);
---
&gt; 						WeaverMessages.format(WeaverMessages.IF_IN_DECLARE),
&gt; 						bindings.getEnclosingAdvice().getSourceLocation(),
&gt; 						null);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeaverStateInfo.java" revision="1.4" state="changed">165,166c165,166
&lt; 				world.showMessage(IMessage.ERROR, "aspect " + entry.aspectType + 
&lt; 					" is needed when using type " + onType,
---
&gt; 				world.showMessage(IMessage.ERROR,
&gt; 					WeaverMessages.format(WeaverMessages.ASPECT_NEEDED,entry.aspectType,onType),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.29" state="changed">1138,1140c1138,1140
&lt; 							MessageUtil.error("inter-type declaration from " + munger.getAspectType().getName() +
&lt; 											" conflicts with existing member: " + existingMember,
&lt; 											munger.getSourceLocation())
---
&gt; 							MessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_MEMBER_CONFLICT,munger.getAspectType().getName(),
&gt; 									existingMember),
&gt; 							munger.getSourceLocation())
1156,1158c1156,1157
&lt; 				"can't override " + parent +
&lt; 				" with " + child + " return types don't match",
&lt; 				child.getSourceLocation(), parent.getSourceLocation());
---
&gt; 					WeaverMessages.format(WeaverMessages.ITD_RETURN_TYPE_MISMATCH,parent,child),
&gt; 					child.getSourceLocation(), parent.getSourceLocation());
1166,1168c1165,1166
&lt; 					"can't override " + parent +
&lt; 					" with " + child + " parameter types don't match",
&lt; 					child.getSourceLocation(), parent.getSourceLocation());
---
&gt; 						WeaverMessages.format(WeaverMessages.ITD_PARAM_TYPE_MISMATCH,parent,child),
&gt; 						child.getSourceLocation(), parent.getSourceLocation());
1175,1177c1173,1174
&lt; 				"can't override " + parent +
&lt; 				" with " + child + " visibility is reduced",
&lt; 				child.getSourceLocation(), parent.getSourceLocation());
---
&gt; 					WeaverMessages.format(WeaverMessages.ITD_VISIBILITY_REDUCTION,parent,child),
&gt; 					child.getSourceLocation(), parent.getSourceLocation());
1196,1197c1193,1195
&lt; 			world.showMessage(IMessage.ERROR, "overriden method doesn't throw " 
&lt; 					+ childExceptions[i].getName(), child.getSourceLocation(), null);
---
&gt; 			world.showMessage(IMessage.ERROR,
&gt; 					WeaverMessages.format(WeaverMessages.ITD_DOESNT_THROW,childExceptions[i].getName()),
&gt; 					child.getSourceLocation(), null);
1203,1204c1201,1202
&lt; 			  child.toString()+" cannot override "+parent.toString()+"; overridden method is static",
&lt; 			  child.getSourceLocation(),null);
---
&gt; 					WeaverMessages.format(WeaverMessages.ITD_OVERRIDDEN_STATIC,child,parent),
&gt; 					child.getSourceLocation(),null);
1207,1208c1205,1206
&lt; 			  child.toString()+" cannot override "+parent.toString()+"; overriding method is static",
&lt; 			  child.getSourceLocation(),null);
---
&gt; 					WeaverMessages.format(WeaverMessages.ITD_OVERIDDING_STATIC,child,parent),
&gt; 					child.getSourceLocation(),null);
1255,1261c1253,1255
&lt; 			"intertype declaration from "
&lt; 				+ m1.getAspectType().getName()
&lt; 				+ " conflicts with intertype declaration: "
&lt; 				+ m2.getSignature()
&lt; 				+ " from "
&lt; 				+ m2.getAspectType().getName(),
&lt; 			m2.getSourceLocation(), getSourceLocation());
---
&gt; 				WeaverMessages.format(WeaverMessages.ITD_CONFLICT,m1.getAspectType().getName(),
&gt; 									m2.getSignature(),m2.getAspectType().getName()),
&gt; 						m2.getSourceLocation(), getSourceLocation());
1311,1313c1305,1306
&lt; 						"inherited abstract " + inherited + 
&lt; 						" is not made concrete in " + this.getName(),
&lt; 						inherited.getSourceLocation(), this.getSourceLocation());
---
&gt; 							WeaverMessages.format(WeaverMessages.POINCUT_NOT_CONCRETE,inherited,this.getName()),
&gt; 							inherited.getSourceLocation(), this.getSourceLocation());
1343,1344c1336
&lt; 							"conflicting inherited pointcuts in "
&lt; 								+ this.getName() + toAdd.getSignature(),
---
&gt; 							WeaverMessages.format(WeaverMessages.CONFLICTING_INHERITED_POINTCUTS,this.getName() + toAdd.getSignature()),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/TypePattern.java" revision="1.10" state="changed">27a28
&gt; import org.aspectj.weaver.WeaverMessages;
172c173,174
&lt; 		s.getMessageHandler().handleMessage(MessageUtil.error("exact type pattern required", getSourceLocation()));
---
&gt; 		s.getMessageHandler().handleMessage(MessageUtil.error(
&gt; 				WeaverMessages.format(WeaverMessages.EXACT_TYPE_PATTERN_REQD), getSourceLocation()));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Advice.java" revision="1.12" state="changed">95,96c95,96
&lt; 	    				"Only before advice is supported on handler join points (compiler limitation)", 
&lt; 	    				getSourceLocation(), shadow.getSourceLocation());
---
&gt; 							WeaverMessages.format(WeaverMessages.ONLY_BEFORE_ON_HANDLER),
&gt; 							getSourceLocation(), shadow.getSourceLocation());
111,112c111,112
&lt; 	    				"around on pre-initialization not supported (compiler limitation)", 
&lt; 	    				getSourceLocation(), shadow.getSourceLocation());
---
&gt; 	    					WeaverMessages.format(WeaverMessages.AROUND_ON_PREINIT),
&gt; 							getSourceLocation(), shadow.getSourceLocation());
116,117c116,117
&lt; 						"around on initialization not supported (compiler limitation)", 
&lt; 						getSourceLocation(), shadow.getSourceLocation());
---
&gt; 							WeaverMessages.format(WeaverMessages.AROUND_ON_INIT),
&gt; 							getSourceLocation(), shadow.getSourceLocation());
123,126c123,124
&lt; 						"around on staticinitialization of interface \'" + 
&lt; 						shadow.getEnclosingType().getName() +
&lt; 						"\' not supported (compiler limitation)", 
&lt; 						getSourceLocation(), shadow.getSourceLocation());
---
&gt; 							WeaverMessages.format(WeaverMessages.AROUND_ON_INTERFACE_STATICINIT,shadow.getEnclosingType().getName()),
&gt; 							getSourceLocation(), shadow.getSourceLocation());
133c131
&lt;     							"applying to join point that doesn't return void: " + shadow,
---
&gt;     							WeaverMessages.format(WeaverMessages.NON_VOID_RETURN,shadow),	
141,142c139,140
&lt; 						world.showMessage(IMessage.ERROR, 
&lt; 								"incompatible return type applying to " + shadow,
---
&gt; 						world.showMessage(IMessage.ERROR,
&gt; 								WeaverMessages.format(WeaverMessages.INCOMPATIBLE_RETURN_TYPE,shadow),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java" revision="1.6" state="changed">24a25
&gt; import org.aspectj.weaver.WeaverMessages;
55,56c56
&lt; 			  MessageUtil.error("expected per clause on super aspect not found on " + 
&lt; 			  					inAspect.getSuperclass(), getSourceLocation())
---
&gt; 			  MessageUtil.error(WeaverMessages.format(WeaverMessages.MISSING_PER_CLAUSE,inAspect.getSuperclass()), getSourceLocation())
61,62c61
&lt; 			  MessageUtil.error("wrong kind of per clause on super, expected " + 
&lt; 			  					kind + " but found " + p.getKind(),
---
&gt; 			  MessageUtil.error(WeaverMessages.format(WeaverMessages.WRONG_PER_CLAUSE,kind,p.getKind()),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java" revision="1.13" state="changed">29a30
&gt; import org.aspectj.weaver.WeaverMessages;
351c352
&lt; 							MessageUtil.error("can't bind type name '" + originalName + "'",
---
&gt; 							MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_BIND_TYPE,originalName),
369c370
&lt; 					MessageUtil.error("wildcard type pattern not allowed, must use type name",
---
&gt; 					MessageUtil.error(WeaverMessages.format(WeaverMessages.WILDCARD_NOT_ALLOWED),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java" revision="1.14" state="changed">37a38
&gt; import org.aspectj.weaver.WeaverMessages;
134,135c135,136
&lt; 			  "cflow"+(isBelow?"below":"")+"() pointcut designator cannot be used in declare statement",
&lt; 			  bindings.getEnclosingAdvice().getSourceLocation(), null);
---
&gt; 					WeaverMessages.format(WeaverMessages.CFLOW_IN_DECLARE,isBelow?"below":""),
&gt; 					bindings.getEnclosingAdvice().getSourceLocation(), null);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java" revision="1.11" state="changed">27a28
&gt; import org.aspectj.weaver.WeaverMessages;
133,134c134,135
&lt; 		    (isThis?"this":"target")+"() pointcut designator cannot be used in declare statement",
&lt; 		    bindings.getEnclosingAdvice().getSourceLocation(), null);
---
&gt; 		  		WeaverMessages.format(WeaverMessages.THIS_OR_TARGET_IN_DECLARE,isThis?"this":"target"),
&gt; 				bindings.getEnclosingAdvice().getSourceLocation(), null);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java" revision="1.14" state="changed">33a34
&gt; import org.aspectj.weaver.WeaverMessages;
141,142c142,143
&lt; 			"args() pointcut designator cannot be used in declare statement",
&lt; 			bindings.getEnclosingAdvice().getSourceLocation(), null);
---
&gt; 		  		WeaverMessages.format(WeaverMessages.ARGS_IN_DECLARE),
&gt; 				bindings.getEnclosingAdvice().getSourceLocation(), null);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java" revision="1.6" state="changed">23a24
&gt; import org.aspectj.weaver.WeaverMessages;
90c91
&lt;     					excType.getName() + " is not a subtype of Throwable",
---
&gt;     					WeaverMessages.format(WeaverMessages.NOT_THROWABLE,excType.getName()),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclareParents.java" revision="1.8" state="changed">26a27
&gt; import org.aspectj.weaver.WeaverMessages;
118,119c119,121
&lt; 			world.showMessage(IMessage.ERROR, "can't change the parents of java.lang.Object",
&lt; 			                  this.getSourceLocation(), null);
---
&gt; 			world.showMessage(IMessage.ERROR, 
&gt; 					WeaverMessages.format(WeaverMessages.DECP_OBJECT),
&gt; 			        this.getSourceLocation(), null);
127c129,130
&lt; 				"type \'" + targetType.getName() + "\'can not extend itself", this.getSourceLocation(), null
---
&gt; 					WeaverMessages.format(WeaverMessages.CANT_EXTEND_SELF,targetType.getName()),
&gt; 					this.getSourceLocation(), null
135,136c138,139
&lt; 					"interface can not extend a class", 
&lt; 					this.getSourceLocation(), null
---
&gt; 						WeaverMessages.format(WeaverMessages.INTERFACE_CANT_EXTEND_CLASS),
&gt; 						this.getSourceLocation(), null
144,147c147,150
&lt; 									"can only insert a class into hierarchy, but "
&lt; 									+ iType.getName() + " is not a subtype of " +
&lt; 									targetType.getSuperclass().getName(), 
&lt; 									this.getSourceLocation(), null
---
&gt; 						WeaverMessages.format(WeaverMessages.DECP_HIERARCHY_ERROR,
&gt; 								iType.getName(),
&gt; 								targetType.getSuperclass().getName()), 
&gt; 						this.getSourceLocation(), null
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java" revision="1.6" state="changed">23a24
&gt; import org.aspectj.weaver.WeaverMessages;
77,78c78,79
&lt;     					"circularity in declare precedence, '*' occurs more than once",
&lt;     					pi.getSourceLocation(), null);    				
---
&gt;     						WeaverMessages.format(WeaverMessages.TWO_STARS_IN_PRECEDENCE),
&gt; 							pi.getSourceLocation(), null);    				
89,90c90,91
&lt;     				"Non-aspect types can only be specified in a declare precedence statement when subtypes are included.  Non-aspect type is : "+exactType.getName(),
&lt;     				pi.getSourceLocation(),null);
---
&gt;     					WeaverMessages.format(WeaverMessages.CLASSES_IN_PRECEDENCE,exactType.getName()),
&gt; 						pi.getSourceLocation(),null);
99,100c100,101
&lt;     					"circularity in declare precedence, '" + exactType.getName() + 
&lt;     						"' matches two patterns", pi.getSourceLocation(), pj.getSourceLocation());
---
&gt;     						WeaverMessages.format(WeaverMessages.TWO_PATTERN_MATCHES_IN_PRECEDENCE,exactType.getName()), 
&gt; 							pi.getSourceLocation(), pj.getSourceLocation());
119,120c120,121
&lt; 					a.getWorld().showMessage(IMessage.ERROR, "multiple matches for " + a + 
&lt; 							", matches both " + patterns.get(knownMatch) + " and " + p,
---
&gt; 					a.getWorld().showMessage(IMessage.ERROR,
&gt; 							WeaverMessages.format(WeaverMessages.MULTIPLE_MATCHES_IN_PRECEDENCE,a,patterns.get(knownMatch),p),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java" revision="1.18" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java" revision="1.21" state="changed">60a61
&gt; import org.aspectj.weaver.WeaverMessages;
401,403c402
&lt; 					"overwriting JSR45 information for "
&lt; 						+ getFileName()
&lt; 						+ " (compiler limitation)",
---
&gt; 					WeaverMessages.format(WeaverMessages.OVERWRITE_JSR45,getFileName()),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java" revision="1.31" state="changed">56a57
&gt; import org.aspectj.weaver.WeaverMessages;
577c578,580
&lt; 			world.showMessage(IMessage.INFO, "weaver operating in reweavable mode.  Need to verify any required types exist.", null, null);
---
&gt; 			world.showMessage(IMessage.INFO,
&gt; 					WeaverMessages.format(WeaverMessages.REWEAVABLE_MODE),
&gt; 					null, null);
586c589,591
&lt; 			world.showMessage(IMessage.INFO,"processing reweavable type "+className+": "+classType.getSourceLocation().getSourceFile(),null,null);
---
&gt; 			world.showMessage(IMessage.INFO,
&gt; 					WeaverMessages.format(WeaverMessages.PROCESSING_REWEAVABLE,className,classType.getSourceLocation().getSourceFile()),
&gt; 					null,null);
595,597c600,602
&lt; 							world.showMessage(IMessage.ERROR, "type " + requiredTypeName + 
&lt; 								" is needed by reweavable type " + className,
&lt; 								classType.getSourceLocation(), null);
---
&gt; 							world.showMessage(IMessage.ERROR, 
&gt; 									WeaverMessages.format(WeaverMessages.MISSING_REWEAVABLE_TYPE,requiredTypeName,className),
&gt; 								    classType.getSourceLocation(), null);
600,601c605,607
&lt; 							  world.showMessage(IMessage.INFO,"successfully verified type "+requiredTypeName+
&lt; 		                        " exists.  Originates from "+rtx.getSourceLocation().getSourceFile(),null,null);
---
&gt; 							  world.showMessage(IMessage.INFO,
&gt; 							  		WeaverMessages.format(WeaverMessages.VERIFIED_REWEAVABLE_TYPE,requiredTypeName,rtx.getSourceLocation().getSourceFile()),
&gt; 									null,null);
665,667c671,672
&lt; 							"can't use declare parents to change superclass of binary form \'" +
&lt; 							onType.getName() + "\' (implementation limitation)",
&lt; 							p.getSourceLocation(), null);
---
&gt; 								WeaverMessages.format(WeaverMessages.DECP_BINARY_LIMITATION,onType.getName()),
&gt; 								p.getSourceLocation(), null);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java" revision="1.25" state="changed">56a57
&gt; import org.aspectj.weaver.WeaverMessages;
327,328c328,332
&lt;     			IMessage.ERROR, "problem generating method " + 
&lt;     			this.getClassName() + "." + this.getName() + ": " + e.getMessage(),
---
&gt;     			IMessage.ERROR, 
&gt; 				WeaverMessages.format(WeaverMessages.PROBLEM_GENERATING_METHOD,
&gt; 						              this.getClassName(),
&gt; 									  this.getName(),
&gt; 									  e.getMessage()),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java" revision="1.28" state="changed">64a65
&gt; import org.aspectj.weaver.WeaverMessages;
291c292
&lt; 				"class \'" + clazz.getType().getName() + "\' is already woven and has not been built with -Xreweavable",
---
&gt;         		  WeaverMessages.format(WeaverMessages.ALREADY_WOVEN,clazz.getType().getName()),
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/WeaverMessagesTestCase.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.aspectj.weaver;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.MissingResourceException;

import junit.framework.TestCase;

/**
 * @author colyer
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Generation - Code and Comments
 */
public class WeaverMessagesTestCase extends TestCase {
	
	public void testAllMessagesDefined() {
		
		Class wmClass = WeaverMessages.class;
		Field[] fields = wmClass.getDeclaredFields();
		List fieldList = new ArrayList();
		for (int i = 0; i &lt; fields.length; i++) {
			Field f = fields[i];
			if (f.getType() == String.class) {
				try {
					String key = (String) f.get(null);
					String value = WeaverMessages.format(key);
					assertFalse("Each key should be unique",fieldList.contains(key));
					fieldList.add(key);
//					System.out.println(key + "," + value);
				} catch (IllegalAccessException ex) {					
				} catch(MissingResourceException mrEx) {
					fail("Missing resource: " + mrEx);
				}
			}
		}
	}

}
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/BcweaverTests.java" revision="1.7" state="changed">55a56
&gt; 		suite.addTestSuite(WeaverMessagesTestCase.class);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/weaver-messages.properties" revision="1.1" state="new"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeaverMessages.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.aspectj.weaver;

import java.text.MessageFormat;
import java.util.ResourceBundle;


public class WeaverMessages {
	
	private static ResourceBundle bundle = ResourceBundle.getBundle("org.aspectj.weaver.weaver-messages");

	public static final String ARGS_IN_DECLARE = "argsInDeclare";
	public static final String CFLOW_IN_DECLARE = "cflowInDeclare";
	public static final String IF_IN_DECLARE = "ifInDeclare";
	public static final String THIS_OR_TARGET_IN_DECLARE = "thisOrTargetInDeclare";
	public static final String ABSTRACT_POINTCUT = "abstractPointcut";
	public static final String POINCUT_NOT_CONCRETE = "abstractPointcutNotMadeConcrete";
	public static final String CONFLICTING_INHERITED_POINTCUTS = "conflictingInheritedPointcuts";
	public static final String CIRCULAR_POINTCUT = "circularPointcutDeclaration";
	public static final String CANT_FIND_POINTCUT = "cantFindPointcut";
	public static final String EXACT_TYPE_PATTERN_REQD = "exactTypePatternRequired";
	public static final String CANT_BIND_TYPE = "cantBindType";
	public static final String WILDCARD_NOT_ALLOWED = "wildcardTypePatternNotAllowed";
	
	public static final String DECP_OBJECT = "decpObject";
	public static final String CANT_EXTEND_SELF="cantExtendSelf";
	public static final String INTERFACE_CANT_EXTEND_CLASS="interfaceExtendClass";
	public static final String DECP_HIERARCHY_ERROR = "decpHierarchy";
	
	public static final String MULTIPLE_MATCHES_IN_PRECEDENCE = "multipleMatchesInPrecedence";
	public static final String TWO_STARS_IN_PRECEDENCE = "circularityInPrecedenceStar";
	public static final String CLASSES_IN_PRECEDENCE = "nonAspectTypesInPrecedence";
	public static final String TWO_PATTERN_MATCHES_IN_PRECEDENCE = "circularityInPrecedenceTwo";
	
	public static final String NOT_THROWABLE = "notThrowable";
	
	public static final String ITD_CONS_ON_ASPECT = "itdConsOnAspect";
	public static final String ITD_RETURN_TYPE_MISMATCH = "returnTypeMismatch";
	public static final String ITD_PARAM_TYPE_MISMATCH = "paramTypeMismatch";
	public static final String ITD_VISIBILITY_REDUCTION = "visibilityReduction";
	public static final String ITD_DOESNT_THROW = "doesntThrow";
	public static final String ITD_OVERRIDDEN_STATIC = "overriddenStatic";
	public static final String ITD_OVERIDDING_STATIC = "overridingStatic";
	public static final String ITD_CONFLICT = "itdConflict";
	public static final String ITD_MEMBER_CONFLICT = "itdMemberConflict";
	
	
	public static final String NON_VOID_RETURN = "nonVoidReturn";
	public static final String INCOMPATIBLE_RETURN_TYPE="incompatibleReturnType";
	public static final String CANT_THROW_CHECKED = "cantThrowChecked";
	public static final String CIRCULAR_DEPENDENCY = "circularDependency";
	
	public static final String MISSING_PER_CLAUSE = "missingPerClause";
	public static final String WRONG_PER_CLAUSE = "wrongPerClause";
	
	public static final String ALREADY_WOVEN = "alreadyWoven";
	public static final String REWEAVABLE_MODE = "reweavableMode";
	public static final String PROCESSING_REWEAVABLE = "processingReweavable";
	public static final String MISSING_REWEAVABLE_TYPE = "missingReweavableType";
	public static final String VERIFIED_REWEAVABLE_TYPE = "verifiedReweavableType";
	public static final String ASPECT_NEEDED = "aspectNeeded";
	
	public static final String CANT_FIND_TYPE = "cantFindType";
	
	public static final String DECP_BINARY_LIMITATION = "decpBinaryLimitation";
	public static final String OVERWRITE_JSR45 = "overwriteJSR45";
	public static final String IF_IN_PERCLAUSE = "ifInPerClause";
	public static final String IF_LEXICALLY_IN_CFLOW = "ifLexicallyInCflow";
	public static final String ONLY_BEFORE_ON_HANDLER = "onlyBeforeOnHandler";
	public static final String AROUND_ON_PREINIT = "aroundOnPreInit";
	public static final String AROUND_ON_INIT = "aroundOnInit";
	public static final String AROUND_ON_INTERFACE_STATICINIT = "aroundOnInterfaceStaticInit";
	
	public static final String PROBLEM_GENERATING_METHOD = "problemGeneratingMethod";
	
	public static final String ZIPFILE_ENTRY_MISSING = "zipfileEntryMissing";
	public static final String ZIPFILE_ENTRY_INVALID = "zipfileEntryInvalid";
	public static final String DIRECTORY_ENTRY_MISSING = "directoryEntryMissing";
	
	public static final String XLINT_LOAD_ERROR = "problemLoadingXLint";
	public static final String XLINTDEFAULT_LOAD_ERROR = "unableToLoadXLintDefault";
	public static final String XLINTDEFAULT_LOAD_PROBLEM = "errorLoadingXLintDefault";
	public static final String XLINT_KEY_ERROR = "invalidXLintKey";
	public static final String XLINT_VALUE_ERROR = "invalidXLintMessageKind";
	
	
	public static String format(String key) {
		return bundle.getString(key);
	}
	
	public static String format(String key, Object insert) {
		return MessageFormat.format(bundle.getString(key),new Object[] {insert});
	}

	public static String format(String key, Object insert1, Object insert2) {
		return MessageFormat.format(bundle.getString(key),new Object[] {insert1,insert2});
	}

	public static String format(String key, Object insert1, Object insert2, Object insert3) {
		return MessageFormat.format(bundle.getString(key),new Object[] {insert1, insert2, insert3});
	}

}
</file>
</fixedFiles>
</bug>
<bug id="31423" transactionid="72499">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-return K-true O-== T V Z-if</fullfingerprint>
<bugreport>Pointcut adviceexecution() does not seem to pick advice execution
join points in beta4. Here is a program that shows the problem:

public class Test {
    public static void main(String[] args) {
    }
}

aspect Aspect1 {
    before() : execution(* Test.*(..)) {
	System.out.println("Reached " + thisJoinPoint);
    }
}

aspect Aspect2 {
    before() : adviceexecution() &amp;&amp; !within(Aspect2) {
	System.out.println("Reached " + thisJoinPoint);
    }
}

F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc -version
AspectJ Compiler 1.1beta4

F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc Test.java

F:\aop\bugs\1.1\b4\adviceexecution&gt;java Test
Reached execution(void Test.main(String[]))</bugreport>
<testsforfix ID="31423" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Pointcut adviceexecution() does not work"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="25" file="output/31423/pre-fix/testresults.xml" passing="675" size="700"/>
<post-fix-testcases failing="24" file="output/31423/post-fix/testresults.xml" passing="677" size="701"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java" revision="1.4" state="changed">87a88,89
&gt; 		if (kind == Member.ADVICE) return true;
&gt; 		
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java" revision="1.3" state="changed">38,39d37
&lt; 		
&lt; 		
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.32" state="changed">5575a5576,5581
&gt;     &lt;ajc-test dir="bugs" pr="31423" 
&gt;     		title="Pointcut adviceexecution() does not work"&gt;
&gt;         &lt;compile files="AdviceExec.java"/&gt;
&gt;         &lt;run class="AdviceExec"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs/AdviceExec.java" revision="1.1" state="new">// for Bug#:  31423  
import org.aspectj.testing.Tester;


public class AdviceExec {
    public static void main(String[] args) {
    	Tester.checkEqual(Aspect1.ran, 2, "Aspect1 ran");
    	Tester.checkEqual(Aspect2.ran, 2, "Aspect2 ran");
    }
}

aspect Aspect1 {
	static int ran = 0;
    before() : execution(* AdviceExec.*(..)) {
		//System.out.println("Reached " + thisJoinPoint);
		ran++;
    }
    
    void around(): execution(* AdviceExec.*(..)) {
    	ran++;
    	proceed();
    }
}

aspect Aspect2 {
	static int ran = 0;
    before() : adviceexecution() &amp;&amp; !within(Aspect2) {
		//System.out.println("Reached " + thisJoinPoint);
		ran++;
    }
}
</file>
</fixedFiles>
</bug>
<bug id="31460" transactionid="70772">
<property name="files-churned" value="12"/>
<property name="java-files-churned" value="6"/>
<property name="classes-churned" value="6"/>
<property name="methods-churned" value="6"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="611"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="611"/>
<property name="priority" value="P2"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-else K-false K-for K-if K-import K-instanceof K-interface K-new K-null K-package K-return K-super K-this K-throw K-true K-try K-while M O-&lt; O-== O-|| O-- O-! O-!= O-?: O-() O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-cond Z-for Z-if Z-throw Z-vardecl Z-while</fullfingerprint>
<bugreport>Hi!

As discussed on the mailing list a few days ago I implemented a weaving class
loader to enable bytecode based weaving at class loading time. The class loader
is based on the URLClassLoader and can be used like any other URLClassLoader. In
addition to that you can add aspects to the weaving loader. These aspects got
woven into each class that is loaded. The test cases for the class loader aren't
implemented yet, I am still thinking about how to implement them. I will
contribute them later, okay?

-Martin</bugreport>
<testsforfix ID="31460" type="new">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java">
      <test NAME="testLoadClass"/>
      <test NAME="testLoadWovenClass"/>
      <test NAME="testWeaveWovenClass"/>
      <test NAME="testWeavingURLClassLoader"/>
      <test NAME="testWeaveAdvice"/>
      <test NAME="testWeaveAroundClosure"/>
      <test NAME="testWeavingITD"/>
      <test NAME="testWeavingPer"/>
      <test NAME="testWeavingAspects"/>
      <test NAME="testJunkJar"/>
      <test NAME="testAddURL"/>
      <test NAME="testParentChild"/>
      <test NAME="testIncompletePath"/>
      <test NAME="testPackage"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="110" file="output/31460/pre-fix/testresults.xml" passing="1161" size="1271"/>
<post-fix-testcases failing="94" file="output/31460/post-fix/testresults.xml" passing="1047" size="1141"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/testdata/megatrace0hard.jar" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/docs/build.xml" revision="1.9" state="changed">169c169
&lt;        description="javadoc for AspectJ lang and lang.reflect"&gt;
---
&gt;        description="javadoc for AspectJ lang, lang.reflect and org.aspectj.weaver.tools"&gt;
172c172
&lt;         &lt;javadoc sourcepath="${aspectj.modules.dir}/runtime/src"
---
&gt;         &lt;javadoc sourcepath="${aspectj.modules.dir}/runtime/src;${aspectj.modules.dir}/weaver/src"
176c176,177
&lt;                packagenames="org.aspectj.lang,org.aspectj.lang.reflect" /&gt;
---
&gt;                        classpath="${aspectj.modules.dir}/asm/bin;${aspectj.modules.dir}/bridge/bin;${aspectj.modules.dir}/util/bin;${aspectj.modules.dir}/lib/bcel/bcel.jar"
&gt;                packagenames="org.aspectj.lang,org.aspectj.lang.reflect,org.aspectj.weaver.tools" /&gt;
</file>
<file name="org.aspectj/modules/util/src/org/aspectj/util/FileUtil.java" revision="1.16" state="changed">1265c1265,1274
&lt; 
---
&gt; 	
&gt; 	public static List makeClasspath(URL[] urls) {
&gt; 		List ret = new LinkedList();
&gt; 		if (urls != null) {
&gt; 			for (int i = 0; i &lt; urls.length; i++) {
&gt; 				ret.add(urls[i].getPath());
&gt; 			}
&gt; 		}
&gt; 		return ret;
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/testdata/megatrace.jar" revision="1.11" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/tracing.jar" revision="1.11" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/megatraceNoweave.jar" revision="1.11" state="changed"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java" revision="1.9" state="changed">38a39,40
&gt; 
&gt; 		makeURLWeavingClassLoaderJars();
181a184,263
&gt; 	public static void makeURLWeavingClassLoaderJars() throws IOException {
&gt; 		List args = new ArrayList();
&gt; 
&gt; 		/*
&gt; 		 * Vanilla classes
&gt; 		 */
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../weaver/testdata/ltw-classes.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWHelloWorld.java");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/ltw/LTWPackageTest.java");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 
&gt; 		/* 
&gt; 		 * Woven classes
&gt; 		 */
&gt; 		args = new ArrayList();
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../weaver/testdata/ltw-woven.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWHelloWorld.java");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAspect.aj");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 
&gt; 		/*
&gt; 		 * Advice
&gt; 		 */
&gt; 		args = new ArrayList();
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../weaver/testdata/ltw-aspects.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAspect.aj");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 
&gt; 		/*
&gt; 		 * Around closure advice
&gt; 		 */
&gt; 		args = new ArrayList();
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../weaver/testdata/ltw-acaspects.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAroundClosure.aj");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 
&gt; 		/*
&gt; 		 * ITD
&gt; 		 */
&gt; 		args = new ArrayList();
&gt; 		args.add("-Xlint:ignore"); 
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../weaver/testdata/ltw-itdaspects.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWInterfaceITD.aj");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWFieldITD.aj");
&gt; 		/* Uncomment when bug #55341 fixed */
&gt; //		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWMethodITD.aj");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 
&gt; 		/*
&gt; 		 * perXXX()
&gt; 		 */
&gt; 		args = new ArrayList();
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../weaver/testdata/ltw-peraspects.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWPerthis.aj");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 	}	
</file>
<file name="org.aspectj/modules/weaver/testdata/megatrace0easy.jar" revision="1.5" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/dummyAspect.jar" revision="1.11" state="changed"/>
<file name="org.aspectj/modules/docs/dist/doc/examples/build.xml" revision="1.8" state="changed">396a397,454
&gt;     &lt;!-- ============================================================= --&gt;
&gt;     &lt;!-- do tracing example with 1.2 load-time weaving                 --&gt;
&gt;     &lt;!-- (and use fork/forkclasspath to avoid Eclipse 2.x bug)         --&gt;
&gt;     &lt;!-- ============================================================= --&gt;
&gt;     &lt;target name="tracing-lt" depends="init"
&gt;      description="tracing example with load-time aspect weaving"&gt;
&gt;        &lt;antcall target="clean" /&gt;
&gt; 
&gt;        &lt;!-- build application classes --&gt;
&gt;        &lt;iajc outjar="${jar.dir}/tracingApp.jar"
&gt;           classpath="${aspectjrt.jar}"
&gt;           fork="true"
&gt;           forkclasspath="${aspectjtools.jar}"
&gt;             verbose="off"&gt;
&gt;          &lt;src path="${example.dir}"/&gt;
&gt;          &lt;include name="tracing/*.java" /&gt;
&gt;        &lt;/iajc&gt;
&gt; 
&gt;        &lt;!-- Build a read-only tracing library --&gt;
&gt;        &lt;iajc outjar="${jar.dir}/tracingLib.jar"
&gt;           classpath="${aspectjrt.jar}:${jar.dir}/tracingApp.jar"
&gt;           fork="true"
&gt;           forkclasspath="${aspectjtools.jar}"
&gt;             verbose="off"&gt;
&gt;          &lt;src path="${example.dir}"/&gt;
&gt;          &lt;include name="tracing/version2/Trace.java" /&gt;
&gt;          &lt;include name="tracing/version2/TraceMyClasses.java" /&gt;
&gt;        &lt;/iajc&gt;
&gt; 
&gt;        &lt;!-- test standalone application by running without tracing --&gt;
&gt;        &lt;echo message="---------- running without tracing - START"/&gt;
&gt;        &lt;java classname="tracing.ExampleMain"&gt;
&gt;          &lt;classpath&gt;
&gt;             &lt;pathelement path="${aspectjrt.jar}"/&gt; 
&gt;             &lt;pathelement path="${jar.dir}/tracingApp.jar"/&gt; 
&gt;          &lt;/classpath&gt;
&gt;        &lt;/java&gt;
&gt;        &lt;echo message="---------- running without tracing - FINISH "/&gt;
&gt; 
&gt;        &lt;!-- run appliaction with LTW to add tracing --&gt;
&gt;        &lt;echo message="---------- running with tracing - START"/&gt;
&gt;        &lt;java classname="tracing.ExampleMain"
&gt;          fork="true"&gt;
&gt;          &lt;classpath&gt;
&gt;             &lt;pathelement path="${aspectjrt.jar}"/&gt; 
&gt;             &lt;pathelement path="${aspectjtools.jar}"/&gt; 
&gt;             &lt;pathelement path="d:/eclipse_aspectj/workspace/weaver/bin"/&gt; 
&gt;          &lt;/classpath&gt;
&gt; 		 &lt;jvmarg line="-showversion"/&gt;
&gt; 		 &lt;sysproperty key="java.system.class.loader" value="org.aspectj.weaver.WeavingURLClassLoader"/&gt;
&gt;          &lt;sysproperty key="aj.weaving.verbose" value="True"/&gt;
&gt;          &lt;sysproperty key="aj.class.path" path="${jar.dir}/tracingLib.jar:${jar.dir}/tracingApp.jar"/&gt;
&gt;          &lt;sysproperty key="aj.aspect.path" path="${jar.dir}/tracingLib.jar"/&gt;
&gt;        &lt;/java&gt;
&gt;        &lt;echo message="---------- running with tracing - FINISH"/&gt;
&gt; 
&gt;     &lt;/target&gt;
&gt; 
</file>
<file name="org.aspectj/modules/weaver/testsrc/BcweaverModuleTests.java" revision="1.4" state="changed">24c24
&lt;         suite.addTest(org.aspectj.weaver.patterns.PatternsTests.suite()); 
---
&gt; 		suite.addTest(org.aspectj.weaver.patterns.PatternsTests.suite()); 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/ltw/LTWPackageTest.java" revision="1.1" state="new">package ltw;

public class LTWPackageTest {

	public static void main(String[] args) {
	}

}
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/BcweaverTests.java" revision="1.5" state="changed">18a19
&gt; import org.aspectj.weaver.tools.*;
52c53,54
&lt;         suite.addTestSuite(TypeXTestCase.class); 
---
&gt; 		suite.addTestSuite(TypeXTestCase.class); 
&gt; 		suite.addTestSuite(WeavingURLClassLoaderTest.class); 
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster     initial implementation 
 * ******************************************************************/

package org.aspectj.weaver;

import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;

import junit.framework.TestCase;

import org.aspectj.bridge.AbortException;
import org.aspectj.util.FileUtil;
import org.aspectj.weaver.tools.WeavingAdaptor;

/**
 * @author websterm
 *
 * To change the template for this generated type comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
public class WeavingURLClassLoaderTest extends TestCase {

	private final static String CLASSES_JAR = BcweaverTests.TESTDATA_PATH + "/ltw-classes.jar";
	private final static String WOVEN_JAR = BcweaverTests.TESTDATA_PATH + "/ltw-woven.jar";
	private final static String JUNK_JAR = BcweaverTests.TESTDATA_PATH + "/ltw-junk.jar";
	private final static String ADVICE_ASPECTS = BcweaverTests.TESTDATA_PATH + "/ltw-aspects.jar";
	private final static String AROUNDCLOSURE_ASPECTS = BcweaverTests.TESTDATA_PATH + "/ltw-acaspects.jar";
	private final static String ITD_ASPECTS = BcweaverTests.TESTDATA_PATH + "/ltw-itdaspects.jar";
	private final static String PER_ASPECTS = BcweaverTests.TESTDATA_PATH + "/ltw-peraspects.jar";


	public WeavingURLClassLoaderTest(String name) {
		super(name);
		System.setProperty(WeavingAdaptor.WEAVING_ADAPTOR_VERBOSE,"true");
	}

	public void testLoadClass () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] {}); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public void testLoadWovenClass () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,WOVEN_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public void testWeaveWovenClass () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + WOVEN_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			fail("Expecting org.aspectj.bridge.AbortException");
		}
		catch (Exception ex) {
			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex,(ex instanceof AbortException));
		}
	}

	public void testWeavingURLClassLoader () {
		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
		URL aspects = FileUtil.getFileURL(new File(ADVICE_ASPECTS));
		URL[] classURLs = new URL[] { aspects, classes };
		URL[] aspectURLs = new URL[] { aspects };
		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public void testWeaveAdvice () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public void testWeaveAroundClosure () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,AROUNDCLOSURE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,AROUNDCLOSURE_ASPECTS + File.pathSeparator + CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAroundClosure" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public void testWeavingITD () {
		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
		URL aspects = FileUtil.getFileURL(new File(ITD_ASPECTS));
		URL[] classURLs = new URL[] { aspects, classes };
		URL[] aspectURLs = new URL[] { aspects };
		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			/* Uncomment when bug #55341 fixed */
//			invokeMain(clazz,new String[] { "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD" }); 
			invokeMain(clazz,new String[] { "LTWInterfaceITD", "LTWFieldITD" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public void testWeavingPer () {
		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
		URL aspects = FileUtil.getFileURL(new File(PER_ASPECTS));
		URL[] classURLs = new URL[] { aspects, classes };
		URL[] aspectURLs = new URL[] { aspects };
		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWPerthis" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public void testWeavingAspects () {
		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
		URL aspects1 = FileUtil.getFileURL(new File(ADVICE_ASPECTS));
		URL aspects2 = FileUtil.getFileURL(new File(AROUNDCLOSURE_ASPECTS));
		URL aspects3 = FileUtil.getFileURL(new File(ITD_ASPECTS));
		URL aspects4 = FileUtil.getFileURL(new File(PER_ASPECTS));
		URL[] classURLs = new URL[] {  aspects1, aspects2, aspects3, aspects4, classes };
		URL[] aspectURLs = new URL[] { aspects1, aspects2, aspects3, aspects4 };
		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			/* Uncomment when bug #55341 fixed */
//			invokeMain(clazz,new String[] { "LTWAspect", "LTWAroundClosure", "LTWPerthis", "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD", "LTWPerthis"}); 
			invokeMain(clazz,new String[] { "LTWAspect", "LTWAroundClosure", "LTWPerthis", "LTWInterfaceITD", "LTWFieldITD", "LTWPerthis"}); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public void testJunkJar () {		
		File junkJar = new File(JUNK_JAR);
		assertFalse(junkJar + " should not exist",junkJar.exists());
		
		URL classes = FileUtil.getFileURL(junkJar);
		URL[] classURLs = new URL[] { classes };
		URL[] aspectURLs = new URL[] { };
		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			fail("Expecting java.lang.ClassNotFoundException");
		}
		catch (Exception ex) {
			assertTrue("Expecting java.lang.ClassNotFoundException caught " + ex,(ex instanceof ClassNotFoundException));
		}
	}

	public void testAddURL () {
		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
		URL aspects = FileUtil.getFileURL(new File(ADVICE_ASPECTS));
		URL[] classURLs = new URL[] { aspects };
		URL[] aspectURLs = new URL[] { aspects };

		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
		loader.addURL(classes);

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public void testParentChild() {
		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
		URL aspects = FileUtil.getFileURL(new File(ADVICE_ASPECTS));
		
		URL[] classURLs = new URL[] { aspects };
		URL[] aspectURLs = new URL[] { aspects };
		WeavingURLClassLoader parent = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
		
		classURLs = new URL[] { classes };
		aspectURLs = new URL[] { };
		WeavingURLClassLoader child = new WeavingURLClassLoader(classURLs,aspectURLs,parent);

		try {
			Class clazz = child.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	/*
	 * Aspects on ASPECTPATH but missing from CLASSPATH
	 */
	public void testIncompletePath () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
			fail("Expecting java.lang.NoClassDefFoundError");
		}
		catch (Exception ex) {
		}
	}

	/*
	 * Ensure package object is correct
	 */
	public void testPackage () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("ltw.LTWPackageTest");
			invokeMain(clazz,new String[] { }); 
			Package pakkage = clazz.getPackage();
			assertTrue("Expected 'ltw' got " + pakkage,(pakkage != null));
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}

	public static void invokeMain (Class clazz, String[] args)
	{
		Class[] paramTypes = new Class[1];
		paramTypes[0] = args.getClass();
	
		try {
			Method method = clazz.getDeclaredMethod("main",paramTypes);
			Object[] params = new Object[1];
			params[0] = args;
			method.invoke(null,params);
		}
		catch (InvocationTargetException ex) {
			throw new RuntimeException(ex.getTargetException().toString());
		}
		catch (Exception ex) {
			throw new RuntimeException(ex.toString());
		}
	}

}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/

package org.aspectj.weaver;

import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.security.CodeSource;

import org.aspectj.util.FileUtil;
import org.aspectj.weaver.bcel.ClassPathManager;
import org.aspectj.weaver.tools.*;

public abstract class ExtensibleURLClassLoader extends URLClassLoader {
	
	private ClassPathManager classPath;
	
	public ExtensibleURLClassLoader (URL[] urls, ClassLoader parent) {
		super(urls,parent);

//		System.err.println("? ExtensibleURLClassLoader.&lt;init&gt;() path=" + WeavingAdaptor.makeClasspath(urls));
		classPath = new ClassPathManager(FileUtil.makeClasspath(urls),null);
	}

	protected void addURL(URL url) {
		classPath.addPath(url.getPath(),null);
	}
	
	protected Class findClass(String name) throws ClassNotFoundException {
//		System.err.println("? ExtensibleURLClassLoader.findClass(" + name + ")");
		try {
			byte[] bytes = getBytes(name);
			if (bytes != null) {
				return defineClass(name,bytes);
			}
			else {
				throw new ClassNotFoundException(name);
			}
		}
		catch (IOException ex) {
			throw new ClassNotFoundException(name);
		}
	}

	protected Class defineClass(String name, byte[] b, CodeSource cs) throws IOException {
//		System.err.println("? ExtensibleURLClassLoader.defineClass(" + name + ",[" + b.length + "])");
		return defineClass(name, b, 0, b.length, cs);
	}

	protected byte[] getBytes (String name) throws IOException {
		byte[] b = null;
		ClassPathManager.ClassFile classFile = classPath.find(TypeX.forName(name));
		if (classFile != null) {
			b = FileUtil.readAsByteArray(classFile.getInputStream());
		}
		return b;
	}

	private Class defineClass(String name, byte[] bytes /*ClassPathManager.ClassFile classFile*/) throws IOException {
		String packageName = getPackageName(name);
		if (packageName != null) {
			Package pakkage = getPackage(packageName);
			if (pakkage == null) {
				definePackage(packageName,null,null,null,null,null,null,null);
			}
		}
		
		return defineClass(name, bytes, null);
	}

	private String getPackageName (String className) {
		int offset = className.lastIndexOf('.');
		return (offset == -1)? null : className.substring(0,offset);  
	}

}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LTWAspect.aj" revision="1.1" state="new">import java.util.List;&#13;
&#13;
public privileged aspect LTWAspect {&#13;
	&#13;
	pointcut method (List list) :&#13;
		execution(* LTWHelloWorld.*(..)) &amp;&amp; this(list);&#13;
	&#13;
	before (List list) : method (list) {&#13;
		System.err.println("LTWAspect.method(" + thisJoinPointStaticPart + ")");&#13;
		list.add("LTWAspect");&#13;
	}&#13;
}&#13;
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LTWPerthis.aj" revision="1.1" state="new">import java.util.List;&#13;
&#13;
public aspect LTWPerthis perthis(this(LTWHelloWorld)) {&#13;
&#13;
	pointcut println (List list) :&#13;
		execution(* println()) &amp;&amp; this(list);&#13;
	&#13;
	before (List list) : println (list) {&#13;
		System.err.println("LTWPerthis.println(" + thisJoinPointStaticPart + ")");&#13;
		list.add(getClass().getName());&#13;
	}&#13;
&#13;
}&#13;
</file>
<file name="org.aspectj/modules/weaver/testdata/ltw-acaspects.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LTWHelloWorld.java" revision="1.1" state="new">import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;

public class LTWHelloWorld extends ArrayList {

	private String message = "Hello World!";

	public void println () {
		System.out.println(message);
	}

	public static void main(String[] args) {
		LTWHelloWorld hw = new LTWHelloWorld();
		hw.println();		
		for (int i = 0; i &lt; args.length; i++) {
			String jp = args[i];
			if (!hw.contains(jp)) {
				throw new RuntimeException(jp + " missing"); 
			}
		}
	}

}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LTWInterfaceITD.aj" revision="1.1" state="new">import java.util.List;&#13;
&#13;
public privileged aspect LTWInterfaceITD {&#13;
&#13;
	declare parents : LTWHelloWorld implements Runnable;&#13;
	&#13;
	public void LTWHelloWorld.run () {&#13;
		add("LTWInterfaceITD");&#13;
	}&#13;
&#13;
	pointcut init (LTWHelloWorld hw) :&#13;
		execution(LTWHelloWorld.new()) &amp;&amp; this(hw);&#13;
		&#13;
	after (LTWHelloWorld hw) : init (hw) {&#13;
		System.err.println("LTWInterfaceITD.init(" + thisJoinPointStaticPart + ")");&#13;
		hw.run();&#13;
	}&#13;
}&#13;
</file>
<file name="org.aspectj/modules/weaver/testdata/ltw-peraspects.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/docs/dist/doc/examples/ltw/README" revision="1.1" state="new"/>
<file name="org.aspectj/modules/weaver/testdata/ltw-classes.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/docs/dist/doc/examples/ltw/aj" revision="1.1" state="new"/>
<file name="org.aspectj/modules/docs/dist/doc/examples/ltw/aj.bat" revision="1.1" state="new"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingClassLoader.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/

package org.aspectj.weaver.tools;

import java.net.URL;

/**
 * An interface for weaving class loaders to provide callbacks for a
 * WeavingAdaptor.
 */
public interface WeavingClassLoader extends GeneratedClassHandler {
	
	/**
	 * Returns the aspects to be used by a WeavingAdaptor to weave classes
	 * defined by the class loader.
	 * @return the aspects used for weaving classes.
	 */
	public URL[] getAspectURLs ();

}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/package.html" revision="1.1" state="new"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LTWAroundClosure.aj" revision="1.1" state="new">import java.util.List;&#13;
&#13;
public aspect LTWAroundClosure {&#13;
&#13;
	pointcut println (List list) :&#13;
		execution(* println()) &amp;&amp; this(list);&#13;
	&#13;
	void around (final List list) : println (list) {&#13;
&#13;
		Runnable runnable = new Runnable() {&#13;
			public void run () {&#13;
				System.err.println("LTWAroundClosure.run(" + thisJoinPointStaticPart + ")");&#13;
				proceed(list);&#13;
			}&#13;
		};&#13;
		runnable.run();&#13;
		list.add("LTWAroundClosure");				&#13;
	}&#13;
&#13;
}&#13;
</file>
<file name="org.aspectj/modules/weaver/testdata/ltw-itdaspects.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LTWFieldITD.aj" revision="1.1" state="new">import java.util.List;&#13;
&#13;
public aspect LTWFieldITD {&#13;
&#13;
	private int LTWHelloWorld.intField = 999;&#13;
&#13;
	pointcut init (LTWHelloWorld hw) :&#13;
		execution(LTWHelloWorld.new()) &amp;&amp; this(hw);&#13;
		&#13;
	after (LTWHelloWorld hw) : init (hw) {&#13;
		System.err.println("LTWFieldITD.init(" + thisJoinPointStaticPart + ")");&#13;
		hw.intField = 999999;&#13;
		hw.add(getClass().getName());&#13;
	}&#13;
&#13;
}&#13;
</file>
<file name="org.aspectj/modules/weaver/testdata/ltw-woven.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/weaver/testdata/ltw-aspects.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/

package org.aspectj.weaver.tools;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

import org.aspectj.bridge.AbortException;
import org.aspectj.bridge.IMessage;
import org.aspectj.bridge.IMessageHandler;
import org.aspectj.bridge.MessageHandler;
import org.aspectj.bridge.IMessage.Kind;
import org.aspectj.util.FileUtil;
import org.aspectj.weaver.IClassFileProvider;
import org.aspectj.weaver.IWeaveRequestor;
import org.aspectj.weaver.ResolvedTypeX;
import org.aspectj.weaver.bcel.BcelObjectType;
import org.aspectj.weaver.bcel.BcelWeaver;
import org.aspectj.weaver.bcel.BcelWorld;
import org.aspectj.weaver.bcel.LazyClassGen;
import org.aspectj.weaver.bcel.UnwovenClassFile;

/**
 * This adaptor allows the AspectJ compiler to be embedded in an existing
 * system to facilitate load-time weaving. It provides an interface for a
 * weaving class loader to provide a classpath to be woven by a set of
 * aspects. A callback is supplied to allow a class loader to define classes
 * generated by the compiler during the weaving process.
 * &lt;p&gt;
 * A weaving class loader should create a &lt;code&gt;WeavingAdaptor&lt;/code&gt; before
 * any classes are defined, typically during construction. The set of aspects 
 * passed to the adaptor is fixed for the lifetime of the adaptor although the
 * classpath can be augmented. A system property can be set to allow verbose
 * weaving messages to be written to the console.
 *
 */
public class WeavingAdaptor {

	/**
	 * System property used to turn on verbose weaving messages 
	 */
	public static final String WEAVING_ADAPTOR_VERBOSE = "aj.weaving.verbose"; 

	private boolean enabled = true;
	private boolean verbose = getVerbose();
	private BcelWorld bcelWorld = null;
	private BcelWeaver weaver = null;
	private IMessageHandler messageHandler = null;
	private GeneratedClassHandler generatedClassHandler;
	private Map generatedClasses = new HashMap(); /* String -&gt; UnwovenClassFile */ 

	/**
	 * Construct a WeavingAdaptor with a reference to a weaving class loader. The
	 * adaptor will automatically search the class loader hierarchy to resolve
	 * classes. The adaptor will also search the hierarchy for WeavingClassLoader
	 * instances to determine the set of aspects to be used ofr weaving. 
     * @param loader instance of &lt;code&gt;ClassLoader&lt;/code&gt;
	 */
	public WeavingAdaptor (WeavingClassLoader loader) {
//		System.err.println("? WeavingAdaptor.&lt;init&gt;(" + loader +"," + aspectURLs.length + ")");
		generatedClassHandler = loader;
		init(getFullClassPath((ClassLoader)loader),getFullAspectPath((ClassLoader)loader/*,aspectURLs*/));
	}

	/**
	 * Construct a WeavingAdator with a reference to a
	 * &lt;code&gt;GeneratedClassHandler&lt;/code&gt;, a full search path for resolving 
	 * classes and a complete set of aspects. The search path must include
	 * classes loaded by the class loader constructing the WeavingAdaptor and
	 * all its parents in the hierarchy.   
	 * @param handler &lt;code&gt;GeneratedClassHandler&lt;/code&gt;
     * @param classURLs the URLs from which to resolve classes
     * @param aspectURLs the aspects used to weave classes defined by this class loader
	 */
	public WeavingAdaptor (GeneratedClassHandler handler, URL[] classURLs, URL[] aspectURLs) {
//		System.err.println("? WeavingAdaptor.&lt;init&gt;()");
		generatedClassHandler = handler;
		init(FileUtil.makeClasspath(classURLs),FileUtil.makeClasspath(aspectURLs));
	}
	
	private List getFullClassPath (ClassLoader loader) {
		List list = new LinkedList();
		for (; loader != null; loader = loader.getParent()) {
			if (loader instanceof URLClassLoader) {
				URL[] urls = ((URLClassLoader)loader).getURLs();
				list.addAll(0,FileUtil.makeClasspath(urls));
			}
			else {
				if (verbose) System.err.println("WeavingAdaptor: Warning - could not determine classpath for " + loader); 
			}
		}

		list.addAll(0,makeClasspath(System.getProperty("sun.boot.class.path")));

		return list;
	}
	
	private List getFullAspectPath (ClassLoader loader) {
		List list = new LinkedList();
		for (; loader != null; loader = loader.getParent()) {
			if (loader instanceof WeavingClassLoader) {
				URL[] urls = ((WeavingClassLoader)loader).getAspectURLs();
				list.addAll(0,FileUtil.makeClasspath(urls));
			}
		}

		return list;
	}
	
	private static boolean getVerbose () {
		return Boolean.getBoolean(WEAVING_ADAPTOR_VERBOSE);
	}
	
	private void init(List classPath, List aspectPath) {
		if (verbose) System.out.println("WeavingAdaptor: classPath='" + classPath + "'");
		
		// make sure the weaver can find all types...
		messageHandler = new MessageHandler();
		bcelWorld = new BcelWorld(classPath,messageHandler,null);
		bcelWorld.setXnoInline(false);
		bcelWorld.getLint().loadDefaultProperties();

		weaver = new BcelWeaver(bcelWorld);
		registerAspectLibraries(aspectPath);
	}
	
	/**
	 * Appends URL to path used by the WeavingAdptor to resolve classes
	 * @param url to be appended to search path
	 */
	public void addURL(URL url) {
		try {
			weaver.addLibraryJarFile(new File(url.getPath()));
		}
		catch (IOException ex) {
		}
	}

	/**
	 * Weave a class using aspects previously supplied to the adaptor.
	 * @param name the name of the class
	 * @param bytes the class bytes
	 * @return the woven bytes
     * @exception IOException weave failed
	 */
	public byte[] weaveClass (String name, byte[] bytes) throws IOException {
		if (shouldWeave(name)) {
			bytes = getWovenBytes(name, bytes);
		}
		return bytes;
	}

	private boolean shouldWeave (String name) {
		name = name.replace('/','.');
		boolean b = (enabled &amp;&amp; !generatedClasses.containsKey(name) &amp;&amp; shouldWeaveName(name) &amp;&amp; shouldWeaveAspect(name));
		if (verbose) System.out.println("WeavingAdaptor: shouldWeave('" + name + "') " + b);
		return b;
	}
	
	private boolean shouldWeaveName (String name) {
		return !((name.startsWith("org.apache.bcel.") || name.startsWith("org.aspectj.") || name.startsWith("java.") || name.startsWith("javax.")));
	}
	
	private boolean shouldWeaveAspect (String name) {
		ResolvedTypeX type = bcelWorld.resolve(name);
		return (type == null || !type.isAspect());
	}

	/**
	 * Weave a set of bytes defining a class. 
	 * @param name the name of the class being woven
	 * @param bytes the bytes that define the class
	 * @return byte[] the woven bytes for the class
	 * @throws IOException
	 * @throws FileNotFoundException
	 */
	private byte[] getWovenBytes(String name, byte[] bytes) throws IOException {
		WeavingClassFileProvider wcp = new WeavingClassFileProvider(name,bytes);
		weaver.weave(wcp);
		return wcp.getBytes();		
		
//		UnwovenClassFile unwoven = new UnwovenClassFile(name,bytes);
//		
//		// weave
//		BcelObjectType bcelType = bcelWorld.addSourceObjectType(unwoven.getJavaClass());
//		LazyClassGen woven = weaver.weaveWithoutDump(unwoven,bcelType);
//		
//		byte[] wovenBytes = woven != null ? woven.getJavaClass(bcelWorld).getBytes() : bytes;
//		return wovenBytes;
	}
	
	private void registerAspectLibraries(List aspectPath) {
//		System.err.println("? WeavingAdaptor.registerAspectLibraries(" + aspectPath + ")");
		for (Iterator i = aspectPath.iterator(); i.hasNext();) {
			String lib = (String)i.next();
			File libFile = new File(lib);
			if (libFile.isFile() &amp;&amp; lib.endsWith(".jar")) {
				try {
					if (verbose) System.out.println("WeavingAdaptor: adding aspect '" + lib + "' to weaver");
					addAspectLibrary(new File(lib));
				} catch (IOException ioEx) {
					if (verbose) System.err.println(
						"WeavingAdaptor: Warning - could not load aspect path entry " 
						+ lib + " : " + ioEx);
				}
			} else {
				if (verbose) System.err.println(
					"WeavingAdaptor: Warning - ignoring aspect path entry: " + lib);
			}
		}
		
		weaver.prepareForWeave();
	}

	/*
	 * Register an aspect library with this classloader for use during
	 * weaving. This class loader will also return (unmodified) any of the
	 * classes in the library in response to a &lt;code&gt;findClass()&lt;/code&gt; request.
	 * The library is not required to be on the weavingClasspath given when this
	 * classloader was constructed. 
	 * @param aspectLibraryJarFile a jar file representing an aspect library
	 * @throws IOException
	 */
	private void addAspectLibrary(File aspectLibraryJarFile) throws IOException {
		weaver.addLibraryJarFile(aspectLibraryJarFile);
//		weaver.prepareForWeave();
	}
	
	private static List makeClasspath(String cp) {
		List ret = new ArrayList();
		if (cp != null) {
			StringTokenizer tok = new StringTokenizer(cp,File.pathSeparator);
			while (tok.hasMoreTokens()) {
				ret.add(tok.nextToken());
			}
		}
		return ret;
	}

	/**
	 * Processes messages arising from weaver operations. 
	 * Tell weaver to abort on any non-informational error.
	 */
	private class MessageHandler implements IMessageHandler {

		public boolean handleMessage(IMessage message) throws AbortException {
			if (!isIgnoring(message.getKind())) {
				if (verbose) System.err.println(message.getMessage());
				throw new AbortException(message);
			}
			return true;
		}

		public boolean isIgnoring(Kind kind) {
			return ((kind == IMessage.INFO) || (kind == IMessage.DEBUG));
		}
	}

	private class WeavingClassFileProvider implements IClassFileProvider {

		private List unwovenClasses = new ArrayList(); /* List&lt;UnovenClassFile&gt; */
		private UnwovenClassFile wovenClass;

		public WeavingClassFileProvider (String name, byte[] bytes) {
			UnwovenClassFile unwoven = new UnwovenClassFile(name,bytes);
			unwovenClasses.add(unwoven);
			bcelWorld.addSourceObjectType(unwoven.getJavaClass());
		}

		public byte[] getBytes () {
			return wovenClass.getBytes();
		}

		public Iterator getClassFileIterator() {
			return unwovenClasses.iterator();
		}

		public IWeaveRequestor getRequestor() {
			return new IWeaveRequestor() {

				public void acceptResult(UnwovenClassFile result) {
					if (wovenClass == null) {
						wovenClass = result;
					}
					
					/* Classes generated by weaver e.g. around closure advice */
					else {
						String className = result.getClassName();
						generatedClasses.put(className,result);
						generatedClassHandler.acceptClass(className,result.getBytes());
					}
				}

				public void processingReweavableState() {	}

				public void addingTypeMungers() {}

				public void weavingAspects() {}

				public void weavingClasses() {}

				public void weaveCompleted() {}
			};				
		}
	}
}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/

package org.aspectj.weaver;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.net.URLStreamHandlerFactory;
import java.security.CodeSource;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

import org.aspectj.util.UtilClassLoader;
import org.aspectj.weaver.tools.*;

public class WeavingURLClassLoader extends ExtensibleURLClassLoader implements WeavingClassLoader {

	public static final String WEAVING_CLASS_PATH = "aj.class.path"; 
	public static final String WEAVING_ASPECT_PATH = "aj.aspect.path"; 
	
	private URL[] aspectURLs;
	private WeavingAdaptor adaptor; 
	private Map generatedClasses = new HashMap(); /* String -&gt; byte[] */ 

	/*
	 * This constructor is needed when using "-Djava.system.class.loader". 
	 */
	public WeavingURLClassLoader (ClassLoader parent) {
		this(getURLs(getClassPath()),getURLs(getAspectPath()),parent);
//		System.err.println("? WeavingURLClassLoader.&lt;init&gt;(" + parent + ")");
	}
	
	public WeavingURLClassLoader (URL[] classURLs, URL[] aspectURLs, ClassLoader parent) {
		super(classURLs,parent);
//		System.err.println("? WeavingURLClassLoader.&lt;init&gt;()");
		this.aspectURLs = aspectURLs;
		adaptor = new WeavingAdaptor(this);
	}
	
	private static String getAspectPath () {
		return System.getProperty(WEAVING_ASPECT_PATH,"");
	}
	
	private static String getClassPath () {
		return System.getProperty(WEAVING_CLASS_PATH,"");
	}
	
	private static URL[] getURLs (String path) {
		List urlList = new ArrayList();
		for (StringTokenizer t = new StringTokenizer(path,File.pathSeparator);
			 t.hasMoreTokens();) {
			File f = new File(t.nextToken().trim());
			try {
				if (f.exists()) {
					URL url = f.toURL();
					if (url != null) urlList.add(url);
				}
			} catch (MalformedURLException e) {}
		}

		URL[] urls = new URL[urlList.size()];
		urlList.toArray(urls);
		return urls;
	}

	protected void addURL(URL url) {
		adaptor.addURL(url);
		super.addURL(url);
	}

	/**
	 * Override to weave class using WeavingAdaptor 
	 */
	protected Class defineClass(String name, byte[] b, CodeSource cs) throws IOException {
//		System.err.println("? WeavingURLClassLoader.defineClass(" + name + ", [" + b.length + "])");
		b = adaptor.weaveClass(name,b);
		return super.defineClass(name, b, cs);
	}

	/**
	 * Override to find classes generated by WeavingAdaptor
	 */
	protected byte[] getBytes (String name) throws IOException {
		byte[] bytes = super.getBytes(name);
		
		if (bytes == null) {
//			return adaptor.findClass(name);
			return (byte[])generatedClasses.remove(name);
		}
		
		return bytes;
	}

	/**
	 * Implement method from WeavingClassLoader
	 */
	public URL[] getAspectURLs() {
		return aspectURLs;
	}

	public void acceptClass (String name, byte[] bytes) {
		generatedClasses.put(name,bytes);
	}

}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LTWMethodITD.aj" revision="1.1" state="new">import java.util.List;&#13;
&#13;
public privileged aspect LTWMethodITD {&#13;
&#13;
	public String LTWHelloWorld.getMessage () {&#13;
		return message;&#13;
	}&#13;
	&#13;
	public void LTWHelloWorld.setMessage (String newMessage) {&#13;
		message = newMessage;&#13;
	}&#13;
&#13;
	pointcut init (LTWHelloWorld hw) :&#13;
		execution(LTWHelloWorld.new()) &amp;&amp; this(hw);&#13;
		&#13;
	after (LTWHelloWorld hw) : init (hw) {&#13;
		System.err.println("LTWMethodITD.init(" + thisJoinPointStaticPart + ")");&#13;
		hw.getMessage();&#13;
		hw.setMessage("Hello LTWMethodITD");&#13;
		hw.add(getClass().getName());&#13;
	}&#13;
}</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/GeneratedClassHandler.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
package org.aspectj.weaver.tools;

/**
 * Interface implemented by weaving class loaders to allow classes generated by
 * the weaving process to be defined.
 */
public interface GeneratedClassHandler {
	
	/**
	 * Accept class generated by WeavingAdaptor. The class loader should store
	 * the class definition in its local cache until called upon to load it.
	 * @param name class name
	 * @param bytes class definition
	 */
	public void acceptClass (String name, byte[] bytes);

}
</file>
</fixedFiles>
</bug>
<bug id="32463" transactionid="72404">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="11"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="7"/>
<property name="lines-modified" value="43"/>
<property name="lines-churned" value="51"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null K-return K-this K-true K-while M O-== O-|| O-- O-!= O-+ T V Y Z-if Z-while</fullfingerprint>
<bugreport>Version: AspectJ Compiler 1.1beta4

The ajc compiler issues a spurious error message and exits with a negative 
error code when weaving code containing static declaration of a nested class. 
The compiler seem to write the classfiles correctly but the negative exit 
status causes problems when e.g. using the AjcCompilerAdapter in ant.

To reproduce:
1) Extract the following two files into an empty directory:
// File: A.aj:
aspect A  {

    pointcut withinTest(): within(Test);
    pointcut callToHandleOrder() : (withinTest() &amp;&amp;
                             call(* handleOrder(..)));

    Object around(): callToHandleOrder() {

      return "DUMMY inserted by ASPECT" ;
   }
}
// End of File A.aj

// File : Test.java
public class Test
{
    // Commenting out the static declaration makes everything work OK
    static
    {
        class StaticNestedClass
        {
        }
    }
    
    public static void main(String[] args)
    {
      System.out.println(new Test().handleOrder("test"));
    }

    private String handleOrder(String t)
    {
      return t;
    }

}
// End of Test.java

2) Compile the files 
   ajc -sourceroots . -verbose

Output:
-----
compiling c:/aspectj1.1/doc/examples/bug/./A.aj
compiling c:/aspectj1.1/doc/examples/bug/./Test.java
weaving
might need to weave [UnwovenClassFile(null, Test$1$StaticNestedClass), 
UnwovenClassFile(null, A), UnwovenClassFile(null, Test)](world=true)
wrote class file: c:\aspectj1.1\doc\examples\bug\A.class
can't find type Test$1
wrote class file: c:\aspectj1.1\doc\examples\bug\Test$1$StaticNestedClass.class
wrote class file: c:\aspectj1.1\doc\examples\bug\Test.class

1 error
------</bugreport>
<testsforfix ID="32463" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Negation of if pointcut does not work"/>
      <test NAME="ajc reports error when encountering static declaration of nested classes"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="25" file="output/32463/pre-fix/testresults.xml" passing="679" size="704"/>
<post-fix-testcases failing="25" file="output/32463/post-fix/testresults.xml" passing="679" size="704"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/TypeX.java" revision="1.6" state="changed">252c252
&lt; 
---
&gt;     
254,255c254,255
&lt;      * Returns a TypeX object representing the declaring type of this type, or
&lt;      * null if this type does not represent a non-package-level-type.
---
&gt;      * Returns a TypeX object representing the effective outermost enclosing type
&gt;      * for a name type.  For all other types, this will return the type itself.
257,269c257,266
&lt;      * &lt;strong&gt;Warning&lt;/strong&gt;:  This is guaranteed to work for all member types.
&lt;      * For anonymous/local types, the only guarantee is given in JLS 13.1, where
&lt;      * it guarantees that if you call getDeclaringType() repeatedly, you will eventually
&lt;      * get the top-level class, but it does not say anything about classes in between.
&lt;      *
&lt;      * @return the declaring TypeX object, or null.
&lt;      */
&lt;     public TypeX getDeclaringType() {
&lt;     	if (isArray()) return null;
&lt; 		String name = getName();
&lt; 		int lastDollar = name.lastIndexOf('$');
&lt; 		if (lastDollar != -1) {
&lt;         	return TypeX.forName(name.substring(0, lastDollar));
---
&gt;      * The only guarantee is given in JLS 13.1 where code generated according to
&gt;      * those rules will have type names that can be split apart in this way.
&gt;      * @return the outermost enclosing TypeX object or this.
&gt;      */
&gt;     public TypeX getOutermostType() {
&gt;     	if (isArray() || isPrimitive()) return this;
&gt; 		String sig = getSignature();
&gt; 		int dollar = sig.indexOf('$');
&gt; 		if (dollar != -1) {
&gt; 			return TypeX.forSignature(sig.substring(0, dollar) + ';');
271c268
&lt; 			return null;
---
&gt; 			return this;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/NameMangler.java" revision="1.7" state="changed">271,277d270
&lt; 	private static TypeX getOutermostType(TypeX type) {
&lt; 		TypeX outerType = type.getDeclaringType();
&lt; 		if (outerType == null) return type;
&lt; 		return getOutermostType(outerType);
&lt; 	}
&lt; 
&lt; 
280c273
&lt; 			return getOutermostType(aspectType).getNameAsIdentifier();
---
&gt; 			return aspectType.getOutermostType().getNameAsIdentifier();
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java" revision="1.6" state="changed">37c37,38
&lt; 		TypeX enclosingType = shadow.getEnclosingType();
---
&gt; 		ResolvedTypeX enclosingType = shadow.getIWorld().resolve(shadow.getEnclosingType());
&gt; 		//System.err.println("enclosingType: " + enclosingType);
43c44
&lt; 			if (type.matchesStatically(shadow.getIWorld().resolve(enclosingType))) {
---
&gt; 			if (type.matchesStatically(enclosingType)) {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.14" state="changed">795,799c795,817
&lt; 	private static ResolvedTypeX getOutermostType(ResolvedTypeX t) {
&lt; 		TypeX dec = t.getDeclaringType();
&lt; 		if (dec == null) return t;
&lt; 		return getOutermostType(dec.resolve(t.getWorld()));
&lt; 	}
---
&gt;     /**
&gt;      * Returns a ResolvedTypeX object representing the declaring type of this type, or
&gt;      * null if this type does not represent a non-package-level-type.
&gt;      * 
&gt;      * &lt;strong&gt;Warning&lt;/strong&gt;:  This is guaranteed to work for all member types.
&gt;      * For anonymous/local types, the only guarantee is given in JLS 13.1, where
&gt;      * it guarantees that if you call getDeclaringType() repeatedly, you will eventually
&gt;      * get the top-level class, but it does not say anything about classes in between.
&gt;      *
&gt;      * @return the declaring TypeX object, or null.
&gt;      */
&gt;     public ResolvedTypeX getDeclaringType() {
&gt;     	if (isArray()) return null;
&gt; 		String name = getName();
&gt; 		int lastDollar = name.lastIndexOf('$');
&gt; 		while (lastDollar != -1) {
&gt; 			ResolvedTypeX ret = world.resolve(TypeX.forName(name.substring(0, lastDollar)), true);
&gt; 			if (ret != ResolvedTypeX.MISSING) return ret;
&gt; 			lastDollar = name.lastIndexOf('$', lastDollar-1);
&gt; 		}
&gt; 		return null;
&gt;     }
&gt; 	
807c825
&lt; 			return getOutermostType(targetType).equals(getOutermostType(fromType));
---
&gt; 			return targetType.getOutermostType().equals(fromType.getOutermostType());
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java" revision="1.3" state="changed">61,62c61,62
&lt;     	assertEquals(t.getDeclaringType(), TypeX.forName("java.util.Map"));
&lt;     	assertNull(TypeX.forName("java.util.Map").getDeclaringType());
---
&gt;     	assertEquals(t.getOutermostType(), TypeX.forName("java.util.Map"));
&gt;     	assertEquals(TypeX.forName("java.util.Map").getOutermostType(), TypeX.forName("java.util.Map"));
</file>
<file name="org.aspectj/modules/tests/bugs/WeaveLocal.java" revision="1.1" state="new">// for Bug#:  32463  
import org.aspectj.testing.Tester;


public class WeaveLocal
{
    // Commenting out the static declaration makes everything work OK
    static
    {
        class StaticNestedClass
        {
        }
    }
    
    public static void main(String[] args)
    {
      System.out.println(new WeaveLocal().handleOrder("test"));
    }

    private String handleOrder(String t)
    {
      return t;
    }

}

aspect A  {

    pointcut withinTest(): within(WeaveLocal);
    pointcut callToHandleOrder() : (withinTest() &amp;&amp;
                             call(* handleOrder(..)));

    Object around(): callToHandleOrder() {

      return "DUMMY inserted by ASPECT" ;
   }
}
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.34" state="changed">5587a5588,5601
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="33635" 
&gt;     		title="Negation of if pointcut does not work"&gt;
&gt;         &lt;compile files="NotIf.java"/&gt;
&gt;         &lt;run class="NotIf"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="32463" 
&gt;     		title="ajc reports error when encountering static declaration of nested classes"&gt;
&gt;         &lt;compile files="WeaveLocal.java"/&gt;
&gt;         &lt;run class="WeaveLocal"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/jimTests.xml" revision="1.11" state="changed">4,9c4
&lt;     &lt;ajc-test dir="bugs" pr="33635" 
&lt;     		title="Negation of if pointcut does not work"&gt;
&lt;         &lt;compile files="NotIf.java"/&gt;
&lt;         &lt;run class="NotIf"/&gt;
&lt;     &lt;/ajc-test&gt;
&lt;     
---
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="33635" transactionid="72363">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="6"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="12"/>
<property name="lines-churned" value="18"/>
<property name="priority" value="P1"/>
<property name="severity" value="critical"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-import M T V</fullfingerprint>
<bugreport>In "!if(expression)" the negation part is ignored. I am using beta4.

How to reproduce:

public class Test {
    public static void main(String args[]) {
    }
}

aspect NotIfBugAspect {
    before() : execution(* main(..)) &amp;&amp; !if(true) {
	System.out.println("NotIfBugAspect message");
    }
}

&gt; ajc *.java
&gt; java Test
NotIfBugAspect message

If I change the pointcut in before advice to move negation inside if(), 
everything works fine:
aspect NotIfBugAspect {
    before() : execution(* main(..)) &amp;&amp; if(!true) {
	System.out.println("NotIfBugAspect message");
    }
}

&gt; ajc *.java
&gt; java Test
  &lt;no output&gt;</bugreport>
<testsforfix ID="33635" type="new">
    <file LOCATION="org.aspectj/modules/tests/jimTests.xml">
      <test NAME="Negation of if pointcut does not work"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="24" file="output/33635/pre-fix/testresults.xml" passing="678" size="702"/>
<post-fix-testcases failing="24" file="output/33635/post-fix/testresults.xml" passing="680" size="704"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/IfPointcut.java" revision="1.8" state="changed">31a32
&gt; import org.aspectj.weaver.ast.*;
86a88,90
&gt; 
&gt; 	//??? The implementation of name binding and type checking in if PCDs is very convoluted
&gt; 	//    There has to be a better way...
94,96c98,100
&lt; 			//??? some of these tests are preconditions for the if to run correctly
&lt; 			//    this implementation will duplicate those tests, we should be more careful
&lt; 			Test preTest = residueSource.findResidue(shadow, myState); // might need this
---
&gt; 			//??? we throw out the test that comes from this walk.  All we want here
&gt; 			//    is bindings for the arguments
&gt; 			residueSource.findResidue(shadow, myState);
99a104,105
&gt; 			Test ret = Literal.TRUE;
&gt; 			
102c108,112
&lt; 	        	args.add(myState.get(i));
---
&gt; 	        	Var v = myState.get(i);
&gt; 	        	args.add(v);
&gt; 	        	ret = Test.makeAnd(ret, 
&gt; 	        		Test.makeInstanceof(v, 
&gt; 	        			testMethod.getParameterTypes()[i].resolve(shadow.getIWorld())));
117,118c127,130
&lt; 			Test myTest = Test.makeCall(testMethod, (Expr[])args.toArray(new Expr[args.size()]));
&lt; 			return Test.makeAnd(preTest, myTest);
---
&gt; 	        
&gt; 	        ret = Test.makeAnd(ret, Test.makeCall(testMethod, (Expr[])args.toArray(new Expr[args.size()])));
&gt; 
&gt; 			return ret; 
</file>
<file name="org.aspectj/modules/tests/bugs/NotIf.java" revision="1.1" state="new">// for Bug#:  33635  
import org.aspectj.testing.Tester;


public class NotIf {
    public static void main(String[] args) {
		Tester.checkEqual(Aspect1.ranNone, 0, "shouldn't run");
		Tester.checkEqual(Aspect1.ranTwo, 2, "should run");
		Tester.checkEqual(Aspect2.ran, 1, "should run with values");
    }
}

aspect Aspect1 {
	static int ranNone = 0;
	static int ranTwo = 0;
	
	static boolean testTrue() { return true; }
	
	static boolean testFalse() { return false; }
	
	before(): execution(void main(..)) &amp;&amp; !if(testTrue()) {
		ranNone += 1;
	}
	
	before(): execution(void main(..)) &amp;&amp; if(!testTrue()) {
		ranNone += 1;
	}
	before(): execution(void main(..)) &amp;&amp; !if(testFalse()) {
		ranTwo += 1;
	}
	
	before(): execution(void main(..)) &amp;&amp; if(!testFalse()) {
		ranTwo += 1;
	}
}

aspect Aspect2 {
	static int ran = 0;
	
	static boolean testValues(int i, String s, Object o) {
		return false;
	}
	
	before(String[] a): execution(void main(String[])) &amp;&amp; 
				!if(testValues(a.length, a.toString(), a)) &amp;&amp; args(a)
	{
		ran += 1;
	}
}
</file>
<file name="org.aspectj/modules/tests/jimTests.xml" revision="1.10" state="changed">3a4,10
&gt;     &lt;ajc-test dir="bugs" pr="33635" 
&gt;     		title="Negation of if pointcut does not work"&gt;
&gt;         &lt;compile files="NotIf.java"/&gt;
&gt;         &lt;run class="NotIf"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     
</file>
</fixedFiles>
</bug>
<bug id="34858" transactionid="72423">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="5"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P1"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-continue K-if M O-! T V Z-if</fullfingerprint>
<bugreport>this test file (Test.java) crashes the weaver:

public class Test {
    static aspect MockProcessing {
        pointcut testFlow(final Thread thread) : 
            cflow(execution(void run()) &amp;&amp; this(thread) &amp;&amp; within(Thread)); // 
the within is an optimization

        Object around() :
                call(* DummyConfiguration.createRootApplicationModule(..)) &amp;&amp; 
testFlow(Thread)
        {
            return null;
        }
    }
}

class Bar {
    void foo() {
        DummyConfiguration.createRootApplicationModule();
    }
}

class DummyConfiguration {
    static Object createRootApplicationModule() {
        return null;
    }
}

prompt&gt;ajc -d 11bin -1.4 Test.java
Exception thrown from AspectJ 1.1rc1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
0
0
java.lang.ArrayIndexOutOfBoundsException: 0
        at org.aspectj.weaver.IntMap.get(IntMap.java:109)
        at org.aspectj.weaver.patterns.CflowPointcut.concretize1(CflowPointcut.j
ava:170)
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePo
intcut.java:270)
        at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:
88)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)
        at org.aspectj.weaver.Advice.concretize(Advice.java:207)
        at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMe
mbers.java:78)
        at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingM
embers.java:72)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedT
ypeX.java:328)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(Crosscut
tingMembersSet.java:54)
        at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:16
4)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:214)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerat
eClassFiles(AjBuildManager.java:394)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBu
ildManager.java:149)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort</bugreport>
<testsforfix ID="34858" type="new">
    <file LOCATION="org.aspectj/modules/tests/jimTests.xml">
      <test NAME="type not imported in around advice"/>
      <test NAME="type not imported in aspect"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="cflow binding issues with ignoring state"/>
      <test NAME="cflow binding -- original weaver crash"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="24" file="output/34858/pre-fix/testresults.xml" passing="689" size="713"/>
<post-fix-testcases failing="24" file="output/34858/post-fix/testresults.xml" passing="691" size="715"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java" revision="1.7" state="changed">169a170,174
&gt; 			
&gt; 			// we don't need to keep state that isn't actually exposed to advice
&gt; 			//??? this means that we will store some state that we won't actually use, optimize this later
&gt; 			if (!bindings.hasKey(freeVar)) continue; 
&gt; 			
</file>
<file name="org.aspectj/modules/tests/bugs/CflowBinding.java" revision="1.1" state="new">// for Bugzilla Bug 34858  
//   Weaver crash w/ coverage

import org.aspectj.testing.Tester;

public class CflowBinding {
	public static void main(String[] args) {
		new Bar().bar(10);
	}
	
	
	static aspect A {
		pointcut flow(int i, Object o): cflow(execution(void bar(int)) &amp;&amp; this(o) &amp;&amp; args(i));
		
		Object around() : call(void m()) &amp;&amp; flow(int, Object) {
			return proceed();
		}
		
		Object around(final int i) : call(void m()) &amp;&amp; flow(i, Object) {
			System.out.println("i: " + i);
			return proceed(i);
		}
		
		Object around(final Object o) : call(void m()) &amp;&amp; flow(int, o) {
			System.out.println("o: " + o);
			return proceed(o);
		}
		
		Object around(final Object o, final int i) : call(void m()) &amp;&amp; flow(i, o) {
			System.out.println("o: " + o + ", i: " + i);
			return proceed(o, i);
		}
	}
}

class Bar {
	void bar(int i) {
		m();
	}
	void m() {
		System.out.println("m");
	}
}

</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.41" state="changed">5687a5688,5699
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="34858"
&gt;       title="cflow binding issues with ignoring state"&gt;
&gt;         &lt;compile files="CflowBinding.java"/&gt;
&gt;         &lt;run class="CflowBinding"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs" pr="34858"
&gt;       title="cflow binding -- original weaver crash"&gt;
&gt;         &lt;compile files="CflowBindingOrig.java"/&gt;
&gt;         &lt;run class="CflowBindingOrig"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/CflowBindingOrig.java" revision="1.1" state="new">// for Bugzilla Bug 34858  
//   Weaver crash 

import org.aspectj.testing.Tester;

/**
 * Almost an exact duplicate of the reported issue
 */
public class CflowBindingOrig {
	public static void main(String[] args) {
		new Bar().foo();
	}
	
    static aspect MockProcessing {
        pointcut testFlow(final Thread thread) : 
            cflow(execution(void run()) &amp;&amp; this(thread) &amp;&amp; within(Thread)); //  the within is an optimization

        Object around() :
                call(* DummyConfiguration.createRootApplicationModule(..)) &amp;&amp;  testFlow(Thread)
        {
            return null;
        }
    }
}

class Bar {
    void foo() {
        DummyConfiguration.createRootApplicationModule();
    }
}

class DummyConfiguration {
    static Object createRootApplicationModule() {
        return null;
    }
}
</file>
<file name="org.aspectj/modules/tests/jimTests.xml" revision="1.17" state="changed">3a4,9
&gt;     &lt;ajc-test dir="errors"  
&gt;     		title="type not imported in around advice"&gt;
&gt;         &lt;compile files="TypeNotImportedInAroundCE.java"&gt;
&gt;         	&lt;message kind="error" line="10"/&gt;
&gt;         &lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
4a11,16
&gt;     &lt;ajc-test dir="errors"  
&gt;     		title="type not imported in aspect"&gt;
&gt;         &lt;compile files="TypeInAspectNotImportedCE.java"&gt;
&gt;         	&lt;message kind="error" line="6"/&gt;
&gt;         &lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="34925" transactionid="72515">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="20"/>
<property name="lines-added" value="10"/>
<property name="lines-deleted" value="7"/>
<property name="lines-modified" value="52"/>
<property name="lines-churned" value="69"/>
<property name="priority" value="P2"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-instanceof K-new K-null K-return K-super K-throw M O-== O-!= O-() O-+ O-cast O-instanceof T V Y Z-cast Z-if Z-throw</fullfingerprint>
<bugreport>These test files crash the compiler (in fact if you just compile 
ConvertToUnchecked it crashes it):

ConvertToUnchecked.java:

import java.io.IOException;

// example 3
aspect ConvertToUnchecked {
  // make all exceptions in an application unchecked; "soft"
  //declare soft: (Exception &amp;&amp; !RuntimeException): within(com.foo.app..*);

  // convert IOExceptions in a package to PersistenceException
  pointcut module() : within(test.*); // within
(com.foo.framework.persistence.*);
  // convert exceptions
  // within(test.*) would work to allow an immediate catch, except for
  // the last statement in a try block
  // however, I suspect that would also generate inefficient code
  // even this might be inefficient: it needs to wrap every method body in a
  // try ... catch block
  after() throwing (IOException e) : within(test.*) {
    throw new PersistenceException(e);
  }
  declare soft: (IOException): module();
}
// tested by: test.ConvertToUnchecked
----

PersistenceException.java
public class PersistenceException extends Exception 
{
  public PersistenceException(Throwable cause) {
    super(cause);
  }
}

---
sample run:
C:\ron\devel\articles\errorHandling&gt;ajc -1.4 ConvertToUnchecked.java 
Persistence
Exception.java
java.lang.RuntimeException: unimplemented: throw new PersistenceException(e)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow
(Ec
lipseShadow.java:148)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow
(E
clipseFactory.java:292)
        at 
org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandle
dException(AjProblemReporter.java:67)
        at 
org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHand
lers(FlowContext.java:249)
        at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode
(Thro
wStatement.java:35)
        at 
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analy
seCode(AbstractMethodDeclaration.java:106)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(Typ
eDeclaration.java:445)
        at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal
yseCode(CompilationUnitDeclaration.java:76)
        at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:539)

        at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java
:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:340)

        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:232)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:171)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.ru
n(AjBuildManager.java:656)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:139)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\ron\devel\articles\errorHandling\ConvertToUnchecked.java:0 Internal compiler
error
java.lang.RuntimeException: unimplemented: throw new PersistenceException(e)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow
(Ec
lipseShadow.java:148)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow
(E
clipseFactory.java:292)
        at 
org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandle
dException(AjProblemReporter.java:67)
        at 
org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHand
lers(FlowContext.java:249)
        at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode
(Thro
wStatement.java:35)
        at 
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analy
seCode(AbstractMethodDeclaration.java:106)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(Typ
eDeclaration.java:445)
        at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal
yseCode(CompilationUnitDeclaration.java:76)
        at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:539)

        at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java
:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:340)

        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:232)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:171)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.ru
n(AjBuildManager.java:656)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:139)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
ABORT
Exception thrown from AspectJ 1.1rc1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
unimplemented: throw new PersistenceException(e)
unimplemented: throw new PersistenceException(e)
java.lang.RuntimeException: unimplemented: throw new PersistenceException(e)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow
(Ec
lipseShadow.java:148)
        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow
(E
clipseFactory.java:292)
        at 
org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandle
dException(AjProblemReporter.java:67)
        at 
org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHand
lers(FlowContext.java:249)
        at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode
(Thro
wStatement.java:35)
        at 
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analy
seCode(AbstractMethodDeclaration.java:106)
        at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode
(Typ
eDeclaration.java:445)
        at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal
yseCode(CompilationUnitDeclaration.java:76)
        at org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:539)

        at org.aspectj.ajdt.internal.compiler.AjCompiler.process
(AjCompiler.java
:65)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:340)

        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:232)
        at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Ab
stractImageBuilder.java:171)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.ru
n(AjBuildManager.java:656)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:139)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)
        at org.aspectj.tools.ajc.Main.run(Main.java:216)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 1 error</bugreport>
<testsforfix ID="34925" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="declare soft and throw statements"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="28" file="output/34925/pre-fix/testresults.xml" passing="693" size="721"/>
<post-fix-testcases failing="28" file="output/34925/post-fix/testresults.xml" passing="694" size="722"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java" revision="1.9" state="changed">68,71d67
&lt; 			if (callSite == null) {
&lt; 				super.unhandledException(exceptionType, location);
&lt; 				return;
&lt; 			}
73,75c69,70
&lt; 	//		System.err.println("about to show error for unhandled exception: "  + exceptionType + 
&lt; 	//				" at " + location + " in " + referenceContext);
&lt; 			
---
&gt; //			System.err.println("about to show error for unhandled exception: "  + new String(exceptionType.sourceName()) + 
&gt; //					" at " + location + " in " + referenceContext);		
79,84c74,82
&lt; 				FuzzyBoolean match = d.getPointcut().match(callSite);
&lt; 				if (match.alwaysTrue()) {
&lt; 					//System.err.println("matched callSite: "  + callSite + " with " + d);
&lt; 					return;
&lt; 				} else if (!match.alwaysFalse()) {
&lt; 					throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
---
&gt; 				if (callSite != null) {
&gt; 					FuzzyBoolean match = d.getPointcut().match(callSite);
&gt; 					if (match.alwaysTrue()) {
&gt; 						//System.err.println("matched callSite: "  + callSite + " with " + d);
&gt; 						return;
&gt; 					} else if (!match.alwaysFalse()) {
&gt; 						//!!! need this check to happen much sooner
&gt; 						//throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
&gt; 					}
86,92c84,92
&lt; 				
&lt; 				match = d.getPointcut().match(enclosingExec);
&lt; 				if (match.alwaysTrue()) {
&lt; 					//System.err.println("matched enclosingExec: "  + enclosingExec + " with " + d);
&lt; 					return;
&lt; 				} else if (!match.alwaysFalse()) {
&lt; 					throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
---
&gt; 				if (enclosingExec != null) {
&gt; 					FuzzyBoolean match = d.getPointcut().match(enclosingExec);
&gt; 					if (match.alwaysTrue()) {
&gt; 						//System.err.println("matched enclosingExec: "  + enclosingExec + " with " + d);
&gt; 						return;
&gt; 					} else if (!match.alwaysFalse()) {
&gt; 						//!!! need this check to happen much sooner
&gt; 						//throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
&gt; 					}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java" revision="1.8" state="changed">16,20c16,17
&lt; import org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration;
&lt; import org.aspectj.ajdt.internal.compiler.ast.InterTypeConstructorDeclaration;
&lt; import org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration;
&lt; import org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration;
&lt; import org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration;
---
&gt; 
&gt; import org.aspectj.ajdt.internal.compiler.ast.*;
22,26c19
&lt; import org.aspectj.bridge.SourceLocation;
&lt; import org.aspectj.weaver.Member;
&lt; import org.aspectj.weaver.Shadow;
&lt; import org.aspectj.weaver.TypeX;
&lt; import org.aspectj.weaver.World;
---
&gt; import org.aspectj.weaver.*;
28,34c21
&lt; import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
&lt; import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
&lt; import org.eclipse.jdt.internal.compiler.ast.AstNode;
&lt; import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
&lt; import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
&lt; import org.eclipse.jdt.internal.compiler.ast.MessageSend;
&lt; import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
---
&gt; import org.eclipse.jdt.internal.compiler.ast.*;
47,48c34,35
&lt; 	//XXXReferenceContext context;
&lt; 	AbstractMethodDeclaration enclosingMethod;
---
&gt; 	ReferenceContext context;
&gt; 	//AbstractMethodDeclaration enclosingMethod;
56,57c43
&lt; 		//XXX can this fail in practice?
&lt; 		this.enclosingMethod = (AbstractMethodDeclaration)context;
---
&gt; 		this.context = context;
66c52,58
&lt; 		return world.fromBinding(enclosingMethod.binding.declaringClass);
---
&gt; 		if (context instanceof TypeDeclaration) {
&gt; 			return world.fromBinding(((TypeDeclaration)context).binding);
&gt; 		} else if (context instanceof AbstractMethodDeclaration) {
&gt; 			return world.fromBinding(((AbstractMethodDeclaration)context).binding.declaringClass);
&gt; 		} else {
&gt; 			return ResolvedTypeX.MISSING;
&gt; 		}
75c67,74
&lt; 		return world.makeResolvedMember(enclosingMethod.binding);
---
&gt; 		if (context instanceof TypeDeclaration) {
&gt; 			return new Member(Member.STATIC_INITIALIZATION, getEnclosingType(), 0, 
&gt; 						ResolvedTypeX.VOID, "&lt;clinit&gt;", TypeX.NONE);
&gt; 		} else if (context instanceof AbstractMethodDeclaration) {
&gt; 			return world.makeResolvedMember(((AbstractMethodDeclaration)context).binding);
&gt; 		} else {
&gt; 			return null;
&gt; 		}
116a116
&gt; 			if (e.isSuperAccess()) return null;  // super calls don't have shadows
120,124c120,121
&lt; 			//??? these need to be ignored, they don't have shadows
&lt; 			return null;
&lt; //			ExplicitConstructorCall e = (ExplicitConstructorCall)astNode;
&lt; //			return new EclipseShadow(world, Shadow.MethodCall,
&lt; //					world.makeResolvedMember(e.binding), astNode, context);					
---
&gt; 			//??? these should be ignored, they don't have shadows
&gt; 			return null;				
141a139,140
&gt; 			} else if (e instanceof Clinit) {
&gt; 				kind = Shadow.StaticInitialization; 
143c142,143
&lt; 				throw new RuntimeException("unimplemented: " + e);
---
&gt; 				return null;
&gt; 				//throw new RuntimeException("unimplemented: " + e);
146a147,152
&gt; 		} else if (astNode instanceof TypeDeclaration) {
&gt; 			return new EclipseShadow(world, Shadow.StaticInitialization,
&gt; 							new Member(Member.STATIC_INITIALIZATION, 
&gt; 								world.fromBinding(((TypeDeclaration)astNode).binding), 0, 
&gt; 								ResolvedTypeX.VOID, "&lt;clinit&gt;", TypeX.NONE),
&gt; 							astNode, context);
148c154,155
&lt; 			throw new RuntimeException("unimplemented: " + astNode);
---
&gt; 			return null;
&gt; 			//throw new RuntimeException("unimplemented: " + astNode);
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.45" state="changed">5764a5765,5770
&gt;     &lt;ajc-test dir="bugs" pr="34925"
&gt;       title="declare soft and throw statements"&gt;
&gt;         &lt;compile files="ConvertToUnchecked.java"/&gt;
&gt;         &lt;run class="ConvertToUnchecked"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/jimTests.xml" revision="1.20" state="changed">3a4,5
&gt; 
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs/ConvertToUnchecked.java" revision="1.1" state="new">
import org.aspectj.testing.Tester;

/** Bugzilla Bug 34925  
   compiler crash on yesterday's rc1 build 
 */
import java.io.*;

public aspect ConvertToUnchecked {
	
	public static void main(String[] args) {
		try {
			Foo foo = new Foo("hello");
			Tester.check(false, "shouldn't get here");
		} catch (PersistenceException pe) {
		}
	}
	
    // convert IOExceptions in Foo to PersistenceException
    pointcut module() : within(Foo);
  
	after() throwing (IOException e) : module() {
	   throw new PersistenceException(e);
	}
    declare soft: (IOException): module();
}

class PersistenceException extends RuntimeException 
{
  public PersistenceException(Throwable cause) {
    super(cause);
  }
}


class Root {
	Root(String s) throws IOException {
	}
}

class Foo extends Root {
	Foo(String s) {
		super(s);
	}
	
	static {
		if (false) {
			getFile();
			throw new IOException("bar");
		}
		
	}
	
	{
		if (false) throw new IOException("bar");
	}
	
	File f = getFile();
	
	static File getFile() throws IOException {
		throw new IOException("bad");
	}
	
	
	public void m() {
		throw new IOException("hi");
	}
}</file>
</fixedFiles>
</bug>
<bug id="34951" transactionid="72550">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="9"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="9"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-import M T V Y</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Compiling spacewar without specifying aspectjrt.jar on the classpath causes a 
NPE.  Expected an error message "aspectjrt.jar required".

Steps to reproduce
1) install latest
2) cd doc/examples
3) java -jar ../../lib/aspectjtools.jar -verbose @spacewar/debug.lst
RESULT:NPE in attached log</bugreport>
<testsforfix ID="34951" type="new">
    <file LOCATION="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java">
      <test NAME="testMissingRuntimeError"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="28" file="output/34951/pre-fix/testresults.xml" passing="710" size="738"/>
<post-fix-testcases failing="28" file="output/34951/post-fix/testresults.xml" passing="710" size="738"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.16" state="changed">47a48
&gt; import org.aspectj.weaver.ResolvedTypeX;
287a289,296
&gt; 		
&gt; 		//check for org.aspectj.runtime.JoinPoint
&gt; 		bcelWorld.resolve("org.aspectj.lang.JoinPoint");
&gt; 		
&gt; //		if () {
&gt; //			bcelWorld.showMessage(IMessage.ERROR,
&gt; //					"can't find type org.aspectj.lang.JoinPoint on classpath", null, null);
&gt; //		}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java" revision="1.5" state="changed">17a18,21
&gt; import org.aspectj.ajdt.ajc.AjdtCommand;
&gt; import org.aspectj.bridge.ICommand;
&gt; import org.aspectj.bridge.MessageHandler;
&gt; 
98a103,119
&gt; 	public void testMissingRuntimeError() {
&gt; 		List args = new ArrayList();
&gt; 
&gt; 		args.add("-d");
&gt; 		args.add("out");
&gt; 		
&gt; 		args.add("-classpath");
&gt; 		args.add("../lib/junit/junit.jar;../testing-client/bin");
&gt; 		args.add("testdata/src1/Xlint.java");
&gt; 		
&gt; 		ICommand command = new AjdtCommand();
&gt; 		MessageHandler myHandler = new MessageHandler();
&gt; 		myHandler.setInterceptor(org.aspectj.tools.ajc.Main.MessagePrinter.TERSE);
&gt; 		boolean result = command.runCommand((String[])args.toArray(new String[args.size()]), myHandler);
&gt; 
&gt; 		assertEquals("error for org.aspectj.lang.JoinPoint not found", 1, myHandler.getErrors().length);
&gt; 	}
</file>
</fixedFiles>
</bug>
<bug id="36234" transactionid="71379">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="17"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="17"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKM</concisefingerprint>
<fullfingerprint>H K-catch K-new K-null K-true K-try M O-+ T V Y</fullfingerprint>
<bugreport>Getting an out of memory error when compiling with Ajc 1.1 RC1. 
I know this is not very descriptive, but maybe you can point me into a 
direction of getting more output.

here some additional information though:
Code base is medium size (about 1500 classfiles)
I removed all my aspects and still receive the error.
Running it from the command line: ajc -classpath whateveritis -sourceroots 
whateveritis -d whateveritis</bugreport>
<pre-fix-testcases failing="95" file="output/36234/pre-fix/testresults.xml" passing="1123" size="1218"/>
<post-fix-testcases failing="95" file="output/36234/post-fix/testresults.xml" passing="1123" size="1218"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java" revision="1.18" state="changed">69a70,77
&gt; 
&gt; 	private static final String OUT_OF_MEMORY_MSG
&gt; 		= "AspectJ " + Version.text + " ran out of memory during compilation:" + LangUtil.EOL + LangUtil.EOL
&gt; 		  + "Please increase the memory available to ajc by editing the ajc script " + LangUtil.EOL
&gt; 		  + "found in your AspectJ installation directory. The -Xmx parameter value" + LangUtil.EOL
&gt; 		  + "should be increased from 64M (default) to 128M or even 256M." + LangUtil.EOL + LangUtil.EOL
&gt; 		  + "See the AspectJ FAQ available from the documentation link" + LangUtil.EOL
&gt; 		  + "on the AspectJ home page at http://www.eclipse.org/aspectj";
156c164,173
&lt;         run(args, holder);
---
&gt;         
&gt;         // make sure we handle out of memory gracefully...
&gt;         try {
&gt;         	// byte[] b = new byte[100000000]; for testing OoME only!
&gt;         	run(args, holder);
&gt;         } catch (OutOfMemoryError outOfMemory) {
&gt;         	IMessage outOfMemoryMessage = new Message(OUT_OF_MEMORY_MSG,null,true);
&gt;         	holder.handleMessage(outOfMemoryMessage);
&gt;         	systemExit(holder);  // we can't reasonably continue from this point.
&gt;         }
</file>
</fixedFiles>
</bug>
<bug id="36430" transactionid="68436">
<property name="files-churned" value="17"/>
<property name="java-files-churned" value="15"/>
<property name="classes-churned" value="15"/>
<property name="methods-churned" value="15"/>
<property name="hunks" value="59"/>
<property name="lines-added" value="323"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="32"/>
<property name="lines-churned" value="355"/>
<property name="priority" value="P2"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-for K-if K-import K-instanceof K-new K-null K-return K-this K-throw K-true K-while M O-&lt; O-&lt;&lt; O-== O-&gt; O-- O-! O-!= O-() O-&amp; O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-throw Z-vardecl Z-while</fullfingerprint>
<bugreport>Adding a RFE as Wes suggested...

Wes' reply:
There are some issues with the -Xnoweave option that we won't
have the time to carefully resolve for 1.1, even though, 
as you suggest, there may be times when it would be useful.

The workaround at present is to weave tracing into transactions 
when the transactions jar is compiled. e.g.,

-- do the build
  ajc @tracing.lst -outjar tracing.jar
  ajc @transactions.lst -aspectpath tracing.jar \
      -outjar transactions.jar
  ajc @app.lst -aspectpath "tracing.jar;transactions.jar" \
      -outjar app.jar
-- build the jar
  mkdir final
  cd final
  jar xf ../tracing.jar
  jar xf ../transactions.jar
  jar xf ../app.jar
  # fixup manifest, etc?
  jar cf ../final.jar *

What if you don't have the sources for the transactions.jar?
This is a case of getting binary transactions aspects from a 
vendor who won't provide source and wanting to weave your 
tracing into it.  I would hope that by the time that problem 
becomes prevalent, we will have a solution for it.

If you'd like to keep this on the radar, please submit this
discussion as an RFE for the compiler at

  http://dev.eclipse.org/bugs/enter_bug.cgi?product=AspectJ

Thank you -
Wes

P.S. - Personally, I think this case

&gt; &gt; ajc -injars app.jar;transaction.jar
&gt;       -aspectpath transaction.jar;tracing.jar

doesn't make sense.  Things on the aspectpath are defined,
whereas things in injars will be woven into and redefined.
It's not clear from this command which variant the user 
expects when refering to a type in transactions.jar.

Ramnivas Laddad wrote:
&gt; 
&gt; Hello,
&gt; 
&gt; I think I have a use case that cannot be implemented
&gt; (at least elegantly, anyway) without noweave/XnoWeave
&gt; option (and thus I request to make it a regular option
&gt; instead of experimental -X).
&gt; 
&gt; Basically, I want to have my tracing.jar (
&gt; contains tracing aspect) weave into transaction.jar
&gt; (contains abstract transaction mangement aspects,
&gt; concrete policy enforcement aspects, and supporting
&gt; classes). Assume app.jar contain business classes
&gt; and interfaces. Each of the jar is created using
&gt; -ourjar (but not -noweave or -XnoWeave).
&gt; 
&gt; To build the final system I issue the following
&gt; command:
&gt; &gt; ajc -injars app.jar;transaction.jar
&gt;       -aspectpath transaction.jar;tracing.jar
&gt; 
&gt; Now compiler gives me error due to multiply woven
&gt; classes and aspects in transaction.jar.
&gt; 
&gt; Everything works fine if I create the original jar
&gt; files using -noweave.
&gt; 
&gt; I could workaround by creating multiple jars, but
&gt; I hink -noweave is the right approach as
&gt; I really don't want to ship multiple jars that are
&gt; needed to implement a single concern and expect the
&gt; users to correctly specify jar files in -injars
&gt; and -aspectpath.
&gt; 
&gt; -Ramnivas</bugreport>
<testsforfix ID="36430" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/ReweavableTestCase.java">
      <test NAME="testNonReweavableCompile"/>
      <test NAME="testReweavableCompile"/>
      <test NAME="testReweavableCompressCompile"/>
      <test NAME="testReweavableSimpleCompile"/>
      <test NAME="testForReweavableSimpleErrorCompile"/>
      <test NAME="testErrorScenario2Compile"/>
      <test NAME="testWorkingScenario2Compile"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="97" file="output/36430/pre-fix/testresults.xml" passing="1130" size="1227"/>
<post-fix-testcases failing="104" file="output/36430/post-fix/testresults.xml" passing="1130" size="1234"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java" revision="1.18" state="changed">58a59,60
&gt; 	private boolean Xreweavable = false;
&gt; 	private boolean XreweavableCompressClasses = false;
216a219,222
&gt; 	
&gt; 	public void setInPath(List dirsOrJars) {
&gt; 		inPath = dirsOrJars;
&gt; 	}
464a471,486
&gt; 	public void setXreweavable(boolean b) {
&gt; 		Xreweavable = true;
&gt; 	}
&gt; 	
&gt; 	public boolean isXreweavable() {
&gt; 		return Xreweavable;
&gt; 	}
&gt; 	
&gt; 	public void setXreweavableCompressClasses(boolean b) {
&gt; 		XreweavableCompressClasses = true;
&gt; 	}
&gt; 	
&gt; 	public boolean getXreweavableCompressClasses() {
&gt; 		return XreweavableCompressClasses;
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.21" state="changed">446a447,451
&gt;             } else if (arg.startsWith("-Xreweavable")) {
&gt;             	buildConfig.setXreweavable(true);
&gt;             	if (arg.endsWith(":compress")) {
&gt;             		buildConfig.setXreweavableCompressClasses(true);
&gt;             	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java" revision="1.7" state="changed">31c31
&lt; 		super(null, null);
---
&gt; 		super(null,(ResolvedTypeX)cflowStackField.getDeclaringType());
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java" revision="1.23" state="changed">64a65
&gt; import org.aspectj.weaver.WeaverStateInfo;
99a101,105
&gt; 
&gt; 	// Static setting across BcelClassWeavers
&gt; 	private static boolean inReweavableMode = false;
&gt; 	private static boolean compressReweavableAttributes = false;
&gt;     
282c288,289
&lt;         if (clazz.isWoven()) {
---
&gt; 		
&gt;         if (clazz.isWoven() &amp;&amp; !clazz.isReweavable()) {
284c291
&lt; 				"class \'" + clazz.getType().getName() + "\' is already woven",
---
&gt; 				"class \'" + clazz.getType().getName() + "\' is already woven and has not been built with -Xreweavable",
287a295,298
&gt;        
&gt; 
&gt;         Set aspectsAffectingType = null;
&gt;         if (inReweavableMode) aspectsAffectingType = new HashSet();
303c314,318
&lt;         	isChanged |= munger.munge(this);
---
&gt;         	boolean typeMungerAffectedType = munger.munge(this);
&gt;         	if (typeMungerAffectedType) {
&gt;         		isChanged = true;
&gt;         		if (inReweavableMode) aspectsAffectingType.add(munger.getAspectType().getName());
&gt;         	}
330c345,350
&lt;             isChanged |= match(mg);
---
&gt; 			boolean shadowMungerMatched = match(mg);
&gt; 			if (shadowMungerMatched) {
&gt; 				// For matching mungers, add their declaring aspects to the list that affected this type
&gt; 				if (inReweavableMode) aspectsAffectingType.addAll(findAspectsForMungers(mg));
&gt;               isChanged = true;
&gt; 			}
354a375,383
&gt;         if (inReweavableMode) {
&gt;         	WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo();
&gt;         	wsi.addAspectsAffectingType(aspectsAffectingType);
&gt;         	wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
&gt;         	wsi.setReweavable(true,compressReweavableAttributes);
&gt;         } else {
&gt;         	clazz.getOrCreateWeaverStateInfo().setReweavable(false,false);
&gt;         }
&gt;         
357a387,404
&gt; 	private Set findAspectsForMungers(LazyMethodGen mg) {
&gt; 		Set aspectsAffectingType = new HashSet();
&gt; 		for (Iterator iter = mg.matchedShadows.iterator(); iter.hasNext();) {
&gt; 			BcelShadow aShadow = (BcelShadow) iter.next();	
&gt; 			// Mungers in effect on that shadow
&gt; 			for (Iterator iter2 = aShadow.getMungers().iterator();iter2.hasNext();) {
&gt; 				ShadowMunger aMunger = (ShadowMunger) iter2.next();
&gt; 				if (aMunger instanceof BcelAdvice) {
&gt; 					BcelAdvice bAdvice = (BcelAdvice)aMunger;
&gt; 					aspectsAffectingType.add(bAdvice.getConcreteAspect().getName());
&gt; 				} else {
&gt; 				// It is a 'Checker' - we don't need to remember aspects that only contributed Checkers...
&gt; 				}		
&gt; 			}
&gt; 		}
&gt; 		return aspectsAffectingType;
&gt; 	}
&gt; 
1097a1145,1150
&gt; 	
&gt; 	// Called by the BcelWeaver to let us know all BcelClassWeavers need to collect reweavable info
&gt; 	public static void setReweavableMode(boolean mode,boolean compress) {
&gt; 		inReweavableMode = mode;
&gt; 		compressReweavableAttributes = compress;
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java" revision="1.13" state="changed">87a88,94
&gt;     
&gt;     // repeat initialization
&gt;     public void setJavaClass(JavaClass newclass) {
&gt;     	this.javaClass = newclass;
&gt;     	resetState();
&gt;     }
&gt;     
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java" revision="1.19" state="changed">27a28
&gt; import java.util.Set;
472a474,483
&gt; 	public boolean isReweavable() {
&gt; 		if (myType.getWeaverState()==null) return false;
&gt; 		return myType.getWeaverState().isReweavable();
&gt; 	}
&gt; 	
&gt; 	public Set getAspectsAffectingType() {
&gt; 		if (myType.getWeaverState()==null) return null;
&gt; 		return myType.getWeaverState().getAspectsAffectingType();
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/messages.properties" revision="1.12" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java" revision="1.7" state="changed">17a18
&gt; import java.util.HashSet;
20a22
&gt; import java.util.Set;
21a24,25
&gt; import org.aspectj.weaver.bcel.BcelTypeMunger;
&gt; import org.aspectj.weaver.patterns.DeclareParents;
147c151,167
&lt; 	}	
---
&gt; 	}
&gt; 
&gt; 
&gt; 	public ResolvedTypeX findAspectDeclaringParents(DeclareParents p) {
&gt; 		Set result = new HashSet();
&gt; 		Set keys = this.members.keySet();
&gt; 		for (Iterator iter = keys.iterator(); iter.hasNext();) {
&gt; 			ResolvedTypeX element = (ResolvedTypeX) iter.next();
&gt; 			for (Iterator i = ((CrosscuttingMembers)members.get(element)).getDeclareParents().iterator(); i.hasNext(); ) {
&gt; 				DeclareParents dp = (DeclareParents)i.next();
&gt; 				return element;
&gt; 			}
&gt; 		}
&gt; 		return null;
&gt; 	}
&gt; 
&gt; 	
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.41" state="changed">228a229,231
&gt; 		
&gt; 		bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Advice.java" revision="1.11" state="changed">40c40
&lt;     public static Advice makeCflowEntry(World world, Pointcut entry, boolean isBelow, Member stackField, int nFreeVars, List innerCflowEntries) {
---
&gt;     public static Advice makeCflowEntry(World world, Pointcut entry, boolean isBelow, Member stackField, int nFreeVars, List innerCflowEntries, ResolvedTypeX inAspect){
45a46
&gt;     	ret.concreteAspect = inAspect;
69c70
&lt;     public static Advice makeSoftener(World world, Pointcut entry, TypePattern exceptionType) {
---
&gt;     public static Advice makeSoftener(World world, Pointcut entry, TypePattern exceptionType,ResolvedTypeX inAspect) {
74c75,76
&lt;     	//System.out.println("made ret: " + ret + " with " + exceptionType);
---
&gt;     	ret.concreteAspect = inAspect;
&gt;     	// System.out.println("made ret: " + ret + " with " + exceptionType);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembers.java" revision="1.10" state="changed">113c113
&lt; 			ShadowMunger m = Advice.makeSoftener(world, concretePointcut, d.getException());
---
&gt; 			ShadowMunger m = Advice.makeSoftener(world, concretePointcut, d.getException(),inAspect);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Shadow.java" revision="1.17" state="changed">41a42
&gt; 
52c53,57
&lt;     
---
&gt; 
&gt; 	public List /*ShadowMunger*/ getMungers() {
&gt; 		return mungers;
&gt; 	}
&gt; 	    
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java" revision="1.10" state="changed">164c164
&lt; 				Advice.makeCflowEntry(world, concreteEntry, isBelow, cflowField, freeVars.length, innerCflowEntries));
---
&gt; 				Advice.makeCflowEntry(world, concreteEntry, isBelow, cflowField, freeVars.length, innerCflowEntries,inAspect));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java" revision="1.23" state="changed">31a32
&gt; import java.util.Set;
37a39
&gt; import org.aspectj.bridge.AbortException;
48a51
&gt; import org.aspectj.weaver.WeaverStateInfo;
58c61,64
&lt; 
---
&gt;     
&gt;     private boolean inReweavableMode = false;
&gt;     private boolean compressReweavableAttributes = false;
&gt;     
356a363,368
&gt; 
&gt; 		if (inReweavableMode)
&gt; 			world.showMessage(IMessage.INFO, "weaver operating in reweavable mode.  Need to verify any required types exist.", null, null);
&gt;     	 	
&gt;     	
&gt;     	Set alreadyConfirmedOK = new HashSet();
362c374,403
&lt;             classType.resetState();
---
&gt; 
&gt; 			
&gt;             // If the class is marked reweavable, check any aspects around when it was built are in this world
&gt; 			WeaverStateInfo wsi = classType.getWeaverState();		
&gt; 			if (wsi!=null &amp;&amp; wsi.isReweavable()) { // Check all necessary types are around!
&gt; 				world.showMessage(IMessage.INFO,"processing reweavable type "+className+": "+classType.getSourceLocation().getSourceFile(),null,null);
&gt;         		Set aspectsPreviouslyInWorld = wsi.getAspectsAffectingType();
&gt; 				if (aspectsPreviouslyInWorld!=null) {
&gt; 					for (Iterator iter = aspectsPreviouslyInWorld.iterator(); iter.hasNext();) {
&gt; 						String requiredTypeName = (String) iter.next();
&gt; 						if (!alreadyConfirmedOK.contains(requiredTypeName)) {
&gt; 							ResolvedTypeX rtx = world.resolve(TypeX.forName(requiredTypeName),true);
&gt; 							boolean exists = rtx!=ResolvedTypeX.MISSING;
&gt; 							if (!exists) {
&gt; 								world.showMessage(IMessage.ERROR, "type " + requiredTypeName + 
&gt; 									" is needed by reweavable type " + className,
&gt; 									classType.getSourceLocation(), null);
&gt; 							} else {
&gt; 								if (!world.getMessageHandler().isIgnoring(IMessage.INFO))
&gt; 								  world.showMessage(IMessage.INFO,"successfully verified type "+requiredTypeName+
&gt;                                     " exists.  Originates from "+rtx.getSourceLocation().getSourceFile(),null,null);
&gt; 								alreadyConfirmedOK.add(requiredTypeName);
&gt; 							}
&gt; 						}		
&gt; 					}
&gt; 				}
&gt; 				classType.setJavaClass(Utility.makeJavaClass(classType.getJavaClass().getFileName(), wsi.getUnwovenClassFileData()));
&gt; 			} else {
&gt;             	classType.resetState();
&gt; 			}
434c475
&lt; 					onType.addInterTypeMunger(new BcelTypeMunger(newParentMunger, null));
---
&gt; 					onType.addInterTypeMunger(new BcelTypeMunger(newParentMunger, xcutSet.findAspectDeclaringParents(p)));
464a506
&gt; 
576a619,625
&gt; 	public void setReweavableMode(boolean mode,boolean compress) {
&gt; 		inReweavableMode = mode;
&gt; 		compressReweavableAttributes = compress;
&gt; 		WeaverStateInfo.setReweavableModeDefaults(mode,compress);
&gt; 		BcelClassWeaver.setReweavableMode(mode,compress);
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeaverStateInfo.java" revision="1.3" state="changed">19a20
&gt; import java.util.Collection;
20a22
&gt; import java.util.HashSet;
22a25,28
&gt; import java.util.Set;
&gt; import java.util.zip.ZipEntry;
&gt; import java.util.zip.ZipInputStream;
&gt; import java.util.zip.ZipOutputStream;
26a33,49
&gt; 
&gt; /**
&gt;  * WeaverStateInfo represents how a type was processed.  It is used by the weaver to determine how a type 
&gt;  * was previously treated and whether reweaving is allowed.
&gt;  * The format in the data stream is:
&gt;  * 
&gt;  * Byte:  Kind.  UNTOUCHED|WOVEN|EXTENDED - If extended it can have two extra bits set 'REWEAVABLE' and 'REWEAVABLE_COMPRESSION_BIT'
&gt;  * Short: typeMungerCount - how many type mungers have affected this type
&gt;  * &lt;TypeX &amp; ResolvedTypeMunger&gt;: The type mungers themselves
&gt;  * If we are reweavable then we also have:
&gt;  * Short: Number of aspects that touched this type in some way when it was previously woven
&gt;  * &lt;String&gt; The fully qualified name of each type
&gt;  * Int: Length of class file data (i.e. the unwovenclassfile)
&gt;  * Byte[]: The class file data, compressed if REWEAVABLE_COMPRESSION_BIT set.
&gt;  */
&gt; 
&gt; 
30a54,62
&gt; 	
&gt; 	
&gt; 	private boolean reweavable;
&gt; 	private boolean reweavableCompressedMode;     // If true, unwovenClassFile is compressed on write and uncompressed on read
&gt; 	private Set /*String*/ aspectsAffectingType;  // These must exist in the world for reweaving to be valid
&gt; 	private byte[] unwovenClassFile;			  // Original 'untouched' class file
&gt; 	private static boolean reweavableDefault = false;
&gt; 	private static boolean reweavableCompressedModeDefault = false;
&gt; 	
32c64
&lt; 		this(new ArrayList(), false);
---
&gt; 		this(new ArrayList(), false,reweavableDefault,reweavableCompressedModeDefault);
35c67
&lt; 	private WeaverStateInfo(List typeMungers, boolean oldStyle) {
---
&gt; 	private WeaverStateInfo(List typeMungers, boolean oldStyle,boolean reweavableMode,boolean reweavableCompressedMode) {
37c69,78
&lt; 		this.oldStyle = oldStyle;
---
&gt; 		this.oldStyle    = oldStyle;
&gt; 		this.reweavable  = reweavableMode;
&gt; 		this.reweavableCompressedMode = reweavableCompressedMode;
&gt; 		this.aspectsAffectingType= new HashSet();
&gt; 		this.unwovenClassFile = null;
&gt; 	}
&gt; 	
&gt; 	public static void setReweavableModeDefaults(boolean mode, boolean compress) {
&gt; 		reweavableDefault = mode;
&gt; 		reweavableCompressedModeDefault = compress;
41a83,86
&gt; 	// Use 'bits' for these capabilities - only valid in EXTENDED mode
&gt; 	private static final byte REWEAVABLE_BIT             = 1&lt;&lt;4;
&gt; 	private static final byte REWEAVABLE_COMPRESSION_BIT = 1&lt;&lt;5;
&gt; 	
44a90,95
&gt; 		boolean isReweavable = ((b&amp;REWEAVABLE_BIT)!=0);
&gt; 		if (isReweavable) b=(byte) (b-REWEAVABLE_BIT);
&gt; 
&gt; 		boolean isReweavableCompressed = ((b&amp;REWEAVABLE_COMPRESSION_BIT)!=0);
&gt; 		if (isReweavableCompressed) b=(byte) (b-REWEAVABLE_COMPRESSION_BIT);
&gt; 
49c100
&lt; 				return new WeaverStateInfo(Collections.EMPTY_LIST, true);
---
&gt; 				return new WeaverStateInfo(Collections.EMPTY_LIST, true,isReweavable,isReweavableCompressed);
59c110,112
&lt; 				return new WeaverStateInfo(l, false);
---
&gt; 			    WeaverStateInfo wsi = new WeaverStateInfo(l,false,isReweavable,isReweavableCompressed);
&gt; 			    readAnyReweavableData(wsi,s);
&gt; 				return wsi;
63a117,118
&gt; 	
&gt; 	
80c135,138
&lt; 		s.writeByte(EXTENDED);
---
&gt; 		byte weaverStateInfoKind = EXTENDED;
&gt; 		if (reweavable) weaverStateInfoKind |= REWEAVABLE_BIT;
&gt; 		if (reweavableCompressedMode) weaverStateInfoKind |= REWEAVABLE_COMPRESSION_BIT;
&gt; 		s.writeByte(weaverStateInfoKind);
87a146
&gt; 		writeAnyReweavableData(this,s);
119a179,275
&gt; 
&gt; 	public byte[] getUnwovenClassFileData() {
&gt; 		return unwovenClassFile;
&gt; 	}
&gt; 
&gt; 	public void setUnwovenClassFileData(byte[] data) {
&gt; 		unwovenClassFile = data;
&gt; 	}
&gt; 
&gt; 	public boolean isReweavable() {
&gt; 		return reweavable;
&gt; 	}
&gt; 	
&gt; 	public void setReweavable(boolean rw,boolean compressData) {
&gt; 		reweavable = rw;
&gt; 		reweavableCompressedMode = compressData;
&gt; 	}
&gt; 	
&gt; 	public void addAspectsAffectingType(Collection /*String*/ aspects) {
&gt; 		aspectsAffectingType.addAll(aspects);
&gt; 	}
&gt; 	public void addAspectAffectingType(String aspectType) {
&gt; 		aspectsAffectingType.add(aspectType);
&gt; 	}
&gt; 	public Set /*String*/ getAspectsAffectingType() {
&gt; 		return this.aspectsAffectingType;
&gt; 	}
&gt; 
&gt; 
&gt;     ////
&gt;     
&gt; 	private static void readAnyReweavableData(WeaverStateInfo wsi,DataInputStream s) throws IOException {
&gt; 
&gt; 		if (wsi.isReweavable()) {		
&gt; 			// Load list of aspects that need to exist in the world for reweaving to be 'legal'
&gt; 			int numberAspectsAffectingType = s.readShort();
&gt; 			for (int i=0; i &lt; numberAspectsAffectingType; i++) {wsi.addAspectAffectingType(s.readUTF());} 
&gt; 			
&gt; 			int unwovenClassFileSize = s.readInt();
&gt; 			byte[] classData = null;					
&gt; 			// The data might or might not be compressed:
&gt; 			if (!wsi.reweavableCompressedMode) {
&gt; 				// Read it straight in
&gt; 				classData = new byte[unwovenClassFileSize];
&gt; 				int bytesread = s.read(classData);
&gt; 				if (bytesread!=unwovenClassFileSize) 
&gt; 				  throw new IOException("ERROR whilst reading reweavable data, expected "+
&gt; 				                        unwovenClassFileSize+" bytes, only found "+bytesread);
&gt; 			} else {
&gt; 				// Decompress it
&gt; 				classData = new byte[unwovenClassFileSize];
&gt; 						
&gt; 				ZipInputStream zis = new ZipInputStream(s);
&gt; 				ZipEntry zen = zis.getNextEntry();
&gt; 				int current = 0; 
&gt; 				int bytesToGo=unwovenClassFileSize;
&gt; 				while (bytesToGo&gt;0) {
&gt; 					int amount = zis.read(classData,current,bytesToGo);
&gt; 					current+=amount;
&gt; 					bytesToGo-=amount;
&gt; 				}
&gt; 				zis.closeEntry();
&gt; 				if (bytesToGo!=0) 
&gt; 				  throw new IOException("ERROR whilst reading compressed reweavable data, expected "+
&gt; 				                        unwovenClassFileSize+" bytes, only found "+current);
&gt; 			}
&gt; 			wsi.setUnwovenClassFileData(classData);
&gt; 		}
&gt; 	}
&gt; 
&gt; 
&gt; 
&gt; 	private static void writeAnyReweavableData(WeaverStateInfo wsi,DataOutputStream s) throws IOException {
&gt; 		if (wsi.isReweavable()) {
&gt; 			// Write out list of aspects that must exist next time we try and weave this class
&gt; 			s.writeShort(wsi.aspectsAffectingType.size());
&gt; 			if (wsi.aspectsAffectingType.size()&gt;0) {
&gt; 				for (Iterator iter = wsi.aspectsAffectingType.iterator(); iter.hasNext();) {
&gt; 					String type = (String) iter.next();
&gt; 					s.writeUTF(type);	
&gt; 				}
&gt; 			}
&gt; 			byte[] data = wsi.unwovenClassFile;
&gt; 			s.writeInt(data.length);
&gt; 			// Do we need to compress the data?
&gt; 			if (!wsi.reweavableCompressedMode) {
&gt; 				s.write(wsi.unwovenClassFile);
&gt; 			} else {
&gt; 				ZipOutputStream zos = new ZipOutputStream(s);
&gt; 				ZipEntry ze = new ZipEntry("data");
&gt; 				zos.putNextEntry(ze);
&gt; 				zos.write(wsi.unwovenClassFile,0,wsi.unwovenClassFile.length);
&gt; 				zos.closeEntry();
&gt; 			}
&gt; 		}
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/docs/devGuideDB/ajc.xml" revision="1.10" state="changed">382a383,390
&gt;       
&gt;       &lt;varlistentry&gt;
&gt;         &lt;term&gt;-Xreweavable[:compress]&lt;/term&gt;
&gt;         &lt;listitem&gt;&lt;para&gt;(Experimental) runs weaver in reweavable mode which causes
&gt;         it to create woven classes that can be rewoven, subject to the restriction that
&gt;         on attempting a reweave all the types that advised the woven type must be accessible.
&gt;         &lt;/para&gt;&lt;/listitem&gt;
&gt;       &lt;/varlistentry&gt;
</file>
<file name="org.aspectj/modules/taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java" revision="1.26" state="changed">456a457,460
&gt;     
&gt;     public void setXReweavable(boolean reweavable) {
&gt;     	cmd.addFlag("-Xreweavable",reweavable);
&gt;     }
1701a1706,1707
&gt; 			} else if ("-Xreweavable".equals(flag)) {
&gt; 				setXReweavable(true);
</file>
<file name="org.aspectj/modules/testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java" revision="1.21" state="changed">1647a1648
&gt;                         factory.create("Xreweavable"),
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AjdeTests.java" revision="1.13" state="changed">33a34
&gt; 		suite.addTestSuite(ReweavableTestCase.class);
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/ReweavableTestCase.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     Initial version
 * ******************************************************************/

package org.aspectj.ajde;

import java.io.File;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.aspectj.ajde.internal.CompilerAdapter;
import org.aspectj.ajde.ui.UserPreferencesAdapter;
import org.aspectj.ajde.ui.internal.AjcBuildOptions;
import org.aspectj.ajdt.internal.core.builder.AjBuildConfig;
import org.aspectj.bridge.MessageHandler;
import org.aspectj.util.FileUtil;

public class ReweavableTestCase extends AjdeTestCase {

	private MessageHandler messageHandler;
	private NullIdeProperties projectProperties;
	private AjcBuildOptions buildOptions;
	private UserPreferencesAdapter preferencesAdapter = null;
	private CompilerAdapter compilerAdapter;
	private static final String configFile = 
		AjdeTests.TESTDATA_PATH + "/examples/figures-coverage/all.lst";
	public static final String PROJECT_DIR = "ReweavableTest";

	private AjBuildConfig buildConfig = null;
	public static final String binDir = "bin";

	public static final String indir1Name = "indir1";
	public static final String indir2Name = "indir2";
	public static final String injarName  = "injar.jar";
	public static final String outjarName = "/bin/output.jar";


	public static int nonreweavesize_CalculatePI;
	public static int nonreweavesize_Logger;
	public static int reweavablesize_CalculatePI;
	public static int reweavablesize_Logger;
			
	/**
	 * Constructor for JarResourceCopyTestCase.
	 * @param arg0
	 */
	public ReweavableTestCase(String arg0) {
		super(arg0);
	}



	/*
	 * Ensure the output directpry in clean
	 */
	protected void setUp() throws Exception {
		super.setUp(PROJECT_DIR);
		FileUtil.deleteContents(openFile(binDir));
	}


	/**
	 * Aim: Check we haven't damaged 'normal compilation' when not supplying -Xreweavable.  Also determines
	 *      baseline sizes for the compiled class files for later comparison.
	 * 
	 * Inputs to the compiler:
	 *   NonReweavable1.lst
	 *   -&gt; CalculatePI.java
	 *   -&gt; Logger.aj
	 *   -&gt; -verbose
	 *   -&gt; -noExit
	 * 
	 * Expected result = Compile successful, the types will not be reweavable and the weaver
	 *                   should not report it is running in reweavable mode.
	 */
	public void testNonReweavableCompile() {
		System.out.println("testNonReweavableCompile: Building with NonReweavable1.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(true);
		compilerAdapter.compile((String) openFile("NonReweavable1.lst").getAbsolutePath(),new BPM(),false);
	
		assertFalse("Did not expect to find a message about the weaver operating in reweavable mode",
		  checkFor("weaver operating in reweavable mode"));

		File fCalc = openFile("bin/CalculatePI.class");
		File fLog = openFile("bin/Logger.class");
		assertTrue("bin/CalculatePI.class should exist?!?",fCalc.exists());
		assertTrue("bin/Logger.class should exist?!?",fLog.exists());
		System.out.println("CalculatePI.class is of size: "+fCalc.length());
		System.out.println("Logger.class is of size: "+fLog.length());
		System.out.println("\n\n\n");
		nonreweavesize_CalculatePI = (int)fCalc.length();
		nonreweavesize_Logger = (int)fLog.length();
	}


	/**
	 * Aim: Basic call to -Xreweavable.  Weaver should report it is in reweavable mode and the
	 *      classes produced should be much larger than normal classes (those produced in the first
	 *      test).
	 * 
	 * Inputs to the compiler:
	 *   Reweavable1.lst
	 *   -&gt; CalculatePI.java
	 *   -&gt; Logger.aj
	 *   -&gt; -Xreweavable
	 *   -&gt; -verbose
	 *   -&gt; -noExit
	 * 
	 * Expected result = Compile successful, the types will be reweavable and the weaver
	 *                   should report it is running in reweavable mode.  The files produced
	 *  				 should be larger than those created during the last test.
	 */
	public void testReweavableCompile() {
		System.out.println("testReweavableCompile: Building with Reweavable1.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(true);
		compilerAdapter.compile((String) openFile("Reweavable1.lst").getAbsolutePath(),new BPM(),false);
	
		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
		  checkFor("weaver operating in reweavable mode"));
		  
		File fCalc = openFile("bin/CalculatePI.class");
		File fLog = openFile("bin/Logger.class");
		assertTrue("bin/CalculatePI.class should exist?!?",fCalc.exists());
		assertTrue("bin/Logger.class should exist?!?",fLog.exists());
		System.out.println("CalculatePI.class is of size: "+fCalc.length());
		System.out.println("Logger.class is of size: "+fLog.length());
		assertTrue("Reweavable version should be larger than non-reweavable version of CalculatePI",
		  fCalc.length()&gt;nonreweavesize_CalculatePI);
		assertTrue("Reweavable version should be larger than non-reweavable version of Logger",
		  fLog.length()&gt;nonreweavesize_Logger);

		reweavablesize_CalculatePI = (int)fCalc.length();
		reweavablesize_Logger = (int)fLog.length();
		
		System.out.println("\n\n\n");
	}
	
	
	/**
	 * Aim: Use the optional ':compress' modifier on -Xreweavable.  This causes some of the meta-data
	 *      for use in reweaving to be compressed.  It should succeed and produce class files smaller
	 *      than straight -Xreweavable but larger than without specifying -Xreweavable.
	 * 
	 * Inputs to the compiler:
	 *   ReweavableCompress1.lst
	 *   -&gt; CalculatePI.java
	 *   -&gt; Logger.aj
	 *   -&gt; -Xreweavable:compress
	 *   -&gt; -verbose
	 *   -&gt; -noExit
	 * 
	 * Expected result = Compile successful, the types will be reweavable and the weaver
	 *                   should report it is running in reweavable mode.  The files created should
	 * 					 have a size between the non-reweavable versions and the reweavable (without
	 * 					 compression) versions.
	 */
	public void testReweavableCompressCompile() {
		System.out.println("testReweavableCompressCompile: Building with ReweavableCompress1.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(true);
		compilerAdapter.compile((String) openFile("ReweavableCompress1.lst").getAbsolutePath(),new BPM(),false);
	
		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
		  checkFor("weaver operating in reweavable mode"));
		  
		File fCalc = openFile("bin/CalculatePI.class");
		File fLog = openFile("bin/Logger.class");
		assertTrue("bin/CalculatePI.class should exist?!?",fCalc.exists());
		assertTrue("bin/Logger.class should exist?!?",fLog.exists());
		System.out.println("CalculatePI.class is of size: "+fCalc.length());
		System.out.println("Logger.class is of size: "+fLog.length());
		assertTrue("Reweavable version should be larger than non-reweavable version of CalculatePI",
		  fCalc.length()&gt;nonreweavesize_CalculatePI);
		assertTrue("Reweavable version should be larger than non-reweavable version of Logger",
		  fLog.length()&gt;nonreweavesize_Logger);
		
		assertTrue("Reweavable (with compression) version should be smaller than reweavable (without compression) version of CalculatePI",
		  fCalc.length()&lt;reweavablesize_CalculatePI);
		assertTrue("Reweavable (with compression) version should be smaller than reweavable (without compression) version of Logger",
		  fLog.length()&lt;reweavablesize_Logger);  
		 
		System.out.println("\n\n\n");
	}
	
	
	/**
	 * Aim: The tests above have determined that reweaving appears to be behaving in terms of the .class
	 *      files it is creating.  Now lets actually attempt a reweave.  For this, we build two files
	 *      as reweavable and then build a single file whilst specifying an inpath that contains the
	 *      .class files from the first compile.  This should succeed.
	 * 
	 * Inputs to the first compile:
	 *   Reweavable1.lst
	 *   -&gt; CalculatePI.java
	 *   -&gt; Logger.aj
	 *   -&gt; -Xreweavable
	 *   -&gt; -verbose
	 *   -&gt; -noExit
	 * 
	 * Input to the second compile:
	 *   Reweavable2.lst
	 *   -&gt; SecondAspect.aj
	 *   -&gt; -Xreweavable
	 *   -&gt; -verbose
	 *   -&gt; -noExit
	 *   -inpath bin\.
	 * 
	 * Expected result = Both compiles will succeed.
	 */
	public void testReweavableSimpleCompile() {
		System.out.println("testReweavableSimpleCompile: Building with Reweavable1.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(true);
		compilerAdapter.compile((String) openFile("Reweavable1.lst").getAbsolutePath(),new BPM(),false);
	
		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
		  checkFor("weaver operating in reweavable mode"));
		  
		  
		System.out.println("\ntestReweavableSimpleCompile: Building with Reweavable2.lst");
		Set paths = new HashSet();
		paths.add(openFile(binDir));
		ideManager.getProjectProperties().setInpath(paths);
		compilerAdapter.compile((String) openFile("Reweavable2.lst").getAbsolutePath(),new BPM(),false);


		String expMessage ="successfully verified type Logger exists";
		assertTrue("Expected message '"+expMessage+"' but did not find it",
		  checkFor(expMessage));
		  
		File fCalc = openFile("bin/CalculatePI.class");
		File fLog = openFile("bin/Logger.class");
		File fSec = openFile("bin/SecondAspect.class");
		assertTrue("bin/CalculatePI.class should exist?!?",fCalc.exists());
		assertTrue("bin/Logger.class should exist?!?",fLog.exists());
		assertTrue("bin/SecondAspect.class should exist?!?",fSec.exists());
		 
		System.out.println("\n\n\n");
	}
	
	
	/**
	 * Aim: Based on the test above, if we delete Logger.class between the first and second compiles
	 *      the second compile should fail because there is not enough information to reweave CalculatePI
	 * 
	 * Inputs to the first compile:
	 *   Reweavable1.lst
	 *   -&gt; CalculatePI.java
	 *   -&gt; Logger.aj
	 *   -&gt; -Xreweavable
	 *   -&gt; -verbose
	 *   -&gt; -noExit
	 * 
	 * Input to the second compile:
	 *   Reweavable2.lst
	 *   -&gt; SecondAspect.aj
	 *   -&gt; -Xreweavable
	 *   -&gt; -verbose
	 *   -&gt; -noExit
	 *   -inpath bin\.
	 * 
	 * Expected result = Second compile will fail - reporting that Logger is missing (it 'touched' in the first compile CalculatePI)
	 */
	public void testForReweavableSimpleErrorCompile() {
		System.out.println("testForReweavableSimpleErrorCompile: Building with Reweavable2.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(true);
		compilerAdapter.compile((String) openFile("Reweavable1.lst").getAbsolutePath(),new BPM(),false);
	
		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
		  checkFor("weaver operating in reweavable mode"));
		  
		  
		assertTrue("Could not delete bin/Logger.class??",openFile("bin/Logger.class").delete());


		System.out.println("\ntestForReweavableSimpleErrorCompile: Building with Reweavable2.lst");
		Set paths = new HashSet();
		paths.add(openFile(binDir));
		ideManager.getProjectProperties().setInpath(paths);
		compilerAdapter.compile((String) openFile("Reweavable2.lst").getAbsolutePath(),new BPM(),false);


		String expMessage ="type Logger is needed by reweavable type CalculatePI";
		assertTrue("Expected message '"+expMessage+"' but did not find it",
		  checkFor(expMessage));
		  
		File fCalc = openFile("bin/CalculatePI.class");
		File fLog = openFile("bin/Logger.class");
		File fSec = openFile("bin/SecondAspect.class");
		assertTrue("bin/CalculatePI.class should exist!",fCalc.exists());
		assertTrue("bin/Logger.class should not exist!",!fLog.exists());
		assertTrue("bin/SecondAspect.class should not exist!",fSec.exists());
		 
		System.out.println("\n\n\n");
	}
	
	
	/**
	 * Aim: Based on the test above, if we delete Logger.class between the first and second compiles
	 *      the second compile should fail because there is not enough information to reweave CalculatePI
	 * 
	 * Inputs to the first compile:
	 *   TJP1.lst
	 *   -&gt; tjp/Demo.java
	 *   -&gt; tjp/GetInfo.java
	 *   -&gt; -Xreweavable
	 *   -&gt; -verbose
	 *   -&gt; -noExit
	 * 
	 * Now, delete bin\tjp\GetInfo.class and do a compile with:
	 *   TJP2.lst
	 *   -&gt; -Xreweavable
	 *   -&gt; -verbose
	 *   -&gt; -noExit
	 *   -inpath bin\.
	 * 
	 * Expected result = Second compile will fail - reporting that tjp.GetInfo is missing (it 'touched' in the first compile tjp.Demo)
	 */
	public void testErrorScenario2Compile() {
		System.out.println("testErrorScenario2: Building with TJP1.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(true);
		compilerAdapter.compile((String) openFile("TJP1.lst").getAbsolutePath(),new BPM(),false);
	
		assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
		  checkFor("weaver operating in reweavable mode"));
		  
		  
		assertTrue("Could not delete bin/tjp/GetInfo.class??",openFile("bin/tjp/GetInfo.class").delete());


		System.out.println("\ntestErrorScenario2: Building with TJP2.lst");
		Set paths = new HashSet();
		paths.add(openFile(binDir));
		ideManager.getProjectProperties().setInpath(paths);
		compilerAdapter.compile((String) openFile("TJP2.lst").getAbsolutePath(),new BPM(),false);


		String expMessage ="type tjp.GetInfo is needed by reweavable type tjp.Demo";
		assertTrue("Expected message '"+expMessage+"' but did not find it",
		  checkFor(expMessage));
		  
		File fDemo = openFile("bin/tjp/Demo.class");
		File fGetInfo = openFile("bin/tjp/GetInfo.class");
		assertTrue("bin/tjp/Demo.class should exist!",fDemo.exists());
		assertTrue("bin/tjp/GetInfo.class should not exist!",!fGetInfo.exists());
		 
		System.out.println("\n\n\n");
	}
	
	public void testWorkingScenario2Compile() {
			System.out.println("testWorkingScenario2: Building with TJP1.lst");
			compilerAdapter = new CompilerAdapter();
			compilerAdapter.showInfoMessages(true);
			compilerAdapter.compile((String) openFile("TJP1.lst").getAbsolutePath(),new BPM(),false);
	
			assertTrue("Expected a message about operating in reweavable mode, but didn't get one",
			  checkFor("weaver operating in reweavable mode"));
		  
		
			System.out.println("\ntestWorkingScenario2: Building with TJP2.lst");
			Set paths = new HashSet();
			paths.add(openFile(binDir));
			ideManager.getProjectProperties().setInpath(paths);
			compilerAdapter.compile((String) openFile("TJP2.lst").getAbsolutePath(),new BPM(),false);


			String expMessage ="successfully verified type tjp.GetInfo exists";
			assertTrue("Expected message '"+expMessage+"' but did not find it",
			  checkFor(expMessage));
		  
			File fGetInfo = openFile("bin/tjp/GetInfo.class");
			File fDemo = openFile("bin/tjp/Demo.class");
			assertTrue("bin/tjp/GetInfo.class should exist!",fGetInfo.exists());
			assertTrue("bin/tjp/Demo.class should not exist!",fDemo.exists());
			
			System.out.println("\n\n\n");
		}
	

	private class BPM implements BuildProgressMonitor {
		public void start(String configFile) {}

				public void setProgressText(String text) {}

				public void setProgressBarVal(int newVal) {	}

				public void incrementProgressBarVal() {}

				public void setProgressBarMax(int maxVal) {	}

				public int getProgressBarMax() {
					return 0;
				}

				public void finish() {}
		
	}
	


	
	private boolean checkFor(String what) {
		List ll = ideManager.getCompilationSourceLineTasks();
		for (Iterator iter = ll.iterator(); iter.hasNext();) {
			Object element = (Object) iter.next();
			if (element.toString().indexOf(what)!=-1) return true;
		}
		return false;
	}
	

}
</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/NonReweavable1.lst" revision="1.1" state="new">CalculatePI.java&#13;
Logger.aj&#13;
-verbose&#13;
-noExit</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/TJP1.lst" revision="1.1" state="new">tjp/Demo.java&#13;
tjp/GetInfo.java&#13;
-Xreweavable&#13;
-verbose&#13;
-noExit</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/tjp/Demo.java" revision="1.1" state="new">
/*

Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.

Use and copying of this software and preparation of derivative works based
upon this software are permitted.  Any distribution of this software or
derivative works must comply with all applicable United States export control
laws.

This software is made available AS IS, and Xerox Corporation makes no warranty
about the software, its performance or its conformity to any specification.

*/
package tjp;

public class Demo {
	static Demo d;

	public static void main(String[] args){
		new Demo().go();
	}

	void go(){
		d = new Demo();
		d.foo(1,d);
		System.out.println(d.bar(new Integer(3)));
	}

	void foo(int i, Object o){
		System.out.println("Demo.foo(" + i + ", " + o + ")\n");
	}

	String bar (Integer j){
		System.out.println("Demo.bar(" + j + ")\n");
		return "Demo.bar(" + j  + ")";
	}
}
</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/Reweavable2.lst" revision="1.1" state="new">SecondAspect.aj&#13;
-Xreweavable&#13;
-verbose&#13;
-noExit</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/ThirdAspect.aj" revision="1.1" state="new">&#13;
public aspect ThirdAspect {&#13;
&#13;
	int CalculatePI.x;&#13;
}</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/tjp/GetInfo.java" revision="1.1" state="new">
/*
Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.

Use and copying of this software and preparation of derivative works based
upon this software are permitted.  Any distribution of this software or
derivative works must comply with all applicable United States export control
laws.

This software is made available AS IS, and Xerox Corporation makes no warranty
about the software, its performance or its conformity to any specification.
*/

package tjp;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.reflect.CodeSignature;

aspect GetInfo {

   static final void println(String s){ System.out.println(s); }

   pointcut goCut(): cflow(this(Demo) &amp;&amp; execution(void go()));

   pointcut demoExecs(): within(Demo) &amp;&amp; execution(* *(..));

   Object around(): demoExecs() &amp;&amp; !execution(* go()) &amp;&amp; goCut() {
	  println("Intercepted message: " +
		  thisJoinPointStaticPart.getSignature().getName());
	  println("in class: " +
		  thisJoinPointStaticPart.getSignature().getDeclaringType().getName());
	  printParameters(thisJoinPoint);
	  println("Running original method: \n" );
	  Object result = proceed();
	  println("  result: " + result );
	  return result;
   }

   static private void printParameters(JoinPoint jp) {
	  println("Arguments: " );
	  Object[] args = jp.getArgs();
	  String[] names = ((CodeSignature)jp.getSignature()).getParameterNames();
	  Class[] types = ((CodeSignature)jp.getSignature()).getParameterTypes();
	  for (int i = 0; i &lt; args.length; i++) {
		 println("  "  + i + ". " + names[i] +
			 " : " +            types[i].getName() +
			 " = " +            args[i]);
	  }
   }
}
</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/Reweavable1.lst" revision="1.1" state="new">CalculatePI.java&#13;
Logger.aj&#13;
-Xreweavable&#13;
-verbose&#13;
-noExit</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/ReweavableCompress1.lst" revision="1.1" state="new">CalculatePI.java&#13;
Logger.aj&#13;
-Xreweavable:compress&#13;
-verbose&#13;
-noExit</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/Logger.aj" revision="1.1" state="new">&#13;
&#13;
public aspect Logger {&#13;
  &#13;
  after(): call(* approximate(..)) {&#13;
  	if (CalculatePI.iteration%10000==0) &#13;
  	  System.out.println("Approximation is now:"+&#13;
  	    (CalculatePI.inCircle/CalculatePI.inSquare)*4.0f);&#13;
  }&#13;
  &#13;
}</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/Second.lst" revision="1.1" state="new">Logger.aj&#13;
-Xreweavable&#13;
-verbose</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/CalculatePI.java" revision="1.1" state="new">import java.util.Random;

public class CalculatePI {
	
	static Random r = new Random();
	static double piApproximation = 1.0f;
	static int repetitions = 500000;
	static int iteration = 0;
	static double inSquare = 0;
	static double inCircle = 0;
		
	public static void main(String[] args) {
	  for (iteration = 0;iteration&lt;repetitions;iteration++) approximate();
	  piApproximation = (inCircle/inSquare)*4.0f;
	  System.out.println("After "+repetitions+" iterations, pi is estimated to be "+piApproximation);
	}
	
	public static void approximate() {
		double x = r.nextDouble();
		double y = r.nextDouble();
		inSquare++;
		if (x*x + y*y &lt; 1) {inCircle++;}
	}

	
}</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/TJP2.lst" revision="1.1" state="new">-Xreweavable&#13;
-verbose&#13;
-noExit</file>
<file name="org.aspectj/modules/ajde/testdata/ReweavableTest/SecondAspect.aj" revision="1.1" state="new">&#13;
public aspect SecondAspect {&#13;
&#13;
  declare parents: Logger implements java.io.Serializable;&#13;
}</file>
</fixedFiles>
</bug>
<bug id="36803" transactionid="72571">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P2"/>
<property name="severity" value="major"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-new K-this M T V</fullfingerprint>
<tag>exception</tag>
<bugreport>[iajc] expected state: resolved got: concrete
     [iajc] expected state: resolved got: concrete
     [iajc] org.aspectj.weaver.BCException: expected state: resolved got: 
concrete
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.assertState
(Pointcut.java:236)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize
(Pointcut.java:126)
     [iajc]     at org.aspectj.weaver.patterns.CflowPointcut.concretize1
(CflowPointcut.java:143)
     [iajc]     at org.aspectj.weaver.patterns.NotPointcut.concretize1
(NotPointcut.java:94)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.concretize1
(AndPointcut.java:88)
     [iajc]     at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePointcut.java:270)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.concretize1
(AndPointcut.java:88)
     [iajc]     at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePointcut.java:270)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize
(Pointcut.java:127)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize
(Pointcut.java:120)
     [iajc]     at org.aspectj.weaver.Advice.concretize(Advice.java:207)
     [iajc]     at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger
(CrosscuttingMembers.java:78)
     [iajc]     at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers
(CrosscuttingMembers.java:72)
     [iajc]     at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedTypeX.java:328)
     [iajc]     at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(CrosscuttingMembersSet.java:54)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave
(BcelWeaver.java:164)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave
(BcelWeaver.java:214)
     [iajc]     at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFile
s(AjBuildManager.java:394)
     [iajc]     at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:149)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand
(AjdtCommand.java:55)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:216)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute
(AjcTask.java:646)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute
(UnknownElement.java:193)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:309)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:336)
     [iajc]     at org.apache.tools.ant.Project.executeTarget
(Project.java:1339)
     [iajc]     at org.apache.tools.ant.Project.executeTargets
(Project.java:1255)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:609)
     [iajc]     at org.apache.tools.ant.Main.start(Main.java:196)
     [iajc]     at org.apache.tools.ant.Main.main(Main.java:235)</bugreport>
<testsforfix ID="36803" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="cflow concretization causing assertion failure"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="29" file="output/36803/pre-fix/testresults.xml" passing="708" size="737"/>
<post-fix-testcases failing="28" file="output/36803/post-fix/testresults.xml" passing="710" size="738"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/Pointcut.java" revision="1.6" state="changed">140c140,142
&lt; 	 * ??? does this return a new pointcut
---
&gt; 	 * This must always return a new Pointcut object (even if the concretized
&gt; 	 * Pointcut is identical to the resolved one).  That behavior is
&gt; 	 * assumed in many places.
215c217
&lt; 			return this;
---
&gt; 			return makeMatchesNothing(state);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java" revision="1.6" state="changed">106d105
&lt; 		//return this; //??? no pointers out of here so we're okay
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java" revision="1.5" state="changed">87c87
&lt; 		return this; //??? no pointers out of here so we're okay
---
&gt; 		return new WithincodePointcut(signature);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java" revision="1.8" state="changed">96c96
&lt; 		return this; //??? no pointers out of here so we're okay
---
&gt; 		return new WithinPointcut(typePattern);
</file>
<file name="org.aspectj/modules/tests/bugs/CflowConcrete.java" revision="1.1" state="new">// for Bug#:  31423  
import org.aspectj.testing.Tester;


public class CflowConcrete {
    public static void main(String[] args) {
    }
}

aspect TestAjc {
   pointcut notMySelf(): !within(TestAjc) &amp;&amp; !cflow(within(TestAjc));

	pointcut      eachCall(): notMySelf() &amp;&amp;      call(* *.*(..));
	pointcut eachExecution(): notMySelf() &amp;&amp; execution(* *.*(..)) ;

	before(): eachCall() { System.out.println(thisJoinPoint); }

	before(): eachExecution() { System.out.println(thisJoinPoint); }
} 
</file>
<file name="org.aspectj/modules/tests/jimTests.xml" revision="1.31" state="changed">4c4
&lt;     
---
&gt; 
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.57" state="changed">5874a5875,5880
&gt;     &lt;ajc-test dir="bugs" pr="36803"
&gt;       title="cflow concretization causing assertion failure"&gt;
&gt;         &lt;compile files="CflowConcrete.java"/&gt;
&gt;         &lt;run class="CflowConcrete"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
</fixedFiles>
</bug>
<bug id="37576" transactionid="75963">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="28"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="27"/>
<property name="lines-churned" value="55"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-null K-return M T V Z-if</fullfingerprint>
<bugreport>The AjcTask (iajc) task takes nested bootclasspath entities as classpath and 
vice-versa.</bugreport>
<testsforfix ID="37576" type="new">
    <file LOCATION="org.aspectj/modules/taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java">
      <test NAME="testClasspath"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="109" file="output/37576/pre-fix/testresults.xml" passing="894" size="1003"/>
<post-fix-testcases failing="111" file="output/37576/post-fix/testresults.xml" passing="892" size="1003"/>
<fixedFiles>
<file name="org.aspectj/modules/taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java" revision="1.12" state="changed">656,657c656,657
&lt;         if (bootclasspath == null) {
&lt;             bootclasspath = new Path(project);
---
&gt;         if (classpath == null) {
&gt;             classpath = new Path(project);
659c659
&lt;         return bootclasspath.createPath();
---
&gt;         return classpath.createPath();
671,672c671,672
&lt;         if (classpath == null) {
&lt;             classpath = new Path(project);
---
&gt;         if (bootclasspath == null) {
&gt;             bootclasspath = new Path(project);
674c674
&lt;         return classpath.createPath();
---
&gt;         return bootclasspath.createPath();
752,778c752,754
&lt;         	if (0 &lt; ignored.size()) {
&lt; 				for (Iterator iter = ignored.iterator(); iter.hasNext();) {
&lt; 					log("ignored: " + iter.next(), Project.MSG_INFO);					
&lt; 				}
&lt;         	}
&lt;             // when copying resources, use temp jar for class output
&lt;             // then copy temp jar contents and resources to output jar
&lt;             if (null != outjar) {
&lt;                 if (copyInjars || (null != sourceRootCopyFilter)) {
&lt;                     String path = outjar.getAbsolutePath();
&lt;                     int len = FileUtil.zipSuffixLength(path);
&lt;                     if (len &lt; 1) {
&lt;                         log("not copying injars - weird outjar: " + path);
&lt;                     } else {
&lt;                         path = path.substring(0, path.length()-len) + ".tmp.jar";
&lt;                         tmpOutjar = new File(path);
&lt;                     }
&lt;                 }
&lt;                 if (null == tmpOutjar) {                
&lt;                     cmd.addFlagged("-outjar", outjar.getAbsolutePath());        
&lt;                 } else {
&lt;                     cmd.addFlagged("-outjar", tmpOutjar.getAbsolutePath());        
&lt;                 }
&lt;             }
&lt;             
&lt;             addListArgs();
&lt; 	        if (verbose || listFileArgs) { // XXX if listFileArgs, only do that
---
&gt;             boolean copyArgs = false;
&gt;             setupCommand(copyArgs);
&gt;             if (verbose || listFileArgs) { // XXX if listFileArgs, only do that
780,781c756,757
&lt; 	        	log("ajc " + Arrays.asList(args), Project.MSG_VERBOSE);
&lt; 	        }
---
&gt;                 log("ajc " + Arrays.asList(args), Project.MSG_VERBOSE);
&gt;             }
799a776,809
&gt;     }
&gt; 
&gt;     String[] setupCommand(boolean copyArgs) {
&gt;         if (0 &lt; ignored.size()) {
&gt;             for (Iterator iter = ignored.iterator(); iter.hasNext();) {
&gt;                 log("ignored: " + iter.next(), Project.MSG_INFO);                   
&gt;             }
&gt;         }
&gt;         // when copying resources, use temp jar for class output
&gt;         // then copy temp jar contents and resources to output jar
&gt;         if (null != outjar) {
&gt;             if (copyInjars || (null != sourceRootCopyFilter)) {
&gt;                 String path = outjar.getAbsolutePath();
&gt;                 int len = FileUtil.zipSuffixLength(path);
&gt;                 if (len &lt; 1) {
&gt;                     log("not copying injars - weird outjar: " + path);
&gt;                 } else {
&gt;                     path = path.substring(0, path.length()-len) + ".tmp.jar";
&gt;                     tmpOutjar = new File(path);
&gt;                 }
&gt;             }
&gt;             if (null == tmpOutjar) {                
&gt;                 cmd.addFlagged("-outjar", outjar.getAbsolutePath());        
&gt;             } else {
&gt;                 cmd.addFlagged("-outjar", tmpOutjar.getAbsolutePath());        
&gt;             }
&gt;         }
&gt;         
&gt;         addListArgs();
&gt;         String[] result = null;
&gt;         if (copyArgs) {
&gt;             result = cmd.extractArguments();
&gt;         }
&gt;         return result;
</file>
<file name="org.aspectj/modules/taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java" revision="1.8" state="changed">136a137,154
&gt;     public void testClasspath() {
&gt;         AjcTask task = getTask(NOFILE);
&gt;         String[] cmd = task.setupCommand(true);
&gt;         String classpath = null;
&gt;         String bootclasspath = null;
&gt;         for (int i = 0; i &lt; cmd.length; i++) {
&gt;             if ("-classpath".equals(cmd[i])) {
&gt;                 classpath = cmd[i+1];
&gt;             } else if ("-bootclasspath".equals(cmd[i])) {
&gt;                 bootclasspath = cmd[i+1];
&gt;             }        
&gt;         }
&gt;         assertTrue("not expecting bootclasspath", 
&gt;             null == bootclasspath);
&gt;         assertTrue("expecting aspectj in classpath", 
&gt;             (-1 != classpath.indexOf("aspectjrt.jar")));
&gt;     }
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="37739" transactionid="72587">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="minor"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-return M Z-if</fullfingerprint>
<bugreport>The following code produces an Xlint:unresolvableMember warning:

class A {
    A(Class type) {}

    A() {
        this(String.class);
    }
}

class B {

    public void test() {
    }

    public void test2() {
        test();
    }
}

aspect C {
    void around() :
        (call (void B.test()) &amp;&amp;
         withincode (void B.test2())) {
        proceed();
    }
}

The warning text is:

Warning.java:22 can not resolve this member:
void A.&lt;catch&gt;(java.lang.ClassNotFoundException) [Xlint:unresolvableMember]

Line 22 is the line in the aspect that says "withincode".  If I comment out 
the aspect, the warning goes away.  Also, if I comment out A's default 
constructor, it goes away.  The "String.class" seems to have something to do 
with the warning.  

I can reproduce this with 1.1rc1 and 1.1rc2.</bugreport>
<testsforfix ID="37739" type="new">
    <file LOCATION="org.aspectj/modules/tests/bugs/CatchSig.java">
      <test NAME="test"/>
      <test NAME="test2"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Unexpected Xlint:unresolvableMember warning with withincode"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="111" file="output/37739/pre-fix/testresults.xml" passing="934" size="1045"/>
<post-fix-testcases failing="111" file="output/37739/post-fix/testresults.xml" passing="935" size="1046"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.20" state="changed">830a831
&gt;     //??? need to better understand all the enclosing variants
832c833
&lt;     	if (enclosingShadow == null) {
---
&gt;     	if (getKind().isEnclosingKind()) {
833a835,836
&gt;     	} else if (enclosingShadow == null) {
&gt;     		return getEnclosingMethod().getMemberView();
</file>
<file name="org.aspectj/modules/tests/jimTests.xml" revision="1.36" state="changed">3a4,5
&gt; 
&gt; 
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.70" state="changed">6227a6228,6234
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="37739"
&gt;    	 title="Unexpected Xlint:unresolvableMember warning with withincode"&gt;
&gt;         &lt;compile files="CatchSig.java"&gt;
&gt;         &lt;/compile&gt;
&gt;         &lt;run class="CatchSig"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/CatchSig.java" revision="1.1" state="new">/*
 * Bugzilla Bug 37739  
   Unexpected Xlint:unresolvableMember warning with withincode 
 */
public class CatchSig {
	CatchSig(Class type) {}

	CatchSig() {
		this(String.class);
	}
	
	public static void main(String[] args) {
		new CatchSig();
		new B().test();
		new B().test2();
		B.findClass();
	}
}

class B extends CatchSig {
	public B() {
		super(findClass());
	}
	
	static Class findClass() {
		return B.class;
	}

	public void test() {
	}

	public void test2() {
		test();
	}
}

aspect C {
	void around() :
		(call (void B.test()) &amp;&amp;
		 withincode (void B.test2())) {
		System.out.println("test from test2");
		proceed();
	}
	
	before(): call(Class B.findClass()) {
		System.out.println("from: " + thisEnclosingJoinPointStaticPart);
	}
	before(): call(Class B.findClass()) &amp;&amp; withincode(B.new()) {
		System.out.println("from B.new()");
	}
}
</file>
</fixedFiles>
</bug>
<bug id="38131" transactionid="72539">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-else K-new M T V</fullfingerprint>
<bugreport>I am using 1.1rc1. This is a regression since rc1 and a deviation from javac.
I am guessing this may have to do something with change in the underlying
Eclipse compiler.

Create a class in a subpackage such as:
package subpackage;

public class Test {
    public static void main(String[] args) {
	System.out.println("Hello");
    }
}

Then compile using following command:
&gt; ajc subpackage\Test.java

You will see a directory "subpackage" created under the existing "subpackage"
directory. The test.class is then put in subpackage\subpackage directory.
This means running java command results in 
Exception in thread "main" java.lang.NoClassDefFoundError: subpackage/Test

Running either of the following command fixes the problem:
&gt; ajc -d . subpackage\Test.java

or 

&gt; javac subpackage\Test.java

No big deal, really. But it will be nice to have same behavior as javac.</bugreport>
<testsforfix ID="38131" type="new">
    <file LOCATION="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java">
      <test NAME="testImplicitOutputDir"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="114" file="output/38131/pre-fix/testresults.xml" passing="958" size="1072"/>
<post-fix-testcases failing="115" file="output/38131/post-fix/testresults.xml" passing="958" size="1073"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.25" state="changed">422c422,425
&lt; 					destinationPath = new File(extractDestinationPathFromSourceFile(unitResult));
---
&gt; 					filename = new File(filename).getName();
&gt; 					filename = new File(extractDestinationPathFromSourceFile(unitResult), filename).getPath();
&gt; 				} else {
&gt; 					filename = new File(destinationPath, filename).getPath();
424c427
&lt; 				filename = new File(destinationPath, filename).getPath();
---
&gt; 				
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java" revision="1.7" state="changed">14a15
&gt; import java.io.File;
141a143,172
&gt; 	
&gt; 	public void testImplicitOutputDir() {
&gt; 		List args = new ArrayList();
&gt; 		
&gt; 		args.add("-classpath");
&gt; 		args.add("../runtime/bin;../lib/junit/junit.jar;../testing-client/bin");
&gt; 		
&gt; 		File f1 = new File("testdata/src1/p1/Foo.class");
&gt; 		File f2 = new File("testdata/src1/WrongPackage.class");
&gt; 		File f3 = new File("testdata/src1/WrongPackage$1.class");
&gt; 		
&gt; 		if (f1.exists()) f1.delete();
&gt; 		if (f2.exists()) f2.delete();
&gt; 		if (f3.exists()) f3.delete();
&gt; 		
&gt; 		args.add("testdata/src1/p1/Foo.java");
&gt; 		args.add("testdata/src1/WrongPackage.java");
&gt; 		
&gt; 		runCompiler(args, NO_ERRORS);
&gt; 		
&gt; 		assertTrue(f1.getPath(), f1.exists());
&gt; 		assertTrue(f2.getPath(), f2.exists());
&gt; 		assertTrue(f3.getPath(), f3.exists());
&gt; 		
&gt; 		if (f1.exists()) f1.delete();
&gt; 		if (f2.exists()) f2.delete();
&gt; 		if (f3.exists()) f3.delete();
&gt; 		
&gt; 
&gt; 	}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/WrongPackage.java" revision="1.1" state="new">package a.b.c;

public class WrongPackage {
    public static void main(String[] args) {
    	Runnable r = new Runnable() {
    		public void run() {}
    	};
    	r.run();
    }
}</file>
</fixedFiles>
</bug>
<bug id="39436" transactionid="71744">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="7"/>
<property name="lines-modified" value="25"/>
<property name="lines-churned" value="32"/>
<property name="priority" value="P2"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-instanceof K-null K-return M O-== O-- O-() O-cast O-instanceof T V Y Z-cast Z-if</fullfingerprint>
<bugreport>build I20030625

The old tasks view showed a summary of the number of tasks, errors, warnings 
and infos in the status line.  This is missing in the reworked view.</bugreport>
<pre-fix-testcases failing="124" file="output/39436/pre-fix/testresults.xml" passing="1034" size="1158"/>
<post-fix-testcases failing="125" file="output/39436/post-fix/testresults.xml" passing="1033" size="1158"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java" revision="1.18" state="changed">259d258
&lt;                             lng.setStart(null);
262d260
&lt;                             lng.setEnd(null);
838,846c836,839
&lt;                             if (i instanceof LocalVariableInstruction) {
&lt;                                 int index = ((LocalVariableInstruction)i).getIndex();
&lt;                                 if (lvt.getSlot() == index) {
&lt;                                     if (localVariableStarts.get(lvt) == null) {
&lt;                                         localVariableStarts.put(lvt, jh);
&lt;                                     }
&lt;                                     localVariableEnds.put(lvt, jh);
&lt;                                 }
&lt;                             }
---
&gt; 			    if (localVariableStarts.get(lvt) == null) {
&gt; 				localVariableStarts.put(lvt, jh);
&gt; 			    }
&gt; 			    localVariableEnds.put(lvt, jh);
855c848
&lt; 
---
&gt; 	
875c868
&lt;         
---
&gt;         // Reverse sort these keys
877,884c870,895
&lt; 	keys.addAll(localVariableStarts.keySet()); 
&lt; 	Collections.sort(keys,new Comparator() { 
&lt; 		public int compare(Object a,Object b) { 
&lt;                          LocalVariableTag taga = (LocalVariableTag)a; 
&lt;                          LocalVariableTag tagb = (LocalVariableTag)b; 
&lt;                          return taga.getName().compareTo(tagb.getName()); 
&lt;                  }}); 
&lt;          for (Iterator iter = keys.iterator(); iter.hasNext(); ) { 
---
&gt;         keys.addAll(localVariableStarts.keySet());
&gt; //		System.err.println("Keys for local variable tags"); 
&gt; //		for (int i = 0;i &lt;keys.size();i++) {
&gt; //			System.err.println("Before sort: #"+i+"="+keys.get(i));
&gt; //		}
&gt;         Collections.sort(keys, new Comparator() {
&gt;             public int compare(Object a, Object b) {
&gt;                 LocalVariableTag taga = (LocalVariableTag) a;
&gt;                 LocalVariableTag tagb = (LocalVariableTag) b;
&gt;                 if (taga.getName().startsWith("arg")) {
&gt;                     if (tagb.getName().startsWith("arg")) {
&gt;                         return -taga.getName().compareTo(tagb.getName());
&gt;                     } else {
&gt;                         return 1; // Whatever tagb is, it must come out before 'arg'
&gt;                     }
&gt;                 } else if (tagb.getName().startsWith("arg")) {
&gt;                     return -1; // Whatever taga is, it must come out before 'arg'
&gt;                 } else {
&gt;                     return -taga.getName().compareTo(tagb.getName());
&gt;                 }
&gt;             }
&gt;         });
&gt; //		for (int i = 0;i &lt;keys.size();i++) {
&gt; //			System.err.println("After  sort: #"+i+"="+keys.get(i));
&gt; //		}
&gt;         for (Iterator iter = keys.iterator(); iter.hasNext(); ) {
</file>
</fixedFiles>
</bug>
<bug id="39626" transactionid="74157">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="11"/>
<property name="lines-churned" value="11"/>
<property name="priority" value="P2"/>
<property name="severity" value="minor"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null M O-!= O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>I use AspectJ 1.1 from within eclipse.
After some time of developing, I get following stack trace (Wrapped in the 
eclipse gui), when I try to compile a java file with a huge amount of syntax 
errors, missing variables, and other problems.

As soon as I have fixed these issues, I can comnpile normally as ever.

Unfortunatly I can not provide any more detailed information because:
this errors pops up randomly,
disappears when the bug is fixed, 
I have neither the time nor the permission to create a more accurate sample

java.lang.NullPointerException
    at java.lang.String.&lt;init&gt;(String.java:214)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit
(AsmBuilder.java:231)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit
(AsmBuilder.java:259)
    at 
org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration.traverse
(AnonymousLocalTypeDeclaration.java:138)
    at 
org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse
(QualifiedAllocationExpression.java:342)
    at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse
(MessageSend.java:299)
    at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:147)
    at org.eclipse.jdt.internal.compiler.ast.ForStatement.traverse
(ForStatement.java:347)
    at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse
(MethodDeclaration.java:157)
    at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse
(TypeDeclaration.java:946)
    at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse
(CompilationUnitDeclaration.java:303)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.internalBuild
(AsmBuilder.java:169)
    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.build
(AsmBuilder.java:66)
    at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit
(EclipseFactory.java:303)
    at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:67)
    at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:338)
    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:372)
    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:133)
    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:78)
    at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:117)
    at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:164)
    LoadTest.java   CrefoClient/src/com/dcbank/scoring/socketserver 
 
kind regards
   Arno Schmidmeier</bugreport>
<testsforfix ID="39626" type="new">
    <file LOCATION="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java">
      <test NAME="testNullHandlingOfVisit"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/39626/pre-fix/testresults.xml" passing="987" size="1099"/>
<post-fix-testcases failing="112" file="output/39626/post-fix/testresults.xml" passing="988" size="1100"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java" revision="1.13" state="changed">72c72
&lt;     private AsmBuilder(CompilationResult result) {
---
&gt;     protected AsmBuilder(CompilationResult result) {
231c231,237
&lt; 		String fullName = new String(memberTypeDeclaration.binding.constantPoolName());
---
&gt; 		
&gt; 		String fullName = "&lt;undefined&gt;";
&gt; 		if (memberTypeDeclaration.binding != null
&gt; 			&amp;&amp; memberTypeDeclaration.binding.constantPoolName() != null) {
&gt; 			fullName = new String(memberTypeDeclaration.binding.constantPoolName());
&gt; 		}
&gt; 		 
431c437,439
&lt; 		String fileName = new String(currCompilationResult.getFileName());
---
&gt; 		
&gt; 		String fileName = "";
&gt; 		if (currCompilationResult.getFileName() != null) new String(currCompilationResult.getFileName());
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.java" revision="1.4" state="changed">24a25
&gt; 		suite.addTestSuite(AsmBuilderTest.class); 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/


package org.aspectj.ajdt.internal.core.builder;

import java.util.EmptyStackException;

import junit.framework.*;

import org.eclipse.jdt.internal.compiler.CompilationResult;
import org.eclipse.jdt.internal.compiler.ast.LocalTypeDeclaration;
import org.eclipse.jdt.internal.compiler.env.*;
import org.eclipse.jdt.internal.compiler.lookup.BlockScope;

public class AsmBuilderTest extends TestCase {

    public static Test suite() { 
        TestSuite suite = new TestSuite(AsmBuilderTest.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(AsmBuilderTest.class); 
        //$JUnit-END$
        return suite;
    }

	/**
	 * Test for bug#39626
	 */
	public void testNullHandlingOfVisit() { 
		ICompilationUnit cu = new ICompilationUnit() {
			public char[] getContents() {
				return null;
			}

			public char[] getMainTypeName() {
				return null;
			}

			public char[][] getPackageName() {
				return null;
			}
			
			public char[] getFileName() { 
				return null;
			}
			
		};
		LocalTypeDeclaration local = new LocalTypeDeclaration(new CompilationResult(cu, 0, 0, 0));
		local.name = new char[2];
		BlockScope scope = null;
		
		try { 
			new AsmBuilder(new CompilationResult(cu, 0, 0, 0)).visit(local, scope);
		} catch (Exception e) {
			assertTrue(e instanceof EmptyStackException);
		}
	}

}  
</file>
</fixedFiles>
</bug>
<bug id="39974" transactionid="74042">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="13"/>
<property name="priority" value="P2"/>
<property name="severity" value="critical"/>
<concisefingerprint>HK</concisefingerprint>
<fullfingerprint>H K-catch K-try T V Y</fullfingerprint>
<bugreport>When I compiled the observer/subject protocol example with JBuilder7 
integrated AJDE,there was a strange internal error

C:/JBuilder7/extras/aspectj-110/doc/examples/observer/Observer.java:0: 
Internal compiler error
java.lang.NullPointerException

	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseWorld.makeResolvedMember
(Unknown Source)

	at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit(Unknown 
Source)

	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse
(Unknown Source)

	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse
(Unknown Source)

	at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse
(Unknown Source)

	at org.aspectj.ajdt.internal.core.builder.AsmBuilder.internalBuild
(Unknown Source)

	at org.aspectj.ajdt.internal.core.builder.AsmBuilder.build(Unknown 
Source)

	at 
org.aspectj.ajdt.internal.compiler.lookup.EclipseWorld.finishedCompilationUnit
(Unknown Source)

	at org.aspectj.ajdt.internal.compiler.AjCompiler.process(Unknown 
Source)

	at org.eclipse.jdt.internal.compiler.Compiler.compile(Unknown Source)

	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Unknown Source)

	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(Unknown Source)

	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run(Unknown 
Source)

	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(Unknown Source)

	at org.aspectj.ajde.internal.CompilerAdapter.compile(Unknown Source)

	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(Unknown Source)

I firstly fix it by changing the interface Subject and Observer like this:
interface Observer {    void update();}
interface Subject { Object getData(); }
then it could compile successfully ,however,I immediately got another 
confusing.The compiler only made Display.java Observer.java Subject.java 
SubjectObserverProtocol.java and SubjectObserverProtocolImpl.java but ignoring 
the others.I don't know why,it seems to be a bug.

Meanwhile, I use ajc command-line  to compile this example ,it can get through 
without any exceptions.</bugreport>
<pre-fix-testcases failing="112" file="output/39974/pre-fix/testresults.xml" passing="988" size="1100"/>
<post-fix-testcases failing="113" file="output/39974/post-fix/testresults.xml" passing="987" size="1100"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java" revision="1.14" state="changed">183d182
&lt; 		//System.err.println("type with name: " + name);
283a283
&gt; 	// TODO: improve handling of malformed methodDeclaration.binding
331,333c331,342
&lt; 			Member member = EclipseFactory.makeResolvedMember(methodDeclaration.binding);
&lt; 			peNode.setBytecodeName(member.getName());
&lt; 			peNode.setBytecodeSignature(member.getSignature());
---
&gt; 			String memberName = "";
&gt; 			String memberBytecodeSignature = "";
&gt; 			try {
&gt; 				Member member = EclipseFactory.makeResolvedMember(methodDeclaration.binding);
&gt; 				memberName = member.getName();
&gt; 				memberBytecodeSignature = member.getSignature();
&gt; 			} catch (NullPointerException npe) {
&gt; 				memberName = "&lt;undefined&gt;";
&gt; 			}
&gt; 
&gt; 			peNode.setBytecodeName(memberName);
&gt; 			peNode.setBytecodeSignature(memberBytecodeSignature);
</file>
</fixedFiles>
</bug>
<bug id="39993" transactionid="72484">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="11"/>
<property name="lines-added" value="162"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="16"/>
<property name="lines-churned" value="178"/>
<property name="priority" value="P2"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-else K-if K-import K-instanceof K-new K-null K-package K-return K-super K-this K-true M O-== O-|| O-!= O-cast O-instanceof T V Y Z-cast Z-if</fullfingerprint>
<bugreport>From an email sent to the user's list 6/26/2003:
------------------------------------------
ajc 1.1 NPE when an aspect declares hashcode() as follows:

     interface Identifiable {
         void setId(Id id);
         Id getId();
     }
 
     aspect IdentifiableAspect {
         private Id Identifiable.id = null;
         public Id Identifiable.getId() {
 		return this.id;
 	  }
         public void Identifiable.setId(Id id) {
             this.id = id;
         }
 
         public int Identifiable.hashCode() {
             return (this.getId() == null)
                 ? super.hashCode()
                 : this.getId().hashCode();
         }
     }

A workaround for callers the compiler controls is to replace the declaration
with around advice:

     int around(Identifiable i): target(i)
         &amp;&amp; call(public int hashCode())
     {
         return (i.getId() == null)
             ? proceed(i)
             : i.getId().hashCode();
     }</bugreport>
<testsforfix ID="39993" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="ajc stack trace on declaring hashcode() method in aspect"/>
      <test NAME="using super in method introduced on interface with multiple supertypes"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="125" file="output/39993/pre-fix/testresults.xml" passing="961" size="1086"/>
<post-fix-testcases failing="125" file="output/39993/post-fix/testresults.xml" passing="963" size="1088"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java" revision="1.12" state="changed">19a20
&gt; import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
65a67,69
&gt; 		fixSuperCallsForInterfaceContext(upperScope);
&gt; 		if (ignoreFurtherInvestigation) return;
&gt; 		
69a74,82
&gt; 	private void fixSuperCallsForInterfaceContext(ClassScope scope) {
&gt; 		if (onTypeBinding.isInterface()) {
&gt; 			InterSuperFixerVisitor v =
&gt; 				new InterSuperFixerVisitor(this, 
&gt; 						EclipseFactory.fromScopeLookupEnvironment(scope), scope);
&gt; 			this.traverse(v, scope);
&gt; 		}
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.9" state="changed">342,356c342
&lt; 			Set neededSuperCalls = munger.getSuperMethodsCalled();
&lt; 
&lt; 			for (Iterator iter = neededSuperCalls.iterator(); iter.hasNext(); ) {
&lt; 				ResolvedMember superMethod = (ResolvedMember) iter.next();
&lt; 				if (weaver.addDispatchTarget(superMethod)) {
&lt; 					//System.err.println("super type: " + superMethod.getDeclaringType() + ", " + gen.getType());
&lt; 					boolean isSuper = !superMethod.getDeclaringType().equals(gen.getType());
&lt; 					String dispatchName;
&lt; 					if (isSuper) dispatchName = NameMangler.superDispatchMethod(onType, superMethod.getName());
&lt; 					else dispatchName = NameMangler.protectedDispatchMethod(onType, superMethod.getName());
&lt; 					LazyMethodGen dispatcher = makeDispatcher(gen, dispatchName, superMethod, weaver.getWorld(), isSuper);
&lt; 
&lt; 					weaver.addLazyMethodGen(dispatcher);
&lt; 				}
&lt; 			}
---
&gt; 			addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
390a377,378
&gt; 			addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
&gt; 			
396a385,406
&gt; 	private void addNeededSuperCallMethods(
&gt; 		BcelClassWeaver weaver,
&gt; 		ResolvedTypeX onType,
&gt; 		Set neededSuperCalls)
&gt; 	{
&gt; 		LazyClassGen gen = weaver.getLazyClassGen();
&gt; 		
&gt; 		for (Iterator iter = neededSuperCalls.iterator(); iter.hasNext(); ) {
&gt; 			ResolvedMember superMethod = (ResolvedMember) iter.next();
&gt; 			if (weaver.addDispatchTarget(superMethod)) {
&gt; 				//System.err.println("super type: " + superMethod.getDeclaringType() + ", " + gen.getType());
&gt; 				boolean isSuper = !superMethod.getDeclaringType().equals(gen.getType());
&gt; 				String dispatchName;
&gt; 				if (isSuper) dispatchName = NameMangler.superDispatchMethod(onType, superMethod.getName());
&gt; 				else dispatchName = NameMangler.protectedDispatchMethod(onType, superMethod.getName());
&gt; 				LazyMethodGen dispatcher = makeDispatcher(gen, dispatchName, superMethod, weaver.getWorld(), isSuper);
&gt; 		
&gt; 				weaver.addLazyMethodGen(dispatcher);
&gt; 			}
&gt; 		}
&gt; 	}
&gt; 
489a500,502
&gt; 		int modifiers = Modifier.PUBLIC;
&gt; 		if (onGen.isInterface()) modifiers |= Modifier.ABSTRACT;
&gt; 				
492c505
&lt; 					Modifier.PUBLIC,
---
&gt; 					modifiers,
499a513,514
&gt; 		if (onGen.isInterface()) return mg;
&gt; 		
</file>
<file name="org.aspectj/modules/tests/bugs/MultipleSuperCf.java" revision="1.1" state="new">import org.aspectj.testing.Tester;

interface B1 { }
interface B2 { }

interface D extends B1, B2 {}

aspect A {
	public int B1.m() {
		return 2;
	}
	
	public int D.m() {
		return super.m();  // CE even though B1.m is the only thing that makes sense
	}
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.84" state="changed">6422a6423,6435
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="39993"
&gt;    	 title="ajc stack trace on declaring hashcode() method in aspect"&gt;
&gt;         &lt;compile files="OverridingInterfaceObjectMethod.java"/&gt;
&gt;         &lt;run class="OverridingInterfaceObjectMethod"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs"
&gt;    	 title="using super in method introduced on interface with multiple supertypes"&gt;
&gt;         &lt;compile files="MultipleSuperCf.java"&gt;
&gt;         	&lt;message kind="error" line="14"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperReference.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/


package org.aspectj.ajdt.internal.compiler.ast;

import org.eclipse.jdt.internal.compiler.ast.SuperReference;
import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;

/**
 * Used to represent super references inside of inter-type declarations.  Special mechanism
 * needed for handling in an interface context.
 * 
 * @author Jim Hugunin
 */
public class InterSuperReference extends SuperReference {
	public InterSuperReference(SuperReference template, TypeBinding myType) {
		super(template.sourceStart, template.sourceEnd);
		this.resolvedType = myType;
	}

	public TypeBinding resolveType(BlockScope scope) {
		return resolvedType;
	}

}
</file>
<file name="org.aspectj/modules/tests/bugs/OverridingInterfaceObjectMethod.java" revision="1.1" state="new">import org.aspectj.testing.Tester;

public class OverridingInterfaceObjectMethod {
	private static final int VALUE = 10;
	
	public static void main(String[] args) {
		Identifiable i = new C();
		Tester.checkEqual(i.hashCode(), 42); //System.identityHashCode(i));
		i.setId(new Id(VALUE));
		Tester.checkEqual(i.hashCode(), VALUE);
	}
}

//TODO explore complicated inheritance hierarchies

class C implements Identifiable {}

interface Base { }

interface Identifiable extends Base {
	void setId(Id id);
	Id getId();
}

class Id {
	public Id(int value) {
		this.value = value;
	}
	int value;
}
 
aspect IdentifiableAspect {
	private Id Identifiable.id = null;
	public Id Identifiable.getId() {
       return this.id;
    }
	public void Identifiable.setId(Id id) {
		this.id = id;
	}
 
	public int Identifiable.hashCode() {
		return (this.getId() == null)
			? super.hashCode()
			: this.getId().value;
	}
	
	public int Base.hashCode() {
		return 42;
	}
}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/


package org.aspectj.ajdt.internal.compiler.ast;

import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
import org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceLocation;
import org.aspectj.bridge.IMessage;
import org.aspectj.bridge.ISourceLocation;
import org.eclipse.jdt.internal.compiler.AbstractSyntaxTreeVisitorAdapter;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.FieldReference;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.ast.SuperReference;
import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
import org.eclipse.jdt.internal.compiler.lookup.Scope;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;

/**
 * Walks the body of inter-type declarations and replaces SuperReference with InterSuperReference
 * 
 * @author Jim Hugunin
 */

public class InterSuperFixerVisitor extends AbstractSyntaxTreeVisitorAdapter {
	InterTypeDeclaration dec;
	ReferenceBinding onType;
	TypeBinding superType;

	EclipseFactory world; 
	public InterSuperFixerVisitor(InterTypeDeclaration dec, EclipseFactory world, Scope scope) {
		this.dec = dec;
		this.onType = dec.onTypeBinding;
		this.world = world;
		
		if (onType.superclass() != null) {
			superType = onType.superclass();
		} else if (onType.superInterfaces() == null || onType.superInterfaces().length == 0) {
			superType = scope.getJavaLangObject();
		} else if (onType.superInterfaces().length == 1) {
			superType = onType.superInterfaces()[0];
		} else {
			superType = null;
		}
	}

	public void endVisit(FieldReference ref, BlockScope scope) {
		ref.receiver = fixReceiver(ref.receiver, scope);
	}
	public void endVisit(MessageSend send, BlockScope scope) {
		send.receiver = fixReceiver(send.receiver, scope);
	}

	private Expression fixReceiver(Expression expression, BlockScope scope) {
		if (expression instanceof SuperReference) {
			SuperReference superRef = (SuperReference) expression;
			if (superType == null) {
				ISourceLocation location =
					new EclipseSourceLocation(scope.problemReporter().referenceContext.compilationResult(),
										expression.sourceStart, expression.sourceEnd);
				
				world.showMessage(IMessage.ERROR, "multiple supertypes for this interface", location, null);
				dec.ignoreFurtherInvestigation = true;
			}
			//FIXME note error
			expression = new InterSuperReference(superRef, superType);	
		}
		return expression;
	}
	


}
</file>
</fixedFiles>
</bug>
<bug id="40192" transactionid="68926">
<property name="files-churned" value="5"/>
<property name="java-files-churned" value="5"/>
<property name="classes-churned" value="5"/>
<property name="methods-churned" value="5"/>
<property name="hunks" value="29"/>
<property name="lines-added" value="77"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="40"/>
<property name="lines-churned" value="118"/>
<property name="priority" value="P2"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-if K-import K-new K-null K-return K-this K-throw K-true K-try M O-|| O-- O-!= O-/ O-() O-* O-&amp;&amp; O-+ O-++ O-cast T V Y Z-cast Z-if Z-throw</fullfingerprint>
<bugreport>The build can not be cancelled during the bytecode weaving stage.</bugreport>
<testsforfix ID="40192" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.java">
      <test NAME="testCancelFirstCompile"/>
      <test NAME="testCancelThirdCompile"/>
      <test NAME="testCancelFirstAspectWeave"/>
      <test NAME="testCancelThirdAspectWeave"/>
      <test NAME="testCancelFirstClassWeave"/>
      <test NAME="testCancelSecondClassWeave"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="103" file="output/40192/pre-fix/testresults.xml" passing="1159" size="1262"/>
<post-fix-testcases failing="109" file="output/40192/post-fix/testresults.xml" passing="1159" size="1268"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java" revision="1.3" state="changed">23a24
&gt; import org.aspectj.bridge.IProgressListener;
46a48
&gt; 	private IProgressListener progressListener;
75a78
&gt; 							 IProgressListener progressListener,
83a87
&gt; 		this.progressListener = progressListener;
132a137
&gt; 		
215c220
&lt; 		weaver.weave(new WeaverAdapter(this,weaverMessageHandler));
---
&gt; 		weaver.weave(new WeaverAdapter(this,weaverMessageHandler,progressListener));
</file>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java" revision="1.6" state="changed">19d18
&lt; import org.aspectj.bridge.AbortException;
52a52,59
&gt; 	public void setCancelledRequested(boolean cancelRequested) {
&gt; 		this.cancelRequested = cancelRequested;
&gt; 	}
&gt; 
&gt; 	public boolean isCancelledRequested() {
&gt; 		return cancelRequested;
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java" revision="1.2" state="changed">16a17
&gt; import org.aspectj.bridge.IProgressListener;
19a21,22
&gt; import org.eclipse.core.runtime.OperationCanceledException;
&gt; import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
34a38
&gt; 	private IProgressListener progressListener;
35a40
&gt; 	private int localIteratorCounter;
36a42,48
&gt; 	// Fields related to progress monitoring
&gt; 	private int progressMaxTypes;
&gt; 	private String progressPhasePrefix;
&gt; 	private double fromPercent;
&gt; 	private double toPercent = 100.0;
&gt; 	private int progressCompletionCount;
&gt; 
39,40c51,53
&lt; 						 WeaverMessageHandler weaverMessageHandler) { 
&lt; 		this.compilerAdapter = forCompiler; 
---
&gt; 						 WeaverMessageHandler weaverMessageHandler,
&gt; 						 IProgressListener progressListener) { 
&gt; 		this.compilerAdapter = forCompiler;
41a55
&gt; 		this.progressListener = progressListener;
48a63
&gt; 		localIteratorCounter = 0;
100a116
&gt; 		localIteratorCounter++;
102a119
&gt; 		// weaverMessageHandler.handleMessage(new Message("weaving " + nowProcessing.fileName(),IMessage.INFO, null, null));
111c128
&lt; 	
---
&gt; 
115c132
&lt; 	
---
&gt; 
117,120c134,163
&lt; 	public void processingReweavableState() {}
&lt; 	public void addingTypeMungers() {}
&lt; 	public void weavingAspects() {}
&lt; 	public void weavingClasses() {finalPhase = true;}
---
&gt; 	public void processingReweavableState() {
&gt; 		
&gt; 		// progress reporting logic
&gt; 		fromPercent = 50.0; // Assume weaving takes 50% of the progress bar...
&gt; 	    recordProgress("processing reweavable state");
&gt; 	}
&gt; 	
&gt; 	public void addingTypeMungers() {
&gt; 		
&gt; 		// progress reporting logic
&gt; 		// At this point we have completed one iteration through all the classes/aspects 
&gt; 		// we'll be dealing with, so let us remember this max value for localIteratorCounter
&gt; 		// (for accurate progress reporting)
&gt; 		recordProgress("adding type mungers");
&gt; 		progressMaxTypes = localIteratorCounter;
&gt; 	}
&gt; 	
&gt; 	public void weavingAspects() {
&gt; 		
&gt; 		// progress reporting logic
&gt; 		progressPhasePrefix="woven aspect ";
&gt; 		progressCompletionCount=0; // Start counting from *now*
&gt; 	}
&gt; 	
&gt; 	public void weavingClasses() {
&gt; 		finalPhase = true;
&gt; 		
&gt; 		// progress reporting logic
&gt; 		progressPhasePrefix="woven class ";
&gt; 	}
126a170,171
&gt; 	
&gt; 
137a183,196
&gt; 		
&gt; 		if (progressListener != null) {
&gt; 			progressCompletionCount++;
&gt; 			
&gt; 			// Smoothly take progress from 'fromPercent' to 'toPercent'
&gt; 			recordProgress(
&gt; 			  fromPercent
&gt; 			  +((progressCompletionCount/(double)progressMaxTypes)*(toPercent-fromPercent)),
&gt; 			  progressPhasePrefix+result.getClassName()+" (from "+nowProcessing.fileName()+")");
&gt; 
&gt; 			if (progressListener.isCancelledRequested()) {
&gt; 		      throw new AbortCompilation(true,new OperationCanceledException("Weaving cancelled as requested"));
&gt; 			}
&gt; 		}
162a222,234
&gt; 	
&gt; 	private void recordProgress(String message) {
&gt; 		if (progressListener!=null) {
&gt; 			progressListener.setText(message);
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	private void recordProgress(double percentage,String message) {
&gt; 		if (progressListener!=null) {
&gt; 			progressListener.setProgress(percentage/100);
&gt; 			progressListener.setText(message);
&gt; 		}
&gt; 	}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.48" state="changed">33a34
&gt; import org.eclipse.core.runtime.OperationCanceledException;
40a42
&gt; import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
161c163
&lt;                     if (handler.hasErrors()) {
---
&gt;                     if (handler.hasErrors() || (progressListener!=null &amp;&amp; progressListener.isCancelledRequested())) {
575,576c577,581
&lt; 		compiler.compile(getCompilationUnits(filenames, encodings));
&lt; 		
---
&gt; 		try {
&gt; 			compiler.compile(getCompilationUnits(filenames, encodings));
&gt; 		} catch (OperationCanceledException oce) {
&gt; 			handler.handleMessage(new Message("build cancelled:"+oce.getMessage(),IMessage.WARNING,null,null));
&gt; 		}
594a600,604
&gt; 				
&gt; 				if (progressListener!=null &amp;&amp; progressListener.isCancelledRequested()) { 
&gt; 					throw new AbortCompilation(true,
&gt; 					  new OperationCanceledException("Compilation cancelled as requested"));
&gt; 				}
856c866,868
&lt; 						getInterimResultRequestor(),this,
---
&gt; 						getInterimResultRequestor(),
&gt; 						progressListener,
&gt; 						this,
</file>
<file name="org.aspectj/modules/bridge/src/org/aspectj/bridge/IProgressListener.java" revision="1.2" state="changed">28a29,39
&gt; 	
&gt;     /**
&gt;      * @param cancelRequested true if the caller wants the current compilation to stop asap
&gt;      */
&gt; 	public void setCancelledRequested(boolean cancelRequested);
&gt; 	
&gt; 	/**
&gt; 	 * @return true if the consumer of the progress info would like the compileation to stop
&gt; 	 */
&gt; 	public boolean isCancelledRequested();
&gt; 	
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AjdeTests.java" revision="1.15" state="changed">37a38
&gt; 		suite.addTestSuite(BuildCancellingTest.class);
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     Initial version
 * ******************************************************************/

package org.aspectj.ajde;

import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.aspectj.ajde.internal.CompilerAdapter;
import org.aspectj.util.FileUtil;

/**
 * It is now possible to cancel the compiler during either the
 * compilation or weaving phases - this testcase verifies a few
 * cases, making sure the process stops when expected.  It can
 * check the disk contents, but it doesn't right now.
 * 
 * Two different .lst files are used during these tests: LoadsaCode.lst and 
 * EvenMoreCode.lst which contain mixes of aspects and classes
 * 
 * Here are some things to think about that will help you understand what is 
 * on the disk when we cancel the compiler.
 * 
 * There are 3 important phases worth remembering :
 * - Compile all the types 
 * - Weave all the aspects
 * - Weave all the classes
 * 
 * Each of those steps goes through all the types.  This
 * means during the 'weave all the aspects' step we are 
 * jumping over classes and during the 'weave all the
 * classes ' step we are jumping over aspects.  Why is this important?
 * 
 *  
 * We only write bytes out during the 'weave all the classes ' phase and it is even
 * during that phase that we write out the bytes for aspects.  This means if you cancel
 * during compilation or during the weaving of aspects - there will be nothing on the 
 * disk.  If you cancel whilst in the 'weave all the classes ' phase then the disk
 * will contain anything finished with by the cancellation point.
 */
public class BuildCancellingTest extends AjdeTestCase {

	private CompilerAdapter compilerAdapter;
	public static final String PROJECT_DIR = "BuildCancelling";
	public static final String binDir = "bin";

	public BuildCancellingTest(String arg0) {
		super(arg0);
	}

	// Ensure the output directory is clean
	protected void setUp() throws Exception {
		super.setUp(PROJECT_DIR);
		FileUtil.deleteContents(openFile(binDir));
	}
	

	
	/**
	 * After first compilation message, get it to cancel, there should be one more warning
	 * message about cancelling the compile and their should be nothing on the disk.
	 */
	public void testCancelFirstCompile() {
		System.out.println("\n\n\ntestCancelFirstCompile: Building with LoadsaCode.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(false);
		BuildProgMon programmableBPM = new BuildProgMon();

		programmableBPM.cancelOn("compiled:",1); // Force a cancel after the first compile occurs

		compilerAdapter.compile(
			(String) openFile("LoadsaCode.lst").getAbsolutePath(),
			programmableBPM,
			false);
			
		assertTrue("Should have cancelled after first compile?:"+programmableBPM.numCompiledMessages,
		  programmableBPM.numCompiledMessages==1);
		
// Comment out to check the disk contents  
//		assertTrue("As weaving was cancelled, no files should have been written out, but I found:"+wovenClassesFound(),
//		  wovenClassesFound()==0);
		  
		boolean expectedCancelMessageFound = checkFor("Compilation cancelled as requested");
		if (!expectedCancelMessageFound) dumpTaskData(); // Useful for debugging
		assertTrue("Failed to get warning message about compilation being cancelled!", expectedCancelMessageFound);
	}
	
	
	
	/**
	 * After third compilation message, get it to cancel, there should be one more warning
	 * message about cancelling the compile and their should be nothing on the disk.
	 */
	public void testCancelThirdCompile() {
		System.out.println("\n\n\ntestCancelThirdCompile: Building with LoadsaCode.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(false);
		BuildProgMon programmableBPM = new BuildProgMon();

		programmableBPM.cancelOn("compiled:",3); // Force a cancel after the third compile occurs

		compilerAdapter.compile(
			(String) openFile("LoadsaCode.lst").getAbsolutePath(),
			programmableBPM,
			false);
			
		assertTrue("Should have cancelled after third compile?:"+programmableBPM.numCompiledMessages,
		  programmableBPM.numCompiledMessages==3);
		  
//		Comment out to check the disk contents 		  
//		assertTrue("As weaving was cancelled, no files should have been written out, but I found:"+wovenClassesFound(),
//		  wovenClassesFound()==0);

		boolean expectedCancelMessageFound = checkFor("Compilation cancelled as requested");
		if (!expectedCancelMessageFound) dumpTaskData(); // Useful for debugging
		assertTrue("Failed to get warning message about compilation being cancelled!", expectedCancelMessageFound);
	}


	/**
	 * After first weave aspect message, get it to cancel, there should be one more warning
	 * message about cancelling the weave and their should be nothing on the disk.
	 */
	public void testCancelFirstAspectWeave() {
		System.out.println("\n\n\ntestCancelFirstAspectWeave: Building with LoadsaCode.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(false);
		BuildProgMon programmableBPM = new BuildProgMon();

		programmableBPM.cancelOn("woven aspect ",1); // Force a cancel after the first weave aspect occurs

		compilerAdapter.compile((String) openFile("LoadsaCode.lst").getAbsolutePath(),programmableBPM,false);
			
		assertTrue("Should have cancelled after first aspect weave?:"+programmableBPM.numWovenAspectMessages,
		  programmableBPM.numWovenAspectMessages==1);

// 		Comment out to check the disk contents
//		assertTrue("As weaving was cancelled, no files should have been written out?:"+wovenClassesFound(),
//		  wovenClassesFound()==0);

		boolean expectedCancelMessageFound = checkFor("Weaving cancelled as requested");
		if (!expectedCancelMessageFound) dumpTaskData(); // Useful for debugging
		assertTrue("Failed to get warning message about weaving being cancelled!", expectedCancelMessageFound);
	}
	


	/**
	 * After third weave aspect message, get it to cancel, there should be one more warning
	 * message about cancelling the weave and their should be nothing on the disk.
	 */	
	public void testCancelThirdAspectWeave() {
		System.out.println("\n\n\ntestCancelThirdAspectWeave: Building with LoadsaCode.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(false);
		
		BuildProgMon programmableBPM = new BuildProgMon();
		// Force a cancel after the third weave occurs.
		// This should leave two class files on disk - I think?
		programmableBPM.cancelOn("woven aspect ",3); 
			
		compilerAdapter.compile(
			(String) openFile("LoadsaCode.lst").getAbsolutePath(),
			programmableBPM,
			false);
		
		assertTrue("Should have cancelled after third weave?:"+programmableBPM.numWovenAspectMessages,
		  programmableBPM.numWovenAspectMessages==3);
		  
//		Comment out to check disk contents
//		assertTrue("As weaving was cancelled, no files should have been written out?:"+wovenClassesFound(),
//		  wovenClassesFound()==0);
		  
		boolean expectedCancelMessageFound = checkFor("Weaving cancelled as requested");
		if (!expectedCancelMessageFound) dumpTaskData(); // Useful for debugging
		assertTrue("Failed to get warning message about weaving being cancelled!", expectedCancelMessageFound);

	}
	
	/**
	 * After first weave class message, get it to cancel, there should be one more
	 * warning message about cancelling the weave and their should be nothing on the
	 * disk.
	 * 
	 * EvenMoreCode.lst contains:
	 * A1.aj
	 * Cl1.java
	 * A2.aj
	 * Cl2.java
	 * HW.java
	 * A3.aj
	 * Cl3.java
	 * A4.aj
	 * 
	 */
	public void testCancelFirstClassWeave() {
		System.out.println("testCancelFirstClassWeave: Building with EvenMoreCode.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(false);
		BuildProgMon programmableBPM = new BuildProgMon();

		programmableBPM.cancelOn("woven class",1); 
	
		compilerAdapter.compile(
			(String) openFile("EvenMoreCode.lst").getAbsolutePath(),
			programmableBPM,
			false);
	
//		Should just be A1 on the disk - uncomment this line to verify that!
//		assertTrue("Incorrect disk contents found",diskContents("A1"));

		assertTrue("Should have cancelled after first class weave?:"+programmableBPM.numWovenClassMessages,
		  programmableBPM.numWovenClassMessages==1);
		  
		boolean expectedCancelMessageFound = checkFor("Weaving cancelled as requested");
		if (!expectedCancelMessageFound) dumpTaskData(); // Useful for debugging
		assertTrue("Failed to get warning message about weaving being cancelled!", expectedCancelMessageFound);
	}
	
	
	/**
	 * After first weave aspect message, get it to cancel, there should be one more
	 * warning message about cancelling the weave and their should be nothing on the
	 * disk.
	 * 
	 * EvenMoreCode.lst contains:
	 * A1.aj
	 * Cl1.java
	 * A2.aj
	 * Cl2.java
	 * HW.java
	 * A3.aj
	 * Cl3.java
	 * A4.aj
	 * 
	 */
	public void testCancelSecondClassWeave() {
		System.out.println("testCancelSecondClassWeave: Building with EvenMoreCode.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(false);
		BuildProgMon programmableBPM = new BuildProgMon();

		programmableBPM.cancelOn("woven class",2); 
	
		compilerAdapter.compile(
			(String) openFile("EvenMoreCode.lst").getAbsolutePath(),
			programmableBPM,
			false);
	
//		Uncomment this line to verify disk contents
//		assertTrue("Incorrect disk contents found",diskContents("A1 Cl1 A2"));

		assertTrue("Should have cancelled after first class weave?:"+programmableBPM.numWovenClassMessages,
		  programmableBPM.numWovenClassMessages==2);
		  
		boolean expectedCancelMessageFound = checkFor("Weaving cancelled as requested");
		if (!expectedCancelMessageFound) dumpTaskData(); // Useful for debugging
		assertTrue("Failed to get warning message about weaving being cancelled!", expectedCancelMessageFound);

	}
	
	
	// ----
	// Helper classes and methods
	

	private class BuildProgMon implements BuildProgressMonitor {
		
        public int numWovenClassMessages = 0;
        public int numWovenAspectMessages = 0;
        public int numCompiledMessages = 0;
        
		private String programmableString;
		private int count;
		private List messagesReceived = new ArrayList();
		private int currentVal;
        
		public void start(String configFile) {
			currentVal = 0;
		}

		public void cancelOn(String string,int count) {
			programmableString = string;
			this.count = count;
		}

		public void setProgressText(String text) {
			String newText = text+" [Percentage="+currentVal+"%]";
			messagesReceived.add(newText);
			if (text.startsWith("woven aspect ")) numWovenAspectMessages++;
			if (text.startsWith("woven class ")) numWovenClassMessages++;
			if (text.startsWith("compiled:")) numCompiledMessages++;
			if (programmableString != null
				&amp;&amp; text.indexOf(programmableString) != -1) {
				count--;
				if (count==0) {
					System.out.println("Just got message '"+newText+"' - asking build to cancel");
					compilerAdapter.requestCompileExit();
					programmableString = null;
				}
			}
		}
		
		public boolean containsMessage(String prefix,String distinguishingMarks) {
			for (Iterator iter = messagesReceived.iterator(); iter.hasNext();) {
				String element = (String) iter.next();
				if (element.startsWith(prefix) &amp;&amp;
				    element.indexOf(distinguishingMarks)!=-1) return true;
			}
			return false;
		}
		
		public void dumpMessages() {
			System.out.println("ProgressMonitorMessages");
			for (Iterator iter = messagesReceived.iterator(); iter.hasNext();) {
				String element = (String) iter.next();
				System.out.println(element);
			}
		}

		public void setProgressBarVal(int newVal) {
			this.currentVal = newVal;
		}

		public void incrementProgressBarVal() {
			System.err.println("ipbv");
		}

		public void setProgressBarMax(int maxVal) {
			System.err.println("spbm"+maxVal);
		}

		public int getProgressBarMax() {
			return 100; // Causes setProgressBarVal() to be fed what are effectively percentages
		}

		public void finish() {
		}

	}
	
	private boolean diskContents(String shouldExist) {
		String[] fullList = new String[] { "A1","A2","A3","A4","Cl1","Cl2","Cl3","HW"};
		boolean isOK = true;
		for (int i = 0; i &lt; fullList.length; i++) {
			String file = fullList[i];
			if (shouldExist.indexOf(file)!=-1) {
				// There should be a class file called this
				if (!openFile("bin/"+file+".class").exists()) {
					isOK=false; 
					System.out.println("Couldn't find this expected file: "+file+".class");
				}
			} else {
				// There should NOT be a class file called this
				if (openFile("bin/"+file+".class").exists()) {
					isOK=false;
					System.out.println("Found this file when not expected: "+file+".class");
				}
			}
		}
		return isOK;
	}
	
	private int wovenClassesFound() {
		int found = 0;
		File fA1 = openFile("bin/A1.class");
		File fA2 = openFile("bin/A2.class");
		File fA3 = openFile("bin/A3.class");
		File fA4 = openFile("bin/A4.class");
		File fHW = openFile("bin/HW.class");

		found+=(fA1.exists()?1:0);
		found+=(fA2.exists()?1:0);
		found+=(fA3.exists()?1:0);
		found+=(fA4.exists()?1:0);
		found+=(fHW.exists()?1:0);
		return found;
	}
	

	private boolean checkFor(String what) {
		List ll = ideManager.getCompilationSourceLineTasks();
		for (Iterator iter = ll.iterator(); iter.hasNext();) {
			Object element = (Object) iter.next();
			if (element.toString().indexOf(what) != -1)
				return true;
		}
		return false;
	}
	
	private void dumpTaskData() {
		List ll = ideManager.getCompilationSourceLineTasks();
		for (Iterator iter = ll.iterator(); iter.hasNext();) {
			Object element = (Object) iter.next();
			System.out.println("RecordedMessage&gt;"+element);
		}
	}

}
</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/Cl3.java" revision="1.1" state="new">public class Cl3 {
	public static void callPrint(String s) {
	}
}</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/Cl1.java" revision="1.1" state="new">public class Cl1 {
	public static void main(String[] args) {
	}
}</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/A3.aj" revision="1.1" state="new">&#13;
public aspect A3 {&#13;
&#13;
  pointcut m1(): call(* *print*(..));&#13;
  &#13;
  before(): m1() {&#13;
    System.err.println("Calling print");&#13;
  }&#13;
}</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/A4.aj" revision="1.1" state="new">&#13;
public aspect A4 {&#13;
&#13;
  pointcut m1(): call(* *print*(..));&#13;
  &#13;
  after(): m1() {&#13;
    System.err.println("After call to print");&#13;
  }&#13;
}</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/A2.aj" revision="1.1" state="new">&#13;
public aspect A2 {&#13;
&#13;
  pointcut m1(): execution(* main(..));&#13;
  &#13;
  after(): m1() {&#13;
    System.err.println("After main runs");&#13;
  }&#13;
}&#13;
</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/A1.aj" revision="1.1" state="new">&#13;
public aspect A1 {&#13;
&#13;
  pointcut m1(): execution(* main(..));&#13;
  &#13;
  before(): m1() {&#13;
    System.err.println("Before main runs");&#13;
  }&#13;
}</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/LoadsaCode.lst" revision="1.1" state="new">A1.aj&#13;
A2.aj&#13;
HW.java&#13;
A3.aj&#13;
A4.aj&#13;
-verbose&#13;
-noExit&#13;
</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/EvenMoreCode.lst" revision="1.1" state="new">A1.aj&#13;
Cl1.java&#13;
A2.aj&#13;
Cl2.java&#13;
HW.java&#13;
A3.aj&#13;
Cl3.java&#13;
A4.aj&#13;
-verbose&#13;
-noExit&#13;
</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/HW.java" revision="1.1" state="new">
public class HW {
	public static void main(String[] args) {
		callPrint("Hello");
		callPrint(" ");
		callPrint("World");
		callPrint("\n");
	}
	
	public static void callPrint(String s) {
		System.out.print(s);		
	}
}</file>
<file name="org.aspectj/modules/ajde/testdata/BuildCancelling/Cl2.java" revision="1.1" state="new">public class Cl2 {
	public static void main(String[] args) {
	}
}</file>
</fixedFiles>
</bug>
<bug id="40257" transactionid="74193">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P2"/>
<property name="severity" value="minor"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-null M</fullfingerprint>
<bugreport>Relative paths (e.g. "../") are no longer parser properly in AJDE 1.1.0.</bugreport>
<pre-fix-testcases failing="123" file="output/40257/pre-fix/testresults.xml" passing="995" size="1118"/>
<post-fix-testcases failing="122" file="output/40257/post-fix/testresults.xml" passing="995" size="1117"/>
<fixedFiles>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java" revision="1.6" state="changed">60c60
&lt;                 setIcon(null);
---
&gt;                 setIcon(AjdeUIManager.getDefault().getIconRegistry().getInfoIcon());
</file>
<file name="org.aspectj/modules/ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.java" revision="1.2" state="deleted"/>
<file name="org.aspectj/modules/ajbrowser/testsrc/org/aspectj/tools/ajbrowser/InteractiveBrowserTest.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/


package org.aspectj.tools.ajbrowser;

import java.io.File;
import javax.swing.*;
import junit.framework.*;
//import org.aspectj.asm.*;
import org.aspectj.bridge.*;
import org.aspectj.bridge.IMessage;
import org.aspectj.ajde.*;

/**
 * @author Mik Kersten
 */
public class InteractiveBrowserTest extends TestCase {

	public InteractiveBrowserTest(String name) {
		super(name);
	}

	public static TestSuite suite() {
		TestSuite result = new TestSuite();
		result.addTestSuite(InteractiveBrowserTest.class);	
		return result;
	}

	public void testInitNoArgs() {
		//String[] args = { "C:/Dev/aspectj/modules/ajde/testdata/examples/figures-coverage/all.lst" };	
		String[] args = { };
		BrowserManager.getDefault().init(args, true);	
	}

	public void testAddProjectTask() {
		BrowserManager.getDefault().init(new String[]{}, true);	
		Ajde.getDefault().getTaskListManager().addProjectTask(
			"project-level task",
			IMessage.ERROR);

		BrowserManager.getDefault().showMessages();

		assertTrue("confirmation result", verifySuccess("Project task is visible."));
	}
	
	public void testAddSourceLineTasks() {
		BrowserManager.getDefault().init(new String[]{}, true);	
		ISourceLocation dummyLocation = new SourceLocation(new File("&lt;file&gt;"), 0, 0);

		Ajde.getDefault().getTaskListManager().addSourcelineTask(
			"error task",
			dummyLocation,
			IMessage.ERROR); 

		Ajde.getDefault().getTaskListManager().addSourcelineTask(
			"warning task",
			dummyLocation,
			IMessage.WARNING);
		
		Ajde.getDefault().getTaskListManager().addSourcelineTask(
			"info task",
			dummyLocation,
			IMessage.INFO);
			
		BrowserManager.getDefault().showMessages();

		assertTrue("confirmation result", verifySuccess("3 kinds of sourceline tasks are visible."));
	}
	
	
	private boolean verifySuccess(String message) {
		int result = JOptionPane.showConfirmDialog(
			BrowserManager.getDefault().getRootFrame(),
			"Verify Results",
			message,
			JOptionPane.YES_NO_OPTION);		
		return result == JOptionPane.YES_OPTION;
	}
	
	protected void setUp() throws Exception {
		super.setUp();
	}
	
	protected void tearDown() throws Exception {
		super.tearDown();
	}
}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java" revision="1.7" state="changed">15,16c15,20
&lt; import org.aspectj.ajdt.internal.core.builder.AjBuildConfig;
&lt; import org.aspectj.ajdt.internal.core.builder.AjCompilerOptions;
---
&gt; import java.io.*;
&gt; import java.util.*;
&gt; 
&gt; import junit.framework.TestCase;
&gt; 
&gt; import org.aspectj.ajdt.internal.core.builder.*;
22,31d25
&lt; import java.io.File;
&lt; import java.io.FileNotFoundException;
&lt; import java.io.IOException;
&lt; import java.io.PrintWriter;
&lt; import java.util.Arrays;
&lt; import java.util.Collection;
&lt; import java.util.List;
&lt; 
&lt; import junit.framework.TestCase;
&lt; 
330a325,341
&gt; 	public void testNonExistentConfigFile() throws IOException {
&gt; 		String FILE_PATH =   "@" + TEST_DIR + "../bug-40257/d1/test.lst";
&gt; 		AjBuildConfig config = parser.genBuildConfig(new String[] { FILE_PATH }, messageWriter);
&gt; 
&gt; 		String a = new File(TEST_DIR + "../bug-40257/d1/A.java").getCanonicalPath();
&gt; 		String b = new File(TEST_DIR + "../bug-40257/d1/d2/B.java").getCanonicalPath();
&gt; 		String c = new File(TEST_DIR + "../bug-40257/d3/C.java").getCanonicalPath();
&gt; 		List pathList = new ArrayList();
&gt; 		for (Iterator it = config.getFiles().iterator(); it.hasNext(); ) {
&gt; 			pathList.add(((File)it.next()).getCanonicalPath());
&gt; 		}
&gt; 		assertTrue(pathList.contains(a));
&gt; 		assertTrue(pathList.contains(b));
&gt; 		assertTrue(pathList.contains(c));
&gt; 			
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtAjcTests.java" revision="1.3" state="changed">28c28
&lt;         return suite;
---
&gt;         return suite;  
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/bug-40257/d1/d2/B.java" revision="1.1" state="new">package d1.d2;

class B { }</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/bug-40257/d1/test.lst" revision="1.1" state="new">A.java
d2/B.java
../d3/C.java
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/bug-40257/d3/C.java" revision="1.1" state="new">package d3;

class C { }</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/bug-40257/d1/A.java" revision="1.1" state="new">
package d1;

public class A {

}
</file>
</fixedFiles>
</bug>
<bug id="40380" transactionid="74244">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="26"/>
<property name="lines-deleted" value="9"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="38"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-import K-new K-return K-true M T V Z-if</fullfingerprint>
<bugreport>AJDT 1.1.3, Eclipse 2.1

To build a JDK 1.4. program under Eclipse using JDK 1.3 the appropriate build 
library should be selected in the Project Properties "Java Build Path". 
However AspectJ continues to use the JDK associated with Eclipse so errors 
result from using 1.4 APIs. The same will occur running Eclipse under 1.4 and 
compiling programs for 1.5

Testcase:
1. Run Eclipse under JDK 1.3
2. Create a Java project which uses a 1.4 JDK
3. Write a Java classes that uses 1.4 APIs e.g.

public class TestStringBuffer {

	public  static void main(String[] args) {
		new StringBuffer("Test").indexOf("T");
  	}
}
4. Convert to AspectJ project</bugreport>
<pre-fix-testcases failing="124" file="output/40380/pre-fix/testresults.xml" passing="969" size="1093"/>
<post-fix-testcases failing="124" file="output/40380/post-fix/testresults.xml" passing="969" size="1093"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java" revision="1.12" state="changed">123c123
&lt; 
---
&gt; 	
141c141
&lt;         if (null != message) {
---
&gt;         if (null != message) {  
</file>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java" revision="1.11" state="changed">18a19,27
&gt; import java.io.File;
&gt; import java.util.ArrayList;
&gt; import java.util.Collection;
&gt; import java.util.Iterator;
&gt; import java.util.List;
&gt; import java.util.Map;
&gt; import java.util.Set;
&gt; import java.util.StringTokenizer;
&gt; 
24a34
&gt; import org.aspectj.ajdt.ajc.BuildArgParser;
37,45d46
&lt; import java.io.File;
&lt; import java.util.ArrayList;
&lt; import java.util.Collection;
&lt; import java.util.Iterator;
&lt; import java.util.List;
&lt; import java.util.Map;
&lt; import java.util.Set;
&lt; import java.util.StringTokenizer;
&lt; 
161c162,164
&lt;         AjBuildConfig local = AjdtCommand.genBuildConfig(args, counter);
---
&gt; 		BuildArgParser parser = new BuildArgParser();
&gt;         AjBuildConfig local = parser.genBuildConfig(args, counter, false);  
&gt;              
164c167,168
&lt;         }
---
&gt;         } 
&gt;         
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.13" state="changed">93c93,105
&lt;     
---
&gt; 
&gt; 	/**
&gt; 	 * Generate build configuration for the input args,
&gt; 	 * passing to handler any error messages.
&gt; 	 * @param args the String[] arguments for the build configuration
&gt; 	 * @param handler the IMessageHandler handler for any errors
&gt; 	 * @return AjBuildConfig per args, 
&gt; 	 *         which will be invalid unless there are no handler errors.
&gt; 	 */
&gt; 	public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {
&gt; 		return genBuildConfig(args, handler, true);
&gt; 	}  
&gt;       
98a111
&gt;      * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
102c115
&lt; 	public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {
---
&gt; 	public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, boolean setClasspath) {
156c169,171
&lt; 			buildConfig.setClasspath(getClasspath(parser));
---
&gt; 			if (setClasspath) {
&gt; 				buildConfig.setClasspath(getClasspath(parser));
&gt; 			}
</file>
</fixedFiles>
</bug>
<bug id="40824" transactionid="74128">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="13"/>
<property name="lines-churned" value="13"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if M O-- O-!= T V Y Z-if</fullfingerprint>
<bugreport>"declare parents" member declarations report their kind as "method" instead of 
what they are.</bugreport>
<pre-fix-testcases failing="112" file="output/40824/pre-fix/testresults.xml" passing="986" size="1098"/>
<post-fix-testcases failing="111" file="output/40824/post-fix/testresults.xml" passing="987" size="1098"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java" revision="1.12" state="changed">291,292c291,303
&lt; 			if (label.indexOf("warning") != -1) kind = ProgramElementNode.Kind.DECLARE_WARNING;
&lt; 			if (label.indexOf("error") != -1) kind = ProgramElementNode.Kind.DECLARE_ERROR;
---
&gt; 			
&gt; 			// TODO: fix this horrible way of checking what kind of declare it is
&gt; 			if (label.indexOf("warning") != -1) {
&gt; 				kind = ProgramElementNode.Kind.DECLARE_WARNING;
&gt; 			} else if (label.indexOf("error") != -1) {
&gt; 				kind = ProgramElementNode.Kind.DECLARE_ERROR;
&gt; 			} else if (label.indexOf("parents") != -1) {
&gt; 				kind = ProgramElementNode.Kind.DECLARE_PARENTS;
&gt; 			} else if (label.indexOf("soft") != -1) {
&gt; 				kind = ProgramElementNode.Kind.DECLARE_SOFT;
&gt; 		    } else {
&gt; 				kind = ProgramElementNode.Kind.ERROR;	
&gt; 			}
296c307
&lt; 		} 
---
&gt; 		}
</file>
</fixedFiles>
</bug>
<bug id="41123" transactionid="72519">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="9"/>
<property name="lines-added" value="23"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="25"/>
<property name="priority" value="P2"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-import K-new K-null K-true M O-+ T V Y Z-if</fullfingerprint>
<bugreport>Sample run that fails using injars:
C:\devel\test\libraryWeave&gt;ajc ajee\testing\ExecutionMonitor.aj

C:\devel\test\libraryWeave&gt;jar cf ajee.jar ajee\testing\*.class

C:\devel\test\libraryWeave&gt;ajc -injars ajee.jar model\BusObj.java 
model\MonitorB
usObj.java
C:\devel\test\libraryWeave\model\BusObj.java:3 Class must implement the 
inherite
d abstract method ExecutionMonitor.MonitoredItem.ajc$interMethodDispatch2
$ajee_t
esting_ExecutionMonitor$record(String, String)
public class BusObj {
             ^^^^^^

1 error

It works in a single pass compilation:
C:\devel\test\libraryWeave&gt;ajc ajee\testing\ExecutionMonitor.aj 
model\BusObj.jav
a model\MonitorBusObj.java

C:\devel\test\libraryWeave&gt;

Sample source code:
package ajee.testing;

public aspect ExecutionMonitor {
    public interface MonitoredItem {}
    private void MonitoredItem.record(String eventType, String eventName) {}
}         
---
package model;

public class BusObj {

}
---
package model;

import ajee.testing.ExecutionMonitor;

public aspect MonitorBusObj {
    declare parents: BusObj implements ExecutionMonitor.MonitoredItem;
}</bugreport>
<testsforfix ID="41123" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml"/>
  </testsforfix>
<pre-fix-testcases failing="123" file="output/41123/pre-fix/testresults.xml" passing="999" size="1122"/>
<post-fix-testcases failing="122" file="output/41123/post-fix/testresults.xml" passing="1004" size="1126"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.12" state="changed">163c163
&lt; 			//System.out.println("mungers: " + mungers);
---
&gt; 			//System.out.println(onType + " mungers: " + mungers);
237a238,243
&gt; 				if (dangerousInterfaces.containsKey(parent)) {
&gt; 					ResolvedTypeX onType = factory.fromEclipse(sourceType);
&gt; 					factory.showMessage(IMessage.ERROR, 
&gt; 										onType + ": " + dangerousInterfaces.get(parent),
&gt; 										onType.getSourceLocation(), null);
&gt; 				}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java" revision="1.16" state="changed">32a33
&gt; import org.apache.bcel.classfile.Synthetic;
37a39
&gt; import org.apache.bcel.generic.ConstantPoolGen;
87a90,91
&gt;     private boolean isSynthetic = false;
&gt;     
704a709,715
&gt;         
&gt;         if (isSynthetic) {
&gt; 			ConstantPoolGen cpg = gen.getConstantPool();
&gt; 			int index = cpg.addUtf8("Synthetic");
&gt; 			gen.addAttribute(new Synthetic(index, 0, new byte[0], cpg.getConstantPool()));
&gt;         }
&gt;         
713a725,728
&gt;     
&gt;     public void makeSynthetic() {
&gt;     	isSynthetic = true;
&gt;     }    	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.11" state="changed">226c226
&lt; 		return new LazyMethodGen(
---
&gt; 		LazyMethodGen ret = new LazyMethodGen(
232a233,234
&gt; 		ret.makeSynthetic();
&gt; 		return ret;
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.96" state="changed">6669a6670,6705
&gt; 		
&gt; 	&lt;ajc-test dir="bugs/moreInterfaceLibrary"
&gt; 		pr="41123"
&gt; 		title="Weaving failure when using injars (no jars)"&gt;
&gt; 		&lt;compile
&gt; 			files="lib/ExecutionMonitor.aj,model/BusObj.java,model/MonitorBusObj.java"&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
&gt; 	
&gt; 	&lt;ajc-test dir="bugs/moreInterfaceLibrary"
&gt; 		pr="41123"
&gt; 		title="Weaving failure when using injars (on aspectpath)"&gt;
&gt; 		&lt;compile
&gt; 			files="model/BusObj.java,model/MonitorBusObj.java"
&gt; 			aspectpath="lib.jar"&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
&gt; 
&gt; 	&lt;ajc-test dir="bugs/moreInterfaceLibrary"
&gt; 		pr="41123"
&gt; 		title="Weaving failure when using injars (on classpath)"&gt;
&gt; 		&lt;compile
&gt; 			files="model/BusObj.java,model/MonitorBusObj.java"
&gt; 			classpath="lib.jar"&gt;
&gt; 		    &lt;message kind="error" line="3"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
&gt; 	
&gt; 	&lt;ajc-test dir="bugs/moreInterfaceLibrary"
&gt; 		pr="41123"
&gt; 		title="Weaving failure when using injars (actual injars)"&gt;
&gt; 		&lt;compile
&gt; 			files="model/BusObj.java,model/MonitorBusObj.java,lib.jar"&gt;
&gt; 		    &lt;message kind="error" line="3"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/moreInterfaceLibrary/lib/ExecutionMonitor.aj" revision="1.1" state="new">package lib;&#13;
&#13;
public aspect ExecutionMonitor {&#13;
    public interface MonitoredItem {}&#13;
    private void MonitoredItem.record(String eventType, String eventName) {}&#13;
}   </file>
<file name="org.aspectj/modules/tests/bugs/moreInterfaceLibrary/model/BusObj.java" revision="1.1" state="new">package model;

public class BusObj {

}
</file>
<file name="org.aspectj/modules/tests/bugs/moreInterfaceLibrary/model/MonitorBusObj.java" revision="1.1" state="new">package model;

import lib.ExecutionMonitor;

public aspect MonitorBusObj {
	declare parents: BusObj implements ExecutionMonitor.MonitoredItem;
}</file>
<file name="org.aspectj/modules/tests/bugs/moreInterfaceLibrary/lib.jar" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="41952" transactionid="72543">
<property name="files-churned" value="16"/>
<property name="java-files-churned" value="15"/>
<property name="classes-churned" value="15"/>
<property name="methods-churned" value="15"/>
<property name="hunks" value="42"/>
<property name="lines-added" value="159"/>
<property name="lines-deleted" value="9"/>
<property name="lines-modified" value="74"/>
<property name="lines-churned" value="242"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-else K-false K-for K-if K-import K-instanceof K-new K-null K-return K-this K-throw K-true K-try M O-== O-|| O-! O-!= O-?: O-() O-&amp;&amp; O-+ O-cast O-instanceof T V Y Z-cast Z-cond Z-for Z-if Z-throw Z-vardecl</fullfingerprint>
<bugreport>Some would like an XLint compiler warning when the user in a call PCD specifies
a declaring type that is not the defining type, because that constrains the join
points to those whose bytecode signature contain the specified type as the
declaring type.  e.g., 

----
class A { void run() {} }
class B extends A {}
aspect C {
    before() : call(void B.run()) { } // warn here
}
public class Main {
    public static void main(String[] args) {
        // ok with -1.4; otherwise, becomes A.run in bytecode
        new B().run();        
        // never works - compile-time type of reference is A, not B
        ((A) new B()).run();
}
----
This warning is useful for two reasons.  First, the user probably intended that
any call to an instance of that object be picked out (regardless of the
compile-time type of the reference used to make the call), and thus should use

   target(B) &amp;&amp; call(void run())

(This suggestion could be in the XLint message.)

Second, older compilers (i.e., compilers not using -1.4) would incorrectly
specify the declaring type of the method call as the first type in the hierarchy
which defined the method, so even if the user meant to constrain the join point
by the compile-time reference type, the bytecode signature could be incorrect
and the pointcut fail to pick out the join point.

One problem with this XLint warning is that is also picks out valid declare
warning/error statements enforcing requirements at compile-time about the type
of the reference used to invoke a method (e.g., when using a static reference of
the wrong type).  So perhaps the default level should be ignore.

See also bug 41888.</bugreport>
<testsforfix ID="41952" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="XLint warning for call PCD's using subtype of defining type"/>
      <test NAME="(-Xlint:ignore) XLint warning for call PCD's using subtype of defining type"/>
      <test NAME="(-1.4) XLint warning for call PCD's using subtype of defining type"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="85" file="output/41952/pre-fix/testresults.xml" passing="1103" size="1188"/>
<post-fix-testcases failing="85" file="output/41952/post-fix/testresults.xml" passing="1106" size="1191"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java" revision="1.15" state="changed">274c274
&lt; 				return pointcutDec.getPointcut().concretize1(searchStart, newBindings);
---
&gt; 				return pointcutDec.getPointcut().concretize(searchStart, newBindings);
282a283,287
&gt;     
&gt;     // We want to keep the original source location, not the reference location
&gt;     protected boolean shouldCopyLocationForConcretize() {
&gt;         return false;
&gt;     }
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java" revision="1.5" state="changed">76c76
&lt;     	return "ExactTypePattern(" + type.toString() + (includeSubtypes ? "+" : "") + ")";
---
&gt;     	return type.toString() + (includeSubtypes ? "+" : "");
</file>
<file name="org.aspectj/modules/bridge/src/org/aspectj/bridge/MessageUtil.java" revision="1.7" state="changed">762,765c762,764
&lt;         StringBuffer result = new StringBuffer();
&lt;         
&lt;         result.append(message.getKind().toString());
&lt;         result.append(" ");
---
&gt;        
&gt;         ISourceLocation loc = message.getSourceLocation();
&gt;         String locString = (null == loc ? "" : " at " + loc);
767,770c766,771
&lt;         String messageString = message.getMessage();
&lt;         if (!LangUtil.isEmpty(messageString)) {
&lt;             result.append(messageString);
&lt;             result.append(" ");
---
&gt;         String result = message.getKind() + locString + " " + message.getMessage();
&gt;       
&gt;         Throwable thrown = message.getThrown();
&gt;         if (thrown != null) {
&gt;             result += " -- " + LangUtil.renderExceptionShort(thrown);  
&gt;             result += "\n" + LangUtil.renderException(thrown, elide);         
772,775c773,775
&lt; 
&lt;         ISourceLocation loc = message.getSourceLocation();
&lt;         if ((null != loc) &amp;&amp; (loc != ISourceLocation.EMPTY)) {
&lt;             result.append("at " + renderSourceLocation(loc));
---
&gt;         
&gt;         if (message.getExtraSourceLocations().isEmpty()) {
&gt;             return result;    
777,780c777,778
&lt;         Throwable thrown = message.getThrown(); 
&lt;         if (null != thrown) {
&lt;             result.append(" -- " + LangUtil.renderExceptionShort(thrown));
&lt;             result.append("\n" + LangUtil.renderException(thrown, elide));            
---
&gt;         else {
&gt;             return addExtraSourceLocations(message, result);    
782d779
&lt;         return result.toString();
783a781,804
&gt; 
&gt; 	public static String addExtraSourceLocations(
&gt; 		IMessage message,
&gt; 		String baseMessage)
&gt; 	{
&gt; 		StringWriter buf = new StringWriter();
&gt; 		PrintWriter writer = new PrintWriter(buf);
&gt; 		writer.println(baseMessage);
&gt; 		for (Iterator iter = message.getExtraSourceLocations().iterator(); iter.hasNext();) {
&gt; 		    ISourceLocation element = (ISourceLocation) iter.next();
&gt; 		    writer.print("\tsee also: " + element.toString());
&gt; 		    if (iter.hasNext()) {
&gt; 		        writer.println();
&gt; 		    }
&gt; 		}
&gt; 		try { buf.close(); } 
&gt; 		catch (IOException ioe) {} 
&gt; 		return buf.getBuffer().toString();    
&gt; 	}
&gt;     
&gt;     
&gt;     
&gt;     
&gt;     
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java" revision="1.7" state="changed">16c16,18
&lt; import java.io.*;
---
&gt; import java.io.DataInputStream;
&gt; import java.io.DataOutputStream;
&gt; import java.io.IOException;
17a20
&gt; import org.aspectj.bridge.ISourceLocation;
19c22,29
&lt; import org.aspectj.weaver.*;
---
&gt; import org.aspectj.weaver.Checker;
&gt; import org.aspectj.weaver.ISourceContext;
&gt; import org.aspectj.weaver.IntMap;
&gt; import org.aspectj.weaver.ResolvedTypeX;
&gt; import org.aspectj.weaver.Shadow;
&gt; import org.aspectj.weaver.ShadowMunger;
&gt; import org.aspectj.weaver.TypeX;
&gt; import org.aspectj.weaver.World;
25a36,37
&gt;     
&gt;     private ShadowMunger munger = null; // only set after concretization
27,32c39,52
&lt; 	public KindedPointcut(
&lt; 		Shadow.Kind kind,
&lt; 		SignaturePattern signature) {
&lt; 		this.kind = kind;
&lt; 		this.signature = signature;
&lt; 	}
---
&gt;     public KindedPointcut(
&gt;         Shadow.Kind kind,
&gt;         SignaturePattern signature) {
&gt;         this.kind = kind;
&gt;         this.signature = signature;
&gt;     }
&gt;     public KindedPointcut(
&gt;         Shadow.Kind kind,
&gt;         SignaturePattern signature,
&gt;         ShadowMunger munger)
&gt;     {
&gt;         this(kind, signature);
&gt;         this.munger = munger;
&gt;     }
40c60,65
&lt; 		if (!signature.matches(shadow.getSignature(), shadow.getIWorld())) return  FuzzyBoolean.NO;
---
&gt; 		if (!signature.matches(shadow.getSignature(), shadow.getIWorld())){
&gt;             if(kind == Shadow.MethodCall) {
&gt;                 warnOnConfusingSig(shadow);
&gt;             }
&gt;             return  FuzzyBoolean.NO; 
&gt;         }
44a70,123
&gt; 	private void warnOnConfusingSig(Shadow shadow) {
&gt;         // no warnings for declare error/warning
&gt;         if (munger instanceof Checker) return;
&gt;         
&gt;         World world = shadow.getIWorld();
&gt;         
&gt; 		// warning never needed if the declaring type is any
&gt; 		TypeX exactDeclaringType = signature.getDeclaringType().getExactType();
&gt;         
&gt; 		ResolvedTypeX shadowDeclaringType =
&gt; 			shadow.getSignature().getDeclaringType().resolve(world);
&gt;         
&gt; 		if (signature.getDeclaringType().isStar()
&gt; 			|| exactDeclaringType== ResolvedTypeX.MISSING)
&gt; 			return;
&gt; 
&gt;         // warning not needed if match type couldn't ever be the declaring type
&gt; 		if (!shadowDeclaringType.isAssignableFrom(exactDeclaringType)) {
&gt;             return;
&gt; 		}
&gt; 
&gt; 		// if the method in the declaring type is *not* visible to the
&gt; 		// exact declaring type then warning not needed.
&gt; 		int shadowModifiers = shadow.getSignature().getModifiers(world);
&gt; 		if (!ResolvedTypeX
&gt; 			.isVisible(
&gt; 				shadowModifiers,
&gt; 				shadowDeclaringType,
&gt; 				exactDeclaringType.resolve(world))) {
&gt; 			return;
&gt; 		}
&gt; 
&gt; 		SignaturePattern nonConfusingPattern =
&gt; 			new SignaturePattern(
&gt; 				signature.getKind(),
&gt; 				signature.getModifiers(),
&gt; 				signature.getReturnType(),
&gt; 				TypePattern.ANY,
&gt; 				signature.getName(), 
&gt; 				signature.getParameterTypes(),
&gt; 				signature.getThrowsPattern());
&gt; 
&gt; 		if (nonConfusingPattern
&gt; 			.matches(shadow.getSignature(), shadow.getIWorld())) {
&gt;                 shadow.getIWorld().getLint().unmatchedSuperTypeInCall.signal(
&gt;                     new String[] {
&gt;                         shadow.getSignature().getDeclaringType().toString(),
&gt;                         signature.getDeclaringType().toString()
&gt;                     },
&gt;                     this.getSourceLocation(),
&gt;                     new ISourceLocation[] {shadow.getSourceLocation()} );               
&gt; 		}
&gt; 	}
&gt; 
105c184,186
&lt; 		return new KindedPointcut(kind, signature);
---
&gt; 		Pointcut ret = new KindedPointcut(kind, signature, bindings.getEnclosingAdvice());
&gt;         ret.copyLocationFrom(this);
&gt;         return ret;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/NotPointcut.java" revision="1.5" state="changed">94c94
&lt; 		return new NotPointcut(body.concretize1(inAspect, bindings));
---
&gt; 		return new NotPointcut(body.concretize(inAspect, bindings));
</file>
<file name="org.aspectj/modules/bridge/src/org/aspectj/bridge/Message.java" revision="1.4" state="changed">20a21,24
&gt; import java.util.Arrays;
&gt; import java.util.Collections;
&gt; import java.util.Iterator;
&gt; import java.util.List;
32a37
&gt;     private final List/*SourceLocation*/ extraSourceLocations;
63c68
&lt; 		ISourceLocation sourceLocation) {
---
&gt; 		ISourceLocation sourceLocation, Throwable thrown, ISourceLocation[] extraSourceLocations) {
65c70
&lt; 		this.message = message;
---
&gt; 		this.message = (message==null) ? thrown.getMessage() : message;
68,75c73,76
&lt; 		this.thrown = null;
&lt; 		if (null == message) {
&lt; 			if (null != thrown) {
&lt; 				message = thrown.getMessage();
&lt; 			} 
&lt; 			if (null == message) {
&lt; 				throw new IllegalArgumentException("null message");
&lt; 			}
---
&gt; 		this.thrown = thrown;
&gt;         
&gt; 		if (extraSourceLocations != null) {
&gt; 			this.extraSourceLocations = Arrays.asList(extraSourceLocations);
76a78,80
&gt;         else {
&gt;             this.extraSourceLocations = Collections.EMPTY_LIST;
&gt;         }
95,110c99,115
&lt;         this.message = message;
&lt;         this.kind = kind;
&lt;         this.thrown = thrown;
&lt;         this.sourceLocation = sourceLocation;
&lt;         this.details = "";
&lt;         if (null == message) {
&lt;             if (null != thrown) {
&lt;                 message = thrown.getMessage();
&lt;             } 
&lt;             if (null == message) {
&lt;                 throw new IllegalArgumentException("null message");
&lt;             }
&lt;         }
&lt;         if (null == kind) {
&lt;              throw new IllegalArgumentException("null kind");
&lt;         }
---
&gt;           this(message, "", kind, sourceLocation, thrown, null );              
&gt; //        this.message = message;
&gt; //        this.kind = kind;
&gt; //        this.thrown = thrown;
&gt; //        this.sourceLocation = sourceLocation;
&gt; //        this.details = "";
&gt; //        if (null == message) {
&gt; //            if (null != thrown) {
&gt; //                message = thrown.getMessage();
&gt; //            } 
&gt; //            if (null == message) {
&gt; //                throw new IllegalArgumentException("null message");
&gt; //            }
&gt; //        }
&gt; //        if (null == kind) {
&gt; //             throw new IllegalArgumentException("null kind");
&gt; //        }
168c173
&lt;         return Message.renderToString(this);
---
&gt;         return MessageUtil.renderMessage(this,false);
171,177d175
&lt;     public static String renderToString(IMessage message) { 
&lt;         ISourceLocation loc = message.getSourceLocation();
&lt;         String locString = (null == loc ? "" : " at " + loc);
&lt;         Throwable thrown = message.getThrown();
&lt;         return message.getKind() + locString + ": " + message.getMessage()
&lt;             + (null == thrown ? "" : render(thrown));
&lt;     }
202a201,205
&gt;     
&gt; 	public List getExtraSourceLocations() {
&gt; 		return extraSourceLocations;
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/bridge/src/org/aspectj/bridge/IMessage.java" revision="1.5" state="changed">126a127,128
&gt;     
&gt;     public List getExtraSourceLocations();
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java" revision="1.16" state="changed">435c435,440
&lt;             return sb.toString();
---
&gt;             if (message.getExtraSourceLocations().isEmpty()) {
&gt; 				return sb.toString();
&gt;             } else {
&gt;             	return MessageUtil.addExtraSourceLocations(message, sb.toString());
&gt;             }
&gt;             
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Lint.java" revision="1.8" state="changed">49c49,52
&lt; 		
---
&gt; 
&gt;     public final Kind unmatchedSuperTypeInCall = 
&gt;         new Kind("unmatchedSuperTypeInCall", "does not match because declaring type is {0}, if match desired use target({1})");
&gt;             
151a155,163
&gt; 
&gt; 		public void signal(String[] infos, ISourceLocation location, ISourceLocation[] extraLocations) {
&gt;             if (kind == null) return;
&gt;             
&gt;             String text = MessageFormat.format(message, infos );
&gt;             text += " [Xlint:" + name + "]";
&gt;             world.getMessageHandler().handleMessage(
&gt;                 new Message(text, "", kind, location, null, extraLocations));
&gt; 		}
</file>
<file name="org.aspectj/modules/testing/src/org/aspectj/testing/xml/SoftMessage.java" revision="1.7" state="changed">17a18
&gt; import java.util.Collections;
289a291,297
&gt; 
&gt; 	/* (non-Javadoc)
&gt; 	 * @see org.aspectj.bridge.IMessage#getExtraSourceLocations()
&gt; 	 */
&gt; 	public List getExtraSourceLocations() {
&gt; 		return Collections.EMPTY_LIST;
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/Pointcut.java" revision="1.8" state="changed">125c125
&lt; 		assertState(RESOLVED);
---
&gt; 		//!!! add this test -- assertState(RESOLVED);
126a127
&gt;         if (shouldCopyLocationForConcretize()) ret.copyLocationFrom(this);
131a133,137
&gt; 	protected boolean shouldCopyLocationForConcretize() {
&gt; 		return true;
&gt; 	}
&gt; 
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/XlintDefault.properties" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/bridge/src/org/aspectj/bridge/SourceLocation.java" revision="1.6" state="changed">138c138
&lt;         sb.append("" + startLine + "-" + endLine);
---
&gt;         sb.append(startLine); //"" + startLine + "-" + endLine);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Checker.java" revision="1.11" state="changed">52c52,54
&lt; 				shadow.getSourceLocation());
---
&gt; 				shadow.getSourceLocation(),
&gt;                 null,
&gt;                 new ISourceLocation[]{this.getSourceLocation()});
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java" revision="1.9" state="changed">240a241,268
&gt; 	/**
&gt; 	 * @return
&gt; 	 */
&gt; 	public ModifiersPattern getModifiers() {
&gt; 		return modifiers;
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * @return
&gt; 	 */
&gt; 	public TypePatternList getParameterTypes() {
&gt; 		return parameterTypes;
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * @return
&gt; 	 */
&gt; 	public TypePattern getReturnType() {
&gt; 		return returnType;
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * @return
&gt; 	 */
&gt; 	public ThrowsPattern getThrowsPattern() {
&gt; 		return throwsPattern;
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/OrPointcut.java" revision="1.6" state="changed">91,92c91,92
&lt; 		return new OrPointcut(left.concretize1(inAspect, bindings),
&lt; 								right.concretize1(inAspect, bindings));
---
&gt; 		return new OrPointcut(left.concretize(inAspect, bindings),
&gt; 								right.concretize(inAspect, bindings));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AndPointcut.java" revision="1.6" state="changed">88,89c88,89
&lt; 		return new AndPointcut(left.concretize1(inAspect, bindings),
&lt; 								right.concretize1(inAspect, bindings));
---
&gt; 		return new AndPointcut(left.concretize(inAspect, bindings),
&gt; 								right.concretize(inAspect, bindings));
</file>
<file name="org.aspectj/modules/tests/new/CallTypesI.java" revision="1.2" state="changed">56c56
&lt; interface I2 extends I1a, I1b {}
---
&gt; ////interface I2 extends I1a, I1b {}
76a77
&gt;     
79a81
&gt;     
</file>
<file name="org.aspectj/modules/tests/new/IndeterminateArgType.java" revision="1.2" state="changed">100c100,101
&lt;     pointcut safe()                                : call(Safe+.new(..)) || call(* Safe+.*(..)); 
---
&gt;     pointcut safe()                                : (call(Safe+.new(..))) ||
&gt;                                                         (call(* *.*(..)) &amp;&amp; target(Safe)); 
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.116" state="changed">2789c2789
&lt;         &lt;compile files="Simple.java"/&gt;
---
&gt;         &lt;compile files="Simple.java" options="-Xlint:ignore"/&gt;
3511c3511
&lt;         &lt;compile files="MethodSignatures.java" options="-1.4"/&gt;
---
&gt;         &lt;compile files="MethodSignatures.java" options="-1.4,-Xlint:ignore"/&gt;
3534c3534
&lt;         &lt;compile files="CallTypes.java" options="-1.4"/&gt;
---
&gt;         &lt;compile files="CallTypes.java" options="-1.4,-Xlint:ignore"/&gt;
3701c3701
&lt;         &lt;compile files="CallTypesI.java" options="-1.4"/&gt;
---
&gt;         &lt;compile files="CallTypesI.java" options="-1.4,-Xlint:ignore"/&gt;
3809c3809
&lt;         &lt;compile files="PR519.java"/&gt;
---
&gt;         &lt;compile files="PR519.java" options="-Xlint:ignore"/&gt;
4226c4226
&lt;         &lt;compile files="IntroductionsOverriding.java"/&gt;
---
&gt;         &lt;compile files="IntroductionsOverriding.java" options="-Xlint:ignore" /&gt;
4233c4233
&lt;         &lt;compile files="MultiAndAround.java"/&gt;
---
&gt;         &lt;compile files="MultiAndAround.java" options="-Xlint:ignore"/&gt;
4270c4270
&lt;         &lt;compile files="NotAndDeclaringTypes.java"/&gt;
---
&gt;         &lt;compile files="NotAndDeclaringTypes.java" options="-Xlint:ignore"/&gt;
5040c5040
&lt;         &lt;compile files="Driver.java,p1/C1.java,p1/p2/C2.java"/&gt;
---
&gt;         &lt;compile files="Driver.java,p1/C1.java,p1/p2/C2.java" /&gt;
6824c6824
&lt;     
---
&gt; 
6851a6852,6885
&gt; 
&gt; 	&lt;ajc-test dir="bugs"
&gt; 		title="XLint warning for call PCD's using subtype of defining type"
&gt; 		pr="41952"
&gt; 		&gt;
&gt; 		&lt;compile 
&gt; 			files="DeclaringTypeWarning.java" &gt;
&gt; 			&lt;!-- Should test for extra source locations lines 12 and 14 --&gt;
&gt; 			&lt;message kind="warning" line="6"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 		&lt;/ajc-test&gt;
&gt; 
&gt; 	&lt;ajc-test dir="bugs"
&gt; 		title="(-Xlint:ignore) XLint warning for call PCD's using subtype of defining type"
&gt; 		pr="41952"
&gt; 		&gt;
&gt; 		&lt;compile
&gt; 			options="-Xlint:ignore" 
&gt; 			files="DeclaringTypeWarning.java" &gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
&gt; 	
&gt; 	&lt;ajc-test dir="bugs"
&gt; 		title="(-1.4) XLint warning for call PCD's using subtype of defining type"
&gt; 		pr="41952"
&gt; 		&gt;
&gt; 		&lt;compile
&gt; 			options="-1.4" 
&gt; 			files="DeclaringTypeWarning.java" &gt;
&gt; 			&lt;!-- Should test for extra source locations line 14 --&gt;
&gt; 			&lt;message kind="warning" line="6"/&gt;
&gt; 			&lt;message kind="error" line="12" /&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/new/IndeterminateArg.java" revision="1.2" state="changed">123c123,124
&lt;     pointcut safe()                                : (call(C+.new(..)) || call(* C+.*(..))); 
---
&gt;     pointcut safe()                                : (call(C+.new(..))) ||
&gt;                                                         (call(* *.*(..)) &amp;&amp; target(C)); 
</file>
<file name="org.aspectj/modules/tests/bugs/DeclaringTypeWarning.java" revision="1.1" state="new">
class A { void run() {} }
class B extends A {}
aspect C {
    before() : runB() { } // warn here
    pointcut runB(): call(void B.run());
    before() : call(int B.run()) {}
}
public class DeclaringTypeWarning {
    public static void main(String[] args) {
        // ok with -1.4; otherwise, becomes A.run in bytecode
        new B().run();        
        // never works - compile-time type of reference is A, not B
        ((A) new B()).run();
    }
}
aspect D {
    declare error : call(void B.run()) : // warn here
        "This should be the only error";
    
    declare error : call(int B.run()) :
        "This error should not happen";
}
</file>
</fixedFiles>
</bug>
<bug id="42539" transactionid="72362">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P2"/>
<property name="severity" value="major"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M Z-if</fullfingerprint>
<bugreport>Given the following point cut and advice:

public aspect ExceptionAspect
{
    pointcut exceptionThrower() : execution(public * ExceptionBugTest.*(..)
throws Exception+);

    declare warning : exceptionThrower() : "throws Exception+";
}

And the to be aspected code:

public class ExceptionBugTest
{

    class MyException extends Exception
    {
    }

    public void method1() throws Exception
    {
    }

    public void method2() throws MyException
    {
    }
}

listing file default.lst:
C:\temp\AJC Bug\ExceptionAspect.aj
C:\temp\AJC Bug\ExceptionBugTest.java


AJC does not advise ExceptionBugTest.method2().  The output from the compilation
is the following:
C:\temp\AJC Bug&gt;ajc -argfile default.lst -classpath %ASPECTJ_HOME%\lib\aspectjrt.jar
C:\eclipse\workspace\AJC Bug\ExceptionBugTest.java:11 throws Exception+

From the aspect-j mailing list, contributed by Jim Hugunin:
&amp;lt;detail&amp;gt;The bug was caused because the code for ThrowsPattern mistakenly
used the internal protected method TypePattern.matchesExactly instead of the
external public method TypePattern.matchesStatically.  Because the classes were
in the same package, Java's accessibility rules allowed this.  It would be nice
if there was an easy way to specifiy that a method could only be accessed from
subtypes.&amp;lt;/detail&amp;gt;</bugreport>
<testsforfix ID="42539" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml"/>
  </testsforfix>
<pre-fix-testcases failing="119" file="output/42539/pre-fix/testresults.xml" passing="1037" size="1156"/>
<post-fix-testcases failing="120" file="output/42539/post-fix/testresults.xml" passing="1037" size="1157"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java" revision="1.5" state="changed">94c94
&lt; 			if (typePattern.matchesExactly(types[i])) return true;	
---
&gt; 			if (typePattern.matchesStatically(types[i])) return true;	
</file>
<file name="org.aspectj/modules/tests/bugs/throwsSignature/ExceptionBugTest.java" revision="1.1" state="new">public class ExceptionBugTest {
    int x;
    class MyException extends Exception {}

    public void method1() throws Exception { x = 1; } // warning here

    public void method2() throws MyException { x = 2; } // warning here
}</file>
<file name="org.aspectj/modules/tests/bugs/throwsSignature/ExceptionAspect.java" revision="1.1" state="new">public aspect ExceptionAspect
{
    pointcut exceptionThrower() :
        execution(public * ExceptionBugTest.*(..) throws Exception+);

    declare warning : exceptionThrower() : "throws both";
    
    declare error : execution(public * ExceptionBugTest.*(..) throws Exception) : 
        "throws Exception";
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.99" state="changed">6722a6723,6732
&gt; 	
&gt; 	&lt;ajc-test dir="bugs/throwsSignature"
&gt; 		pr="42539"
&gt; 		title="throw derivative pointcuts not advised"&gt;
&gt; 		&lt;compile files="ExceptionBugTest.java,ExceptionAspect.java"&gt;
&gt; 		    &lt;message line="5" kind="warning" text="throws both"/&gt;
&gt; 		    &lt;message line="5" kind="error" text="throws Exception"/&gt;
&gt; 		    &lt;message line="7" kind="warning" text="throws both"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="42573" transactionid="71160">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="8"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="30"/>
<property name="lines-churned" value="38"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-new K-null K-return K-while M O-!= T V Z-if Z-while</fullfingerprint>
<bugreport>My -classpath entry in a config/.lst file was resolved relative to the working
directory rather than to the config/.lst file.  BuildArgParser.java looks like
this would also be true for bootclasspath and extdirs, but not for injars,
aspectpath, or sourceroots.</bugreport>
<testsforfix ID="42573" type="new">
    <file LOCATION="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java">
      <test NAME="testDefaultClasspathAndTargetCombo"/>
      <test NAME="testPathResolutionFromConfigArgs"/>
      <test NAME="testExtDirs"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/42573/pre-fix/testresults.xml" passing="1233" size="1345"/>
<post-fix-testcases failing="112" file="output/42573/post-fix/testresults.xml" passing="1234" size="1346"/>
<fixedFiles>
<file name="org.aspectj/modules/util/src/org/aspectj/util/ConfigParser.java" revision="1.6" state="changed">22a23
&gt;     protected File relativeDirectory = null;
71a73,74
&gt;         File oldRelativeDirectory = relativeDirectory; // for nested arg files;
&gt;         relativeDirectory = configFile.getParentFile();
72a76
&gt;         relativeDirectory = oldRelativeDirectory;
206c210,214
&lt;         return makeFile(getCurrentDir(), name);
---
&gt;         if (relativeDirectory != null) {
&gt;             return makeFile(relativeDirectory,name);
&gt;         } else {
&gt;             return makeFile(getCurrentDir(), name);
&gt;         }
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.27" state="changed">506c506,515
&lt; 					bootclasspath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
---
&gt; 					String bcpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
&gt; 					StringBuffer bcp = new StringBuffer();
&gt; 					StringTokenizer strTok = new StringTokenizer(bcpArg,File.pathSeparator);
&gt; 					while (strTok.hasMoreTokens()) {
&gt; 					    bcp.append(makeFile(strTok.nextToken()));
&gt; 					    if (strTok.hasMoreTokens()) {
&gt; 					        bcp.append(File.pathSeparator);
&gt; 					    }
&gt; 					}
&gt; 					bootclasspath = bcp.toString();
513c522,531
&lt; 					classpath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
---
&gt; 					String cpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
&gt; 					StringBuffer cp = new StringBuffer();
&gt; 					StringTokenizer strTok = new StringTokenizer(cpArg,File.pathSeparator);
&gt; 					while (strTok.hasMoreTokens()) {
&gt; 					    cp.append(makeFile(strTok.nextToken()));
&gt; 					    if (strTok.hasMoreTokens()) {
&gt; 					        cp.append(File.pathSeparator);
&gt; 					    }
&gt; 					}
&gt; 					classpath = cp.toString();
520c538,547
&lt; 					extdirs = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
---
&gt; 					String extdirsArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
&gt; 					StringBuffer ed = new StringBuffer();
&gt; 					StringTokenizer strTok = new StringTokenizer(extdirsArg,File.pathSeparator);
&gt; 					while (strTok.hasMoreTokens()) {
&gt; 					    ed.append(makeFile(strTok.nextToken()));
&gt; 					    if (strTok.hasMoreTokens()) {
&gt; 					        ed.append(File.pathSeparator);
&gt; 					    }
&gt; 					}					
&gt; 					extdirs = ed.toString();
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java" revision="1.15" state="changed">45c45
&lt; 	public void testDefaultClasspathAndTargetCombo() throws InvalidInputException {
---
&gt; 	public void testDefaultClasspathAndTargetCombo() throws Exception {
87a88,95
&gt;     		List cp = config.getClasspath();
&gt;     		boolean jar1Found = false;
&gt;     		boolean jar2Found = false;
&gt;     		for (Iterator iter = cp.iterator(); iter.hasNext();) {
&gt;                 String element = (String) iter.next();
&gt;                 if (element.indexOf("1.jar") != -1) jar1Found = true;
&gt;                 if (element.indexOf("2.jar") != -1) jar2Found = true;
&gt;             }
90c98
&lt;     			config.getClasspath().contains("1.jar"));
---
&gt;     			jar1Found);
93c101
&lt;     			config.getClasspath().contains("2.jar"));
---
&gt;     			jar2Found);
103a112,134
&gt; 	public void testPathResolutionFromConfigArgs() {
&gt; 		String FILE_PATH =   "@" + TEST_DIR + "configWithClasspathExtdirsBootCPArgs.lst";
&gt; 		AjBuildConfig config = genBuildConfig(new String[] { FILE_PATH }, messageWriter);
&gt; 		List classpath = config.getClasspath();
&gt; 		// should have three entries, resolved relative to location of .lst file
&gt; 		assertEquals("Three entries in classpath",3,classpath.size());
&gt; 		Iterator cpIter = classpath.iterator();
&gt; 		try {
&gt; 		    assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"xyz").getCanonicalPath(),cpIter.next());
&gt; 		    assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"myextdir" + File.separator + "dummy.jar").getCanonicalPath(),cpIter.next());
&gt; 		    assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"abc.jar").getCanonicalPath(),cpIter.next());
&gt; 			List files = config.getFiles();
&gt; 			assertEquals("Two source files",2,files.size());
&gt; 			Iterator fIter = files.iterator();
&gt; 			assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"Abc.java").getCanonicalFile(),fIter.next());
&gt; 			assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"xyz"+File.separator+"Def.aj").getCanonicalFile(),fIter.next());
&gt; 		    
&gt; 		} catch (IOException ex) {
&gt; 		    fail("Test case failure attempting to create canonical path: " + ex);
&gt; 		}
&gt; 		
&gt; 	}
&gt; 	
257c288
&lt; 	public void testExtDirs() throws InvalidInputException {
---
&gt; 	public void testExtDirs() throws Exception {
263c294
&lt; 			new File(DIR + File.separator + "testclasses.jar").getAbsolutePath()
---
&gt; 			new File(DIR + File.separator + "testclasses.jar").getCanonicalPath()
272c303
&lt; 		assertTrue(config.getClasspath().toString(), config.getClasspath().get(0).equals(PATH)); 
---
&gt; 		assertTrue(config.getClasspath().toString(), ((String)config.getClasspath().get(0)).indexOf(PATH) != -1); 
329a361,368
&gt;    		List cp = config.getClasspath();
&gt; 		boolean jar1Found = false;
&gt; 		boolean jar2Found = false;
&gt; 		for (Iterator iter = cp.iterator(); iter.hasNext();) {
&gt;             String element = (String) iter.next();
&gt;             if (element.indexOf("1.jar") != -1) jar1Found = true;
&gt;             if (element.indexOf("2.jar") != -1) jar2Found = true;
&gt;         }
332,333c371
&lt; 			config.getClasspath().contains("1.jar"));
&lt; 
---
&gt; 			jar1Found);
336c374
&lt; 			config.getClasspath().contains("2.jar"));
---
&gt; 			jar2Found);
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/ajc/configWithClasspathExtdirsBootCPArgs.lst" revision="1.1" state="new">-classpath
abc.jar
-bootclasspath
xyz
-extdirs
myextdir
Abc.java
xyz/Def.aj

</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/ajc/myextdir/dummy.jar" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="42993" transactionid="72358">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="11"/>
<property name="lines-added" value="38"/>
<property name="lines-deleted" value="12"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="53"/>
<property name="priority" value="P1"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-if K-instanceof K-return K-this K-true M O-&lt; O-&lt;= O-! O-() O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>The file AspectBug.java:

public aspect AspectBug extends AbstractCaching
perthis(execution(ContainerLoader+.new(..)))
{
	declare parents: ContainerDescriptor implements AbstractCaching.Key;

	protected pointcut loadExecutions( Key key ):
		ContainerLoader.containerLoads( *, key );
}

abstract aspect AbstractCaching  {
	interface Key {}
	protected abstract pointcut loadExecutions(Key key);
}

class Key {
}

class ContainerDescriptor {
}

class ActiveContainer {
}

class ContainerLoader {
	public ActiveContainer createContainer(ContainerDescriptor c) {
		return null;
	}

    public pointcut containerLoads(ContainerLoader loader,
								   
ContainerDescriptor containerDesc ):
        this(loader) &amp;&amp; args(containerDesc)
        &amp;&amp; execution(ActiveContainer ContainerLoader.createContainer
(ContainerDescriptor));
}

        First, here are the versions of AspectJ I'm using (this is a bash
        shell under cygwin on Windows XP):

~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc -
version
ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.1_02
~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc -
version
AspectJ Compiler 1.1.0
~&gt; CLASSPATH='C:\aspectj1.1.1rc1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc -version
AspectJ Compiler 1.1.1rc1
~&gt; CLASSPATH='C:\aspectj1.1.1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc -version
AspectJ Compiler 1.1.1

        For all four of these compilers, I give them the AspectBug.java file
	(which is attached):

~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc 
AspectBug.java
~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc 
AspectBug.java
~&gt; CLASSPATH='C:\aspectj1.1.1rc1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc AspectBug.java
~&gt; CLASSPATH='C:\aspectj1.1.1
\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc AspectBug.java
C:\Documents and Settings\Macneil Shonle\AspectBug.java:7 incompatible type, 
expected ContainerDescriptor found BindingTypePattern(AbstractCaching$Key, 0)

1 error

        As you can see, only the final run (with the Sept 11 build of
	ajc) do we see the "incompatible type" error. If this is not a
	regression but a desirable result, how should the code be ported?</bugreport>
<testsforfix ID="42993" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Interaction between pointcut binding and declare parents"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="120" file="output/42993/pre-fix/testresults.xml" passing="1004" size="1124"/>
<post-fix-testcases failing="121" file="output/42993/post-fix/testresults.xml" passing="1039" size="1160"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.22" state="changed">332c332
&lt; 		crosscuttingMembers.addDeclares(collectDeclares());
---
&gt; 		crosscuttingMembers.addDeclares(collectDeclares(!this.doesNotExposeShadowMungers()));
339c339
&lt; 	private final Collection collectDeclares() {
---
&gt; 	public final Collection collectDeclares(boolean includeAdviceLike) {
347a348,350
&gt;         
&gt;         if (!includeAdviceLike) return ret;
&gt;         
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.15" state="changed">95,106d94
&lt;             }
&lt;         }
&lt;         for (int i = lastCompletedUnitIndex + 1; i &lt;= lastUnitIndex; i++) {
&lt;             SourceTypeBinding[] b = units[i].scope.topLevelTypes;
&lt;             for (int j = 0; j &lt; b.length; j++) {
&lt;                 resolvePointcutDeclarations(b[j].scope);
&lt;             }
&lt;         }
&lt;         
&lt;         for (int i = lastCompletedUnitIndex + 1; i &lt;= lastUnitIndex; i++) {
&lt;             SourceTypeBinding[] b = units[i].scope.topLevelTypes;
&lt;             for (int j = 0; j &lt; b.length; j++) {
109c97,98
&lt;         }
---
&gt;         }        
&gt; 
121d109
&lt;             units[i] = null; // release unnecessary reference to the parsed unit
122a111,128
&gt;         
&gt;         for (int i = lastCompletedUnitIndex + 1; i &lt;= lastUnitIndex; i++) {
&gt;             SourceTypeBinding[] b = units[i].scope.topLevelTypes;
&gt;             for (int j = 0; j &lt; b.length; j++) {
&gt;                 resolvePointcutDeclarations(b[j].scope);
&gt;             }
&gt;         }
&gt;         
&gt;         for (int i = lastCompletedUnitIndex + 1; i &lt;= lastUnitIndex; i++) {
&gt;             SourceTypeBinding[] b = units[i].scope.topLevelTypes;
&gt;             for (int j = 0; j &lt; b.length; j++) {
&gt;                 addAdviceLikeDeclares(b[j].scope);
&gt;             }
&gt;         }
&gt;         
&gt;         for (int i = lastCompletedUnitIndex + 1; i &lt;= lastUnitIndex; i++) {
&gt;             units[i] = null; // release unnecessary reference to the parsed unit
&gt;         }
134a141,155
&gt;     
&gt;     private void addAdviceLikeDeclares(ClassScope s) {
&gt;         TypeDeclaration dec = s.referenceContext;
&gt;         
&gt;         if (dec instanceof AspectDeclaration) {
&gt;             ResolvedTypeX typeX = factory.fromEclipse(dec.binding);
&gt;             factory.getWorld().getCrosscuttingMembersSet().addAdviceLikeDeclares(typeX);
&gt;         }
&gt;         
&gt;         SourceTypeBinding sourceType = s.referenceContext.binding;
&gt;         ReferenceBinding[] memberTypes = sourceType.memberTypes;
&gt;         for (int i = 0, length = memberTypes.length; i &lt; length; i++) {
&gt;             addCrosscuttingStructures(((SourceTypeBinding) memberTypes[i]).scope);
&gt;         }
&gt;     }
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java" revision="1.6" state="changed">61a62,66
&gt;     
&gt;     public void addAdviceLikeDeclares(ResolvedTypeX aspectType) {
&gt;         CrosscuttingMembers xcut = (CrosscuttingMembers)members.get(aspectType);
&gt;         xcut.addDeclares(aspectType.collectDeclares(true));
&gt;     }
72c77
&lt; 	
---
&gt;     
142,145c147
&lt; 	}
&lt; 	
&lt; 	
&lt; 	
---
&gt; 	}	
</file>
<file name="org.aspectj/modules/tests/bugs/ParentsAndPointcuts.java" revision="1.1" state="new">import org.aspectj.testing.Tester;

public class ParentsAndPointcuts {
    public static void main(String[] args) {
        ContainerDescriptor d = new ContainerDescriptor();
        Tester.check(d instanceof AbstractCaching.Key, "instanceof");
    }
}

aspect AspectBug extends AbstractCaching
perthis(execution(ContainerLoader+.new(..)))
{
    declare parents: ContainerDescriptor implements AbstractCaching.Key;

    protected pointcut loadExecutions( Key key ):
        ContainerLoader.containerLoads( *, key );
}

abstract aspect AbstractCaching  {
    interface Key {}
    protected abstract pointcut loadExecutions(Key key);
}

class Key {
}

class ContainerDescriptor {
}

class ActiveContainer {
}

class ContainerLoader {
    public ActiveContainer createContainer(ContainerDescriptor c) {
        return null;
    }

    public pointcut containerLoads(ContainerLoader loader,
                                   
ContainerDescriptor containerDesc ):
        this(loader) &amp;&amp; args(containerDesc)
        &amp;&amp; execution(ActiveContainer ContainerLoader.createContainer
(ContainerDescriptor));
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.103" state="changed">6753a6754,6759
&gt; 	
&gt;     &lt;ajc-test dir="bugs" pr="42993"
&gt;    	    title="Interaction between pointcut binding and declare parents"&gt;
&gt;         &lt;compile files="ParentsAndPointcuts.java"/&gt;
&gt;         &lt;run class="ParentsAndPointcuts"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="43033" transactionid="70394">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-null M O-== O-?: O-() T V Z-cond</fullfingerprint>
<bugreport>This must be caused by the fix to concretization...

Input sources:
package base;

public abstract aspect ExceptionHandling {
    public abstract pointcut scope();
    declare soft: Exception: scope();
}

package model;

import base.ExceptionHandling;

public aspect ModelExceptionHandling extends ExceptionHandling {
    public pointcut scope() : within(*);

    protected RuntimeException convertCheckedException(Throwable t) {
        return new RuntimeException(t.getMessage(), t
}

Compiler output:
C:\eclipse\workspace\atrack&gt;ajc -d debug @narrow.lst
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\eclipse\workspace\atrack\src\org\atrack\model\error\impl\ModelExceptionHandl
i
ng.java:0 Internal compiler error
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
C:\eclipse\workspace\atrack\src\org\atrack\model\error\impl\ModelExceptionHandl
i
ng.java:23 Unmatched bracket
return new RuntimeException(t.getMessage(), t
                           ^
ABORT
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 2 errors

C:\eclipse\workspace\atrack&gt;cd \devel\test\excHandling\c1

C:\devel\test\excHandling\c1&gt;ajc base\ExceptionHandling.java 
model\ModelExceptio
nHandling.java
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
C:\devel\test\excHandling\c1\model\ModelExceptionHandling.java:0 Internal 
compil
er error
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


!! no source information available !!
C:\devel\test\excHandling\c1\model\ModelExceptionHandling.java:9 Unmatched 
brack
et
return new RuntimeException(t.getMessage(), t
                           ^
ABORT
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1
(ReferencePo
intcut.java:243)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)
        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclare
(CrosscuttingMembers
.java:111)
        at org.aspectj.weaver.CrosscuttingMembers.addDeclares
(CrosscuttingMember
s.java:92)
        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers
(ResolvedT
ypeX.java:332)
        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect
(Crosscut
tingMembersSet.java:50)
        at 
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy
peAndPerClause(AspectDeclaration.java:754)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn
terTypeAndPerClause(AjLookupEnvironment.java:124)
        at 
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet
eTypeBindings(AjLookupEnvironment.java:91)
        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile
(Compiler.ja
va:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:324)

        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:373)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuild
Manager.java:125)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBu
ildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort, 2 errors</bugreport>
<testsforfix ID="43033" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="NPE in concretization error path"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="122" file="output/43033/pre-fix/testresults.xml" passing="1039" size="1161"/>
<post-fix-testcases failing="121" file="output/43033/post-fix/testresults.xml" passing="1041" size="1162"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java" revision="1.14" state="changed">21d20
&lt; import org.apache.bcel.classfile.JavaClass;
24a24
&gt; import org.aspectj.weaver.ShadowMunger;
242a243
&gt; 				ShadowMunger enclosingAdvice = bindings.getEnclosingAdvice();
245c246,247
&lt; 					getSourceLocation(), bindings.getEnclosingAdvice().getSourceLocation());
---
&gt; 					getSourceLocation(), 
&gt; 					(null == enclosingAdvice) ? null : enclosingAdvice.getSourceLocation());
</file>
<file name="org.aspectj/modules/tests/bugs/concretizeNpe/base/ExceptionHandling.java" revision="1.1" state="new">package base;

public abstract aspect ExceptionHandling {
    public abstract pointcut scope();
    declare soft: Exception: scope();
}
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.105" state="changed">6765a6766,6777
&gt;     
&gt;   	&lt;ajc-test dir="bugs/concretizeNpe" pr="43033"
&gt; 		title="NPE in concretization error path"&gt;
&gt; 		&lt;compile files="base/ExceptionHandling.java,model/ModelExceptionHandling.java"&gt;
&gt; 		  &lt;message line="5" kind="error" text="pointcut base.ExceptionHandling.scope() is abstract"/&gt;
&gt; 		  &lt;message line="4" kind="error" text="inherited abstract pointcut base.ExceptionHandling.scope() is not made concrete"/&gt;
&gt; 		  &lt;message line="8" kind="error" text="inherited abstract pointcut base.ExceptionHandling.scope() is not made concrete"/&gt;
&gt; 		  &lt;message line="12" kind="error" text="Unmatched bracket"/&gt;
&gt; 		  &lt;message line="13" kind="error" text="Syntax error on token"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs/concretizeNpe/model/ModelExceptionHandling.java" revision="1.1" state="new">
package model;

import java.lang.RuntimeException;

import base.ExceptionHandling;

public aspect ModelExceptionHandling extends ExceptionHandling {
    public pointcut scope() : within(*);

    protected RuntimeException convertCheckedException(Throwable t) {
        return new RuntimeException(t.getMessage(),t
}
</file>
</fixedFiles>
</bug>
<bug id="43194" transactionid="72321">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P1"/>
<property name="severity" value="critical"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-this M</fullfingerprint>
<bugreport>See the attached file VerifyBug.jar for the source files. You won't need 
anything else to compiler and reproduce this bug:

~/bug&gt; ls
AbstractCaching.java   TreeNode.java         VerifyBug.jar
ContainerCaching.java  TreeNodeFolding.java  WorkspaceGroup.java
ContainerLoader.java   TreePanel.java        WorkspaceNode.java
Makefile               TreeWorkspace.java
~/bug&gt; gmake   
/cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1
\lib\aspectjrt.jar" -version
AspectJ Compiler 1.1.1

/cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar" 
*.java
java -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar;." TreeNode
java.lang.VerifyError: (class: TreeNode, method: doShowAction signature: ()V) 
Unable to pop operand off an empty stack
Exception in thread "main" make: *** [all] Error 1</bugreport>
<testsforfix ID="43194" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Non-functional concretezation of ReferencePointcut"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="121" file="output/43194/pre-fix/testresults.xml" passing="1039" size="1160"/>
<post-fix-testcases failing="78" file="output/43194/post-fix/testresults.xml" passing="402" size="480"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java" revision="1.13" state="changed">252c252
&lt; 			arguments = arguments.resolveReferences(bindings);
---
&gt; 			TypePatternList arguments = this.arguments.resolveReferences(bindings);
</file>
<file name="org.aspectj/modules/tests/bugs/AdviceInteraction.java" revision="1.1" state="new">public class AdviceInteraction {
    public static void main(String [] args) {
        new C().m1();
    }
}

class C {    
    public void m1() {}
    public void m2() {}
}

aspect A {    
    pointcut exec1(C c): this(c) &amp;&amp; execution(void m1());
    pointcut execs(C c): exec1(c); 
    
    before (): execs(*) {}
    before (C c):  execs(c) {}

    // This ordering works correctly
    pointcut exec2(C c): this(c) &amp;&amp; execution(void m2());
    pointcut execs2(C c): exec2(c); 
    
    before (C c):  execs2(c) {}
    before (): execs2(*) {}
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.104" state="changed">6759a6760,6765
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="43194"
&gt;    	 title="Non-functional concretezation of ReferencePointcut"&gt;
&gt;         &lt;compile files="AdviceInteraction.java"/&gt;
&gt;         &lt;run class="AdviceInteraction"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="43709" transactionid="74227">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P2"/>
<property name="severity" value="critical"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-else K-if K-null O-!= T V Y Z-if</fullfingerprint>
<bugreport>I have an library with an aspect that includes advice, which I compile into an 
outjar. In my client project I extend it, and make a concrete pointcut that 
results in the library aspect affecting parts of my system. 

There is a bug and an enhancement request here:

1) A bug: when you look at the structure view for affected classes, there is a 
problem if you try to navigate from calls to advice (in AJDT, it results in an 
NPE). Here is the stack trace in AJDT:
java.lang.NullPointerException
at org.aspectj.asm.internal.ProgramElement.toLinkLabelString
(ProgramElement.java:403)
at org.eclipse.ajdt.internal.core.AJDTStructureViewNode.getLabel
(AJDTStructureViewNode.java:171)
at org.eclipse.ajdt.internal.core.AJDTStructureViewNodeAdapter.getLabel
(AJDTStructureViewNodeAdapter.java:89)
at org.eclipse.ui.model.WorkbenchLabelProvider.getText
(WorkbenchLabelProvider.java:142)
at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:95)
at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run
(AbstractTreeViewer.java:87)
at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:1006)
at org.eclipse.core.runtime.Platform.run(Platform.java:413)
at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem
(AbstractTreeViewer.java:406)
at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run
(StructuredViewer.java:119)
at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:1006)
at org.eclipse.core.runtime.Platform.run(Platform.java:413)
at org.eclipse.jface.viewers.StructuredViewer.updateItem
(StructuredViewer.java:1271)
at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem
(AbstractTreeViewer.java:320)
at org.eclipse.jface.viewers.AbstractTreeViewer$1.run
(AbstractTreeViewer.java:303)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren
(AbstractTreeViewer.java:289)
at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand
(AbstractTreeViewer.java:697)
at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded
(AbstractTreeViewer.java:709)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:175)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:865)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:849)
at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:1909)
at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:3815)
at org.eclipse.swt.widgets.Composite.WM_NOTIFY(Composite.java:642)
at org.eclipse.swt.widgets.Control.windowProc(Control.java:2816)
at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361)
at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:1236)
at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:156)
at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:1517)
at org.eclipse.swt.widgets.Control.windowProc(Control.java:2799)
at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361)
at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1303)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1543)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:858)
at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
at org.eclipse.core.launcher.Main.run(Main.java:747)
at org.eclipse.core.launcher.Main.main(Main.java:583)
 

2) The enhancement request: the concrete aspect that applies the advice should 
also show what is affected in the project. Of course, it would also be nice to 
see how a given concrete library aspect in the aspect path affects your 
project too.</bugreport>
<pre-fix-testcases failing="119" file="output/43709/pre-fix/testresults.xml" passing="1043" size="1162"/>
<post-fix-testcases failing="121" file="output/43709/post-fix/testresults.xml" passing="1041" size="1162"/>
<fixedFiles>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/internal/ProgramElement.java" revision="1.12" state="changed">388a389,391
&gt; 	/**
&gt; 	 * TODO: move the "parent != null"==&gt;injar heuristic to more explicit 
&gt; 	 */
402,403c405,410
&lt; 		} else {
&lt; 			label = parent.getName() + '.';
---
&gt; 		} else { 
&gt; 			if (parent != null) {
&gt; 				label = parent.getName() + '.';
&gt; 			} else { 
&gt; 				label = "injar aspect: ";  
&gt; 			}
</file>
</fixedFiles>
</bug>
<bug id="43783" transactionid="74121">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="5"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="15"/>
<property name="lines-churned" value="20"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null M O-== T V Y Z-if</fullfingerprint>
<bugreport>AJDT is not very stable when an eclipse project contains errors like
missing classes, wrong package statements etc. etc. This may occurs when
refactoring a project (sometimes by changing the source outside eclipse).

Note I am using Eclipse 2.1.1, AJDT 1.1.4 + incremental compilation.

Generally a lot of exceptions will occur (mostly nullpointer). Here are some 
of them:

I:
java.lang.NullPointerException
	at org.aspectj.asm.internal.ProgramElement.toLinkLabelString
(ProgramElement.java:403)
	at org.eclipse.ajdt.internal.core.AJDTStructureViewNode.getLabel
(AJDTStructureViewNode.java:171)
	at org.eclipse.ajdt.internal.core.AJDTStructureViewNodeAdapter.getLabel
(AJDTStructureViewNodeAdapter.java:89)
	at org.eclipse.ui.model.WorkbenchLabelProvider.getText
(WorkbenchLabelProvider.java:142)

II:
java.lang.NullPointerException
	at org.eclipse.ajdt.internal.ui.editor.AspectJEditor$1.run
(AspectJEditor.java:242)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)

III:
java.lang.NullPointerException
	at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:79)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)
!</bugreport>
<pre-fix-testcases failing="122" file="output/43783/pre-fix/testresults.xml" passing="1040" size="1162"/>
<post-fix-testcases failing="121" file="output/43783/post-fix/testresults.xml" passing="1041" size="1162"/>
<fixedFiles>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java" revision="1.15" state="changed">75a76,80
&gt; 		if (configFile == null) {
&gt; 			Ajde.getDefault().getErrorHandler().handleError(
&gt; 				"Tried to build null config file."
&gt; 			);
&gt; 		}
89c94
&lt; 				signalWarning(
---
&gt; 				Ajde.getDefault().getErrorHandler().handleWarning(
106c111,112
&lt;             signalWarning("build cancelled by user");
---
&gt; 			Ajde.getDefault().getErrorHandler().handleWarning(
&gt; 				"build cancelled by user");
113c119
&lt;                 signalWarning(message.getMessage());
---
&gt; 				Ajde.getDefault().getErrorHandler().handleWarning(message.getMessage());
130c136
&lt;      * @param configFile
---
&gt;      * @param configFile	
138c144,146
&lt;             signalError("Config file \"" + configFile + "\" does not exist."); 
---
&gt; 			Ajde.getDefault().getErrorHandler().handleError(
&gt; 				"Config file \"" + configFile + "\" does not exist."
&gt; 			);
204,211c212,219
&lt;     /** signal error text to user */
&lt;     protected void signalError(String text) {
&lt;         Ajde.getDefault().getErrorHandler().handleError(text);
&lt;     }
&lt;     /** signal warning text to user */
&lt;     protected void signalWarning(String text) {
&lt;         Ajde.getDefault().getErrorHandler().handleWarning(text);
&lt;     }
---
&gt; //    /** signal error text to user */
&gt; //    protected void signalError(String text) {
&gt;         
&gt; //    } 
&gt; //    /** signal warning text to user */
&gt; //    protected void signalWarning(String text) {
&gt; //        
&gt; //    }
</file>
</fixedFiles>
</bug>
<bug id="44117" transactionid="74248">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null M O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>java.lang.NullPointerException
at org.aspectj.weaver.AsmRelationshipProvider.checkerMunger
(AsmRelationshipProvider.java:51)
at org.aspectj.weaver.Checker.match(Checker.java:58)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:985)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:791)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:291)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:316)
at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFile
s(AjBuildManager.java:256)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:156)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:70)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:103)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)</bugreport>
<pre-fix-testcases failing="121" file="output/44117/pre-fix/testresults.xml" passing="1041" size="1162"/>
<post-fix-testcases failing="121" file="output/44117/post-fix/testresults.xml" passing="1041" size="1162"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java" revision="1.5" state="changed">51c51,53
&lt; 			back.getTargets().add(sourceHandle);  
---
&gt; 			if (back != null &amp;&amp; back.getTargets() != null) {
&gt; 				back.getTargets().add(sourceHandle);   
&gt; 			}
</file>
</fixedFiles>
</bug>
<bug id="44191" transactionid="68999">
<property name="files-churned" value="7"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="7"/>
<property name="hunks" value="13"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="16"/>
<property name="lines-churned" value="16"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M Z-if</fullfingerprint>
<bugreport>I have experienced situations where IAJC outputs a message like this at the 
end of compilation.

    [iajc] can't find type org.xxx.SomeTest

In my case this was one time highly confusing since I did not expect the class 
in question to be referred anywhere in the project (I have to date still not 
located the reference). 

For such cases, it would be extremely nice if the error message would display 
WHY it need the class (i.e. the name of the refering class(es) or aspect(es) 
possibly with a reasonable cutoff as there is seldom need to list all 
referals). So I would like a message like this:

    [iajc] can't find type org.xxx.SomeTest referred by 
org.yyy.SomeClass,org.yy.SomeOtherClass ...</bugreport>
<pre-fix-testcases failing="112" file="output/44191/pre-fix/testresults.xml" passing="1234" size="1346"/>
<post-fix-testcases failing="113" file="output/44191/post-fix/testresults.xml" passing="1233" size="1346"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.30" state="changed">732,733c732,733
&lt;                     world.resolve(CLONEABLE), 
&lt;                     world.resolve(SERIALIZABLE)
---
&gt;                     world.getCoreType(CLONEABLE), 
&gt;                     world.getCoreType(SERIALIZABLE)
741c741
&lt;             return world.resolve(OBJECT);
---
&gt;             return world.getCoreType(OBJECT);
1067c1067
&lt; 						Arrays.asList(world.resolve(OBJECT).getDeclaredMethods()).iterator())) return;
---
&gt; 						Arrays.asList(world.getCoreType(OBJECT).getDeclaredMethods()).iterator())) return;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java" revision="1.15" state="changed">172,173c172,173
&lt; 		ResolvedTypeX runtimeException = world.resolve(TypeX.RUNTIME_EXCEPTION);
&lt; 		ResolvedTypeX error = world.resolve(TypeX.ERROR);
---
&gt; 		ResolvedTypeX runtimeException = world.getCoreType(TypeX.RUNTIME_EXCEPTION);
&gt; 		ResolvedTypeX error = world.getCoreType(TypeX.ERROR);
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java" revision="1.11" state="changed">74c74
&lt; 		if (binding.isInterface()) return getResolvedTypeX().getWorld().resolve(TypeX.OBJECT);
---
&gt; 		if (binding.isInterface()) return getResolvedTypeX().getWorld().getCoreType(TypeX.OBJECT);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclareParents.java" revision="1.9" state="changed">118c118
&lt; 		if (targetType.equals(world.resolve(TypeX.OBJECT))) {
---
&gt; 		if (targetType.equals(world.getCoreType(TypeX.OBJECT))) {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.36" state="changed">963c963
&lt; 				((BcelVar)getArgVar(0)).appendLoadAndConvert(il, fact, world.resolve(ResolvedTypeX.OBJECT));
---
&gt; 				((BcelVar)getArgVar(0)).appendLoadAndConvert(il, fact, world.getCoreType(ResolvedTypeX.OBJECT));
971,972c971,972
&lt; 				((BcelVar)getArgVar(0)).appendLoadAndConvert(il, fact, world.resolve(ResolvedTypeX.OBJECT));
&lt; 				((BcelVar)getArgVar(1)).appendLoadAndConvert(il, fact, world.resolve(ResolvedTypeX.OBJECT));
---
&gt; 				((BcelVar)getArgVar(0)).appendLoadAndConvert(il, fact, world.getCoreType(ResolvedTypeX.OBJECT));
&gt; 				((BcelVar)getArgVar(1)).appendLoadAndConvert(il, fact, world.getCoreType(ResolvedTypeX.OBJECT));
997c997
&lt;     				world.resolve(TypeX.forName("org.aspectj.lang.JoinPoint$StaticPart")),
---
&gt;     				world.getCoreType(TypeX.forName("org.aspectj.lang.JoinPoint$StaticPart")),
2033c2033
&lt; 			world.resolve(TypeX.OBJECTARRAY),
---
&gt; 			world.getCoreType(TypeX.OBJECTARRAY),
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java" revision="1.7" state="changed">89c89
&lt;     		if (!scope.getWorld().resolve(TypeX.THROWABLE).isAssignableFrom(excType)) {
---
&gt;     		if (!scope.getWorld().getCoreType(TypeX.THROWABLE).isAssignableFrom(excType)) {
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java" revision="1.27" state="changed">131c131
&lt; 			if (world.getWorld().resolve(TypeX.SERIALIZABLE).isAssignableFrom(myType)) {
---
&gt; 			if (world.getWorld().getCoreType(TypeX.SERIALIZABLE).isAssignableFrom(myType)) {
137c137
&lt; 			if (world.getWorld().resolve(TypeX.CLONEABLE).isAssignableFrom(myType)) {
---
&gt; 			if (world.getWorld().getCoreType(TypeX.CLONEABLE).isAssignableFrom(myType)) {
</file>
</fixedFiles>
</bug>
<bug id="44272" transactionid="71434">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint/>
<fullfingerprint>Y</fullfingerprint>
<bugreport>When writing aspects with cycles in the advice precedence, get warning "circular
dependency at {join point}" -- should be "circular advice dependency..." or
"circular advice precedences at {join point} -- reorder the advice in the aspect".

FWIW, here's an example of circularity in advice precedence:
----
aspect A {
    pointcut crun() : execution (void run()) ;
    before() : crun() {}
    after() returning : crun() {}
    void around() : crun() { proceed(); }
}
----

See programming guide for more discussion of circularity in advice precedence.</bugreport>
<testsforfix ID="44272" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="retitle warning to circular {advice} dependency at ..."/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="103" file="output/44272/pre-fix/testresults.xml" passing="1139" size="1242"/>
<post-fix-testcases failing="104" file="output/44272/post-fix/testresults.xml" passing="1139" size="1243"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java" revision="1.4" state="changed">77c77
&lt;     					"circularity in declare dominates, '*' occurs more than once",
---
&gt;     					"circularity in declare precedence, '*' occurs more than once",
91c91
&lt;     					"circularity in declare dominates, '" + exactType.getName() + 
---
&gt;     					"circularity in declare precedence, '" + exactType.getName() + 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Shadow.java" revision="1.18" state="changed">335c335
&lt; 					MessageUtil.error("circular dependency at " + this, m.getSourceLocation()));
---
&gt; 					MessageUtil.error("circular advice dependency at " + this, m.getSourceLocation()));
</file>
<file name="org.aspectj/modules/tests/bugs/CircularAdvicePrecedence.java" revision="1.1" state="new">// bug 44272
public aspect CircularAdvicePrecedence {
    pointcut crun() : execution (void run()) ;
    before() : crun() {}
    after() returning : crun() {}
    void around() : crun() { proceed(); }
}

class Runner {
	
	public void run() {}
	
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.141" state="changed">7296a7297,7305
&gt;     
&gt;       &lt;ajc-test dir="bugs" pr="44272"
&gt;     		title="retitle warning to circular {advice} dependency at ..."&gt;
&gt;         &lt;compile files="CircularAdvicePrecedence.java"&gt;
&gt;             &lt;message kind="error" line="4"/&gt; 
&gt;             &lt;message kind="error" line="5"/&gt; 
&gt;             &lt;message kind="error" line="6"/&gt; 
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="45489" transactionid="74068">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P1"/>
<property name="severity" value="normal"/>
<concisefingerprint/>
<fullfingerprint/>
<bugreport>Some elements have the wrong kinds when a saved structure model is loaded.  
E.g. if I close then re-open the eclipse workbench classes are shown as 
interface in the outline view.  Also if I traverse the tree with the code 
below I get the wrong kinds assigned to classed, interfaces, aspects and 
import declarations.

List list = StructureModelUtil.getPackagesInModel();
for(Iterator i = list.iterator(); i.hasNext();){
    Object[] o = (Object[])i.next();
    IProgramElement node = (IProgramElement)o[0];
List files = StructureModelUtil.getFilesInPackage(node);
			for(Iterator i2 = files.iterator(); i2.hasNext();){
				IProgramElement file = (IProgramElement)i2.next
();
				System.out.println("file " + file.getKind
().toString() + ", " + file.getName());
				boolean added2 = false;
				
				List file_children = file.getChildren();
					// file children can be classes, 
aspects or other things
				for(Iterator i3 = file_children.iterator(); 
i3.hasNext();){
					IProgramElement file_child = 
(IProgramElement)i3.next();
					System.out.println("kind: " + 
file_child.getKind().toString() +", " + file_child.getName());</bugreport>
<testsforfix ID="45489" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.java">
      <test NAME="testInterfaceIsSameInBoth"/>
      <test NAME="testModelIsSamePreAndPostBuild"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="95" file="output/45489/pre-fix/testresults.xml" passing="1128" size="1223"/>
<post-fix-testcases failing="97" file="output/45489/post-fix/testresults.xml" passing="1128" size="1225"/>
<fixedFiles>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/IProgramElement.java" revision="1.9" state="changed">123c123
&lt; 		public static final Modifiers[] ALL = { STATIC, FINAL, ABSTRACT, SYNCHRONIZED, TRANSIENT, VOLATILE, STRICTFP, NATIVE };
---
&gt; 		public static final Modifiers[] ALL = { STATIC, FINAL, ABSTRACT, SYNCHRONIZED, VOLATILE, STRICTFP, TRANSIENT, NATIVE };
213a214
&gt; 				IMPORT_REFERENCE,
216d216
&lt; 				IMPORT_REFERENCE,
234c234,236
&lt; 				ERROR };
---
&gt; 				ERROR
&gt; 
&gt; 			};
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.java" revision="1.1" state="new">

/* *******************************************************************
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/

package org.aspectj.ajde;

import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.aspectj.asm.HierarchyWalker;
import org.aspectj.asm.IHierarchy;
import org.aspectj.asm.IProgramElement;

/**
 * @author Mik Kersten
 */
public class SavedModelConsistencyTest extends AjdeTestCase {
	
	private final String CONFIG_FILE_PATH = "../examples/coverage/coverage.lst";

	public SavedModelConsistencyTest(String name) {
		super(name);
	}

	public static void main(String[] args) {
		junit.swingui.TestRunner.run(SavedModelConsistencyTest.class);
	}
	
	public void testInterfaceIsSameInBoth() {
		File configFile = openFile(CONFIG_FILE_PATH);	
		Ajde.getDefault().getStructureModelManager().readStructureModel(configFile.getAbsolutePath());
		
        IHierarchy model = Ajde.getDefault().getStructureModelManager().getHierarchy();
        assertTrue("model exists", model != null);
        
		assertTrue("root exists", model.getRoot() != null);
		File testFile = openFile("../examples/coverage/ModelCoverage.java");
		assertTrue(testFile.exists());
		
		IProgramElement nodePreBuild = model.findElementForSourceLine(testFile.getAbsolutePath(), 5);	
//		System.err.println(nodePreBuild.getKind());

		doSynchronousBuild(CONFIG_FILE_PATH);	

		IProgramElement nodePostBuild = model.findElementForSourceLine(testFile.getAbsolutePath(), 5);	
//		System.err.println(nodePostBuild.getKind());
		
		assertTrue(nodePreBuild.getKind().equals(nodePostBuild.getKind()));
		
	}

	public void testModelIsSamePreAndPostBuild() {
		File configFile = openFile(CONFIG_FILE_PATH);	
		Ajde.getDefault().getStructureModelManager().readStructureModel(configFile.getAbsolutePath());
		
        IHierarchy model = Ajde.getDefault().getStructureModelManager().getHierarchy();
        assertTrue("model exists", model != null);
	
        final List preBuildKinds = new ArrayList();
		HierarchyWalker walker = new HierarchyWalker() {
  		    public void preProcess(IProgramElement node) {
  		    	preBuildKinds.add(node.getKind());
  		    }
  		};
  		Ajde.getDefault().getStructureModelManager().getHierarchy().getRoot().walk(walker);

		doSynchronousBuild(CONFIG_FILE_PATH);
		
        final List postBuildKinds = new ArrayList();
		HierarchyWalker walker2 = new HierarchyWalker() {
  		    public void preProcess(IProgramElement node) {
  		    	postBuildKinds.add(node.getKind());
  		    }
  		};
  		Ajde.getDefault().getStructureModelManager().getHierarchy().getRoot().walk(walker2);
			
//		System.err.println(preBuildKinds);
//		System.err.println(postBuildKinds);
		
		assertTrue(preBuildKinds.equals(postBuildKinds));
		
	}
	  
	protected void setUp() throws Exception {
		super.setUp("examples");
	}

	protected void tearDown() throws Exception {
		super.tearDown();
	}
}

</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AjdeTests.java" revision="1.12" state="changed">35a36
&gt; 		suite.addTestSuite(SavedModelConsistencyTest. class);
</file>
</fixedFiles>
</bug>
<bug id="46280" transactionid="72578">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if O--- T V Z-if</fullfingerprint>
<bugreport>The compiler complains that "inner aspects must be static" whenever I try to 
qualify an inner (and static) aspect as privileged, no matter what the 
enclosing type is (aspect, interface or class).
I was using j2sdk1.4.0_02, AspectJ 1.1, eclipse 2.1 (with AJDT 1.1.3).
Test case:
------------------
BASE CLASS:
public class Capsule {
   private int hidden;
   public int visible;
   public Capsule(int priv, int pub) {
      hidden = priv;
      visible = pub;
   }
   public void doSomething() {
      System.out.println(""" + hidden + ", " + visible + """);
   }
   public static void main(String[] args) {
      Capsule capsule = new Capsule(1, 1);
      capsule.doSomething();
   }
}
------------------
ASPECT:
public aspect Outer {
   static //privileged &lt;== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(Capsule capsule):
         call(void Capsule.doSomething())
         &amp;&amp; target(capsule);
      before(Capsule capsule): call2doSomething(capsule) {
         capsule.visible++;
         //capsule.hidden++;
      }
   }
}
------------------
INTERFACE:
public interface Marker {
   static //privileged &lt;== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(Capsule capsule):
         call(void Capsule.doSomething())
         &amp;&amp; target(capsule);
      before(Capsule capsule): call2doSomething(capsule) {
         capsule.visible++;
         //capsule.hidden++;
      }
   }
}</bugreport>
<testsforfix ID="46280" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml"/>
  </testsforfix>
<pre-fix-testcases failing="96" file="output/46280/pre-fix/testresults.xml" passing="1118" size="1214"/>
<post-fix-testcases failing="94" file="output/46280/post-fix/testresults.xml" passing="1121" size="1215"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java" revision="1.9" state="changed">232a233,236
&gt; 		if (isPrivileged) {
&gt; 			aspectDecl.modifiersSourceStart = intStack[intPtr--];
&gt; 			aspectDecl.modifiers |= intStack[intPtr--];
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/bugs/PrivilegedParsing.java" revision="1.1" state="new">public class PrivilegedParsing {
   private int hidden;
   public int visible;
   public PrivilegedParsing(int priv, int pub) {
      hidden = priv;
      visible = pub;
   }
   public void doSomething() {
      System.out.println("" + hidden + ", " + visible + "");
   }
   public static void main(String[] args) {
      PrivilegedParsing capsule = new PrivilegedParsing(1, 1);
      capsule.doSomething();
   }
}

aspect Outer {
   static privileged //&lt;== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(PrivilegedParsing capsule):
         call(void PrivilegedParsing.doSomething())
         &amp;&amp; target(capsule);
      before(PrivilegedParsing capsule): call2doSomething(capsule) {
         capsule.visible++;
         capsule.hidden++;
      }
   }
}

interface Marker {
   static privileged //&lt;== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(PrivilegedParsing capsule):
         call(void PrivilegedParsing.doSomething())
         &amp;&amp; target(capsule);
      before(PrivilegedParsing capsule): call2doSomething(capsule) {
         capsule.visible++;
         capsule.hidden++;
      }
   }
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.124" state="changed">6966a6967,6973
&gt;     
&gt;     &lt;ajc-test dir="bugs" 
&gt; 		pr="46280"
&gt; 		title="compiler issues error on inner aspects when privilieged"&gt;
&gt;         &lt;compile files="PrivilegedParsing.java"/&gt;
&gt;         &lt;run class="PrivilegedParsing"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="46298" transactionid="69561">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="13"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="16"/>
<property name="lines-churned" value="29"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-new M O-== O-! O-?: O-() O-&amp;&amp; O-+ T V Y Z-cond Z-if</fullfingerprint>
<bugreport>Under certain condition you can not cleanly decompile code generated by the 
aspectj compiler/byte code weaver.

package com.regular;

public class ExceptionCatcher
{
	public ExceptionCatcher()
	{
		super();
	}
	
	public void catchException()
	{
		try
		{
			ExceptionThrower throwUp = new ExceptionThrower();
			throwUp.throwException();
		}
		catch(Exception e)
		{
			System.out.println("Inside my catch block");
		}
	}
	
	public static void main(String[] args)
	{
		ExceptionCatcher catcher = new ExceptionCatcher();
		catcher.catchException();	
	}
}

package com.aop;

import org.aspectj.lang.JoinPoint;

public aspect ExceptionHandler
{
	pointcut classList() : 
		within(com.regular..*);
	
	before(Throwable e) : 
		classList() 
		&amp;&amp; handler(*)
		&amp;&amp; args(e)
	{
		System.out.println("Starting before block");
		log(thisJoinPointStaticPart, e);
		System.out.println("End of before block");
	}
		
	private void log(JoinPoint.StaticPart jp, Throwable e)
	{
		System.out.println("Class Name: " + jp.getSignature
().getDeclaringType());
		System.out.println("Error Message" + e.getMessage() );
	}
}

Runing JAD:

jad ExceptionCatcher.class
Parsing ExceptionCatcher.class... Generating ExceptionCatcher.jad
Couldn't fully decompile method catchException
Couldn't resolve all exception handlers in method catchException

Now the JAD Output:

// Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov.
// Jad home page: http://www.geocities.com/SiliconValley/Bridge/8617/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   ExceptionCatcher.java

package com.regular;

import com.aop.ExceptionHandler;
import com.capitalone.risk.aop.ITestInterface;
import com.capitalone.risk.aop.ITestInterfaceAspect;
import java.io.PrintStream;
import org.aspectj.runtime.reflect.Factory;

// Referenced classes of package com.regular:
//            ExceptionThrower

public class ExceptionCatcher
    implements com.aop.IntroductionPointCut.IPhilipsTarget
{

    public ExceptionCatcher()
    {
    }

    public void catchException()
    {
        if(this instanceof ITestInterface)
            ITestInterfaceAspect.aspectOf
().ajc$before$com_capitalone_risk_aop_ITestInterfaceAspect$113((ITestInterface)
this);
        ExceptionThrower throwUp = new ExceptionThrower();
        throwUp.throwException();
        break MISSING_BLOCK_LABEL_77;
        Exception exception;
        exception;
        ExceptionHandler.aspectOf().ajc$before$com_aop_ExceptionHandler$1f8
(exception, ajc$tjp_0);
        Exception e = exception;
        System.out.println("Inside my catch block");
        break MISSING_BLOCK_LABEL_77;
        Throwable throwable;
        throwable;
        if(this instanceof ITestInterface)
            ITestInterfaceAspect.aspectOf
().ajc$after$com_capitalone_risk_aop_ITestInterfaceAspect$172((ITestInterface)
this);
        throw throwable;
        if(this instanceof ITestInterface)
            ITestInterfaceAspect.aspectOf
().ajc$after$com_capitalone_risk_aop_ITestInterfaceAspect$172((ITestInterface)
this);
        return;
    }

    public static void main(String args[])
    {
        ExceptionCatcher catcher = new ExceptionCatcher();
        catcher.catchException();
    }

    public static final org.aspectj.lang.JoinPoint.StaticPart ajc$tjp_0;

    static 
    {
        Factory factory = new Factory("ExceptionCatcher.java", Class.forName
("com.regular.ExceptionCatcher"));
        ajc$tjp_0 = factory.makeSJP("exception-handler", 
factory.makeCatchClauseSig("0--com.regular.ExceptionCatcher-
java.lang.Exception-&lt;missing&gt;-"), 33);
    }
}

The aspect class:

jad ExceptionHandler.class
Parsing ExceptionHandler.class... Generating ExceptionHandler.jad
Couldn't fully decompile method aspectOf

// Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov.
// Jad home page: http://www.geocities.com/SiliconValley/Bridge/8617/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   ExceptionHandler.java

package com.aop;

import java.io.PrintStream;
import org.aspectj.lang.NoAspectBoundException;
import org.aspectj.lang.Signature;

public class ExceptionHandler
{

    public ExceptionHandler()
    {
    }

    public void ajc$before$com_aop_ExceptionHandler$1f8(Throwable e, 
org.aspectj.lang.JoinPoint.StaticPart thisJoinPointStaticPart)
    {
        System.out.println("Starting before block");
        log(thisJoinPointStaticPart, e);
        System.out.println("End of before block");
    }

    private void log(org.aspectj.lang.JoinPoint.StaticPart jp, Throwable e)
    {
        System.out.println("Class Name: " + jp.getSignature().getDeclaringType
());
        System.out.println("Error Message" + e.getMessage());
    }

    public static ExceptionHandler aspectOf()
    {
        ajc$perSingletonInstance;
        JVM INSTR dup ;
        JVM INSTR ifnull 8;
           goto _L1 _L2
_L1:
        return;
_L2:
        throw new NoAspectBoundException();
    }

    public static boolean hasAspect()
    {
        return ajc$perSingletonInstance != null;
    }

    private static void ajc$postClinit()
    {
        ajc$perSingletonInstance = new ExceptionHandler();
    }

    public static final ExceptionHandler ajc$perSingletonInstance;

    static 
    {
        ajc$postClinit();
    }
}

Enjoy!

Ron</bugreport>
<pre-fix-testcases failing="111" file="output/46298/pre-fix/testresults.xml" passing="1278" size="1389"/>
<post-fix-testcases failing="112" file="output/46298/post-fix/testresults.xml" passing="1277" size="1389"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.41" state="changed">230c230
&lt; 		
---
&gt;  		
240a241
&gt; 			
243,244c244,259
&lt; 			InstructionHandle start = range.getStart();
&lt; 			InstructionHandle freshIh = body.insert(start, InstructionConstants.NOP);
---
&gt; 			InstructionHandle start = range.getStart();		
&gt; 			
&gt; 			// Create a store instruction to put the value from the top of the 
&gt; 			// stack into a local variable slot.  This is a trimmed version of
&gt; 			// what is in initializeArgVars() (since there is only one argument
&gt; 			// at a handler jp and only before advice is supported) (pr46298)
&gt; 	        argVars = new BcelVar[1];
&gt; 			int positionOffset = (hasTarget() ? 1 : 0) + ((hasThis() &amp;&amp; !getKind().isTargetSameAsThis()) ? 1 : 0);
&gt;             TypeX tx = getArgType(0);
&gt;             argVars[0] = genTempVar(tx, "ajc$arg0");
&gt;             InstructionHandle insertedInstruction = 
&gt;             	range.insert(argVars[0].createStore(getFactory()), Range.OutsideBefore);
&gt; 
&gt;             // Now the exception range starts just after our new instruction.
&gt;             // The next bit of code changes the exception range to point at
&gt;             // the store instruction
250c265
&lt; 					er.updateTarget(start, freshIh, body);
---
&gt; 					er.updateTarget(start, insertedInstruction, body);
280c295,306
&lt; 			range.insert(
---
&gt; 			
&gt; 			// Special case first (pr46298).  If we are an exception handler and the instruction
&gt; 			// just after the shadow is a POP then we should remove the pop.  The code 
&gt; 			// above which generated the store instruction has already cleared the stack.
&gt; 			// We also don't generate any code for the arguments in this case as it would be
&gt; 			// an incorrect aload.
&gt; 			if (getKind() == ExceptionHandler 
&gt; 				&amp;&amp; range.getEnd().getNext().getInstruction().equals(InstructionConstants.POP)) {
&gt; 				// easier than deleting it ...
&gt; 				range.getEnd().getNext().setInstruction(InstructionConstants.NOP);
&gt; 			} else {
&gt; 			  range.insert(
283c309
&lt; 			if (targetVar != null) {
---
&gt; 			  if (targetVar != null) {
287,288c313,314
&lt; 			}
&lt; 			if (getKind() == ConstructorCall) {
---
&gt; 			  }
&gt; 			  if (getKind() == ConstructorCall) {
294a321
&gt; 			  }
</file>
</fixedFiles>
</bug>
<bug id="47318" transactionid="74200">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint/>
<fullfingerprint>T V</fullfingerprint>
<bugreport>org.aspectj.asm.IRelationship.Kind.ALL is an array that should contain all kinds
that an IRelationship may have. There are three possible kinds defined in
IRelationship.java: ADVICE, DECLARE and DECLARE_INTER_TYPE. The Kind[] ALL does
only contain ADVICE and DECLARE. This can lead to an ArrayIndexOutOfBoundsException.</bugreport>
<pre-fix-testcases failing="85" file="output/47318/pre-fix/testresults.xml" passing="1098" size="1183"/>
<post-fix-testcases failing="83" file="output/47318/post-fix/testresults.xml" passing="1100" size="1183"/>
<fixedFiles>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/IRelationship.java" revision="1.6" state="changed">40c40
&lt; 		public static final Kind[] ALL = { ADVICE, DECLARE };
---
&gt; 		public static final Kind[] ALL = { ADVICE, DECLARE, DECLARE_INTER_TYPE };
</file>
</fixedFiles>
</bug>
<bug id="47754" transactionid="70357">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if M Y Z-if</fullfingerprint>
<bugreport>the attached example throws this at class load time.

please note that this bug results in a different exception when happens in a 
different setup, and when the class is loaded by JBoss. (more cryptic, talking 
about generic class format error)



Exception in thread "main" java.lang.ClassFormatError: 
com/netvisor/nvsr/client/InvalidByteCodeBug$Test$ITest (Illegal method 
modifiers: 0x409)
        at java.lang.ClassLoader.defineClass0(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:537)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:
123)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
        at java.lang.ClassLoader.defineClass0(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:537)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:
123)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
        at com.netvisor.nvsr.client.InvalidByteCodeBug.run(InvalidByteCodeBug.
java:15)
        at com.netvisor.nvsr.client.InvalidByteCodeBug.main(InvalidByteCodeBug.
java:8)</bugreport>
<testsforfix ID="47754" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="static method introduction on interfaces, should not be allowed"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="86" file="output/47754/pre-fix/testresults.xml" passing="1100" size="1186"/>
<post-fix-testcases failing="85" file="output/47754/post-fix/testresults.xml" passing="1102" size="1187"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java" revision="1.11" state="changed">75a76,82
&gt; 		if (Modifier.isStatic(declaredModifiers)) {
&gt; 			// Check the target for ITD is not an interface
&gt; 			if (onTypeBinding.isInterface()) {
&gt; 				scope.problemReporter().signalError(sourceStart, sourceEnd,
&gt; 					"methods in interfaces cannot be declared static");
&gt; 			}
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/bugs/StaticInterfaceMethods.java" revision="1.1" state="new">interface StaticInterfaceMethods {
	
}

aspect A {
	
	static int StaticInterfaceMethods.aMethod() {
		return 1;
	}
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.114" state="changed">6837a6838,6845
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="47754"
&gt;       title="static method introduction on interfaces, should not be allowed"&gt;
&gt;         &lt;compile files="StaticInterfaceMethods.java"&gt;
&gt; 		  &lt;message kind="error" line="7" text="methods in interfaces cannot be declared static"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="47910" transactionid="70788">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="16"/>
<property name="lines-added" value="45"/>
<property name="lines-deleted" value="4"/>
<property name="lines-modified" value="9"/>
<property name="lines-churned" value="58"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-import K-new K-null K-return K-true M O-== O-!= O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>I call ajc -sourceroots &lt;mydir&gt; -outjar &lt;my.jar&gt; and an output file is created 
with a .jar extension, but it is not a valid jar file because there is no 
MANIFEST.MF file. I see that the text for ajc says:

-outjar &lt;file&gt;      put output classes in zip file &lt;file&gt;

which might imply that it is supposed to be a zip file, but a parameter called -
outjar which creates a zip file doesn't really make sense. If -outjar is used, 
the resulting file should be a valid jar file, i.e. with a META-INF/MANIFEST.MF 
file inside.</bugreport>
<testsforfix ID="47910" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/JarManifestTest.java">
      <test NAME="testWeave"/>
      <test NAME="testNoweave"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="103" file="output/47910/pre-fix/testresults.xml" passing="1159" size="1262"/>
<post-fix-testcases failing="102" file="output/47910/post-fix/testresults.xml" passing="1160" size="1262"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java" revision="1.29" state="changed">28d27
&lt; import java.util.HashMap;
32d30
&lt; import java.util.Map;
33a32,35
&gt; import java.util.jar.Attributes;
&gt; import java.util.jar.Attributes.Name;
&gt; import java.util.jar.JarInputStream;
&gt; import java.util.jar.Manifest;
83c85,86
&lt; //    private Map  resources         = new HashMap(); /* String -&gt; UnwovenClassFile */ 
---
&gt; //	private Map  resources         = new HashMap(); /* String -&gt; UnwovenClassFile */ 
&gt; 	private Manifest manifest = null;
145,146c148,149
&lt; 	// The ANT copy task should be used to copy resources across.
&lt; 	private final static boolean CopyResourcesFromInpathDirectoriesToOutput=false;
---
&gt; //	// The ANT copy task should be used to copy resources across.
&gt; //	private final static boolean CopyResourcesFromInpathDirectoriesToOutput=false;
200c203
&lt; 		ZipInputStream inStream = null;
---
&gt; 		JarInputStream inStream = null;
208c211,212
&lt; 				inStream = new ZipInputStream(new FileInputStream(inFile)); //??? buffered
---
&gt; 				inStream = new JarInputStream(new FileInputStream(inFile)); //??? buffered
&gt; 				addManifest(inStream.getManifest());
389a394,416
&gt; 	public void addManifest (Manifest newManifest) {
&gt; 		if (manifest == null) {
&gt; 			manifest = newManifest;
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	private static final String WEAVER_MANIFEST_VERSION = "1.0";
&gt; 	private static final Attributes.Name CREATED_BY = new Name("Created-By");
&gt; 	private static final String WEAVER_CREATED_BY = "AspectJ Compiler";
&gt;     
&gt;     public Manifest getManifest (boolean shouldCreate) {
&gt; 		
&gt; 		if (manifest == null &amp;&amp; shouldCreate) {
&gt; 			manifest = new Manifest();
&gt; 
&gt; 			Attributes attributes = manifest.getMainAttributes();
&gt; 			attributes.put(Name.MANIFEST_VERSION,WEAVER_MANIFEST_VERSION);
&gt; 			attributes.put(CREATED_BY,WEAVER_CREATED_BY);
&gt; 		}
&gt; 		
&gt; 		return manifest;
&gt;     }
&gt;     
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.47" state="changed">20,21d19
&lt; import java.util.zip.ZipInputStream;
&lt; import java.util.zip.ZipOutputStream;
47a46
&gt; 	private static final String MANIFEST_NAME = "META-INF/MANIFEST.MF";
55c54
&lt; 	private ZipOutputStream zos;
---
&gt; 	private JarOutputStream zos;
201c200
&lt; 			zos = new ZipOutputStream(os);
---
&gt; 			zos = new JarOutputStream(os,bcelWeaver.getManifest(true));
255a255,256
&gt; 		
&gt; 		writeManifest();
259c260
&lt; 		ZipInputStream inStream = null;
---
&gt; 		JarInputStream inStream = null;
261c262
&lt; 			inStream = new ZipInputStream(new FileInputStream(jarFile));
---
&gt; 			inStream = new JarInputStream(new FileInputStream(jarFile));
336a338,351
&gt; 	
&gt; 	/*
&gt; 	 * If we are writing to an output directory copy the manifest but only
&gt; 	 * if we already have one
&gt; 	 */    
&gt; 	private void writeManifest () throws IOException {
&gt; 		Manifest manifest = bcelWeaver.getManifest(false);
&gt; 		if (manifest != null &amp;&amp; zos == null) {
&gt; 			OutputStream fos = 
&gt; 				FileUtil.makeOutputStream(new File(buildConfig.getOutputDir(),MANIFEST_NAME));
&gt; 			manifest.write(fos);	
&gt; 			fos.close();
&gt; 		}
&gt; 	}
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/InpathTestcase.java" revision="1.5" state="changed">17a18
&gt; import java.util.jar.JarInputStream;
247c248
&lt; 			ZipInputStream outjar;
---
&gt; 			JarInputStream outjar;
250c251
&lt; 				new ZipInputStream(new java.io.FileInputStream(outjarFile));
---
&gt; 				new JarInputStream(new java.io.FileInputStream(outjarFile));
253c254
&lt; 			while (null != (entry = outjar.getNextEntry())) {
---
&gt; 			while (null != (entry = (ZipEntry)outjar.getNextEntry())) {
288,289c289,290
&lt; 			ZipInputStream outjar =
&lt; 				new ZipInputStream(new java.io.FileInputStream(outjarFile));
---
&gt; 			JarInputStream outjar =
&gt; 				new JarInputStream(new java.io.FileInputStream(outjarFile));
322,323c323,324
&lt; 			ZipInputStream outjar =
&lt; 				new ZipInputStream(new java.io.FileInputStream(outjarFile));
---
&gt; 			JarInputStream outjar =
&gt; 				new JarInputStream(new java.io.FileInputStream(outjarFile));
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/JarManifestTest.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
/*
 * Created on 16-Mar-2004
 *
 * To change the template for this generated file go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package org.aspectj.ajde;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.jar.JarInputStream;
import java.util.jar.Manifest;

import org.aspectj.util.FileUtil;

/**
 * @author websterm
 *
 * To change the template for this generated type comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
public class JarManifestTest extends AjdeTestCase {
 
	public static final String PROJECT_DIR = "JarManifestTest";   
	public static final String srcDir = PROJECT_DIR + "/src"; 
	public static final String binDir = "bin"; 

	public static final String outjarName = "/bin/output.jar"; 

	/**
	 * Constructor for JarResourceCopyTestCase.
	 * @param arg0
	 */
	public JarManifestTest (String arg0) {
		super(arg0);
	}

	/*
	 * Ensure the output directpry in clean
	 */	
	protected void setUp() throws Exception {
		super.setUp(PROJECT_DIR);
		FileUtil.deleteContents(openFile(binDir));
	}

	public void testWeave () {
		File outjar = openFile(outjarName);
		ideManager.getProjectProperties().setOutJar(outjar.getAbsolutePath());
		assertTrue("Build failed",doSynchronousBuild("weave.lst"));
		assertTrue("Build warnings",ideManager.getCompilationSourceLineTasks().isEmpty());
		checkManifest(outjar);
	}

	public void testNoweave () {
		File outjar = openFile(outjarName);
		ideManager.getProjectProperties().setOutJar(outjar.getAbsolutePath());
		assertTrue("Build failed",doSynchronousBuild("noweave.lst"));
		assertTrue("Build warnings",ideManager.getCompilationSourceLineTasks().isEmpty());
		checkManifest(outjar);
	}
	
	private void checkManifest (File outjarFile) {
		Manifest manifest = null;

		try {
			JarInputStream outjar = new JarInputStream(new FileInputStream(outjarFile));
			manifest = outjar.getManifest();
			outjar.close();
			assertNotNull("'" + outjarFile.getCanonicalPath() + "' should contain a manifest",manifest);
		}
		catch (IOException ex) {
			fail(ex.toString());
		}
	}
}
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.java" revision="1.8" state="changed">16a17
&gt; import java.util.jar.JarInputStream;
167c168
&lt; 			ZipInputStream outjar = new ZipInputStream(new java.io.FileInputStream(outjarFile));
---
&gt; 			ZipInputStream outjar = new JarInputStream(new java.io.FileInputStream(outjarFile));
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AjdeTests.java" revision="1.14" state="changed">37a38
&gt; 		suite.addTestSuite(JarManifestTest.class);
</file>
<file name="org.aspectj/modules/ajde/testdata/JarManifestTest/src/Main.java" revision="1.1" state="new">import java.io.IOException;

/*
 * Created on 30-Jul-03
 *
 * To change this generated comment go to 
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */

/**
 * @author websterm
 *
 * To change this generated comment go to 
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
public class Main {

	public void println () {
		System.out.println("Main.");
	}

	public static void main(String[] args) throws IOException {
		new Main().println();
	}
}
</file>
<file name="org.aspectj/modules/ajde/testdata/JarManifestTest/weave.lst" revision="1.1" state="new">src/Main.java&#13;
src/Logging.aj&#13;
</file>
<file name="org.aspectj/modules/ajde/testdata/JarManifestTest/src/Logging.aj" revision="1.1" state="new">public aspect Logging {&#13;
	&#13;
	pointcut methods () :&#13;
		execution(* *..*(..)) &amp;&amp; !within(Logging);&#13;
	&#13;
	before () : methods () {&#13;
		System.err.println("&gt; " + thisJoinPoint.getSignature().toLongString());&#13;
	}&#13;
	&#13;
	after () : methods () {&#13;
		System.err.println("&lt; " + thisJoinPoint.getSignature().toLongString());&#13;
	}&#13;
}&#13;
</file>
<file name="org.aspectj/modules/ajde/testdata/JarManifestTest/noweave.lst" revision="1.1" state="new">src/Main.java&#13;
src/Logging.aj&#13;
-noweave</file>
</fixedFiles>
</bug>
<bug id="47952" transactionid="75419">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="42"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="46"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-false K-if K-import K-null K-super K-this K-true K-try M O-! O-!= O-() O-&amp;&amp; T V Y Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>SoftExceptions should print not only their trace but also that of the wrapped
throwable.

We should be able to set a flag on class initialization whether we are running
under 1.4 and then implement it under 1.4 using initCause() and otherwise by
direct delegation.  I can do this fix if we're agreed.</bugreport>
<testsforfix ID="47952" type="new">
    <file LOCATION="org.aspectj/modules/runtime/testsrc/RuntimeModuleTests.java">
      <test NAME="testSoftExceptionPrintStackTrace"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="95" file="output/47952/pre-fix/testresults.xml" passing="1122" size="1217"/>
<post-fix-testcases failing="96" file="output/47952/post-fix/testresults.xml" passing="1122" size="1218"/>
<fixedFiles>
<file name="org.aspectj/modules/runtime/src/org/aspectj/lang/SoftException.java" revision="1.3" state="changed">3c3,4
&lt;  *               2002 Palo Alto Research Center, Incorporated (PARC).
---
&gt;  *               2002 Palo Alto Research Center, Incorporated (PARC),
&gt;  *               2004 Contributors.
16a18,20
&gt; import java.io.PrintStream;
&gt; import java.io.PrintWriter;
&gt; 
24c28,29
&lt;  * &lt;code&gt;getWrappedThrowable()&lt;/code&gt;.
---
&gt;  * &lt;code&gt;getWrappedThrowable()&lt;/code&gt; or
&gt;  * &lt;code&gt;getCause()&lt;/code&gt;.
27c32,50
&lt;     Throwable inner;
---
&gt; 
&gt;     private static final boolean HAVE_JAVA_14;
&gt; 
&gt;     static {
&gt;         boolean java14 = false;
&gt;         try {
&gt;             Class.forName("java.nio.Buffer");
&gt;             java14 = true;
&gt;         } catch (Throwable t) {
&gt;             // still false;
&gt;         }
&gt;         HAVE_JAVA_14 = java14;
&gt;     }
&gt; 
&gt;     // shouldn't field be private final, constructor default or private? 
&gt;     // but either would be a binary incompatible change.
&gt; 
&gt;     Throwable inner; 
&gt; 
35a59,79
&gt;     public void printStackTrace() {
&gt;         printStackTrace(System.err);                
&gt;     }
&gt;     
&gt;     public void printStackTrace(PrintStream stream) {
&gt;         super.printStackTrace(stream);
&gt;         final Throwable _inner = this.inner;
&gt;         if (!HAVE_JAVA_14 &amp;&amp; (null != _inner)) {
&gt;             stream.print("Caused by: ");
&gt;             _inner.printStackTrace(stream);
&gt;         }
&gt;     }
&gt;     
&gt;     public void printStackTrace(PrintWriter stream) {
&gt;         super.printStackTrace(stream);
&gt;         final Throwable _inner = this.inner;
&gt;         if (!HAVE_JAVA_14 &amp;&amp; (null != _inner)) {
&gt;             stream.print("Caused by: ");
&gt;             _inner.printStackTrace(stream);
&gt;         }
&gt;     }
</file>
<file name="org.aspectj/modules/runtime/testsrc/RuntimeModuleTests.java" revision="1.4" state="changed">14d13
&lt; 
17c16,18
&lt; import org.aspectj.lang.NoAspectBoundException;
---
&gt; import java.io.*;
&gt; 
&gt; import org.aspectj.lang.*;
30,31d30
&lt; 
&lt;     public void testNothing() {}
34,36c33,77
&lt;     	RuntimeException fun = new RuntimeException("fun");
&lt;     	NoAspectBoundException nab = new NoAspectBoundException("Foo", fun);
&lt;     	assertEquals(fun,nab.getCause());
---
&gt;         RuntimeException fun = new RuntimeException("fun");
&gt;         NoAspectBoundException nab = new NoAspectBoundException("Foo", fun);
&gt;         assertEquals(fun,nab.getCause());
&gt;     }
&gt; 
&gt;     public void testSoftExceptionPrintStackTrace() {
&gt;         // let's see
&gt; //        Throwable t = new Error("xyz");       
&gt; //        new SoftException(t).printStackTrace();
&gt; 
&gt;         // save to specified PrintStream
&gt;         ByteArrayOutputStream sink = new ByteArrayOutputStream();
&gt;         PrintStream out = new PrintStream(sink);
&gt;         new SoftException(new Error("xyz")).printStackTrace(out);
&gt;         String s = new String(sink.toByteArray());
&gt;         out.flush();
&gt;         checkSoftExceptionString(s);
&gt; 
&gt;         // save to specified PrintWriter
&gt;         sink = new ByteArrayOutputStream();
&gt;         PrintWriter pout = new PrintWriter(sink);
&gt;         new SoftException(new Error("xyz")).printStackTrace(pout);
&gt;         pout.flush();
&gt;         s = new String(sink.toByteArray());
&gt;         checkSoftExceptionString(s);
&gt; 
&gt;         // check System.err redirect
&gt;         PrintStream systemErr = System.err;
&gt;         try {
&gt;             sink = new ByteArrayOutputStream();
&gt;             out = new PrintStream(sink);
&gt;             System.setErr(out);
&gt;             new SoftException(new Error("xyz")).printStackTrace();
&gt;             out.flush();
&gt;             s = new String(sink.toByteArray());
&gt;             checkSoftExceptionString(s);
&gt;         } finally {
&gt;             System.setErr(systemErr);
&gt;         }
&gt;     }
&gt;     static void checkSoftExceptionString(String s) {        
&gt;         assertTrue(-1 != s.indexOf("SoftException"));
&gt;         assertTrue(-1 != s.indexOf("Caused by: java.lang.Error"));
&gt;         assertTrue(-1 != s.indexOf("xyz"));
&gt;         assertTrue(-1 != s.indexOf("testSoftExceptionPrintStackTrace"));
</file>
</fixedFiles>
</bug>
<bug id="48080" transactionid="70878">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P2"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null M O-!= T V Z-if</fullfingerprint>
<bugreport>*** to be discussed on aspectj-dev / users before implementing ***

We have found it useful to be able to include contextual information in the 
messages produced by declare warning /error. We want to be able to write 
something like:

declare warning: call(* com.ibm.ws..*(..)) : "Call to protected WAS API: %s";

and get the compiler message:

"Call to protected WAS API: void com.ibm.ws.SomeClass.someMethod(boolean)"

We prototyped a solution using substitution variables as follows:

%%  	inserts a % character
%k	inserts the joinpoint kind
%s	inserts the signature at the joinpoint
%t	inserts the name of the declaring type at the joinpoint
%i	inserts the name of the identifier at the joinpoint
%j	inserts a string representation of the joinpoint
%f	inserts the filename where the match was found
%l 	inserts the line number where the match was found
%a	inserts the file and line number of the declare error/warning definition

(this may not be the perfect set...)

Here's a complete mini-example showing all the subsitutions in action :

Hello.java
=========

public class Hello {
  public static void main(String[] args) {
  	System.out.println("Hello");	
  	new Hello().sayItToo();
  }	
  
  private void sayItToo() {
  	System.out.println("me too");
  }
}

Warn.java
=========

public aspect Warn {
	
	declare warning : execution(* Hello.*(..)) : 
          "My warning:\n%%k=%k\n%%s=%s\n%%t=%t\n%%i=%i\n%%j=%j\n%%f=%f\n%%l=%
l\n%%a=%a";	

	declare warning : call(* Hello.*(..)) : "Illegal call to %t.%i(..)";	

}

To get the following output:

C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:4 
Illegal call to Hello.sayItToo(..)

C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:3 My 
warning:
%k=method-execution
%s=void Hello.main(java.lang.String[])
%t=Hello
%i=main
%j=method-execution(void Hello.main(java.lang.String[]))
%f=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java
%l=3
%a=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Warn.java:3

C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:8 My 
warning:
%k=method-execution
%s=void Hello.sayItToo()
%t=Hello
%i=sayItToo
%j=method-execution(void Hello.sayItToo())
%f=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java
%l=8
%a=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Warn.java:3

3 warnings

The following patch implements the extension (warning - based on a version of  
Checker.java from a while back).

Index: Checker.java
===================================================================
RCS file: /home/technology/org.
aspectj/modules/weaver/src/org/aspectj/weaver/Checker.java,v
retrieving revision 1.5
diff -u -r1.5 Checker.java
--- Checker.java	12 Mar 2003 19:51:43 -0000	1.5
+++ Checker.java	19 Jul 2003 12:34:12 -0000
@@ -17,6 +17,7 @@
 import java.util.Collections;
 
 import org.aspectj.bridge.IMessage;
+import org.aspectj.bridge.ISourceLocation;
 import org.aspectj.bridge.Message;
 import org.aspectj.weaver.patterns.DeclareErrorOrWarning;
 import org.aspectj.weaver.patterns.PerClause;
@@ -49,7 +50,7 @@
 	public boolean match(Shadow shadow, World world) {
 		if (super.match(shadow, world)) {
 			world.getMessageHandler().handleMessage(
-				new Message(msg,
+				new Message(format(msg,shadow),
 							isError ? IMessage.ERROR : IMessage.WARNING,
 							null,
 							shadow.getSourceLocation()));
@@ -63,5 +64,85 @@
 	}
 	
 	public Collection getThrownExceptions() { return Collections.EMPTY_LIST; }
+
+//	%%  	inserts a % character
+//	%k 		inserts the joinpoint kind
+//	%s		inserts the signature at the joinpoint
+//	%t		inserts the name of the declaring type at the joinpoint
+//	%i		inserts the name of the identifier at the joinpoint
+//	%j		inserts a string representation of the joinpoint
+//	%J		inserts an extended string representation of the joinpoint
+//	%f		inserts the filename where the match was found
+//	%l 		inserts the line number where the match was found
+//	%a		inserts the name of the aspect where the declare was defined	
+	private String format(String msg, Shadow shadow) {
+		StringBuffer ret = new StringBuffer();
+		for(int i = 0; i &lt; msg.length(); i++) {
+			if (msg.charAt(i) != '%') {
+				ret.append(msg.charAt(i));
+			} else {
+				// its a substitution character
+				int subCharPos = i+1;
+				if (subCharPos &lt; msg.length()) {
+					i++; // consume it
+					substitute(ret,shadow,msg.charAt(i));
+				}
+			}
+		}
+		return ret.toString();
+	}
+
+	/**
+	 * @param buf  the buffer in which to insert the substitution
+	 * @param shadow shadow from which to draw context info
+	 * @param c the substitution character
+	 */
+	private void substitute(StringBuffer ret, Shadow shadow, char c) {
+		ISourceLocation loc;
+		switch(c) {
+			case '%':	
+				ret.append('%');
+				break;
+			case 'k':	// kind
+				ret.append(shadow.getKind().getName());
+				break;
+			case 's':
+				ret.append(shadow.getSignature());
+				break;
+			case 't':
+				ret.append(shadow.getEnclosingType());
+				break;
+			case 'i':
+				ret.append(shadow.getSignature().getName());
+				break;
+			case 'j':
+			case 'J':
+				ret.append(shadow.toString());
+				break;
+			case 'f':	// file name
+				loc = shadow.getSourceLocation();
+				if ((loc != null) &amp;&amp; (loc.getSourceFile() != null)) {
+					ret.append(loc.getSourceFile().toString());
+				}
+				break;
+			case 'l':	// line number
+				loc = shadow.getSourceLocation();
+				if (loc != null) {
+					ret.append(loc.getLine());
+				}
+				break;			
+			case 'a':	// aspect file and line number
+				loc = getSourceLocation();
+				if ((loc != null) &amp;&amp; (loc.getSourceFile() != null)) {
+					ret.append(loc.getSourceFile().toString());
+					ret.append(':');
+					ret.append(loc.getLine());
+				}
+				break;				
+			default: // unknown substitution character, leave alone
+				ret.append('%');
+				ret.append(c);
+		}
+	}
 
 }</bugreport>
<pre-fix-testcases failing="103" file="output/48080/pre-fix/testresults.xml" passing="1138" size="1241"/>
<post-fix-testcases failing="103" file="output/48080/post-fix/testresults.xml" passing="1138" size="1241"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java" revision="1.21" state="changed">452a453,459
&gt;             
&gt;             String details = message.getDetails();
&gt;             if (details != null) {
&gt;             	sb.append(LangUtil.EOL);
&gt;             	sb.append('\t');
&gt;             	sb.append(details);
&gt;             }
</file>
</fixedFiles>
</bug>
<bug id="48091" transactionid="72403">
<property name="files-churned" value="9"/>
<property name="java-files-churned" value="8"/>
<property name="classes-churned" value="8"/>
<property name="methods-churned" value="8"/>
<property name="hunks" value="23"/>
<property name="lines-added" value="157"/>
<property name="lines-deleted" value="4"/>
<property name="lines-modified" value="12"/>
<property name="lines-churned" value="173"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-case K-default K-else K-false K-for K-if K-import K-instanceof K-new K-null K-return K-switch K-true M O-== O-&gt; O-! O-!= O-() O-&amp;&amp; O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-switch Z-vardecl</fullfingerprint>
<bugreport>In cases where the body of advice refers to a non-statically evaluable portion 
of thisJoinPoint (so that it can't be optimized by the compiler to 
thisJoinPointStaticPart), the JoinPoint object is currently always created 
before entering the advice body - even if the JoinPoint object would never 
actually be accessed (because of a test within the advice for example). Since
a) thisJoinPoint is often used in tracing applications
b) tracing applications tend to be very pervasive,
c) they must have low overhead when tracing is disabled, and 
d) creation of thisJoinPoint objects is expensive (v. expensive compared to just 
testing a flag)
it would be nice if there was a way to create JoinPoint objects lazily on first 
actual reference within the advice body.</bugreport>
<testsforfix ID="48091" type="new">
    <file LOCATION="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PerformanceTestCase.java">
      <test NAME="testLazyTjpOff"/>
      <test NAME="testLazyTjp"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="96" file="output/48091/pre-fix/testresults.xml" passing="1124" size="1220"/>
<post-fix-testcases failing="94" file="output/48091/post-fix/testresults.xml" passing="1127" size="1221"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java" revision="1.13" state="changed">95c95
&lt;         	((BcelShadow)shadow).getThisJoinPointVar();
---
&gt;         	((BcelShadow)shadow).requireThisJoinPoint(pointcutTest != Literal.TRUE &amp;&amp; getKind() != AdviceKind.Around);
301c301
&lt;         	shadow.getThisJoinPointBcelVar().appendLoad(il, fact);
---
&gt;         	il.append(shadow.loadThisJoinPoint());
</file>
<file name="org.aspectj/modules/weaver/testdata/TjpBeforeHelloWorld.txt" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.15" state="changed">43a44
&gt;     protected boolean XlazyTjp;
369a371,378
&gt; 	
&gt; 	public boolean isXlazyTjp() {
&gt; 		return XlazyTjp;
&gt; 	}
&gt; 
&gt; 	public void setXlazyTjp(boolean b) {
&gt; 		XlazyTjp = b;
&gt; 	}
380a390
&gt; 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.39" state="changed">189a190
&gt; 		bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/Factory.java" revision="1.2" state="changed">43,47c43,67
&lt;     public static JoinPoint makeJP(JoinPoint.StaticPart staticPart, 
&lt;                         Object _this, Object target, Object[] args)
&lt;     {
&lt;         return new JoinPointImpl(staticPart, _this, target, args);
&lt;     }
---
&gt;     private static Object[] NO_ARGS = new Object[0];
&gt; 	public static JoinPoint makeJP(JoinPoint.StaticPart staticPart, 
&gt; 						Object _this, Object target)
&gt; 	{
&gt; 		return new JoinPointImpl(staticPart, _this, target, NO_ARGS);
&gt; 	}
&gt;     
&gt; 	public static JoinPoint makeJP(JoinPoint.StaticPart staticPart, 
&gt; 						Object _this, Object target, Object arg0)
&gt; 	{
&gt; 		return new JoinPointImpl(staticPart, _this, target, new Object[] {arg0});
&gt; 	}
&gt;     
&gt; 	public static JoinPoint makeJP(JoinPoint.StaticPart staticPart, 
&gt; 						Object _this, Object target, Object arg0, Object arg1)
&gt; 	{
&gt; 		return new JoinPointImpl(staticPart, _this, target, new Object[] {arg0, arg1});
&gt; 	}
&gt;     
&gt;     
&gt; 	public static JoinPoint makeJP(JoinPoint.StaticPart staticPart, 
&gt; 						Object _this, Object target, Object[] args)
&gt; 	{
&gt; 		return new JoinPointImpl(staticPart, _this, target, args);
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Lint.java" revision="1.9" state="changed">52a53,55
&gt; 	public final Kind canNotImplementLazyTjp = 
&gt; 		new Kind("canNotImplementLazyTjp", "can not implement lazyTjp on this joinpoint {0} because around advice is used");
&gt; 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java" revision="1.17" state="changed">56a57
&gt; 	private boolean XlazyTjp = false;
454a456,464
&gt; 
&gt; 	public boolean isXlazyTjp() {
&gt; 		return XlazyTjp;
&gt; 	}
&gt; 
&gt; 	public void setXlazyTjp(boolean b) {
&gt; 		XlazyTjp = b;
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/XlintDefault.properties" revision="1.5" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/TjpAround2HelloWorld.txt" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.20" state="changed">444a445,446
&gt; 			} else if (arg.equals("-XlazyTjp")) {
&gt; 				buildConfig.setXlazyTjp(true);
</file>
<file name="org.aspectj/modules/weaver/testdata/TjpAroundHelloWorld.txt" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/lib/test/aspectjrt.jar" revision="1.8" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.27" state="changed">45a46
&gt; import org.aspectj.weaver.Advice;
250a252,253
&gt; 		isThisJoinPointLazy = world.isXlazyTjp();
&gt; 		
255a259,260
&gt; 		initializeThisJoinPoint();
&gt; 
767a773,774
&gt;     private boolean isThisJoinPointLazy;
&gt;     private int lazyTjpConsumers = 0;
771,773d777
&lt; 	public final Var getThisJoinPointVar() {
&lt; 		return getThisJoinPointBcelVar();
&lt; 	}
781c785,790
&lt;     public BcelVar getThisJoinPointBcelVar() {
---
&gt;     public void requireThisJoinPoint(boolean hasGuardTest) {
&gt;     	if (!hasGuardTest) {
&gt;     		isThisJoinPointLazy = false;
&gt;     	} else {
&gt;     		lazyTjpConsumers++;
&gt;     	}
783,806c792
&lt;     		thisJoinPointVar = genTempVar(TypeX.forName("org.aspectj.lang.JoinPoint"));
&lt;     		InstructionFactory fact = getFactory();
&lt;     		InstructionList il = new InstructionList();
&lt;     		BcelVar staticPart = getThisJoinPointStaticPartBcelVar();
&lt;     		staticPart.appendLoad(il, fact);
&lt;     		if (hasThis()) {
&lt;     			((BcelVar)getThisVar()).appendLoad(il, fact);
&lt;     		} else {
&lt;     			il.append(new ACONST_NULL());
&lt;     		}
&lt;     		if (hasTarget()) {
&lt;     			((BcelVar)getTargetVar()).appendLoad(il, fact);
&lt;     		} else {
&lt;     			il.append(new ACONST_NULL());
&lt;     		}
&lt; 			il.append(makeArgsObjectArray());
&lt;     		
&lt;     		il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
&lt;     							"makeJP", LazyClassGen.tjpType,
&lt;     							new Type[] { LazyClassGen.staticTjpType,
&lt;     									Type.OBJECT, Type.OBJECT, new ArrayType(Type.OBJECT, 1)},
&lt;     							Constants.INVOKESTATIC));
&lt;     		il.append(thisJoinPointVar.createStore(fact));
&lt;     		range.insert(il, Range.OutsideBefore);
---
&gt; 			thisJoinPointVar = genTempVar(TypeX.forName("org.aspectj.lang.JoinPoint"));
807a794,798
&gt;     }
&gt;     
&gt;     
&gt;     public Var getThisJoinPointVar() {
&gt;     	requireThisJoinPoint(false);
810a802,922
&gt;     void initializeThisJoinPoint() {
&gt;     	if (thisJoinPointVar == null) return;
&gt;     	
&gt;     	if (isThisJoinPointLazy) {
&gt;     		isThisJoinPointLazy = checkLazyTjp();
&gt;     	}
&gt;     		
&gt; 		if (isThisJoinPointLazy) {
&gt; 			createThisJoinPoint(); // make sure any state needed is initialized, but throw the instructions out
&gt; 			
&gt; 			if (lazyTjpConsumers == 1) return; // special case only one lazyTjpUser
&gt; 			
&gt; 			InstructionFactory fact = getFactory();
&gt; 			InstructionList il = new InstructionList();
&gt; 			il.append(InstructionConstants.ACONST_NULL);
&gt; 			il.append(thisJoinPointVar.createStore(fact));
&gt; 			range.insert(il, Range.OutsideBefore);
&gt; 		} else {
&gt; 			InstructionFactory fact = getFactory();
&gt; 			InstructionList il = createThisJoinPoint();
&gt; 			il.append(thisJoinPointVar.createStore(fact));
&gt; 			range.insert(il, Range.OutsideBefore);
&gt; 		}
&gt;     }
&gt;     
&gt;     private boolean checkLazyTjp() {    	
&gt;     	// check for around advice
&gt;     	for (Iterator i = mungers.iterator(); i.hasNext();) {
&gt; 			ShadowMunger munger = (ShadowMunger) i.next();
&gt; 			if (munger instanceof Advice) {
&gt; 				if ( ((Advice)munger).getKind() == AdviceKind.Around) {
&gt; 					world.getLint().canNotImplementLazyTjp.signal(
&gt; 					    new String[] {toString()},
&gt; 					    getSourceLocation(),
&gt; 					    new ISourceLocation[] { munger.getSourceLocation() }
&gt; 					);
&gt; 					return false;
&gt; 				}
&gt; 			}
&gt; 		}
&gt;     	
&gt;     	return true;
&gt;     }
&gt;     
&gt;     InstructionList loadThisJoinPoint() {
&gt; 		InstructionFactory fact = getFactory();
&gt; 		InstructionList il = new InstructionList();
&gt; 
&gt;     	if (isThisJoinPointLazy) {
&gt;     		il.append(createThisJoinPoint());
&gt;     		
&gt;     		if (lazyTjpConsumers &gt; 1) {
&gt; 				il.append(thisJoinPointVar.createStore(fact));
&gt; 				
&gt; 				InstructionHandle end = il.append(thisJoinPointVar.createLoad(fact));
&gt; 				
&gt; 				il.insert(InstructionFactory.createBranchInstruction(Constants.IFNONNULL, end));
&gt; 				il.insert(thisJoinPointVar.createLoad(fact));
&gt;     		}
&gt;     	} else {			
&gt; 			thisJoinPointVar.appendLoad(il, fact);
&gt;     	}
&gt;     	
&gt; 		return il;
&gt;     }
&gt; 
&gt; 	InstructionList createThisJoinPoint() {
&gt; 		InstructionFactory fact = getFactory();
&gt; 		InstructionList il = new InstructionList();
&gt; 		
&gt; 		BcelVar staticPart = getThisJoinPointStaticPartBcelVar();
&gt; 		staticPart.appendLoad(il, fact);
&gt; 		if (hasThis()) {
&gt; 			((BcelVar)getThisVar()).appendLoad(il, fact);
&gt; 		} else {
&gt; 			il.append(new ACONST_NULL());
&gt; 		}
&gt; 		if (hasTarget()) {
&gt; 			((BcelVar)getTargetVar()).appendLoad(il, fact);
&gt; 		} else {
&gt; 			il.append(new ACONST_NULL());
&gt; 		}
&gt; 		
&gt; 		switch(getArgCount()) {
&gt; 			case 0:
&gt; 				il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
&gt; 									"makeJP", LazyClassGen.tjpType,
&gt; 									new Type[] { LazyClassGen.staticTjpType,
&gt; 											Type.OBJECT, Type.OBJECT},
&gt; 									Constants.INVOKESTATIC));
&gt; 				break;
&gt; 			case 1:
&gt; 				((BcelVar)getArgVar(0)).appendLoadAndConvert(il, fact, world.resolve(ResolvedTypeX.OBJECT));
&gt; 				il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
&gt; 									"makeJP", LazyClassGen.tjpType,
&gt; 									new Type[] { LazyClassGen.staticTjpType,
&gt; 											Type.OBJECT, Type.OBJECT, Type.OBJECT},
&gt; 									Constants.INVOKESTATIC));
&gt; 				break;
&gt; 			case 2:
&gt; 				((BcelVar)getArgVar(0)).appendLoadAndConvert(il, fact, world.resolve(ResolvedTypeX.OBJECT));
&gt; 				((BcelVar)getArgVar(1)).appendLoadAndConvert(il, fact, world.resolve(ResolvedTypeX.OBJECT));
&gt; 				il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
&gt; 									"makeJP", LazyClassGen.tjpType,
&gt; 									new Type[] { LazyClassGen.staticTjpType,
&gt; 											Type.OBJECT, Type.OBJECT, Type.OBJECT, Type.OBJECT},
&gt; 									Constants.INVOKESTATIC));
&gt; 				break;
&gt; 			default:
&gt; 				il.append(makeArgsObjectArray());
&gt; 				il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
&gt; 									"makeJP", LazyClassGen.tjpType,
&gt; 									new Type[] { LazyClassGen.staticTjpType,
&gt; 											Type.OBJECT, Type.OBJECT, new ArrayType(Type.OBJECT, 1)},
&gt; 									Constants.INVOKESTATIC));
&gt; 				break;
&gt; 		}
&gt; 		
&gt; 		return il;
&gt; 	}
&gt;     
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java" revision="1.10" state="changed">47a48,51
&gt; 		checkCompile(source, new String[0], expectedErrors);
&gt; 	}
&gt; 	
&gt; 	public static void checkCompile(String source, String[] extraArgs, int[] expectedErrors) {
60a65,68
&gt; 		for (int i = 0; i &lt; extraArgs.length; i++) {
&gt; 			args.add(extraArgs[i]);
&gt; 		}
&gt; 		
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PerformanceTestCase.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/

package org.aspectj.ajdt.internal.compiler.batch;

import java.io.IOException;

import org.aspectj.testing.util.TestUtil;


public class PerformanceTestCase extends CommandTestCase {

	public PerformanceTestCase(String name) {
		super(name);
	}

	
	// this is a nice test, but not strictly needed
	public void xxx_testLazyTjpOff() throws IOException {
		checkCompile("src1/LazyTjp.aj", NO_ERRORS);
		try {
			TestUtil.runMain("out", "LazyTjp");
			fail("expected an exception when running without -XlazyTjp");
		} catch (IllegalStateException e) {
			// expected exception thrown when no -XlazyTjp
		}
	}
	
	public void testLazyTjp() throws IOException {
		checkCompile("src1/LazyTjp.aj", new String[] {"-XlazyTjp","-Xlint:error"}, new int[] {97});
		TestUtil.runMain("out", "LazyTjp");
	}
}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java" revision="1.3" state="changed">28c28,29
&lt;         suite.addTestSuite(CompileAndRunTestCase.class); 
---
&gt; 		suite.addTestSuite(CompileAndRunTestCase.class); 
&gt; 		suite.addTestSuite(PerformanceTestCase.class); 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LazyTjp.aj" revision="1.1" state="new">public class LazyTjp {&#13;
	&#13;
	private static final int N = 10000000;&#13;
	// if lazy tjp is working, then calling the advice that uses thisJoinPoint should&#13;
	// take at least this much longer than using an if pcd to bypass the advice&#13;
	private static final double minimumRatio = 8.0; &#13;
	&#13;
	public static void main(String[] args) {&#13;
		Trace.enabled = false;&#13;
		double tOff = timeIt();  // throw the first result out for warm-up&#13;
		tOff = timeIt();&#13;
		Trace.enabled = true;&#13;
		double tOn = timeIt();&#13;
		Trace.enabled = false;&#13;
		double tEasy = timeIt0();&#13;
		double tGone = timeIt1();&#13;
		&#13;
		System.out.println("tOff: " + tOff + ", tOn: " + tOn + ", tEasy: " + tEasy + ", tGone: " + tGone);&#13;
		System.out.println("ratio: " + tOn/tOff);&#13;
		&#13;
		Trace.enabled = false;&#13;
		double tOff2 = timeIt2();&#13;
		tOff2 = timeIt2();&#13;
		Trace.enabled = true;&#13;
		double tOn2 = timeIt2();&#13;
		&#13;
		System.out.println("tOff2: " + tOff2 + ", tOn2: " + tOn2);&#13;
		System.out.println("ratio2: " + tOn2/tOff2);&#13;
&#13;
		&#13;
		if (tOn/tOff &lt; minimumRatio) {&#13;
			throw new IllegalStateException("tOn/tOff = " + tOn/tOff + " &lt; " + minimumRatio);&#13;
		}&#13;
	}&#13;
	&#13;
	public static double timeIt() {&#13;
		long start = System.currentTimeMillis();&#13;
	&#13;
		for (int i=0; i &lt; N; i++) {&#13;
			doit(i);&#13;
		}&#13;
		&#13;
		long stop = System.currentTimeMillis();	&#13;
		return (stop-start)/1000.0;	&#13;
	}&#13;
	&#13;
	private static int doit(int x) {&#13;
		return x+1;&#13;
	}&#13;
	&#13;
	public static double timeIt0() {&#13;
		long start = System.currentTimeMillis();&#13;
	&#13;
		for (int i=0; i &lt; N; i++) {&#13;
			doit0(i);&#13;
		}&#13;
		&#13;
		long stop = System.currentTimeMillis();	&#13;
		return (stop-start)/1000.0;	&#13;
	}&#13;
	&#13;
	private static int doit0(int x) {&#13;
		return x+1;&#13;
	}&#13;
	&#13;
	public static double timeIt1() {&#13;
		long start = System.currentTimeMillis();&#13;
	&#13;
		for (int i=0; i &lt; N; i++) {&#13;
			doit1(i);&#13;
		}&#13;
		&#13;
		long stop = System.currentTimeMillis();	&#13;
		return (stop-start)/1000.0;	&#13;
	}&#13;
	&#13;
	private static int doit1(int x) {&#13;
		return x+1;&#13;
	}&#13;
	&#13;
	public static double timeIt2() {&#13;
		long start = System.currentTimeMillis();&#13;
	&#13;
		for (int i=0; i &lt; N; i++) {&#13;
			doit2(i);&#13;
		}&#13;
		&#13;
		long stop = System.currentTimeMillis();	&#13;
		return (stop-start)/1000.0;	&#13;
	}&#13;
	&#13;
	private static int doit2(int x) {&#13;
		return x+1;&#13;
	}&#13;
	&#13;
	private static int doit3(int x) {&#13;
		return x+1;&#13;
	}&#13;
}&#13;
&#13;
aspect Trace {&#13;
	public static boolean enabled = false;&#13;
	&#13;
	public static int counter = 0;&#13;
	&#13;
	pointcut traced(): if (enabled) &amp;&amp; execution(* LazyTjp.doit(..));&#13;
	&#13;
	before(): traced() {&#13;
		Object[] args = thisJoinPoint.getArgs();&#13;
		counter += args.length;&#13;
	}&#13;
	&#13;
	before(): execution(* LazyTjp.doit0(..)) {&#13;
		counter += 1;&#13;
	}&#13;
	&#13;
	pointcut traced2(): if (enabled) &amp;&amp; execution(* LazyTjp.doit2(..));&#13;
	&#13;
	before(): traced2() {&#13;
		Object[] args = thisJoinPoint.getArgs();&#13;
		counter += args.length;&#13;
	}&#13;
&#13;
	after() returning: traced2() {&#13;
		Object[] args = thisJoinPoint.getArgs();&#13;
		counter += args.length;&#13;
	}&#13;
&#13;
&#13;
	pointcut traced3(): if (enabled) &amp;&amp; execution(* LazyTjp.doit3(..));&#13;
	&#13;
	before(): traced3() {&#13;
		Object[] args = thisJoinPoint.getArgs();&#13;
		counter += args.length;&#13;
	}&#13;
&#13;
	Object around(): traced3() {  // expect Xlint warning in -XlazyTjp mode&#13;
		return proceed();&#13;
	}&#13;
&#13;
&#13;
}</file>
</fixedFiles>
</bug>
<bug id="48990" transactionid="71419">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="11"/>
<property name="lines-added" value="150"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="150"/>
<property name="priority" value="P2"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-case K-class K-else K-if K-import K-instanceof K-new K-null K-return K-super M O-instanceof T V Y Z-if</fullfingerprint>
<bugreport>FastMatch, the efficient pattern matching for pointcuts on the constant pool, is
currrently only implemented for the within pointcut. I am planning to provide
further oimplementations for other pointcuts by release 1.2.</bugreport>
<testsforfix ID="48990" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="if(false) optimisation"/>
      <test NAME="if(true) optimisation"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="105" file="output/48990/pre-fix/testresults.xml" passing="1205" size="1310"/>
<post-fix-testcases failing="105" file="output/48990/post-fix/testresults.xml" passing="1207" size="1312"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java" revision="1.5" state="changed">25a26
&gt; import org.eclipse.jdt.internal.compiler.ast.FalseLiteral;
28a30
&gt; import org.eclipse.jdt.internal.compiler.ast.TrueLiteral;
67c69,75
&lt; 		pointcut = new IfPointcut(new ResolvedMember(Member.METHOD, TypeX.OBJECT, 0, "if_", "()V"), 0);
---
&gt; 		if (expr instanceof FalseLiteral) {
&gt; 			return IfPointcut.makeIfFalsePointcut(Pointcut.SYMBOLIC);
&gt; 		} else if (expr instanceof TrueLiteral) {
&gt; 			return IfPointcut.makeIfTruePointcut(Pointcut.SYMBOLIC);
&gt; 		} else {
&gt; 		  pointcut = new IfPointcut(new ResolvedMember(Member.METHOD, TypeX.OBJECT, 0, "if_", "()V"), 0);
&gt; 		}
68a77
&gt; 		
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/Pointcut.java" revision="1.12" state="changed">105a106,107
&gt; 	public static final byte IF_TRUE = 14;
&gt; 	public static final byte IF_FALSE = 15;
219a222,223
&gt; 			case IF_TRUE: ret = IfPointcut.makeIfTruePointcut(RESOLVED); break;
&gt; 			case IF_FALSE: ret = IfPointcut.makeIfFalsePointcut(RESOLVED); break;
286c290,291
&lt;     
---
&gt;  
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/IfPointcut.java" revision="1.15" state="changed">22a23
&gt; import org.aspectj.lang.JoinPoint;
206a208,341
&gt; //	public static Pointcut MatchesNothing = new MatchesNothingPointcut();
&gt; //	??? there could possibly be some good optimizations to be done at this point
&gt; 	public static IfPointcut makeIfFalsePointcut(State state) {
&gt; 		IfPointcut ret = new IfFalsePointcut();
&gt; 		ret.state = state;
&gt; 		return ret;
&gt; 	}
&gt; 
&gt; 	private static class IfFalsePointcut extends IfPointcut {
&gt; 		
&gt; 		public IfFalsePointcut() {
&gt; 			super(null,0);
&gt; 		}
&gt; 		
&gt; 		public Test findResidue(Shadow shadow, ExposedState state) {
&gt; 			return Literal.FALSE; // can only get here if an earlier error occurred
&gt; 		}
&gt; 
&gt; 		public FuzzyBoolean fastMatch(FastMatchInfo type) {
&gt; 			return FuzzyBoolean.NO;
&gt; 		}
&gt; 		
&gt; 		public FuzzyBoolean match(Shadow shadow) {
&gt; 			return FuzzyBoolean.NO;
&gt; 		}
&gt; 		
&gt; 		public FuzzyBoolean match(JoinPoint.StaticPart jpsp) {
&gt; 			return FuzzyBoolean.NO;
&gt; 		}
&gt; 
&gt; 		public void resolveBindings(IScope scope, Bindings bindings) {
&gt; 		}
&gt; 		
&gt; 		public void resolveBindingsFromRTTI() {
&gt; 		}
&gt; 
&gt; 		public void postRead(ResolvedTypeX enclosingType) {
&gt; 		}
&gt; 
&gt; 		public Pointcut concretize1(
&gt; 			ResolvedTypeX inAspect,
&gt; 			IntMap bindings) {
&gt; 			if (isDeclare(bindings.getEnclosingAdvice())) {
&gt; 				// Enforce rule about which designators are supported in declare
&gt; 				inAspect.getWorld().showMessage(IMessage.ERROR,
&gt; 				  "if() pointcut designator cannot be used in declare statement",
&gt; 				  bindings.getEnclosingAdvice().getSourceLocation(),
&gt; 				  null);
&gt; 				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
&gt; 			}
&gt; 			return makeIfFalsePointcut(state);
&gt; 		}
&gt; 
&gt; 
&gt; 		public void write(DataOutputStream s) throws IOException {
&gt; 			s.writeByte(Pointcut.IF_FALSE);
&gt; 		}
&gt; 		
&gt; 	    public int hashCode() {
&gt; 	        int result = 17;
&gt; 	        return result;
&gt; 	    }
&gt; 		
&gt; 	    public String toString() {
&gt; 			return "if(false)";
&gt; 		}	
&gt; 	}
&gt; 
&gt; 	public static IfPointcut makeIfTruePointcut(State state) {
&gt; 		IfPointcut ret = new IfTruePointcut();
&gt; 		ret.state = state;
&gt; 		return ret;
&gt; 	}
&gt; 
&gt; 	private static class IfTruePointcut extends IfPointcut {		
&gt; 			
&gt; 		public IfTruePointcut() {
&gt; 			super(null,0);
&gt; 		}
&gt; 		
&gt; 		public Test findResidue(Shadow shadow, ExposedState state) {
&gt; 			return Literal.TRUE; // can only get here if an earlier error occurred
&gt; 		}
&gt; 
&gt; 		public FuzzyBoolean fastMatch(FastMatchInfo type) {
&gt; 			return FuzzyBoolean.YES;
&gt; 		}
&gt; 		
&gt; 		public FuzzyBoolean match(Shadow shadow) {
&gt; 			return FuzzyBoolean.YES;
&gt; 		}
&gt; 		
&gt; 		public FuzzyBoolean match(JoinPoint.StaticPart jpsp) {
&gt; 			return FuzzyBoolean.YES;
&gt; 		}
&gt; 
&gt; 		public void resolveBindings(IScope scope, Bindings bindings) {
&gt; 		}
&gt; 		
&gt; 		public void resolveBindingsFromRTTI() {
&gt; 		}
&gt; 
&gt; 		public void postRead(ResolvedTypeX enclosingType) {
&gt; 		}
&gt; 
&gt; 		public Pointcut concretize1(
&gt; 			ResolvedTypeX inAspect,
&gt; 			IntMap bindings) {
&gt; 			if (isDeclare(bindings.getEnclosingAdvice())) {
&gt; 				// Enforce rule about which designators are supported in declare
&gt; 				inAspect.getWorld().showMessage(IMessage.ERROR,
&gt; 				  "if() pointcut designator cannot be used in declare statement",
&gt; 				  bindings.getEnclosingAdvice().getSourceLocation(),
&gt; 				  null);
&gt; 				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
&gt; 			}
&gt; 			return makeIfTruePointcut(state);
&gt; 		}
&gt; 
&gt; 
&gt; 		public void write(DataOutputStream s) throws IOException {
&gt; 			s.writeByte(IF_TRUE);
&gt; 		}
&gt; 		
&gt; 	    public int hashCode() {
&gt; 	        int result = 37;
&gt; 	        return result;
&gt; 	    }
&gt; 		
&gt; 	    public String toString() {
&gt; 			return "if(true)";
&gt; 		}	
&gt; 	}
&gt; 
207a343
&gt; 
</file>
<file name="org.aspectj/modules/tests/new/IfTrue.aj" revision="1.1" state="new">import org.aspectj.testing.Tester;

public aspect  IfTrue {
	
	private static boolean x = true;
	
	pointcut p1() : !if(true);
	
	pointcut p2() : !if(  true  );
	
	pointcut p3() : !if(x) &amp;&amp; execution(* *(..));
	
	pointcut p4() : within(IfTrue) &amp;&amp; !if(true);
	
	
	after() returning : p1() {
		// should never get here
		Tester.checkFailed("!if(true) matched!");
	}

	after() returning : p2() {
		// should never get here
		Tester.checkFailed("!if(   true   ) matched!");
	}

	after() returning : p3() {
		// should never get here
		Tester.checkFailed("!if(x) matched!");
	}

	after() returning : p4() {
		// should never get here
		Tester.checkFailed("!if(true) matched!");
	}
	
	public static void main(String[] args) {}
}</file>
<file name="org.aspectj/modules/tests/new/IfFalse.aj" revision="1.1" state="new">import org.aspectj.testing.Tester;

public aspect  IfFalse {
	
	private static boolean x = false;
	
	pointcut p1() : if(false);
	
	pointcut p2() : if(  false  );
	
	pointcut p3() : if(x);
	
	pointcut p4() : within(IfFalse) &amp;&amp; if(false);
	
	
	after() returning : p1() {
		// should never get here
		Tester.checkFailed("if(false) matched!");
	}

	after() returning : p2() {
		// should never get here
		Tester.checkFailed("if(   false   ) matched!");
	}

	after() returning : p3() {
		// should never get here
		Tester.checkFailed("if(x) matched!");
	}

	after() returning : p4() {
		// should never get here
		Tester.checkFailed("if(false) matched!");
	}
	
	public static void main(String[] args) {}
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.164" state="changed">7796a7797,7808
&gt;    
&gt;       &lt;ajc-test dir="new"
&gt;       title="if(false) optimisation" pr="48990"&gt;
&gt;         &lt;compile files="IfFalse.aj"/&gt;
&gt;         &lt;run class="IfFalse"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;    
&gt;     &lt;ajc-test dir="new"
&gt;       title="if(true) optimisation" pr="48990"&gt;
&gt;         &lt;compile files="IfTrue.aj"/&gt;
&gt;         &lt;run class="IfTrue"/&gt;
&gt;     &lt;/ajc-test&gt; 
</file>
</fixedFiles>
</bug>
<bug id="49250" transactionid="70581">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-return T V</fullfingerprint>
<tag>exception</tag>
<bugreport>SoftException should implement getCause():

   public Throwable getCause() {
       return inner;
   }

(As pointed out by Ramnivas, misc mail messages, code comments...)

Using getCause() means the chain should print as expected in 1.4+, esp. when
SoftException is itself wrapped as a RemoteException.  Since getCause()
replicates getWrappedThrowable(), we could deprecate that, but we must continue
to support it to maintain upwards binary compatibility in the runtime classes.</bugreport>
<pre-fix-testcases failing="85" file="output/49250/pre-fix/testresults.xml" passing="1099" size="1184"/>
<post-fix-testcases failing="85" file="output/49250/post-fix/testresults.xml" passing="1099" size="1184"/>
<fixedFiles>
<file name="org.aspectj/modules/runtime/src/org/aspectj/lang/SoftException.java" revision="1.2" state="changed">33a34
&gt;     public Throwable getCause() { return inner; }
35,36d35
&lt;     //XXX should add a getCause() method to parallel j2se 1.4's new
&lt;     //XXX chained exception mechanism
</file>
</fixedFiles>
</bug>
<bug id="49457" transactionid="71495">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-instanceof K-null K-true M O-|| O-!= O-cast O-instanceof T V Z-cast Z-if</fullfingerprint>
<bugreport>The compiler might not be detecting overloaded pointcut names when parameters
are not bound, and/or might not be implementing the pointcut correctly.  Below
is the context from my reply to Ron Bodkin on aspectj-dev "Proper behavior of
overloaded pointcut definitions".  (I have not checked this code recently or
submitted a test case, nor have I evaluated whether my code below actually
replicates Ron's bug.)

---- context from the email
The programming guide says,

  It is an error for two pointcuts to be named with the same
  name in the same class or aspect declaration.

When I compile with overloaded pointcut names, I do get an error.

    pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run());
    pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run());

 $ aspectj-1.1.1 -classpath $ajrt11 OverloadedPointcut.java
 ...\OverloadedPointcut.java:14 duplicate pointcut name: pc
 ...\OverloadedPointcut.java:15 duplicate pointcut name: pc

...

When I use these pointcuts with bound parameters, I get an error.

    before(Runnable r) : pc(r) { log("pc(Runnable r)"); }
    before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); }

When I use these pointcuts with type parameters, I get no errors.

    before() : pc(Runnable) { log("pc(Runnable)"); }
    before() : pc(SubRunnable) { log("pc(SubRunnable)"); }
    before() : pc(*) { log("pc(*)"); }

[...]

---- my code
public class OverloadedPointcut {
    public static void main(String[] args) {
        new C().run();
    }
}
class C { public void run() {} }

aspect A {
    declare parents: C implements Runnable;
    declare parents: C implements SubRunnable;
    interface SubRunnable extends Runnable {}

    pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run());
    pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run());
    before(Runnable r) : pc(r) { log("pc(Runnable r)"); }
    before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); }
    before() : pc(Runnable) { log("pc(Runnable)"); }
    before() : pc(SubRunnable) { log("pc(SubRunnable)"); }
    before() : pc(*) { log("pc(*)"); }
    void log(String s) { System.out.println(s); }
} 

---- Ron's code
[...] the following program compiles with no warnings, produces no output when
run under AspectJ 1.1.1.  It appears to behave as if the more specific
definition is the only definition of the pointcut
[...]
Here is a simple program that illustrates the question and odd behavior:

package lib;

public class RunnablePointcuts {
    public pointcut runnableCalls(Runnable runnable, Object caller) :
        call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller);

    //public pointcut specialRunnableCalls(SpecialRunnable runnable, Object
caller) :
    public pointcut runnableCalls(SpecialRunnable runnable, Object caller) :
        call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller);
}
---
package lib;

public interface SpecialRunnable extends Runnable {
}
---
package client;

import lib.RunnablePointcuts;
import lib.SpecialRunnable;

public aspect Use {
    before(Object caller) : RunnablePointcuts.runnableCalls(*, caller) &amp;&amp;
target(MyRunnable) {
        System.out.println("my runnable called from "+caller);
    }
    public static void main(String args[]) {
	Use.aspectOf().doIt();
    }
    public void doIt() {
        new MyRunnable().run();
    }
}

// the advice will run if you make this implement SpecialRunnable
//class MyRunnable implements SpecialRunnable {
class MyRunnable implements Runnable {
    public void run() {}
}</bugreport>
<testsforfix ID="49457" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="No error on overloaded pointcuts in class"/>
      <test NAME="No error on overloaded pointcuts unless binding variables"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="84" file="output/49457/pre-fix/testresults.xml" passing="1098" size="1182"/>
<post-fix-testcases failing="84" file="output/49457/post-fix/testresults.xml" passing="1066" size="1150"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java" revision="1.17" state="changed">71,72d70
&lt; 		if (concreteName != null) concreteName.checkPointcutDeclarations();
&lt; 		
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.16" state="changed">179c179
&lt;         
---
&gt;         boolean hasPointcuts = false;
184a185
&gt;                 	hasPointcuts = true;
193c194,200
&lt;         
---
&gt; 
&gt; 		if (hasPointcuts || dec instanceof AspectDeclaration) {
&gt;         	ResolvedTypeX.Name name = (ResolvedTypeX.Name)factory.fromEclipse(sourceType);
&gt;         	EclipseSourceType eclipseSourceType = (EclipseSourceType)name.getDelegate();
&gt;         	eclipseSourceType.checkPointcutDeclarations();
&gt; 		}
&gt; 		
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.112" state="changed">6804a6805,6824
&gt;     &lt;ajc-test dir="bugs" pr="49457"
&gt;    	 title="No error on overloaded pointcuts in class"&gt;
&gt;         &lt;compile files="OverloadedPointcutsInClass.java"&gt;
&gt;         	&lt;message kind="error" line="3" text="duplicate pointcut name: pc1"/&gt;
&gt;         	&lt;message kind="error" line="4" text="duplicate pointcut name: pc1"/&gt;
&gt;         	&lt;message kind="error" line="6" text="duplicate pointcut name: pc2"/&gt;
&gt;         	&lt;message kind="error" line="7" text="duplicate pointcut name: pc2"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="49457"
&gt;    	 title="No error on overloaded pointcuts unless binding variables"&gt;
&gt;         &lt;compile files="OverloadedPointcutsInAspect.java"&gt;
&gt;         	&lt;message kind="error" line="15" text="duplicate pointcut name: pc"/&gt;
&gt;         	&lt;message kind="error" line="16" text="duplicate pointcut name: pc"/&gt;
&gt;         	&lt;message kind="error" line="18" text="incompatible type"/&gt;
&gt;         	&lt;message kind="error" line="20" text="incompatible type"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs/OverloadedPointcutsInAspect.java" revision="1.1" state="new">class OverloadedPointcutsInAspect {
	public static void main(String[] args) {
		new C().run();
	}
}
class C { 
	public void run() {} 
}

aspect A {
	declare parents: C implements Runnable;
	declare parents: C implements SubRunnable;
	interface SubRunnable extends Runnable {}

	pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run());
	pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run());
	before(Runnable r) : pc(r) { log("pc(Runnable r)"); }
	before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); }
	before() : pc(Runnable) { log("pc(Runnable)"); }
	before() : pc(SubRunnable) { log("pc(SubRunnable)"); }
	before() : pc(*) { log("pc(*)"); }
	void log(String s) { System.out.println(s); }
} 
</file>
<file name="org.aspectj/modules/tests/bugs/OverloadedPointcutsInClass.java" revision="1.1" state="new">public class OverloadedPointcutsInClass {

  pointcut pc1(): call(* *(..));
  pointcut pc1(): execution(* *(..));
  
  pointcut pc2(String s): call(* *(..)) &amp;&amp; target(s);
  pointcut pc2(StringBuffer sb): call(* *(..)) &amp;&amp; target(sb);

}
</file>
</fixedFiles>
</bug>
<bug id="49638" transactionid="72327">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-new M T V Y</fullfingerprint>
<tag>exception</tag>
<bugreport>The problem is found by the example in Listing 5.15 from Laddad's AspectJ in
Action book. It looks like an exception object in after() throwing(Throwable ex)
advice has a problem being converted to string in a _logger.logp() call.

Environment
-----------
OS:
Solaris 8 kernel patch level 108528-27 plus j2se recommended patches

Java version:
java -version
java version "1.4.2"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2-b28)
Java HotSpot(TM) Client VM (build 1.4.2-b28, mixed mode)

The problem has also been reproduced with AspectJ 1.1.1 on Windows 2000
5.00.2195, SP 4.

Description
-----------
ajc aborts with the following output:

trouble in: 
public class TestException extends java.lang.Object:
  public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1
  public void &lt;init&gt;():
                    ALOAD_0     // TestException this   (line 1)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void TestException.&lt;init&gt;())
    |               RETURN
    constructor-execution(void TestException.&lt;init&gt;())
  end public void &lt;init&gt;()

  public static void main(String[]):
    method-execution(void TestException.main(java.lang.String[]))
    | method-call(void TestException.perform())
    | | catch java.lang.Throwable -&gt; E0
    | | |           INVOKESTATIC TestException.perform ()V   (line 4)
    | | catch java.lang.Throwable -&gt; E0
    | |             GOTO L0
    | |         E0: ASTORE_1
    | |             INVOKESTATIC ExceptionLoggerAspectV2.aspectOf
()LExceptionLoggerAspectV2;
    | |             ALOAD_1
    | |             GETSTATIC TestException.ajc$tjp_0
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL
ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a
(Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | |             ALOAD_1
    | |             ATHROW
    | |         L0: NOP
    | |             ACONST_NULL
    | |             ASTORE_2
    | |             INVOKESTATIC ExceptionLoggerAspectV2.aspectOf
()LExceptionLoggerAspectV2;
    | |             ALOAD_2
    | |             CHECKCAST java.lang.Throwable
    | |             GETSTATIC TestException.ajc$tjp_0
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL
ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a
(Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | |             NOP
    | method-call(void TestException.perform())
    |               RETURN   (line 5)
    method-execution(void TestException.main(java.lang.String[]))
  end public static void main(String[])

  public static void perform():
    method-execution(void TestException.perform())
    |               ACONST_NULL   (line 8)
    |               ASTORE_0
    |               ALOAD_0     // java.lang.Object nullObj   (line 9)
    | method-call(java.lang.String java.lang.Object.toString())
    | | catch java.lang.Throwable -&gt; E0
    | | |           INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String;
    | | catch java.lang.Throwable -&gt; E0
    | |             GOTO L0
    | |         E0: ASTORE_1
    | |             INVOKESTATIC ExceptionLoggerAspectV2.aspectOf
()LExceptionLoggerAspectV2;
    | |             ALOAD_1
    | |             GETSTATIC TestException.ajc$tjp_1
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | |             INVOKEVIRTUAL
ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a
(Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | |             ALOAD_1
    | |             ATHROW
    | |         L0: NOP
    | method-call(java.lang.String java.lang.Object.toString())
    |               POP
    |               RETURN   (line 10)
    method-execution(void TestException.perform())
  end public static void perform()
end public class TestException
ABORT
Exception thrown from AspectJ 1.1.1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
can't convert from java.lang.String to java.lang.Throwable
can't convert from java.lang.String to java.lang.Throwable
org.aspectj.weaver.BCException: can't convert from java.lang.String to
java.lang.Throwable
        at org.aspectj.weaver.bcel.Utility.appendConversion(Utility.java:203)
        at org.aspectj.weaver.bcel.BcelVar.appendLoadAndConvert(BcelVar.java:57)
        at org.aspectj.weaver.bcel.BcelAdvice.getAdviceArgSetup(BcelAdvice.java:287)
        at
org.aspectj.weaver.bcel.BcelAdvice.getAdviceInstructions(BcelAdvice.java:244)
        at
org.aspectj.weaver.bcel.BcelShadow.weaveAfterReturning(BcelShadow.java:986)
        at org.aspectj.weaver.bcel.BcelShadow.weaveAfter(BcelShadow.java:941)
        at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:126)
        at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:341)
        at org.aspectj.weaver.Shadow.implement(Shadow.java:313)
        at
org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1006)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:299)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:327)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:256)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:156)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)


1 fail|abort

Sample code is two files, TextException.java and ExceptionLoggerAspectV2.java
(see below). To reproduce the problem, do

$ ajc *.java

File 1  - TestException.java
----------------------------
public class TestException 
{
    public static void main(String[] args) {
        perform();
    }

    public static void perform() {
        Object nullObj = null;
        nullObj.toString();
    }
}

File 2 - ExceptionLoggerAspectV2.java
-------------------------------------
import java.util.logging.*;
import org.aspectj.lang.*;

public aspect ExceptionLoggerAspectV2 
{
    Logger _logger = Logger.getLogger("exceptions");

    ExceptionLoggerAspectV2() {
        _logger.setLevel(Level.ALL);
    }

    pointcut exceptionLogMethods()
        : call(* *.*(..)) &amp;&amp; !within(ExceptionLoggerAspectV2);

    after() thowing(Throwable ex) : exceptionLogMethods() {
        if (_logger.isLoggable(Level.WARNING)) {
            Signature sig = thisJoinPointStaticPart.getSignature();
            _logger.logp(Level.WARNING,
                         sig.getDeclaringType().getName(),
                         sig.getName(),
                         "Exception logger aspect", ex);
        }
    }
}</bugreport>
<testsforfix ID="49638" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Appropriate message for 'after() thowing(Throwable th)' syntax error"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="84" file="output/49638/pre-fix/testresults.xml" passing="1111" size="1195"/>
<post-fix-testcases failing="84" file="output/49638/post-fix/testresults.xml" passing="1112" size="1196"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java" revision="1.7" state="changed">740c740,745
&lt; 	    	//XXX illegal name here
---
&gt; 			problemReporter().parseError(
&gt; 				start, 
&gt; 				end, 
&gt; 				name, 
&gt; 				String.valueOf(name), 
&gt; 				new String[] {"throwing", "returning", ":"}); 
</file>
<file name="org.aspectj/modules/tests/bugs/AfterThrowingAdviceSyntaxError.java" revision="1.1" state="new">import org.aspectj.lang.*;

public class AfterThrowingAdviceSyntaxError {

	public static void main(String[] args) {
		perform();
	}

	private static void perform() {
		Object nullObj = null;
		nullObj.toString();
	}
}

aspect ExceptionLoggerAspectV2 
{

	pointcut exceptionLogMethods()
		: call(* *.*(..)) &amp;&amp; !within(ExceptionLoggerAspectV2);

	after() thowing(Throwable ex) : exceptionLogMethods() {
		Signature sig = thisJoinPointStaticPart.getSignature();
		System.out.printl("WARNING: " 
			+ sig.getDeclaringType().getName() + " "
			+ sig.getName() + " "
			+ "Exception logger aspect " + ex);
	}
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.118" state="changed">6900c6900,6911
&lt;    
---
&gt; 
&gt; 	&lt;ajc-test dir="bugs"
&gt; 		title="Appropriate message for 'after() thowing(Throwable th)' syntax error"
&gt; 		pr="49638"
&gt; 		&gt;
&gt; 		&lt;compile 
&gt; 			files="AfterThrowingAdviceSyntaxError.java" &gt;
&gt; 			&lt;message kind="error" line="21" /&gt;
&gt; 			&lt;message kind="error" line="23" /&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
&gt;     
</file>
</fixedFiles>
</bug>
<bug id="49657" transactionid="70103">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="24"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="21"/>
<property name="lines-churned" value="45"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-for K-if K-import K-null K-return K-this M O-== O-! O-!= O-?: O-() O-cast T V Y Z-cast Z-cond Z-if Z-vardecl Z-while</fullfingerprint>
<bugreport>I was weaving a 3rd party library and wrote an aspect that should affect both a 
base class and a derived class, but inadvertently wove only the derived class.  
This resulted in the following error. I would like the weaver to catch this 
kind of error at weave (link) time, rather than creating code that results in a 
rt error... I get this error in 1.1.1 final and in a fairly recent version from 
CVS HEAD:

java.lang.AbstractMethodError
	at ajee.logging.LogManager.ajc$interMethodDispatch1
$ajee_logging_LogManager$ajee_logging_Loggable$getLogger(LogManager.java)
	at 
ajee.tracing.ExecutionTracer.ajc$before$ajee_tracing_ExecutionTracer$926
(ExecutionTracer.java:62)
	at library.Derived.&lt;init&gt;(Derived.java:46)

This line is a call to super();

I've attached a small example that reproduces another error that I think is 
related:
C:\devel\test\ctors\twoPass&gt;build

C:\devel\test\ctors\twoPass&gt;call ajc -outjar fullBase.jar sample\Base.java sampl
e\Derived.java
Exception in thread "main" java.lang.ExceptionInInitializerError
        at sample.Derived.&lt;init&gt;(Derived.java:6)
        at sample.Derived.main(Derived.java:13)
Caused by: org.aspectj.lang.NoAspectBoundException
        at sample.Trace.aspectOf(Trace.aj)
        at sample.Trace.&lt;init&gt;(Trace.aj:5)
        at sample.Trace.ajc$postClinit(Trace.aj)
        at sample.Trace.&lt;clinit&gt;(Trace.aj:5)
        ... 2 more</bugreport>
<testsforfix ID="49657" type="new">
    <file LOCATION="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PartiallyExposedHierarchyTestCase.java">
      <test NAME="testPartiallyExposedHierarchy"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="97" file="output/49657/pre-fix/testresults.xml" passing="1121" size="1218"/>
<post-fix-testcases failing="113" file="output/49657/post-fix/testresults.xml" passing="1265" size="1378"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/weaver-messages.properties" revision="1.7" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeaverMessages.java" revision="1.6" state="changed">54a55
&gt; 	public static final String ITD_NON_EXPOSED_IMPLEMENTOR = "itdNonExposedImplementor";
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.20" state="changed">26a27,28
&gt; import org.aspectj.bridge.ISourceLocation;
&gt; import org.aspectj.bridge.MessageUtil;
42a45
&gt; import org.aspectj.weaver.WeaverMessages;
417,420c420,441
&lt; 		} else if (onInterface &amp;&amp; gen.getType().isTopmostImplementor(onType) &amp;&amp; 
&lt; 						!Modifier.isAbstract(signature.getModifiers()))
&lt; 		{
&lt; 			ResolvedMember introMethod = 
---
&gt;     		
&gt; 		} else if (onInterface &amp;&amp; !Modifier.isAbstract(signature.getModifiers())) {
&gt; 			
&gt; 			// This means the 'gen' should be the top most implementor
&gt; 			// - if it is *not* then something went wrong after we worked
&gt; 			// out that it was the top most implementor (see pr49657)
&gt;     		if (!gen.getType().isTopmostImplementor(onType)) {
&gt;     			ResolvedTypeX rtx = gen.getType().getTopmostImplementor(onType);
&gt;     			if (!rtx.isExposedToWeaver()) {
&gt;     				ISourceLocation sLoc = munger.getSourceLocation();
&gt;     			    weaver.getWorld().getMessageHandler().handleMessage(MessageUtil.error(
&gt;     			    		WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR,rtx,getAspectType().getName()),
&gt; 							(sLoc==null?getAspectType().getSourceLocation():sLoc)));
&gt;     			} else {
&gt;     				// XXX what does this state mean?
&gt;     				// We have incorrectly identified what is the top most implementor and its not because
&gt;     				// a type wasn't exposed to the weaver
&gt;     			}
&gt; 				return false;
&gt;     		} else {
&gt; 		
&gt; 			  ResolvedMember introMethod = 
423c444
&lt; 			LazyMethodGen mg = makeMethodGen(gen, introMethod);
---
&gt; 			  LazyMethodGen mg = makeMethodGen(gen, introMethod);
425,426c446,447
&lt; 			Type[] paramTypes = BcelWorld.makeBcelTypes(introMethod.getParameterTypes());
&lt; 			Type returnType = BcelWorld.makeBcelType(introMethod.getReturnType());
---
&gt; 			  Type[] paramTypes = BcelWorld.makeBcelTypes(introMethod.getParameterTypes());
&gt; 			  Type returnType = BcelWorld.makeBcelType(introMethod.getReturnType());
428,430c449,451
&lt; 			InstructionList body = mg.getBody();
&lt; 			InstructionFactory fact = gen.getFactory();
&lt; 			int pos = 0;
---
&gt; 			  InstructionList body = mg.getBody();
&gt; 			  InstructionFactory fact = gen.getFactory();
&gt; 			  int pos = 0;
432c453
&lt; 			if (!introMethod.isStatic()) {
---
&gt; 			  if (!introMethod.isStatic()) {
435,436c456,457
&lt; 			}
&lt; 			for (int i = 0, len = paramTypes.length; i &lt; len; i++) {
---
&gt; 			  }
&gt; 			  for (int i = 0, len = paramTypes.length; i &lt; len; i++) {
440,443c461,464
&lt; 			}
&lt; 			body.append(Utility.createInvoke(fact, weaver.getWorld(), dispatchMethod));
&lt; 			body.append(InstructionFactory.createReturn(returnType));
&lt; 			mg.definingType = onType;
---
&gt; 			  }
&gt; 			  body.append(Utility.createInvoke(fact, weaver.getWorld(), dispatchMethod));
&gt; 			  body.append(InstructionFactory.createReturn(returnType));
&gt; 			  mg.definingType = onType;
445c466
&lt; 			weaver.addOrReplaceLazyMethodGen(mg);
---
&gt; 			  weaver.addOrReplaceLazyMethodGen(mg);
447c468
&lt; 			addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
---
&gt; 			  addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
449c470,471
&lt; 			return true;
---
&gt; 			  return true;
&gt;     		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.32" state="changed">1309a1310,1328
&gt; 	public ResolvedTypeX getTopmostImplementor(ResolvedTypeX interfaceType) {
&gt; 		if (isInterface()) return null;
&gt; 		if (!interfaceType.isAssignableFrom(this)) return null;
&gt; 		// Check if my super class is an implementor?
&gt; 		ResolvedTypeX higherType  = this.getSuperclass().getTopmostImplementor(interfaceType);
&gt; 		if (higherType!=null) return higherType;
&gt; 		return this;
&gt; 	}
&gt; 	
&gt; 	private ResolvedTypeX findHigher(ResolvedTypeX other) {
&gt; 	 if (this == other) return this;
&gt;      for(Iterator i = other.getDirectSupertypes(); i.hasNext(); ) {
&gt;      	ResolvedTypeX rtx = (ResolvedTypeX)i.next();
&gt;      	boolean b = this.isAssignableFrom(rtx);
&gt;      	if (b) return rtx;
&gt;      }       
&gt;      return null;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java" revision="1.5" state="changed">32a33
&gt;         suite.addTestSuite(PartiallyExposedHierarchyTestCase.class);
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PartiallyExposedHierarchyTestCase.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package org.aspectj.ajdt.internal.compiler.batch;

import java.io.File;

import org.aspectj.tools.ajc.AjcTestCase;
import org.aspectj.tools.ajc.CompilationResult;

/**
 * If you need to rebuild the components for this test, I'm afraid you will have
 * to run build.cmd in the testdata/partialHierarchy directory which calls ajc and
 * does some jar manipulation.
 */
public class PartiallyExposedHierarchyTestCase extends AjcTestCase {

	public static final String PROJECT_DIR = "partialHierarchy";

	private File baseDir;
	
	protected void setUp() throws Exception {
		super.setUp();
		baseDir = new File("../org.aspectj.ajdt.core/testdata",PROJECT_DIR);
	}
	
	/**
	 * This test verifies that AspectJ behaves correctly when parts of an object
	 * hierarchy are exposed to it for weaving.  See pr49657 for all the details.
	 */
	public void testPartiallyExposedHierarchy () {
		Message warning = new Message(11,"no interface constructor-execution join point");
		//TODO This line number will change to 15 (from 5) when type mungers remember where they came from!
		Message error   = new Message(5, "type sample.Base must be accessible for weaving interface inter type declaration from aspect sample.Trace");
		CompilationResult result = ajc(baseDir,
				new String[]{"-classpath","fullBase.jar",
							 "-injars","base.jar",
							 "sample"+File.separator+"Trace.aj"});
//		System.err.println(result.getWarningMessages());
//		System.err.println(result.getErrorMessages());
//		System.err.println(result.getStandardOutput());
		MessageSpec spec = new MessageSpec(null,newMessageList(warning),newMessageList(error));
		assertMessages(result,spec);
	}
	

}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/partialHierarchy/base.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/partialHierarchy/woven.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Derived.java" revision="1.1" state="new">package sample;

public class Derived extends Base {
    int y;
    public Derived() {
	super();
	y = 2;
    }

    public void foo() {}

    public static void main(String args[]) {
	new Derived();
    }
}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/partialHierarchy/fullBase.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Base.java" revision="1.1" state="new">package sample;

public abstract class Base implements Iface {
    int x;
    Base() {
	x=1;
    }
    abstract void foo();
}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/partialHierarchy/build.cmd" revision="1.1" state="new"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Trace.aj" revision="1.1" state="new">package sample;&#13;
&#13;
import java.util.logging.Logger;&#13;
&#13;
public aspect Trace {&#13;
    public interface Traced {}&#13;
    declare parents: (sample.* &amp;&amp; !Trace) extends Traced;&#13;
&#13;
//    private Logger Traced.logger;&#13;
    before(Traced current) : &#13;
	execution(Traced+.new(..)) &amp;&amp; !execution(Traced.new()) &amp;&amp; this(current) {&#13;
	current.getLogger().severe("entering ctor for "+thisJoinPoint);&#13;
    }&#13;
&#13;
    public Logger Traced.getLogger() {&#13;
 //       if (logger == null) {&#13;
//	    logger = Logger.getLogger(getClass().toString());&#13;
 //       }&#13;
//	return logger;&#13;
return null;&#13;
    }&#13;
}&#13;
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Iface.java" revision="1.1" state="new">package sample;

public interface Iface {
}
</file>
</fixedFiles>
</bug>
<bug id="49743" transactionid="68384">
<property name="files-churned" value="10"/>
<property name="java-files-churned" value="10"/>
<property name="classes-churned" value="10"/>
<property name="methods-churned" value="10"/>
<property name="hunks" value="22"/>
<property name="lines-added" value="23"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="30"/>
<property name="lines-churned" value="55"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-new K-null K-return K-this K-true M O-== O-|| O-?: O-() O-+ O-cast T V Y Z-cast Z-cond Z-if</fullfingerprint>
<bugreport>I am heavily using the runtime signature information from
thisJoinPoint.getSignature() and the toString() method of it. This causes heavy
String operations each time the toString method is called. Would it be possible
to cache the resulting string for example in MethodSignatureImpl and similar
classes for other signatures?</bugreport>
<testsforfix ID="49743" type="new">
    <file LOCATION="org.aspectj/modules/runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java">
      <test NAME="testToShortMiddleLongString"/>
    </file>
    <file LOCATION="org.aspectj/modules/runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.java">
      <test NAME="testToString"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="66" file="output/49743/pre-fix/testresults.xml" passing="391" size="457"/>
<post-fix-testcases failing="112" file="output/49743/post-fix/testresults.xml" passing="1277" size="1389"/>
<fixedFiles>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java" revision="1.5" state="changed">18a19
&gt; import java.lang.ref.SoftReference;
22a24,26
&gt; 
&gt; 	private static boolean useCache = true;
&gt; 	
26a31
&gt;     SoftReference toStringCacheRef;
34c39,56
&lt;     abstract String toString(StringMaker sm);
---
&gt;     protected abstract String createToString (StringMaker sm);
&gt;     
&gt;     /* Use a soft cache for the short, middle and long String representations */
&gt; 	String toString (StringMaker sm) {
&gt; 		String[] toStringCache = null;
&gt; 		if (toStringCacheRef == null || toStringCacheRef.get() == null) {
&gt; 			toStringCache = new String[3];
&gt; 			if (useCache) toStringCacheRef = new SoftReference(toStringCache);
&gt; 		}
&gt; 		else {
&gt; 			toStringCache = (String[])toStringCacheRef.get();
&gt; 		}
&gt; 		
&gt; 		if (toStringCache[sm.cacheOffset] == null) {
&gt; 			toStringCache[sm.cacheOffset] = createToString(sm);
&gt; 		}
&gt; 		return toStringCache[sm.cacheOffset];
&gt; 	}
95c117
&lt;     String stringRep;
---
&gt;     private String stringRep;
195a218,229
&gt; 
&gt; 	/*
&gt; 	 * Used for testing
&gt; 	 */
&gt; 	static void setUseCache (boolean b) {
&gt; 		useCache = b;
&gt; 	}
&gt; 
&gt; 	static boolean getUseCache () {
&gt; 		return useCache;
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java" revision="1.4" state="changed">41c41
&lt;     String toString(StringMaker sm) {
---
&gt;     protected String createToString(StringMaker sm) {
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java" revision="1.4" state="changed">38c38
&lt;     String toString(StringMaker sm) {
---
&gt;     protected String createToString(StringMaker sm) {
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/StringMaker.java" revision="1.4" state="changed">28a29
&gt;     int cacheOffset;
41a43
&gt; 		shortStringMaker.cacheOffset = 0;
51a54,55
&gt; 
&gt; 		shortStringMaker.cacheOffset = 1;
62a67,68
&gt; 
&gt; 		longStringMaker.cacheOffset = 2;
</file>
<file name="org.aspectj/modules/lib/test/aspectjrt.jar" revision="1.14" state="changed"/>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java" revision="1.4" state="changed">32c32
&lt;     String toString(StringMaker sm) {
---
&gt;     protected String createToString(StringMaker sm) {
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java" revision="1.4" state="changed">35c35
&lt;     String toString(StringMaker sm) {
---
&gt;     protected String createToString(StringMaker sm) {
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java" revision="1.4" state="changed">42c42
&lt;     String toString(StringMaker sm) {
---
&gt;     protected String createToString(StringMaker sm) {
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/Factory.java" revision="1.4" state="changed">151c151
&lt;         return new SourceLocationImpl(lexicalClass, this.filename, line, col);
---
&gt;         return new SourceLocationImpl(lexicalClass, this.filename, line);
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/CatchClauseSignatureImpl.java" revision="1.3" state="changed">44c44
&lt;     String toString(StringMaker sm) {
---
&gt;     protected String createToString(StringMaker sm) {
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.java" revision="1.3" state="changed">23d22
&lt;     int column;
25c24
&lt;     SourceLocationImpl(Class withinType, String fileName, int line, int column) {
---
&gt;     SourceLocationImpl(Class withinType, String fileName, int line) {
29d27
&lt;         this.column = column;
35c33
&lt;     public int getColumn() { return column; }
---
&gt;     public int getColumn() { return -1; }
38,39c36
&lt;     	return getFileName() + ":" + getLine() +
&lt;     		((getColumn() == -1) ? ""  : ":" + getColumn());
---
&gt;     	return getFileName() + ":" + getLine();
</file>
<file name="org.aspectj/modules/runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package org.aspectj.runtime.reflect;

import java.lang.reflect.Method;
import java.util.Timer;
import java.util.TimerTask;

import org.aspectj.lang.Signature;

import junit.framework.TestCase;

public class RuntimePerformanceTest extends TestCase {

	private static final Timer timer = new Timer(true);
	private static final long TIMEOUT = 10000;
	private static final long ITERATIONS = 1000000;
	private static final long WARMUP_ITERATIONS = 10000;
	private static final long EXPECTED_RATIO = 10;
	private static final Factory factory = new Factory("RutimePerformanceTest.java",RuntimePerformanceTest.class);

	private boolean savedUseCaches;
	private Method method;
	private Signature signature;

	private TimerTask task;
	private boolean abort;

	public RuntimePerformanceTest(String name) {
		super(name);
	}

	protected void setUp() throws Exception {
		super.setUp();
		
		/* Save default state */
		savedUseCaches = SignatureImpl.getUseCache();
		
		/* If a test takes too long we can kill it and fail */
		abort = false;
		task = new TimerTask() {
			public void run () {
				abort = true;	
			}
		};
		timer.schedule(task,TIMEOUT);
	}
	
	protected void tearDown() throws Exception {
		super.tearDown();
		
		/* Restore default state */
		SignatureImpl.setUseCache(savedUseCaches);

		task.cancel();
	}

	public void testToString () {
		Signature signature = makeMethodSig("test");

		SignatureImpl.setUseCache(false);
		warmUp(signature);
		long noCache = invokeSignatureToString(signature,ITERATIONS/EXPECTED_RATIO);
		System.out.println("noCache=" + noCache);

		SignatureImpl.setUseCache(true);
		warmUp(signature);
		long cache = invokeSignatureToString(signature,ITERATIONS);
		System.out.println("cache=" + cache);

		long ratio = (EXPECTED_RATIO*noCache/cache);
		System.out.println("ratio=" + ratio);
		assertTrue("Using cache should be " + EXPECTED_RATIO + " times faster: " + ratio,(ratio &gt; EXPECTED_RATIO));
	}
	
	private long invokeSignatureToString (Signature sig, long iterations) {
		long start = System.currentTimeMillis();
		String s;

		for (long l = 0; !abort &amp;&amp; (l &lt; iterations); l++) {
			s = sig.toShortString();
			s = sig.toString();
			s = sig.toLongString();
		}
		if (abort) throw new RuntimeException("invokeSignatureToString aborted after " + (TIMEOUT/1000) + " seconds");

		long finish = System.currentTimeMillis();
		return (finish-start);		
	}
	
	private void warmUp (Signature sig) {
		invokeSignatureToString(sig,WARMUP_ITERATIONS);	 
	}
	
	private Signature makeMethodSig (String methodName) {
		Class clazz = getClass();
		Class[] parameterTypes = new Class[] { String.class };
		String[] parameterNames = new String[] { "s" };
		Class[] exceptionTypes = new Class[] {};
		Class returnType = Void.TYPE;
		return factory.makeMethodSig(1,methodName,clazz,parameterTypes,parameterNames,exceptionTypes,returnType);
	}
}</file>
<file name="org.aspectj/modules/runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java" revision="1.2" state="changed">22a23,33
&gt; 	
&gt; 	public void testToShortMiddleLongString () {
&gt; 		MethodSignatureImpl msi = new MethodSignatureImpl(0,"test",SignatureTest.class,new Class[] { String.class, Integer.TYPE }, new String[] { "s", "i" }, new Class[] {}, Runnable.class);
&gt; 		String shortString = msi.toShortString();
&gt; 		assertSame(shortString,msi.toShortString()); // should be cached.
&gt; 		String middleString = msi.toString();
&gt; 		assertSame(middleString,msi.toString()); // should be cached.
&gt; 		String longString = msi.toLongString();
&gt; 		assertSame(longString,msi.toLongString()); // should be cached.
&gt; 		assertTrue("String representations should be different",!(shortString.equals(middleString) || middleString.equals(longString) || longString.equals(shortString)));
&gt; 	}
</file>
<file name="org.aspectj/modules/runtime/testsrc/RuntimeModuleTests.java" revision="1.7" state="changed">19a20
&gt; import org.aspectj.runtime.reflect.RuntimePerformanceTest;
30c31,32
&lt;         suite.addTestSuite(JoinPointImplTest.class);
---
&gt; 		suite.addTestSuite(JoinPointImplTest.class);
&gt; 		suite.addTestSuite(RuntimePerformanceTest.class);
</file>
</fixedFiles>
</bug>
<bug id="50200" transactionid="70227">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="trivial"/>
<concisefingerprint/>
<fullfingerprint>Y</fullfingerprint>
<bugreport>The name of the aspectjrt.jar's manifest file should be changed from 

META-INF/manifest.mf

to 

META-INF/MANIFEST.MF

According to the Jar file specification (see http://java.sun.com/products/jdk/1.
2/docs/guide/jar/manifest.html) the name of the manifest file needs to be all 
upper case. It's beyond trivial, I know, but it does cause an unnecessary 
warning in at least one popular IDE for J2EE development (IBM WebSphere Studio)
when the aspectjrt.jar is packaged in an EAR file.

If there was an option to assign this a "very, very trivial" severity level I 
would.</bugreport>
<pre-fix-testcases failing="95" file="output/50200/pre-fix/testresults.xml" passing="1125" size="1220"/>
<post-fix-testcases failing="95" file="output/50200/post-fix/testresults.xml" passing="1125" size="1220"/>
<fixedFiles>
<file name="org.aspectj/modules/build/src/org/aspectj/internal/tools/ant/taskdefs/AntBuilder.java" revision="1.13" state="changed">362c362,363
&lt;                 copyFile(manifest, new File(metaInfDir, "manifest.mf"), FILTER_ON);  // XXXFileLiteral
---
&gt; 				// Jar spec requires a MANIFEST.MF not a manifest.mf
&gt; 				copyFile(manifest, new File(metaInfDir, "MANIFEST.MF"), FILTER_ON);  // XXXFileLiteral
</file>
<file name="org.aspectj/modules/lib/build/build.jar" revision="1.14" state="changed"/>
</fixedFiles>
</bug>
<bug id="50570" transactionid="72348">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="27"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="35"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-if K-import K-instanceof K-new K-null K-return M O-== O-&gt;= O-- O--- O-!= O-() O-&amp;&amp; O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>It looks like the getParameterName() operation on org.aspectj.lang.reflect.
CatchClauseSignature is not working. Instead of returning the name of the 
exception as declared in the matched handler, returns the string value 
"&lt;missing&gt;".

Here is a test case that shows the problem :-

------START OF TEST CASE CODE-----------

public class MyApp {

    public void doSomething() {
        // Get around "unreachable code error...
        if (true)
        {
            throw new BusinessException("Surprise!!");
        }
        System.out.println("Busy doing something.");
    }

    public static void main(String[] args) {
        try {
            MyApp m = new MyApp();
            m.doSomething();
        } catch (BusinessException be) {
            System.out.println("Exception caught : " + be.getMessage()); 
        }
    }
}

class BusinessException extends RuntimeException {
    BusinessException(String message) {
        super(message);
    }
}

aspect AppMonitor {
    pointcut problemHandling() : handler(Throwable+);

    before() : problemHandling() {
        CatchClauseSignature cSig =
            (CatchClauseSignature) thisJoinPointStaticPart.getSignature();

        System.out.println(
            "MONITOR::\tCaught a "
                + cSig.getParameterType().getName()
                + " called "
                + cSig.getParameterName());
    }
}

------END OF TEST CASE CODE-----------

The output from running the above was ...

MONITOR::	Caught a BusinessException called &lt;missing&gt;
Exception caught : Surprise !!!!

Operating system : Windows XP
AspectJ : 1.1.1 final and also on latest from CVS HEAD</bugreport>
<testsforfix ID="50570" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="CatchClauseSignature has broken operation"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="94" file="output/50570/pre-fix/testresults.xml" passing="1125" size="1219"/>
<post-fix-testcases failing="96" file="output/50570/post-fix/testresults.xml" passing="1124" size="1220"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedMember.java" revision="1.11" state="changed">29c29
&lt;     protected String[] parameterNames = null;
---
&gt;     public String[] parameterNames = null;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Member.java" revision="1.8" state="changed">193,194c193,194
&lt; 	public static Member makeExceptionHandlerSignature(TypeX inType, TypeX catchType) {
&lt; 		return new Member(
---
&gt; 	public static ResolvedMember makeExceptionHandlerSignature(TypeX inType, TypeX catchType) {
&gt; 		return new ResolvedMember(
599,600d598
&lt;         //XXX we don't actually try to find the handler parameter name
&lt;         //XXX it probably wouldn't be too hard
602,603c600,601
&lt;         //String[] pNames = getParameterNames(world);
&lt;         //if (pNames != null) pName = pNames[0];
---
&gt;         String[] names = getParameterNames(world);
&gt;         if (names != null) pName = names[0];
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.30" state="changed">42a43
&gt; import org.apache.bcel.generic.StoreInstruction;
410a412,416
&gt; 		
&gt; 		ResolvedMember sig = Member.makeExceptionHandlerSignature(inType, catchType);
&gt; 		
&gt; 			
&gt; 		sig.parameterNames = new String[] {findHandlerParamName(startOfHandler)};
415c421
&lt;                 Member.makeExceptionHandlerSignature(inType, catchType),
---
&gt;                 sig,
426a433,453
&gt; 	
&gt; 	private static String findHandlerParamName(InstructionHandle startOfHandler) {		
&gt; 		if (startOfHandler.getInstruction() instanceof StoreInstruction &amp;&amp;
&gt; 			startOfHandler.getNext() != null)
&gt; 		{
&gt; 			int slot = ((StoreInstruction)startOfHandler.getInstruction()).getIndex();
&gt; 			//System.out.println("got store: " + startOfHandler.getInstruction() + ", " + index);
&gt; 			InstructionTargeter[] targeters = startOfHandler.getNext().getTargeters();
&gt; 			for (int i=targeters.length-1; i &gt;= 0; i--) {
&gt; 				if (targeters[i] instanceof LocalVariableTag) {
&gt; 					LocalVariableTag t = (LocalVariableTag)targeters[i];
&gt; 					if (t.getSlot() == slot) {
&gt; 						return t.getName();
&gt; 					}
&gt; 					//System.out.println("tag: " + targeters[i]);
&gt; 				}
&gt;  			}
&gt; 		}
&gt; 		
&gt; 		return "&lt;missing&gt;";
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.129" state="changed">7138a7139,7143
&gt;     &lt;ajc-test dir="bugs" pr="50570"
&gt;       title="CatchClauseSignature has broken operation"&gt;
&gt;         &lt;compile files="HandlerSig.java"/&gt;
&gt;         &lt;run class="HandlerSig"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/HandlerSig.java" revision="1.1" state="new">import org.aspectj.testing.Tester;

import org.aspectj.lang.reflect.*;

public class HandlerSig {

	public void doSomething() {
		// Get around "unreachable code error...
		if (true)
		{
			throw new BusinessException("Surprise!!");
		}
		System.out.println("Busy doing something.");
	}

	public static void main(String[] args) {
		try {
			HandlerSig m = new HandlerSig();
			m.doSomething();
		} catch (BusinessException be) {
			Tester.checkEqual(be.getMessage(), "Surprise!!");
		}
	}
}

class BusinessException extends RuntimeException {
	BusinessException(String message) {
		super(message);
	}
}

aspect AppMonitor {
	pointcut problemHandling() : handler(Throwable+);

	before() : problemHandling() {
		CatchClauseSignature cSig =
			(CatchClauseSignature) thisJoinPointStaticPart.getSignature();

		Tester.checkEqual(cSig.getParameterType(), BusinessException.class);
		Tester.checkEqual(cSig.getParameterName(), "be");
	}
}
</file>
</fixedFiles>
</bug>
<bug id="50776" transactionid="70146">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="blocker"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null K-return O-!= T V Z-if</fullfingerprint>
<bugreport>A first class (class A) declares only one method with some exceptions in the
throws clause ( void m() throws Exception ).
A second class (class B) extends it without redefinig the method. 
An aspect declares a method introduction in the class B, with the same name,
signature and return type of the one in class A, but without throws clause; this
is a legal override.
In the second class (class B) each invocation to the overriden method doesn't
need a try-catch block, because it refers to his hown method that raises no
exception.
This code compiles using 
ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.0
But not using
AspectJ Compiler 1.1.1 
AspectJ Compiler 1.1.0

class A{
  public A(){}
  public void m() throws Exception{}
}

class B extends A{
  public B(){}
  public void some_code(){
    m();}
}

aspect C{
  public void B.m(){}
}</bugreport>
<testsforfix ID="50776" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="fail in compiling aspect with overriding method introduction with different throws clause"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="103" file="output/50776/pre-fix/testresults.xml" passing="1133" size="1236"/>
<post-fix-testcases failing="105" file="output/50776/post-fix/testresults.xml" passing="1132" size="1237"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java" revision="1.8" state="changed">295d294
&lt; 		if (ret != null) return ret;
296a296
&gt; 		// An intertype declaration may override an inherited member (Bug#50776)
304c304
&lt; 		return null;
---
&gt; 		return ret;
</file>
<file name="org.aspectj/modules/tests/bugs/IntertypeDifferentThrows.java" revision="1.1" state="new">class A {
  public A(){}
  public void m() throws Exception{}
}

class B extends A {
  public B(){}
  public void some_code(){
	m();
  }
}

// B.m() introduced here does not throw 'Exception' so class B above
// should compile OK!
aspect C {
  public void B.m(){}
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.137" state="changed">7264a7265,7269
&gt; 	
&gt; 	&lt;ajc-test dir="bugs" pr="50776"
&gt;    	 title="fail in compiling aspect with overriding method introduction with different throws clause "&gt;
&gt;         &lt;compile files="IntertypeDifferentThrows.java" /&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="51320" transactionid="69893">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="12"/>
<property name="lines-added" value="42"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="42"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-instanceof K-null K-return M O-?: O-() O-+ O-instanceof T V Y Z-cond Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>I get the following exception when weaving the attached aspect on the dev build.

java.lang.ClassCastException
	at org.aspectj.weaver.patterns.IfPointcut.concretize1(IfPointcut.java:156)
	at org.aspectj.weaver.patterns.IfPointcut.concretize(IfPointcut.java:143)
	at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:119)
	at org.aspectj.weaver.Checker.concretize(Checker.java:35)
	at org.aspectj.weaver.CrosscuttingMembers.
addShadowMunger(CrosscuttingMembers.java:78)
	at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.
java:102)
	at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.
java:92)
	at org.aspectj.weaver.CrosscuttingMembersSet.
addAdviceLikeDeclares(CrosscuttingMembersSet.java:65)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.
addAdviceLikeDeclares(AjLookupEnvironment.java:147)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.
completeTypeBindings(AjLookupEnvironment.java:122)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:
300)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:314)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.
performCompilation(AjBuildManager.java:384)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.
doBuild(AjBuildManager.java:125)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.
batchBuild(AjBuildManager.java:70)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:104)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
	at org.aspectj.tools.ajc.Main.run(Main.java:234)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:170)
	at org.aspectj.tools.ajc.Main.main(Main.java:81)</bugreport>
<testsforfix ID="51320" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="ClasscastException on concretization of if(false)"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="102" file="output/51320/pre-fix/testresults.xml" passing="1132" size="1234"/>
<post-fix-testcases failing="105" file="output/51320/post-fix/testresults.xml" passing="1130" size="1235"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/IfPointcut.java" revision="1.11" state="changed">24a25
&gt; import org.aspectj.weaver.Checker;
148a150,159
&gt; 		
&gt; 		if (bindings.getEnclosingAdvice() instanceof Checker) {
&gt; 			// Enforce rule about which designators are supported in deow
&gt; 			inAspect.getWorld().showMessage(IMessage.ERROR,
&gt; 			  "if() pointcut designator cannot be used in declare statement",
&gt; 			  bindings.getEnclosingAdvice().getSourceLocation(),
&gt; 			  null);
&gt; 			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
&gt; 		}
&gt; 		
156c167,171
&lt; 			ret.baseArgsCount = ((Advice)advice).getBaseParameterCount();
---
&gt; 			if (advice instanceof Advice) {
&gt; 				ret.baseArgsCount = ((Advice)advice).getBaseParameterCount();
&gt; 			} else {
&gt; 				ret.baseArgsCount = 0;
&gt; 			}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java" revision="1.8" state="changed">19a20
&gt; import org.aspectj.bridge.IMessage;
20a22
&gt; import org.aspectj.weaver.Checker;
117a120,127
&gt; 		if (bindings.getEnclosingAdvice() instanceof Checker) {
&gt; 		  // Enforce rule about which designators are supported in deow
&gt; 		  inAspect.getWorld().showMessage(IMessage.ERROR,
&gt; 		    (isThis?"this":"target")+"() pointcut designator cannot be used in declare statement",
&gt; 		    bindings.getEnclosingAdvice().getSourceLocation(), null);
&gt; 		  return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
&gt; 		}
&gt; 		
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java" revision="1.11" state="changed">23a24
&gt; import org.aspectj.bridge.IMessage;
26a28
&gt; import org.aspectj.weaver.Checker;
123a126,132
&gt; 		if (bindings.getEnclosingAdvice() instanceof Checker) {
&gt; 			// Enforce rule about which designators are supported in deow
&gt; 			inAspect.getWorld().showMessage(IMessage.ERROR,
&gt; 			  "cflow"+(isBelow?"below":"")+"() pointcut designator cannot be used in declare statement",
&gt; 			  bindings.getEnclosingAdvice().getSourceLocation(), null);
&gt; 			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java" revision="1.9" state="changed">22a23
&gt; import org.aspectj.weaver.Checker;
90a92,98
&gt; 		if (bindings.getEnclosingAdvice() instanceof Checker) {
&gt; 		  // Enforce rule about which designators are supported in deow
&gt; 		  inAspect.getWorld().showMessage(IMessage.ERROR,
&gt; 			"args() pointcut designator cannot be used in declare statement",
&gt; 			bindings.getEnclosingAdvice().getSourceLocation(), null);
&gt; 		  return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/bugs/DecwClassCastException.java" revision="1.1" state="new">/*
 * From:
 * 
 * http://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-home/doc/progguide/semantics-declare.html#d0e6499
 *
 * Pointcuts that appear inside of declare forms have certain restrictions. 
 * Like other pointcuts, these pick out join points, but they do so in a 
 * way that is statically determinable. 
 * 
 * Consequently, such pointcuts may not include, directly or indirectly 
 * (through user-defined pointcut declarations) pointcuts that discriminate 
 * based on dynamic (runtime) context. Therefore, such pointcuts may not be 
 * defined in terms of
 * 
 * cflow
 * cflowbelow
 * this
 * target
 * args
 * if
 * 
 * all of which can discriminate on runtime information. 
 */

public aspect DecwClassCastException {

	declare warning : if(true) : "if(true) directly against checker";
	pointcut p(): if(false);
	declare warning : p() : "if(false) through defined pointcut";
	
	declare error : cflow(execution(* main(..))): "cflow(execution(* main(..))) directly against checker";
	pointcut p2(): cflow(execution(* main(..)));
	declare error : p2() : "cflow(execution(* main(..))) through defined pointcut";
	
	declare warning : cflowbelow(execution(* main(..))): "cflowbelow(execution(* main(..))) directly against checker";
	pointcut p3(): cflowbelow(execution(* main(..)));
	declare error : p3() : "cflowbelow(execution(* main(..))) through defined pointcut";
	
	declare warning : this(Object): "this(Object) directly against checker";
	pointcut p4(): this(Object);
	declare warning : p4(): "this(Object) through defined pointcut";
	
	declare warning : target(Object): "target(Object) directly against checker";
	pointcut p5(): target(Object);
	declare warning : p5(): "target(Object) through defined pointcut";
		
	declare warning : args(Object): "args(Object) directly against checker";
	pointcut p6(): args(Object);
	declare warning : p6(): "args(Object) through defined pointcut";
	

    public static void main(String[] args) {
	    System.err.println("In main!");
    }
    
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.134" state="changed">7185a7186,7211
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="51320"
&gt;    	 title="ClasscastException on concretization of if(false)"&gt;
&gt;         &lt;compile files="DecwClassCastException.java"&gt;
&gt;         
&gt;          &lt;!-- These are the illegal PCDs against a deow --&gt;
&gt;          &lt;message kind="error" line="27" text="if() pointcut designator cannot be used"/&gt;
&gt;          &lt;message kind="error" line="29" text="if() pointcut designator cannot be used"/&gt;
&gt;          
&gt;          &lt;message kind="error" line="31" text="cflow() pointcut designator cannot be used"/&gt;
&gt;          &lt;message kind="error" line="33" text="cflow() pointcut designator cannot be used"/&gt;
&gt;          
&gt;          &lt;message kind="error" line="35" text="cflowbelow() pointcut designator cannot be used"/&gt;
&gt;          &lt;message kind="error" line="37" text="cflowbelow() pointcut designator cannot be used"/&gt;
&gt;          
&gt;          &lt;message kind="error" line="39" text="this() pointcut designator cannot be used"/&gt;
&gt;          &lt;message kind="error" line="41" text="this() pointcut designator cannot be used"/&gt;
&gt;          
&gt;          &lt;message kind="error" line="43" text="target() pointcut designator cannot be used"/&gt;
&gt;          &lt;message kind="error" line="45" text="target() pointcut designator cannot be used"/&gt;
&gt;          
&gt;          &lt;message kind="error" line="47" text="args() pointcut designator cannot be used"/&gt;
&gt;          &lt;message kind="error" line="49" text="args() pointcut designator cannot be used"/&gt;
&gt;          
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="51322" transactionid="71478">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="6"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-new K-null K-throw M O-== Z-if Z-throw</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Introduce method with an unknown type as an arguement as follows:
class A {}
public abstract aspect B
{
  public void A.someMethod(WCharType a) { //blah }
}

WCharType is an unknown type or is forgotten to be imported (in my case).

This shall cause ajc to puke the following:
java.lang.NullPointerException
        at
org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration
.java:87)
        at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclarat
ion.java:744)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupE
nvironment.java:206)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnviron
ment.java:94)
        at
org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
/home/czhang/eclipse/workspace/lib/libajob/org/omg/PortableServer/portable/Delegate.java:0
Internal compiler error
java.lang.NullPointerException
        at
org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration
.java:87)
        at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclarat
ion.java:744)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupE
nvironment.java:206)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnviron
ment.java:94)
        at
org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
 
 
!! no source information available !!
!! no source information available !!
ABORT
Exception thrown from AspectJ 1.1.1
 
This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler
 
Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"
 
If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
null
java.lang.NullPointerException
        at
org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration
.java:87)
        at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclarat
ion.java:744)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupE
nvironment.java:206)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnviron
ment.java:94)
        at
org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:217)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)
        at org.aspectj.tools.ajc.Main.main(Main.java:72)
 
 
1 fail|abort, 1 error</bugreport>
<testsforfix ID="51322" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Introduce Unknown Type to class causes Null pointer exception"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="103" file="output/51322/pre-fix/testresults.xml" passing="1140" size="1243"/>
<post-fix-testcases failing="102" file="output/51322/post-fix/testresults.xml" passing="1142" size="1244"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java" revision="1.14" state="changed">30a31
&gt; import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
103a105,109
&gt; 		if (binding == null) {
&gt; 			// if binding is null, we failed to find a type used in the method params, this error
&gt; 			// has already been reported. 
&gt; 			throw new AbortCompilation();
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/bugs/Pr51322.java" revision="1.1" state="new">class A {}
public abstract aspect Pr51322
{
  public void A.aMethod(Object x) {}
  public void A.someMethod(WCharType a) { }
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.142" state="changed">7305a7306,7312
&gt;     
&gt;     &lt;ajc-test dir="bugs"  pr="51322"
&gt;     	title="Introduce Unknown Type to class causes Null pointer exception"  &gt;
&gt;         &lt;compile files="Pr51322.java"&gt; 
&gt;         	&lt;message kind="error" line="5"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="51929" transactionid="72514">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="26"/>
<property name="lines-added" value="23"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="28"/>
<property name="lines-churned" value="53"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-import K-return M O-&gt; O-() O-&amp;&amp; O-cast T V Y Z-cast Z-if</fullfingerprint>
<bugreport>A java.lang.VerifyError is thrown at runtime complaining about 'Bad access to  
protected data' when advice, on a sub-aspect, that calls a protected method, on  
the super-aspect, is woven into a class. 
However another call to the same method woven into the same class but due to  
advice declared in the super-aspect works fine. 
 
The aspects were woven into precompiled (by sun's 1.4 javac) classes. 
The verify error occurs under both sun's 1.4 and blackdowns 1.3 VMs, and presumably 
all VMs. 
 
Workaround: 
Making the protected method public fixes the verify error. 
 
A test case is available in CVS: 
tests/bugs/protectedvf/... 
tests/ajcTestFailing.xml</bugreport>
<testsforfix ID="51929" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="mail list VerifyError with protected access"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="97" file="output/51929/pre-fix/testresults.xml" passing="1128" size="1225"/>
<post-fix-testcases failing="96" file="output/51929/post-fix/testresults.xml" passing="1130" size="1226"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java" revision="1.12" state="changed">184a185,188
&gt; 		return makeResolvedMember(binding, binding.declaringClass);
&gt; 	}
&gt; 
&gt; 	public static ResolvedMember makeResolvedMember(MethodBinding binding, TypeBinding declaringType) {
188c192
&lt; 			fromBinding(binding.declaringClass),
---
&gt; 			fromBinding(declaringType),
197a202,205
&gt; 		return makeResolvedMember(binding, binding.declaringClass);
&gt; 	}
&gt; 	
&gt; 	public static ResolvedMember makeResolvedMember(FieldBinding binding, TypeBinding receiverType) {
200c208
&lt; 			fromBinding(binding.declaringClass),
---
&gt; 			fromBinding(receiverType),
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java" revision="1.15" state="changed">37a38
&gt; import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
43a45
&gt; import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
78c80
&lt; 			ref.binding = getAccessibleField((FieldBinding)ref.binding);
---
&gt; 			ref.binding = getAccessibleField((FieldBinding)ref.binding, ref.actualReceiverType);
83,84d84
&lt; 		//System.err.println("qref: " + ref + ", " + ref.binding.getClass().getName() + ", " + ref.codegenBinding.getClass().getName());
&lt; 		//System.err.println("   others: " + Arrays.asList(ref.otherBindings));
86c86
&lt; 			ref.binding = getAccessibleField((FieldBinding)ref.binding);
---
&gt; 			ref.binding = getAccessibleField((FieldBinding)ref.binding, ref.actualReceiverType);
88c88,98
&lt; 		if (ref.otherBindings != null) {
---
&gt; 		if (ref.otherBindings != null &amp;&amp; ref.otherBindings.length &gt; 0) {
&gt; 			TypeBinding receiverType;
&gt; 			if (ref.binding instanceof FieldBinding) {
&gt; 				receiverType = ((FieldBinding)ref.binding).type;
&gt; 			} else if (ref.binding instanceof VariableBinding) {
&gt; 				receiverType = ((VariableBinding)ref.binding).type;
&gt; 			} else {
&gt; 				//!!! understand and fix this case later
&gt; 				receiverType = ref.otherBindings[0].declaringClass;
&gt; 			}
&gt; 			
90,92c100,102
&lt; 				if (ref.otherBindings[i] instanceof FieldBinding) {
&lt; 					ref.otherBindings[i] = getAccessibleField((FieldBinding)ref.otherBindings[i]);
&lt; 				}
---
&gt; 				FieldBinding binding = ref.otherBindings[i];
&gt; 				ref.otherBindings[i] = getAccessibleField(binding, receiverType);
&gt; 				receiverType = binding.type;
98,100c108
&lt; 		if (ref.binding instanceof FieldBinding) {
&lt; 			ref.binding = getAccessibleField((FieldBinding)ref.binding);
&lt; 		}
---
&gt; 		ref.binding = getAccessibleField(ref.binding, ref.receiverType);
108c116
&lt; 			MethodBinding superAccessBinding = getSuperAccessMethod((MethodBinding)send.binding);
---
&gt; 			MethodBinding superAccessBinding = getSuperAccessMethod(send.binding);
111c119
&lt; 			send.syntheticAccessor = getAccessibleMethod((MethodBinding)send.binding);
---
&gt; 			send.syntheticAccessor = getAccessibleMethod(send.binding, send.receiverType);
135c143
&lt; 	private FieldBinding getAccessibleField(FieldBinding binding) {
---
&gt; 	private FieldBinding getAccessibleField(FieldBinding binding, TypeBinding receiverType) {
139c147
&lt; 		makePublic(binding.declaringClass);
---
&gt; 		makePublic(receiverType);
148c156
&lt; 		ResolvedMember m = EclipseFactory.makeResolvedMember(binding);
---
&gt; 		ResolvedMember m = EclipseFactory.makeResolvedMember(binding, receiverType);
150c158
&lt; 		FieldBinding ret = new InlineAccessFieldBinding(inAspect, binding);
---
&gt; 		FieldBinding ret = new InlineAccessFieldBinding(inAspect, binding, m);
158c166
&lt; 	private MethodBinding getAccessibleMethod(MethodBinding binding) {
---
&gt; 	private MethodBinding getAccessibleMethod(MethodBinding binding, TypeBinding receiverType) {
161c169
&lt; 		makePublic(binding.declaringClass);  //???
---
&gt; 		makePublic(receiverType);  //???
170c178
&lt; 		ResolvedMember m = EclipseFactory.makeResolvedMember(binding);
---
&gt; 		ResolvedMember m = EclipseFactory.makeResolvedMember(binding, receiverType);
230a239,245
&gt; 	public boolean visit(
&gt; 		TypeDeclaration localTypeDeclaration,
&gt; 		BlockScope scope) {
&gt; 		// we don't want to transform any local anonymous classes as they won't be inlined
&gt; 		return false;
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java" revision="1.6" state="changed">17a18
&gt; import org.aspectj.weaver.ResolvedMember;
43c44
&lt; 	public InlineAccessFieldBinding(AspectDeclaration inAspect, FieldBinding baseField) {
---
&gt; 	public InlineAccessFieldBinding(AspectDeclaration inAspect, FieldBinding baseField, ResolvedMember resolvedField) {
49c50
&lt; 					inAspect.typeX, EclipseFactory.makeResolvedMember(baseField)
---
&gt; 					inAspect.typeX, resolvedField
53c54
&lt; 					inAspect.typeX, EclipseFactory.makeResolvedMember(baseField)
---
&gt; 					inAspect.typeX, resolvedField
</file>
<file name="org.aspectj/modules/tests/ajcTestsFailing.xml" revision="1.81" state="changed">136,141d135
&lt; 	&lt;ajc-test dir="bugs/protectedvf"
&lt; 		title="mail list VerifyError with protected access"&gt;
&lt; 		&lt;compile files="main/Driver.java,main/p2/AbstractTest.aj,main/p1/ConcreteTest.aj"/&gt;
&lt; 		&lt;run class="main.Driver"/&gt;
&lt; 		&lt;/ajc-test&gt;
&lt; 
</file>
<file name="org.aspectj/modules/tests/bugs/protectedvf/main/p1/ConcreteTest.aj" revision="1.2" state="changed">13c13
&lt; 		System.out.println("adding to the other stuff");&#13;
---
&gt; 		//System.out.println("adding to the other stuff");&#13;
14a15,16
&gt; 		ConcreteTest ct = this;&#13;
&gt; 		System.out.println("test: " + s + ", " + this.s + ", " + ct.s);&#13;
20c22
&lt; 		/*This doesn't cause a verify error seemably because the advice calling it is in AbstractTest*/&#13;
---
&gt; 		/*This doesn't cause a verify error because this code is not inlined*/&#13;
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.132" state="changed">7174a7175,7180
&gt;     
&gt; 	&lt;ajc-test dir="bugs/protectedvf"
&gt; 		title="mail list VerifyError with protected access"&gt;
&gt; 		&lt;compile files="main/Driver.java,main/p2/AbstractTest.aj,main/p1/ConcreteTest.aj"/&gt;
&gt; 		&lt;run class="main.Driver"/&gt;
&gt; 	&lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/protectedvf/main/Driver.java" revision="1.2" state="changed">12c12
&lt; 		System.out.println("doing other stuff");
---
&gt; 		//System.out.println("doing other stuff");
16c16
&lt; 		System.out.println("doing stuff");
---
&gt; 		//System.out.println("doing stuff");
</file>
<file name="org.aspectj/modules/tests/bugs/protectedvf/main/p2/AbstractTest.aj" revision="1.2" state="changed">5a6
&gt; 	protected String s = "test";&#13;
10a12
&gt; 		s += "-1";&#13;
</file>
</fixedFiles>
</bug>
<bug id="52394" transactionid="69586">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="7"/>
<property name="lines-churned" value="12"/>
<property name="priority" value="P4"/>
<property name="severity" value="major"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M T V Z-cast Z-if</fullfingerprint>
<bugreport>BEA's JRockit JVM (version:
8.1sp2-1.4.1_05-Load10-viking-win32-sthqa29-20031105-1554) crashes on simple
inter-type declarations. (Obviously I have also submitted this bug to BEA, but
the AJ team may be able to shed some light on what is going on and where (if
anywhere) BEA's JVM is behaving wrong.)

The cannonical example lies below:

public class SimpleClass {
    public static void main(String[] args) {
        SimpleClass simple = new SimpleClass();
    }
}

public aspect SimpleAspect {
    public int SimpleClass.foo;
}

When running SimpleClass I get a JVM crash with the following thread stack trace.

Thread Stack Trace:
    at _exprPush+112 ()@0082FF70
    at COM.jrockit.vm.RNI.toNative(Native Method)@32520000
    at COM.jrockit.vm.RNI.clinitTrampoline(Native Method)@325200FA
    at com.vms.adbase.jvmcrashtest.SimpleClass.&lt;init&gt;(SimpleClass.java:4)@344B0055
    at com.vms.adbase.jvmcrashtest.SimpleClass.main(SimpleClass.java:6)@344B0034
    --- End of stack trace

Feel free to ask me for further details. JRockit can be downloaded at:
http://commerce.bea.com/showallversions.jsp?family=WLJR. I reproduced this error
on Windows XP, but it also happend on RedHat.

Is it worth adding JRockit to AspectJ's compatibility test suite?</bugreport>
<pre-fix-testcases failing="104" file="output/52394/pre-fix/testresults.xml" passing="1132" size="1236"/>
<post-fix-testcases failing="104" file="output/52394/post-fix/testresults.xml" passing="1132" size="1236"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java" revision="1.24" state="changed">1001,1002c1001,1007
&lt; 		if (ih.getInstruction() instanceof PUTSTATIC) {
&lt; 			String name = ((PUTSTATIC)ih.getInstruction()).getFieldName(cpg);
---
&gt; 		// Skip the astore_0 and aload_0 at the start of the handler and 
&gt; 		// then check if the instruction following these is 
&gt; 		// 'putstatic ajc$initFailureCause'.  If it is then we are 
&gt; 		// in the handler we created in AspectClinit.generatePostSyntheticCode()
&gt; 		InstructionHandle twoInstructionsAway = ih.getNext().getNext();
&gt; 		if (twoInstructionsAway.getInstruction() instanceof PUTSTATIC) {
&gt; 			String name = ((PUTSTATIC)twoInstructionsAway.getInstruction()).getFieldName(cpg);
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java" revision="1.7" state="changed">78a79,80
&gt; 			// Changes to this exception handling code may require changes to
&gt; 			// BcelClassWeaver.isInitFailureHandler()
82d83
&lt; 			
83a85,86
&gt; 			codeStream.astore_0(); // Bug #52394
&gt; 		    codeStream.aload_0();
</file>
</fixedFiles>
</bug>
<bug id="53012" transactionid="68358">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="8"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null M O-! O-&amp;&amp; O-+ T V Y Z-if</fullfingerprint>
<bugreport>The compiler silently accepts

----
public class DeclarePrecedence {
public static void main(String[] args) {
    System.out.println("hello");
}
}
aspect DP {
    declare precedence: DeclarePrecedence, DP;
    before() : staticinitialization(DeclarePrecedence) {
        System.out.println("ok"); 
    }
}
----

Since this is likely to be a mistake, an error would be nice.  However, that
would mean saying (!TargetClass &amp;&amp; TargetClass+) to pick out the aspect subtypes
of TargetClass.</bugreport>
<testsforfix ID="53012" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="declare precedence on a class should be a compile-time error"/>
      <test NAME="declare precedence on a class should be a compile-time error"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="110" file="output/53012/pre-fix/testresults.xml" passing="1160" size="1270"/>
<post-fix-testcases failing="109" file="output/53012/post-fix/testresults.xml" passing="1161" size="1270"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java" revision="1.5" state="changed">84a85,92
&gt;     		
&gt;     		// Cannot do a dec prec specifying a non-aspect types unless suffixed with a '+'
&gt;     		if (!exactType.isAspect() &amp;&amp; !pi.isIncludeSubtypes()) {
&gt;     			scope.getWorld().showMessage(IMessage.ERROR,
&gt;     				"Non-aspect types can only be specified in a declare precedence statement when subtypes are included.  Non-aspect type is : "+exactType.getName(),
&gt;     				pi.getSourceLocation(),null);
&gt;     		}
&gt;     		
</file>
<file name="org.aspectj/modules/tests/bugs/declarePrecedenceWithClasses/Priority.aj" revision="1.1" state="new">// Bug 53012&#13;
// Although the declare precedence mentions interfaces (and not aspects explicitly), it does&#13;
// mention with a '+' suffix - this should be allowed.&#13;
&#13;
public aspect Priority {&#13;
	public interface Highest {}&#13;
	public interface Lowest {}&#13;
	declare precedence: Highest+, *, Lowest+;&#13;
}&#13;
&#13;
aspect Security implements Priority.Highest {}&#13;
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.149" state="changed">7513a7514,7525
&gt;     &lt;ajc-test dir="bugs/declarePrecedenceWithClasses" pr="53012"
&gt;    	 title="declare precedence on a class should be a compile-time error"&gt;
&gt;         &lt;compile files="DeclarePrecedenceTestClass.java" &gt;
&gt;           &lt;message kind="error" line="10" text="Non-aspect types can only be specified"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs/declarePrecedenceWithClasses" pr="53012"
&gt;    	 title="declare precedence on a class should be a compile-time error"&gt;
&gt;         &lt;compile files="Priority.aj" /&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 	
</file>
<file name="org.aspectj/modules/tests/bugs/declarePrecedenceWithClasses/DeclarePrecedenceTestClass.java" revision="1.1" state="new">//Bug 53012
// DP contains a declare precedence statement that mentions classes

public class DeclarePrecedenceTestClass {
	public static void main(String[] args) {
		System.out.println("hello");
	}
}
aspect DP {
	declare precedence: DeclarePrecedenceTestClass, DP;
	
	before() : staticinitialization(DeclarePrecedenceTestClass) {
		System.out.println("ok"); 
	}
}
</file>
</fixedFiles>
</bug>
<bug id="53981" transactionid="71193">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null K-return M O-! O-!= O-() O-&amp;&amp; Z-if</fullfingerprint>
<bugreport>Using a method named proceed(..) in around advice confuses the compiler (in at
least the 2-3 ways shown below).  

True of the current tree (untested in 1.1.1).  Workaround for now is to rename
the method.  

---- first problem: NPE in compiler
java.lang.NullPointerException
	at
org.aspectj.ajdt.internal.compiler.ast.MakeDeclsPublicVisitor.endVisit(MakeDeclsPublicVisitor.java:44)

public class Proceeding {
    public static void main(String[] args) { }
    static aspect A {
        interface IProceed {
            void proceed(Runnable next);
        }
        IProceed decorator;
        void around() : execution(void main(String[])) {
            decorator.proceed(new Runnable() {
                public void run() {
                    proceed();
                }
            });
        }
    }
}

---- second problem: incorrect error wrt number of arguments

public class Proceeding {
    public static void main(String[] args) {
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            Proceeding.proceed(null); // BUG: treated as proceed(Object);
        }
    }
    static void proceed(Object o) {}
}

---- third hypothetical: we should document how ambiguity is resolved

public class Proceeding {
    public static void main(String[] args) {
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            proceed(); // special form or Proceeding.proceed()?
        }
    }
    void proceed() {}
}</bugreport>
<testsforfix ID="53981" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test023_proceedInAround1"/>
      <test NAME="test024_proceedInAround2"/>
      <test NAME="test025_proceedInAround3"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="proceed used as method name in around advice (1)"/>
      <test NAME="proceed used as method name in around advice (2)"/>
      <test NAME="proceed used as method name in around advice (3)"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="113" file="output/53981/pre-fix/testresults.xml" passing="1237" size="1350"/>
<post-fix-testcases failing="112" file="output/53981/post-fix/testresults.xml" passing="1241" size="1353"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java" revision="1.8" state="changed">2a3
&gt;  *               2004 contributors
10c11,12
&lt;  *     PARC     initial implementation 
---
&gt;  *     PARC     initial implementation
&gt;  *     IBM      ongoing maintenance 
29c31,32
&lt;  * of an &lt;code&gt;around&lt;/code&gt; advice and if not this will be treated like any other
---
&gt;  * of an &lt;code&gt;around&lt;/code&gt; advice and has no receiver (must be a bare proceed call, 
&gt;  * see pr 53981), and if not this will be treated like any other
114c117
&lt; 		
---
&gt; 				
120a124,125
&gt; 					// pr 53981 only match "bare" calls to proceed
&gt; 					if((receiver != null) &amp;&amp; (!receiver.isThis())) { return null; }
</file>
<file name="org.aspectj/modules/docs/progGuideDB/semantics.xml" revision="1.13" state="changed">1562a1563,1588
&gt; 	&lt;para&gt;
&gt; 		Any occurence of &lt;literal&gt;proceed(..)&lt;/literal&gt; within the body of
&gt; 		around advice is treated as the special proceed form (even if the
&gt; 		aspect defines a method named &lt;literal&gt;proceed&lt;/literal&gt;) unless a 
&gt; 		target other than the aspect instance is specified as the recipient of
&gt; 		the call.
&gt; 		For example, in the following program the first 
&gt; 		call to proceed will be treated as a method call to
&gt; 		the &lt;literal&gt;ICanProceed&lt;/literal&gt; instance, whereas the second call to
&gt; 		proceed is treated as the special proceed form.
&gt; 	&lt;/para&gt;
&gt; 
&gt; &lt;programlisting&gt;
&gt;   aspect A {
&gt;      Object around(ICanProceed canProceed) : execution(* *(..)) &lt;![CDATA[&amp;&amp;]]&gt; this(canProceed) {
&gt;         canProceed.proceed();         // a method call
&gt;         return proceed(canProceed);   // the special proceed form
&gt;      }
&gt;      
&gt;      private Object proceed(ICanProceed canProceed) {
&gt;         // this method cannot be called from inside the body of around advice in
&gt;         // the aspect
&gt;      }
&gt;   }	
&gt; &lt;/programlisting&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.6" state="changed">129a130,141
&gt;   
&gt;   public void test023_proceedInAround1() {
&gt;       runTest("proceed used as method name in around advice (1)");
&gt;   }
&gt; 
&gt;   public void test024_proceedInAround2() {
&gt;       runTest("proceed used as method name in around advice (2)");
&gt;   }
&gt; 
&gt;   public void test025_proceedInAround3() {
&gt;       runTest("proceed used as method name in around advice (3)");
&gt;   }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.6" state="changed">186c186,204
&lt; --&gt;
\ Kein Zeilenumbruch am Dateiende.
---
&gt; --&gt;
&gt; 
&gt;   	&lt;ajc-test dir="bugs/pr53981" pr="538981"
&gt;     	title="proceed used as method name in around advice (1)"&gt;
&gt;     	&lt;compile files="Proceeding1.aj"/&gt;
&gt;     	&lt;run class="Proceeding1"/&gt;
&gt;    	&lt;/ajc-test&gt;
&gt; 
&gt;   	&lt;ajc-test dir="bugs/pr53981" pr="538981"
&gt;     	title="proceed used as method name in around advice (2)"&gt;
&gt;     	&lt;compile files="Proceeding2.aj"/&gt;
&gt;     	&lt;run class="Proceeding2"/&gt;
&gt;    	&lt;/ajc-test&gt;
&gt; 
&gt;   	&lt;ajc-test dir="bugs/pr53981" pr="538981"
&gt;     	title="proceed used as method name in around advice (3)"&gt;
&gt;     	&lt;compile files="Proceeding3.aj"/&gt;
&gt;     	&lt;run class="Proceeding3"/&gt;
&gt;    	&lt;/ajc-test&gt;
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.aspectj/modules/tests/bugs/pr53981/Proceeding1.aj" revision="1.1" state="new">import org.aspectj.testing.Tester;

public class Proceeding1 {
    public static void main(String[] args) { 
       Tester.checkAllEvents();
    }
    static aspect A {
        interface IProceed {
            void proceeds(Runnable next);
        }
        IProceed decorator = new IProceed() {
            public void proceeds(Runnable next) {
                Tester.event("IProceed.proceed()");
                next.run();
            }
        };
        void around() : execution(void main(String[])) {
            Tester.expectEvent("IProceed.proceed()");
            decorator.proceeds(new Runnable() {
                public void run() {
                    proceed();
                }
            });
        }
    }
}</file>
<file name="org.aspectj/modules/tests/bugs/pr53981/Proceeding3.aj" revision="1.1" state="new">import org.aspectj.testing.Tester;

public class Proceeding3 {
    public static void main(String[] args) {
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            proceed(); // special form or Proceeding.proceed()?
        }
    }
    void proceed() {
        Tester.checkFailed("A bare call to proceed inside around advice should never refer to a method");
    }
}</file>
<file name="org.aspectj/modules/tests/bugs/pr53981/Proceeding2.aj" revision="1.1" state="new">import org.aspectj.testing.Tester;

public class Proceeding2 {
    public static void main(String[] args) {
        Tester.checkFailed("Proceed with a receiver should be treated as a method call, not the special form");
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            Proceeding2.proceed(null); // BUG: treated as proceed(Object);
        }
    }
    static void proceed(Object o) {}
}</file>
</fixedFiles>
</bug>
<bug id="53999" transactionid="69926">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint/>
<fullfingerprint>T V</fullfingerprint>
<bugreport>cosmetic mistake in error message...

expected: can't bind type name 'unknown.Error'
  actual: can't bind type name 'unknown$Error'

(not sure why it would ever be munged with $)

public class Test {
	public static void main(String[] args) {
		test();
	}
	static void test() {
		throw new Error("hello");
	}
	static aspect A {
		declare soft : unknown.Error : call(void test()); // CE
	}
}</bugreport>
<testsforfix ID="53999" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="'can't bind type' message has $ for . in type name for declare soft"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="105" file="output/53999/pre-fix/testresults.xml" passing="1202" size="1307"/>
<post-fix-testcases failing="106" file="output/53999/post-fix/testresults.xml" passing="1202" size="1308"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java" revision="1.12" state="changed">335a336
&gt; 		String originalName = cleanName;
350c351
&lt; 							MessageUtil.error("can't bind type name '" + cleanName + "'",
---
&gt; 							MessageUtil.error("can't bind type name '" + originalName + "'",
353c354
&lt; 						scope.getWorld().getLint().invalidAbsoluteTypeName.signal(cleanName, getSourceLocation());
---
&gt; 						scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName, getSourceLocation());
357c358
&lt; 					scope.getWorld().getLint().invalidAbsoluteTypeName.signal(cleanName, getSourceLocation());
---
&gt; 					scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName, getSourceLocation());
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.161" state="changed">7772a7773,7778
&gt;     &lt;ajc-test dir="bugs"
&gt; 		pr="53999" title="'can't bind type' message has $ for . in type name for declare soft"&gt;
&gt;         &lt;compile files="Cosmetic.java"&gt;
&gt;         &lt;message kind="error" line="9" text="can't bind type name 'unknown.Error'"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs/Cosmetic.java" revision="1.1" state="new"> class Test {
	public static void main(String[] args) {
		test();
	}
	static void test() {
		throw new Error("hello");
	}
	static aspect A {
		declare soft : unknown.Error : call(void test()); // CE  should be a message saying cant bind type 'unknown.Error' and not 'unknown$Error'
	}
}</file>
</fixedFiles>
</bug>
<bug id="54238" transactionid="74232">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P2"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKM</concisefingerprint>
<fullfingerprint>H K-catch K-try M T V Y</fullfingerprint>
<bugreport>Core compiler implementation changes have resulted in an incompatability with 
AJDE's build cancelling mechanism.  Once the core canceling behavior 
stabilizes this needs to be restored.</bugreport>
<pre-fix-testcases failing="108" file="output/54238/pre-fix/testresults.xml" passing="1182" size="1290"/>
<post-fix-testcases failing="109" file="output/54238/post-fix/testresults.xml" passing="1181" size="1290"/>
<fixedFiles>
<file name="org.aspectj/modules/ajbrowser/src/org/aspectj/tools/ajbrowser/BasicEditor.java" revision="1.3" state="changed">75,77c75,81
&lt; 		showSourceLine(sourceLocation.getSourceFile().getAbsolutePath(), sourceLocation.getLine(), highlight);
&lt; 	}
&lt; 
---
&gt;     	try {
&gt;     		showSourceLine(sourceLocation.getSourceFile().getAbsolutePath(), sourceLocation.getLine(), highlight);
&gt;     	} catch (NullPointerException npe) {
&gt;     		Ajde.getDefault().getIdeUIAdapter().displayStatusInformation(" no corresponding source line to seek to");
&gt;     	}
&gt;     }
&gt;     	
</file>
</fixedFiles>
</bug>
<bug id="54421" transactionid="70026">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="26"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="27"/>
<property name="priority" value="P3"/>
<property name="severity" value="minor"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-if K-new K-null K-return K-throw K-true K-while M O-== O-! O-!= O-&amp;&amp; T V Y Z-if Z-throw Z-while</fullfingerprint>
<bugreport>The following code does not compile because the message uses string 
concatenation (the + operator). 


public class WarningSample {

  public void method() {}
  public void anotherMethod() {
    this.method();
  }

}

aspect WarningAspect {

  pointcut illegalCall(): call(* WarningSample.method())
                &amp;&amp; within(WarningSample);

  // the same thing happens with declare error
  declare warning: illegalCall() : "Hey, don't " +
      "do that, that is not nice. You should do something else";

}</bugreport>
<testsforfix ID="54421" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test026_bindingThisAndTargetToTheSameFormal"/>
      <test NAME="test030_privateITDinitialisersBeingMatched"/>
      <test NAME="test032_stringConcatForDEOW"/>
      <test NAME="test033_stringConcatForDEOWErrorCase"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="Compile time declarations (warning and error) do not accept string concatenation (with +)"/>
      <test NAME="Compile time declarations (warning and error) do not accept string concatenation (with +) (2)"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="113" file="output/54421/pre-fix/testresults.xml" passing="1245" size="1358"/>
<post-fix-testcases failing="112" file="output/54421/post-fix/testresults.xml" passing="1246" size="1358"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PatternParser.java" revision="1.10" state="changed">153c153
&lt; 		String message = parseStringLiteral();
---
&gt; 		String message = parsePossibleStringSequence(true);
738a739,764
&gt; 	public String parsePossibleStringSequence(boolean shouldEnd) {
&gt; 		StringBuffer result = new StringBuffer();
&gt; 		
&gt; 		IToken token = tokenSource.next();
&gt; 		if (token.getLiteralKind()==null) {
&gt; 			throw new ParserException("string",token);
&gt; 		}
&gt; 		while (token.getLiteralKind().equals("string")) {
&gt; 			result.append(token.getString());			
&gt; 			boolean plus = maybeEat("+");
&gt; 			if (!plus) break;
&gt; 			token = tokenSource.next();
&gt; 			if (token.getLiteralKind()==null) {
&gt; 				throw new ParserException("string",token);
&gt; 			}
&gt; 		}
&gt; 		eatIdentifier(";");
&gt; 		IToken t = tokenSource.next();
&gt; 		if (shouldEnd &amp;&amp; t!=IToken.EOF) {
&gt; 			throw new ParserException("&lt;string&gt;;",token);
&gt; 		}
&gt; 
&gt; 		return result.toString();
&gt; 		
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.12" state="changed">206d205
&lt; 
257c256,277
&lt;    	&lt;/ajc-test&gt;
\ Kein Zeilenumbruch am Dateiende.
---
&gt;    	&lt;/ajc-test&gt;
&gt; 	
&gt; 	&lt;ajc-test dir="bugs" pr="54421"
&gt; 		title="Compile time declarations (warning and error) do not accept string concatenation (with +)"&gt;
&gt;         &lt;compile files="decwStrings.java"&gt;
&gt;         	&lt;message kind="warning" line="5"/&gt;
&gt; 			&lt;message kind="warning" line="19" text="hello world"/&gt;
&gt; 			&lt;message kind="warning" line="22" text="hello world"/&gt;
&gt; 			&lt;message kind="warning" line="25" text="hello world"/&gt;
&gt; 			&lt;message kind="warning" line="30" text="hello world"/&gt;
&gt; 			&lt;message kind="warning" line="34" text="hello world"/&gt;
&gt; 			&lt;message kind="warning" line="39" text="abcdefghijklmnopqrstuvwxyz"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 	
&gt; 	&lt;ajc-test dir="bugs" pr="54421"
&gt; 		title="Compile time declarations (warning and error) do not accept string concatenation (with +) (2)"&gt;
&gt;         &lt;compile files="decwStringsErroneous.java"&gt;
&gt; 			&lt;message kind="error" line="22"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.12" state="changed">142c142,143
&lt;     public void test026_bindingThisAndTargetToTheSameFormal() {
---
&gt;   
&gt;   public void test026_bindingThisAndTargetToTheSameFormal() {
158c159
&lt;   public void test030_privateITDinitialisersBeingMatched() {
---
&gt;     public void test030_privateITDinitialisersBeingMatched() {
168a170,173
&gt;   
&gt;   public void test032_stringConcatForDEOW() {
&gt;     runTest("Compile time declarations (warning and error) do not accept string concatenation (with +)");
&gt;   }
169a175,177
&gt;   public void test033_stringConcatForDEOWErrorCase() {
&gt;     runTest("Compile time declarations (warning and error) do not accept string concatenation (with +) (2)");
&gt;   }
</file>
<file name="org.aspectj/modules/tests/bugs/decwStringsErroneous.java" revision="1.1" state="new">class WarningSample {

	public void method() {}
	  public void anotherMethod() {
	    this.method();
	  }

	}

	aspect WarningAspect {

	  pointcut illegalCall(): call(* WarningSample.method())
	                &amp;&amp; within(WarningSample);

	  // the same thing happens with declare error
	  declare warning: illegalCall() : "Hey, don't " +
	      "do that, that is not nice. You should do something else";

	  public void e1() {}
	  declare warning: execution(* e1(..)): "hello " + /* comment */ "world"

	  public void e2() {}
	  declare warning: execution(* e2(..)): "hello " /* comment + "world";
	  
	  public void e3() {}
	  declare warning: execution(* e3(..)): "hello " + // commenthere
	
	}

</file>
<file name="org.aspectj/modules/tests/bugs/decwStrings.java" revision="1.1" state="new">class WarningSample {

	  public void method() {}
	  public void anotherMethod() {
	    this.method();
	  }

	}

	aspect WarningAspect {

	  pointcut illegalCall(): call(* WarningSample.method())
	                &amp;&amp; within(WarningSample);

	  // the same thing happens with declare error
	  declare warning: illegalCall() : "Hey, don't " +
	      "do that, that is not nice. You should do something else";

	  public void e1() {}
	  declare warning: execution(* e1(..)): "hello " + /* comment */ "world";

	  public void e2() {}
	  declare warning: execution(* e2(..)): "hello " /* comment */ + "world";
	  
	  public void e3() {}
	  declare warning: execution(* e3(..)): "hello " + // commenthere
	  // comment here too
	  "world";
	  
	  public void e4() {}
	  declare warning: execution(* e4()): "hello " //xxx
	  	+ "world";
	  
	  public void e5() {}
	  declare warning: execution(* e5()): "hello " //xxx
	  	/* here */
	  	+ "world";
	  	
	  public void e6() {}
	  declare warning: execution(* e6()): "abc" +
 "def" + // def was here
 "ghijklmnopqrstuv" /* silly
place
for a 
comment */ +
/* oops */
 "wxyz";
	}

</file>
</fixedFiles>
</bug>
<bug id="54625" transactionid="71019">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-null K-return M O-!= T V Z-if</fullfingerprint>
<bugreport>Either fix the class file deleting etc. to work with jars, or always do a batch 
build when working with outjars.</bugreport>
<pre-fix-testcases failing="104" file="output/54625/pre-fix/testresults.xml" passing="1159" size="1263"/>
<post-fix-testcases failing="103" file="output/54625/post-fix/testresults.xml" passing="1160" size="1263"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java" revision="1.5" state="changed">83c83
&lt; //		if (newBuildConfig.getOutputJar() != null) return false;
---
&gt; 		if (newBuildConfig.getOutputJar() != null) return false;
</file>
</fixedFiles>
</bug>
<bug id="54965" transactionid="70926">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="11"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="10"/>
<property name="lines-churned" value="14"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-new M T V Z-if</fullfingerprint>
<bugreport>When I added support for -outjar in the test harness, I was surprised to find 
duplicate entry exceptions coming from the output file writing to the outjar. I 
traced it through, and found that every source file passed to an incremental 
compile is in fact compiled twice!

The first time round we note the references, and of course each file has a 
reference to itself. Then we call "AjState.getFilesToCompile" looking to see if 
there are any further files to compile in another iteration. This method does 
not remember the set of files it just compiled, so since we have referenced each 
type we just compiled, and we have no reord of that fact, we compile them again. 
Second time around, the bytecodes are identical to the previous go, so 
recordClassFile doesn't note their dependents - and thus this time we terminate.</bugreport>
<pre-fix-testcases failing="104" file="output/54965/pre-fix/testresults.xml" passing="1157" size="1261"/>
<post-fix-testcases failing="104" file="output/54965/post-fix/testresults.xml" passing="1157" size="1261"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java" revision="1.4" state="changed">51a52
&gt; 	List/*File*/ compiledSourceFiles = new ArrayList();
81a83,84
&gt; //		if (newBuildConfig.getOutputJar() != null) return false;
&gt; 		
120c123
&lt; 		List sourceFiles = new ArrayList();
---
&gt; 		List thisTime = new ArrayList();
121a125
&gt; 			compiledSourceFiles = new ArrayList();
124c128
&lt; 			sourceFiles.addAll(modifiedFiles);
---
&gt; 			thisTime.addAll(modifiedFiles);
131c135
&lt; 			sourceFiles.addAll(addedFiles);	
---
&gt; 			thisTime.addAll(addedFiles);	
135c139
&lt; 			addAffectedSourceFiles(sourceFiles);
---
&gt; 			addAffectedSourceFiles(thisTime,thisTime);
138c142
&lt; 			addAffectedSourceFiles(sourceFiles);
---
&gt; 			addAffectedSourceFiles(thisTime,compiledSourceFiles);
140c144,145
&lt; 		return sourceFiles;
---
&gt; 		compiledSourceFiles = thisTime;
&gt; 		return thisTime;
324c329
&lt; 	protected void addAffectedSourceFiles(List sourceFiles) {
---
&gt; 	protected void addAffectedSourceFiles(List addTo, List lastTimeSources) {
346,347c351,352
&lt; 					if (!sourceFiles.contains(file)) {  //??? O(n**2)
&lt; 						sourceFiles.add(file);
---
&gt; 					if (!lastTimeSources.contains(file)) {  //??? O(n**2)
&gt; 						addTo.add(file);
</file>
</fixedFiles>
</bug>
<bug id="55341" transactionid="69040">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-false K-true</fullfingerprint>
<bugreport>When compiling a binary concrete aspect library (for later LTW) consisting of
more than one aspect that performs an ITD on a target class not exposed to the 
weaver I get the following error:

error Type mismatch: cannot convert from java.lang.String to java.lang.String

The error does not oocur if a complete build &amp; weave is performed. Testcase 
attached.</bugreport>
<testsforfix ID="55341" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="error Type mismatch: cannot convert from java.lang.String to java.lang.String"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="110" file="output/55341/pre-fix/testresults.xml" passing="1175" size="1285"/>
<post-fix-testcases failing="110" file="output/55341/post-fix/testresults.xml" passing="1176" size="1286"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/testdata/ltw-aspects.jar" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/ltw-peraspects.jar" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/ltw-acaspects.jar" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/dummyAspect.jar" revision="1.12" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/ltw-woven.jar" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/megatrace0easy.jar" revision="1.6" state="changed"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java" revision="1.10" state="changed">181a182,191
&gt; 		
&gt; 		// For PR55341
&gt; 		args = new ArrayList();
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar"  +
&gt; 			File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../tests/bugs/StringToString/helloworld.jar");		
&gt; 		args.add("../tests/bugs/StringToString/HW.java");		
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
248,249c258
&lt; 		/* Uncomment when bug #55341 fixed */
&lt; //		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWMethodITD.aj");
---
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWMethodITD.aj");
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java" revision="1.9" state="changed">44c44
&lt; 		FieldBinding retField = sourceTypeBinding.getFieldBase(fieldName, false);  // XXX may need to get the correct value for second parameter in the future
---
&gt; 		FieldBinding retField = sourceTypeBinding.getFieldBase(fieldName, true);  // XXX may need to get the correct value for second parameter in the future (see #55341)
</file>
<file name="org.aspectj/modules/weaver/testdata/megatrace.jar" revision="1.12" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/megatrace0hard.jar" revision="1.5" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/megatraceNoweave.jar" revision="1.12" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/ltw-classes.jar" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/tracing.jar" revision="1.12" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/ltw-itdaspects.jar" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java" revision="1.2" state="changed">143,145c143
&lt; 			/* Uncomment when bug #55341 fixed */
&lt; //			invokeMain(clazz,new String[] { "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD" }); 
&lt; 			invokeMain(clazz,new String[] { "LTWInterfaceITD", "LTWFieldITD" }); 
---
&gt; 			invokeMain(clazz,new String[] { "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD" }); 
180,182c178
&lt; 			/* Uncomment when bug #55341 fixed */
&lt; //			invokeMain(clazz,new String[] { "LTWAspect", "LTWAroundClosure", "LTWPerthis", "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD", "LTWPerthis"}); 
&lt; 			invokeMain(clazz,new String[] { "LTWAspect", "LTWAroundClosure", "LTWPerthis", "LTWInterfaceITD", "LTWFieldITD", "LTWPerthis"}); 
---
&gt; 			invokeMain(clazz,new String[] { "LTWAspect", "LTWAroundClosure", "LTWPerthis", "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD", "LTWPerthis"}); 
</file>
<file name="org.aspectj/modules/tests/bugs/StringToString/HW.java" revision="1.1" state="new">
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;

public class HW extends ArrayList {

  String message = "Hello World!";

	private void check (String args) {
	}

	public void println () {
		System.out.println(message);
	}

	public static void main(String[] args) {
		HW hw = new HW();
		hw.println();		
		for (int i = 0; i &lt; args.length; i++) {
			String jp = args[i];
			if (!hw.contains(jp)) {
				throw new RuntimeException(jp + " missing"); 
			}
		}
	}

}
</file>
<file name="org.aspectj/modules/tests/bugs/StringToString/helloworld.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.150" state="changed">7525a7526,7536
&gt;     &lt;ajc-test dir="bugs/StringToString" pr="55341"
&gt; 	    title="error Type mismatch: cannot convert from java.lang.String to java.lang.String"
&gt;      		comment="make helloworld.jar with 'ajc -outjar helloworld.jar HW.java' or run BcweaverJarMaker"
&gt;      		keywords=""&gt;
&gt;         &lt;compile files="X.java" classpath="helloworld.jar"&gt;
&gt;         	&lt;message kind="warning" line="3"/&gt;
&gt;         	&lt;message kind="warning" line="7"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 	
&gt; 	
</file>
<file name="org.aspectj/modules/tests/bugs/StringToString/X.java" revision="1.1" state="new">// PR55341
aspect F { 
  private int HW.intField = 999;
}

aspect M {
  public String HW.getMessage () {
    return message;
  }
}
</file>
</fixedFiles>
</bug>
<bug id="57430" transactionid="70046">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-if K-instanceof K-new K-throw K-true M O-instanceof T V Z-if Z-throw</fullfingerprint>
<tag>exception</tag>
<bugreport>Exceptions thrown from the compiler used to be printed once, with the submit-bug
header.  Now they are printed twice, without and with the header.  True of CVS
version.</bugreport>
<pre-fix-testcases failing="110" file="output/57430/pre-fix/testresults.xml" passing="1176" size="1286"/>
<post-fix-testcases failing="110" file="output/57430/post-fix/testresults.xml" passing="1176" size="1286"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java" revision="1.5" state="changed">119c119,126
&lt; 		} 
---
&gt; 		} catch (RuntimeException rEx) {
&gt; 			if (rEx instanceof AbortCompilation) throw rEx; // Don't wrap AbortCompilation exceptions!
&gt; 
&gt; 			// This will be unwrapped in Compiler.handleInternalException() and the nested
&gt; 			// RuntimeException thrown back to the original caller - which is AspectJ
&gt; 			// which will then then log it as a compiler problem.
&gt; 			throw new AbortCompilation(true,rEx);
&gt; 		}
</file>
</fixedFiles>
</bug>
<bug id="57436" transactionid="69139">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="9"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-import M T V</fullfingerprint>
<bugreport>Java 1.5 beta reports a ClassFormatError when running programs (e.g., spacewar)
compiled by ajc 1.1.1 and the latest CVS head.  Sun's Java 1.5 beta
binary-compatibility docs say that some obfuscators violated the .class format
specification, so those .class files will fail when run under 1.5.  (The docs
also say they are still incomplete.)  

Although 1.5 is still beta, we would want to submit a bug to Sun if our
implementation techniques are valid, so we don't have to change those
techniques.  For 1.2, we should at document if we don't fix, since many people
are using 1.5.</bugreport>
<pre-fix-testcases failing="109" file="output/57436/pre-fix/testresults.xml" passing="1177" size="1286"/>
<post-fix-testcases failing="109" file="output/57436/post-fix/testresults.xml" passing="1177" size="1286"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java" revision="1.23" state="changed">25a26
&gt; import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
297,298c298,306
&lt; 		codeStream.init(classFile);
&lt; 		codeStream.initializeMaxLocals(methodBinding);
---
&gt; 		
&gt; 		// Use reset() rather than init()
&gt; 		// XXX We need a scope to keep reset happy, initializerScope is *not* the right one, but it works !
&gt; //		 codeStream.init(classFile);
&gt; //		 codeStream.initializeMaxLocals(methodBinding);
&gt; 		MethodDeclaration md = AstUtil.makeMethodDeclaration(methodBinding);
&gt; 		md.scope = initializerScope;
&gt; 		codeStream.reset(md,classFile);
&gt; 		
</file>
</fixedFiles>
</bug>
<bug id="57666" transactionid="68570">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="14"/>
<property name="lines-added" value="11"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="11"/>
<property name="lines-churned" value="24"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-if K-import K-new K-null K-true M O-== O-() O-cast T V Y Z-cast Z-if Z-while</fullfingerprint>
<bugreport>(Ah, the joy of build infrastructure...)

Mostly self-explanatory trace, from a build Monday Apr 5, 2004 at 08:46:01 GMT:

duplicate entry: META-INF/MANIFEST.MF
duplicate entry: META-INF/MANIFEST.MF
java.util.zip.ZipException: duplicate entry: META-INF/MANIFEST.MF
	at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163)
	at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:344)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromJarFile(AjBuildManager.java:288)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:253)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:195)
	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
	at org.aspectj.tools.ajc.Main.run(Main.java:280)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
	at org.aspectj.tools.ajc.Main.main(Main.java:79)</bugreport>
<testsforfix ID="57666" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/DuplicateManifestTest.java">
      <test NAME="testWeave"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="103" file="output/57666/pre-fix/testresults.xml" passing="1213" size="1316"/>
<post-fix-testcases failing="104" file="output/57666/post-fix/testresults.xml" passing="1212" size="1316"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.56" state="changed">292a293
&gt; //				System.out.println("? copyResourcesFromJarFile() filename='" + filename +"'");
383c384,385
&lt; 				(resourceName.endsWith(".class")) 
---
&gt; 				(resourceName.endsWith(".class")) ||
&gt; 				(resourceName.toUpperCase().equals(MANIFEST_NAME))
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java" revision="1.32" state="changed">22a23
&gt; import java.io.InputStream;
27a29
&gt; import java.util.Enumeration;
33a36,37
&gt; import java.util.jar.JarEntry;
&gt; import java.util.jar.JarFile;
184c188
&lt; 		JarInputStream inStream = null;
---
&gt; 		JarFile inJar = null;
192,193c196,198
&lt; 				inStream = new JarInputStream(new FileInputStream(inFile)); //??? buffered
&lt; 				addManifest(inStream.getManifest());
---
&gt; 				inJar = new JarFile(inFile);
&gt; 				addManifest(inJar.getManifest());
&gt; 				Enumeration entries = inJar.entries();
195,198c200,203
&lt; 				while (true) {
&lt; 					ZipEntry entry = inStream.getNextEntry();
&lt; 					if (entry == null) break;
&lt; 				
---
&gt; 				while (entries.hasMoreElements()) {
&gt; 					JarEntry entry = (JarEntry)entries.nextElement();
&gt; 					InputStream inStream = inJar.getInputStream(entry);
&gt; 					
200a206
&gt; //					System.out.println("? addJarFile() filename='" + filename + "'");
213c219
&lt; 					inStream.closeEntry();
---
&gt; 					inStream.close();
215c221
&lt; 				inStream.close();
---
&gt; 				inJar.close();
230,231c236,237
&lt; 			if (inStream != null) {
&lt; 				try {inStream.close();}
---
&gt; 			if (inJar != null) {
&gt; 				try {inJar.close();}
393a400
&gt; //		System.out.println("? addManifest() newManifest=" + newManifest);
398a406,407
&gt; 	public static final String MANIFEST_NAME = "META-INF/MANIFEST.MF";
&gt; 	
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java" revision="1.12" state="changed">40a41,42
&gt; 		
&gt; 		makeDuplicateManifestTestJars();
296a299
&gt; 
297a301,327
&gt; 	public static void makeDuplicateManifestTestJars() throws IOException {
&gt; 		List args = new ArrayList();
&gt; 
&gt; 		/*
&gt; 		 * injar
&gt; 		 */
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../ajde/testdata/DuplicateManifestTest/injar.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/Hello.java");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 
&gt; 		/*
&gt; 		 * aspectjar
&gt; 		 */
&gt; 		args = new ArrayList();
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../ajde/testdata/DuplicateManifestTest/aspectjar.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/Trace.java");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/TraceHello.java");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 	}	
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/DuplicateManifestTest.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package org.aspectj.ajde;

import java.io.File;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

public class DuplicateManifestTest extends AjdeTestCase {


	public static final String PROJECT_DIR = "DuplicateManifestTest";

	public static final String injarName  = "injar.jar";
	public static final String aspectjarName  = "aspectjar.jar";
	public static final String outjarName = "outjar.jar";


	/*
	 * Ensure the output directpry in clean
	 */
	protected void setUp() throws Exception {
		super.setUp(PROJECT_DIR);
	}
	
	public void testWeave () {
		Set injars = new HashSet();
		injars.add(openFile(injarName));
		ideManager.getProjectProperties().setInJars(injars);
		Set aspectpath = new HashSet();
		aspectpath.add(openFile(aspectjarName));
		ideManager.getProjectProperties().setAspectPath(aspectpath);
		File outjar = openFile(outjarName);
		ideManager.getProjectProperties().setOutJar(outjar.getAbsolutePath());
		assertTrue("Build failed", doSynchronousBuild("build.lst"));
		assertTrue(
			"Build warnings",
			ideManager.getCompilationSourceLineTasks().isEmpty());
		compareManifests(openFile(injarName),openFile(outjarName));
	}
	
	private void compareManifests (File inFile, File outFile) {

		try {
			JarFile inJar = new JarFile(inFile);
			Manifest inManifest = inJar.getManifest();
			inJar.close();
			JarFile outJar = new JarFile(outFile);
			Manifest outManifest = outJar.getManifest();
			outJar.close();
			assertTrue("The manifests in '" + inFile.getCanonicalPath() + "' and '" + outFile.getCanonicalPath() + "' sould be the same",inManifest.equals(outManifest));
		}
		catch (IOException ex) {
			fail(ex.toString());
		}
	}

}
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AjdeTests.java" revision="1.16" state="changed">39a40
&gt; 		suite.addTestSuite(DuplicateManifestTest.class);
</file>
<file name="org.aspectj/modules/ajde/testdata/DuplicateManifestTest/update-injar.xml" revision="1.1" state="new">&lt;?xml version="1.0" ?&gt;
&lt;project name="DuplicateManifestTest" default="all" basedir="."&gt;

	&lt;property name="injar" value="${basedir}/injar.jar"/&gt;
	&lt;property name="tempdir" value="${basedir}/temp"/&gt;

	&lt;target name="update"&gt;

		&lt;delete dir="${tempdir}"/&gt;

		&lt;unzip
			dest="${tempdir}"
			src="${injar}"
		/&gt;

		&lt;copy todir="${tempdir}" overwrite="true"&gt;
			&lt;fileset dir="${basedir}"&gt;			
				&lt;include name="META-INF/*"/&gt;
			&lt;/fileset&gt;
		&lt;/copy&gt;

		&lt;zip
			destfile="${injar}"
		&gt;
			&lt;fileset dir="${basedir}/temp"/&gt;
		
		&lt;/zip&gt;	

		&lt;delete dir="${tempdir}"/&gt;
	&lt;/target&gt;
	
	&lt;target name="all" depends="update"/&gt;
&lt;/project&gt;
</file>
<file name="org.aspectj/modules/ajde/testdata/DuplicateManifestTest/META-INF/test.xml" revision="1.1" state="new">&lt;?xml version="1.0" ?&gt;
&lt;jar name="input1.jar"&gt;
&lt;/jar&gt;

</file>
<file name="org.aspectj/modules/ajde/testdata/DuplicateManifestTest/build.ajsym" revision="1.1" state="new"/>
<file name="org.aspectj/modules/ajde/testdata/DuplicateManifestTest/aspectjar.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/ajde/testdata/DuplicateManifestTest/build.lst" revision="1.1" state="new"/>
<file name="org.aspectj/modules/ajde/testdata/DuplicateManifestTest/META-INF/MANIFEST.MF" revision="1.1" state="new"/>
<file name="org.aspectj/modules/ajde/testdata/DuplicateManifestTest/injar.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/ajde/testdata/DuplicateManifestTest/outjar.jar" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="58520" transactionid="70211">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P4"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-|| O-() T V Y Z-if</fullfingerprint>
<bugreport>When a file is advised, javadoc uses the following naming convention for 
setting its "A NAME":

  convertCheckedException(java.lang.Throwable)

However, ajdoc uses the unqualified name for the argument, resuting in the 
follwing in-file anchor link:

  &lt;class-name&gt;.html#convertCheckedException(Throwable)

Which fails to navigate to the anchor within the file, although it does always 
go to the right file.</bugreport>
<testsforfix ID="58520" type="new">
    <file LOCATION="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/FullyQualifiedArgumentTest.java">
      <test NAME="testPr58520"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/58520/pre-fix/testresults.xml" passing="1611" size="1791"/>
<post-fix-testcases failing="180" file="output/58520/post-fix/testresults.xml" passing="1612" size="1792"/>
<fixedFiles>
<file name="org.aspectj/modules/ajdoc/testdata/pr119453/src/pack/C.java" revision="1.2" state="changed">17a18,20
&gt; 	public void method3(String s) { 
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java" revision="1.17" state="changed">295c295
&lt; 			String argType = argArray[i].type.toString();
---
&gt; 			String argType = argArray[i].type.resolvedType.debugName();
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java" revision="1.39" state="changed">421c421,422
&lt; 			if (peNode.toLabelString().equals("main(String[])")
---
&gt; 			if ((peNode.toLabelString().equals("main(String[])")
&gt; 					|| peNode.toLabelString().equals("main(java.lang.String[])"))
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/FullyQualifiedArgumentTest.java" revision="1.1" state="new">/********************************************************************
 * Copyright (c) 2005 Contributors. All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: IBM Corporation - initial API and implementation 
 * 				 Helen Hawkins   - iniital version
 *******************************************************************/
package org.aspectj.tools.ajdoc;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;

import junit.framework.TestCase;

import org.aspectj.util.FileUtil;

public class FullyQualifiedArgumentTest extends TestCase {

	private File outdir;
	private File c, a;
	    
	protected void setUp() throws Exception {
		super.setUp();
		outdir = new File("../ajdoc/testdata/pr119453/doc");
		c = new File("../ajdoc/testdata/pr119453/src/pack/C.java");
		a = new File("../ajdoc/testdata/pr119453/src/pack/A.aj");
	}
	
	protected void tearDown() throws Exception {
		super.tearDown();
		
		FileUtil.deleteContents(new File("ajdocworkingdir"));
		(new File("ajdocworkingdir")).delete();
		
		FileUtil.deleteContents(new File("testdata/pr119453/doc"));
		(new File("testdata/pr119453/doc")).delete();
	}
    
	/**
	 * Test for pr119453
	 */
    public void testPr58520() throws Exception {
        outdir.delete();
        String[] args = { 
              "-XajdocDebug",
              "-private",
            "-d", 
            outdir.getAbsolutePath(),
            c.getAbsolutePath(),
            a.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
        
        checkContentsOfA();        

    }
        
    // check whether the "advises" section of the "Advice Summary" contains
    // the fully qualified argument, so for example, it says it has href
    // .../ajdoc/testdata/pr119453/doc/pack/C.html#method3(java.lang.String) 
    // rather than .../ajdoc/testdata/pr119453/doc/pack/C.html#method3(String)
    private void checkContentsOfA() throws Exception {
        File htmlA = new File("../ajdoc/testdata/pr119453/doc/pack/A.html");
        if (htmlA == null) {
			fail("couldn't find ../ajdoc/testdata/pr119453/doc/pack/A.html - were there compilation errors?");
		}
	    BufferedReader readerA = new BufferedReader(new FileReader(htmlA));
        boolean containsAdviceSummary = false;
        String lineA = readerA.readLine();
        while( lineA != null &amp;&amp; (!containsAdviceSummary)) {
        	if (lineA.indexOf("ADVICE SUMMARY") != -1) {
        		containsAdviceSummary = true;
        		boolean containsFullyQualifiedArgument = false;
        		boolean containsUnqualifiedArgument = false;
        		// walk through the information in this section
				String nextLine = readerA.readLine();
				while(nextLine != null 
						&amp;&amp; (nextLine.indexOf("========") == -1)
						&amp;&amp; (!containsFullyQualifiedArgument || 
								!containsUnqualifiedArgument)) {
					if (nextLine.indexOf("C.html#method3(java.lang.String)") != -1) {
						containsFullyQualifiedArgument = true;
					} 
					if (nextLine.indexOf("C.html#method3(String)") != -1) {
						containsUnqualifiedArgument = true;
					} 
					nextLine = readerA.readLine();
				}
				assertTrue("Advice summary should have link to " +
						"'C.html#method3(java.lang.String)'", 
						containsFullyQualifiedArgument);
				assertFalse("Advice summary should not have link to " +
						"'C.html#method3(String)'", 
						containsUnqualifiedArgument);
				
				lineA = nextLine;
			} else {
				lineA = readerA.readLine();
			}
        }
        readerA.close();
		
        assertTrue("should have Advice Summary information in " +
        		"../ajdoc/testdata/pr119453/doc/pack/A.html", containsAdviceSummary);
               
    }
	
}
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java" revision="1.4" state="changed">43a44
&gt;         suite.addTestSuite(FullyQualifiedArgumentTest.class);
</file>
</fixedFiles>
</bug>
<bug id="58681" transactionid="71165">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="9"/>
<property name="lines-churned" value="13"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-return M Y Z-if</fullfingerprint>
<bugreport>ajc should emit the available -X options on -help or -X request (the latter like
java) to get more traffic and feedback on the experimental options.</bugreport>
<testsforfix ID="58681" type="changed">
    <file LOCATION="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java">
      <test NAME="testMessages"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="105" file="output/58681/pre-fix/testresults.xml" passing="1204" size="1309"/>
<post-fix-testcases failing="105" file="output/58681/post-fix/testresults.xml" passing="1205" size="1310"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/messages.properties" revision="1.14" state="changed"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.25" state="changed">52a53,56
&gt;     public static String getXOptionUsage() {
&gt;     	return Main.bind("xoption.usage");
&gt;     }
&gt;     
560c564
&lt; 
---
&gt; 		
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java" revision="1.23" state="changed">263c263
&lt;             args = new String[] { "-help" };
---
&gt;             args = new String[] { "-?" };
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java" revision="1.16" state="changed">47,49c47,55
&lt;             if ("-help".equals(args[i])) {
&lt;                 // should be info, but handler usually suppresses
&lt;                 MessageUtil.abort(handler, BuildArgParser.getUsage());
---
&gt; // AMC - PR58681. No need to abort on -help as the Eclipse compiler does the right thing.
&gt; //            if ("-help".equals(args[i])) {
&gt; //                // should be info, but handler usually suppresses
&gt; //                MessageUtil.abort(handler, BuildArgParser.getUsage());
&gt; //                return true;
&gt; //            } else 
&gt;         	if ("-X".equals(args[i])) {
&gt;             	 // should be info, but handler usually suppresses
&gt;                 MessageUtil.abort(handler, BuildArgParser.getXOptionUsage());
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java" revision="1.2" state="changed">23c23
&lt; 
---
&gt; 	
26,28c26,30
&lt;         Main.bareMain(new String[] {"-help"}, false, list, null, null, null);
&lt;         assertTrue(1 == list.size());
&lt;         Object o = list.get(0);
---
&gt; // Usage now printed by Eclipse compiler so doesn't appear here in our message list
&gt; //        Main.bareMain(new String[] {"-help"}, false, list, null, null, null);
&gt; //        assertTrue(1 == list.size());
&gt;         Main.bareMain(new String[] {"-X"}, false, list, null, null, null);
&gt;         assertTrue(1 == list.size());        Object o = list.get(0);
30,31c32,33
&lt;         assertTrue(-1 != ((String)o).indexOf("-aspectpath"));
&lt;         assertTrue(-1 != ((String)o).indexOf("-incremental"));
---
&gt; //        assertTrue(-1 != ((String)o).indexOf("-aspectpath"));
&gt; //        assertTrue(-1 != ((String)o).indexOf("-incremental"));
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/EajcModuleTests.java" revision="1.4" state="changed">16a17
&gt; 
26a28
&gt;         suite.addTestSuite(org.aspectj.tools.ajc.MainTest.class);
</file>
</fixedFiles>
</bug>
<bug id="59208" transactionid="70427">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="19"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="19"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-new K-null K-return K-this M O-&gt; T V Y Z-if</fullfingerprint>
<bugreport>This problem was first observed when weaving large binary legacy classes with 
the ajc 1.2 rc1 candidate. It turns out that BCEL fails with different error 
messages dependent on whether we are doing a binary weave or a straight ajc 
compile. In the latter case, the error message is rather confusing.

To reproduce:
1. Compile and run the following code to produce Foo.java
// File FooProducer.java
public class FooProducer
{
  public static final int N_METHODS = 50;
  public static final int N_STATEMENTS = Short.MAX_VALUE/(2 * N_METHODS);
  public static void main(String[] args) {
  	System.out.println("public class Foo {");
  	System.out.println("static java.util.Set hs = new java.util.HashSet
();");
  	for (int i = 0; i &lt; N_METHODS; i++) {		
  	  System.out.println("public void test" + i + "() { ");
            for (int j = 0; j &lt; N_STATEMENTS; j++) {
    	        System.out.println("hs.add(new Object());");
            }
          System.out.println("}");
        }
    System.out.println("}");
  }
}// End of FooProducer.java

2. Create the following Aspect:
// File a.aj
aspect a  {
 boolean around() : (target(java.util.HashSet) &amp;&amp; call(boolean add(..) ) )
    {
      return false;
    }
}
// End of a.aj

*** 3.a - straight compile and weave:
ajc -
sourceroots .                                                                   
          
ABORT
        
Exception thrown from AspectJ 1.2rc1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
Expected class `CONSTANT_Utf8' at index 25700 and got CONSTANT_NameAndType[12]
(name_index = 25696, signature_index = 81)
Expected class `CONSTANT_Utf8' at index 25700 and got CONSTANT_NameAndType[12]
(name_index = 25696, signature_index = 81)
org.apache.bcel.classfile.ClassFormatException: Expected class `CONSTANT_Utf8' 
at index 25700 and got CONSTANT_NameAndType[12](name_index = 25696, 
signature_index = 81)
        at org.apache.bcel.classfile.ConstantPool.getConstant
(ConstantPool.java:271)
        at org.apache.bcel.classfile.Attribute.readAttribute(Attribute.java:163)
        at org.apache.bcel.classfile.FieldOrMethod.&lt;init&gt;(FieldOrMethod.java:98)
        at org.apache.bcel.classfile.Field.&lt;init&gt;(Field.java:83)
        at org.apache.bcel.classfile.ClassParser.readFields
(ClassParser.java:270)
        at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:172)
        at org.aspectj.weaver.bcel.Utility.makeJavaClass(Utility.java:358)
        at org.aspectj.weaver.bcel.UnwovenClassFile.getJavaClass
(UnwovenClassFile.java:63)
        at org.aspectj.weaver.bcel.UnwovenClassFile.getClassName
(UnwovenClassFile.java:147)
        at org.aspectj.ajdt.internal.compiler.WeaverAdapter.acceptResult
(WeaverAdapter.java:177)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
(BcelWeaver.java:621)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:600)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:94)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:280)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
        at org.aspectj.tools.ajc.Main.main(Main.java:79)


1 fail|abort
Signal 127

*** 3b - binary weave
 ajc -noweave -outjar test.jar a.aj
 javac -d classes Foo.java
  ajc  -aspectpath test.jar -inpath classes         
ABORT
        
Exception thrown from AspectJ 1.2rc1

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
Class can't be both final and abstract
Class can't be both final and abstract
org.apache.bcel.classfile.ClassFormatException: Class can't be both final and 
abstract
        at org.apache.bcel.classfile.ClassParser.readClassInfo
(ClassParser.java:242)
        at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:165)
        at org.aspectj.weaver.bcel.Utility.makeJavaClass(Utility.java:358)
        at org.aspectj.weaver.bcel.UnwovenClassFile.getJavaClass
(UnwovenClassFile.java:63)
        at org.aspectj.weaver.bcel.UnwovenClassFile.getClassName
(UnwovenClassFile.java:147)
        at org.aspectj.ajdt.internal.compiler.WeaverAdapter.acceptResult
(WeaverAdapter.java:177)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
(BcelWeaver.java:621)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:600)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:94)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:280)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
        at org.aspectj.tools.ajc.Main.main(Main.java:79)


1 fail|abort
Signal 127</bugreport>
<testsforfix ID="59208" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test021_BcelFailureWithVeryLargeClasses"/>
      <test NAME="test022_BcelFailureWithVeryLargeClasses_Binary"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/bugs/pr59208/FooProducer.java">
      <test NAME="test&quot;"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/bugs/pr59208/Foo.java">
      <test NAME="test0"/>
      <test NAME="test1"/>
      <test NAME="test2"/>
      <test NAME="test3"/>
      <test NAME="test4"/>
      <test NAME="test5"/>
      <test NAME="test6"/>
      <test NAME="test7"/>
      <test NAME="test8"/>
      <test NAME="test9"/>
      <test NAME="test10"/>
      <test NAME="test11"/>
      <test NAME="test12"/>
      <test NAME="test13"/>
      <test NAME="test14"/>
      <test NAME="test15"/>
      <test NAME="test16"/>
      <test NAME="test17"/>
      <test NAME="test18"/>
      <test NAME="test19"/>
      <test NAME="test20"/>
      <test NAME="test21"/>
      <test NAME="test22"/>
      <test NAME="test23"/>
      <test NAME="test24"/>
      <test NAME="test25"/>
      <test NAME="test26"/>
      <test NAME="test27"/>
      <test NAME="test28"/>
      <test NAME="test29"/>
      <test NAME="test30"/>
      <test NAME="test31"/>
      <test NAME="test32"/>
      <test NAME="test33"/>
      <test NAME="test34"/>
      <test NAME="test35"/>
      <test NAME="test36"/>
      <test NAME="test37"/>
      <test NAME="test38"/>
      <test NAME="test39"/>
      <test NAME="test40"/>
      <test NAME="test41"/>
      <test NAME="test42"/>
      <test NAME="test43"/>
      <test NAME="test44"/>
      <test NAME="test45"/>
      <test NAME="test46"/>
      <test NAME="test47"/>
      <test NAME="test48"/>
      <test NAME="test49"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="Weaver fails in BCEL for large classes"/>
      <test NAME="Weaver fails in BCEL for large classes (binary)"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="80" file="output/59208/pre-fix/testresults.xml" passing="1007" size="1087"/>
<post-fix-testcases failing="113" file="output/59208/post-fix/testresults.xml" passing="1237" size="1350"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java" revision="1.23" state="changed">51a52
&gt; import org.aspectj.bridge.SourceLocation;
379a381,397
&gt;         if (getConstantPoolGen().getSize() &gt; Short.MAX_VALUE) {
&gt;             // PR 59208
&gt;             // we've generated a class that is just toooooooooo big (you've been generating programs
&gt;             // again haven't you? come on, admit it, no-one writes classes this big by hand).
&gt;             // create an empty myGen so that we can give back a return value that doesn't upset the
&gt;             // rest of the process.
&gt;             myGen = new ClassGen(myGen.getClassName(), myGen.getSuperclassName(), 
&gt;                     myGen.getFileName(), myGen.getAccessFlags(), myGen.getInterfaceNames());
&gt;             // raise an error against this compilation unit.
&gt;        		getWorld().showMessage(
&gt;         			IMessage.ERROR, 
&gt;     				WeaverMessages.format(WeaverMessages.CLASS_TOO_BIG,
&gt;     						              this.getClassName()),
&gt;     			    new SourceLocation(new File(myGen.getFileName()),0), null
&gt;     			    );
&gt;         	return;
&gt;         }
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeaverMessages.java" revision="1.4" state="changed">85a86
&gt; 	public static final String CLASS_TOO_BIG = "classTooBig";
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/weaver-messages.properties" revision="1.5" state="changed"/>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.5" state="changed">121a122,129
&gt;   
&gt; //  public void test021_BcelFailureWithVeryLargeClasses() {
&gt; //      runTest("Weaver fails in BCEL for large classes");
&gt; //  }
&gt; //  
&gt; //  public void test022_BcelFailureWithVeryLargeClasses_Binary() {
&gt; //      runTest("Weaver fails in BCEL for large classes (binary)");
&gt; //  }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.5" state="changed">165a166,185
&gt; --&gt;
&gt; 
&gt; &lt;!-- these next two tests commented out as they take minutes to run - reinstate if you need to 
&gt; 	investigate 59208 for any reason 
&gt; 	&lt;ajc-test dir="bugs/pr59208" pr="59208"
&gt;     	title="Weaver fails in BCEL for large classes"&gt;
&gt;         &lt;compile files="Foo.java, A.aj"&gt;
&gt; 	        &lt;message kind="error" line="0" text="constant pool too big"&gt;&lt;/message&gt;
&gt; 	    &lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
&gt; 
&gt; 
&gt; 	&lt;ajc-test dir="bugs/pr59208" pr="59208"
&gt;     	title="Weaver fails in BCEL for large classes (binary)"&gt;
&gt;         &lt;compile 
&gt;         	aspectpath="test.jar"
&gt;         	inpath="classes"&gt;
&gt; 	        &lt;message kind="error" line="0" text="constant pool too big"&gt;&lt;/message&gt;
&gt; 	    &lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/pr59208/classes/Foo.class" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/bugs/pr59208/FooProducer.java" revision="1.1" state="new">public class FooProducer {

  public static final int N_METHODS = 50;
  public static final int N_STATEMENTS = Short.MAX_VALUE/(2*N_METHODS);  
  public static void main(String[] args) {
    System.out.println("public class Foo {");
    System.out.println("static java.util.Set hs = new java.util.HashSet();");
    for (int i = 0; i &lt; N_METHODS; i++) {
      System.out.println("public void test" + i + "() {");
      for (int j=0; j &lt; N_STATEMENTS; j++) {
        System.out.println("hs.add(new Object());");
      } 
      System.out.println("}");
    }
    System.out.println("}");
  }

}
</file>
<file name="org.aspectj/modules/tests/bugs/pr59208/A.aj" revision="1.1" state="new">aspect A  {
    boolean around() : (target(java.util.HashSet) &amp;&amp; call(boolean add(..) ) )
       {
         return false;
       }
   }</file>
<file name="org.aspectj/modules/tests/bugs/pr59208/test.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/bugs/pr59208/Foo.java" revision="1.1" state="new">public class Foo {
static java.util.Set hs = new java.util.HashSet();
public void test0() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test1() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test2() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test3() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test4() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test5() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test6() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test7() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test8() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test9() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test10() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test11() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test12() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test13() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test14() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test15() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test16() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test17() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test18() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test19() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test20() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test21() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test22() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test23() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test24() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test25() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test26() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test27() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test28() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test29() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test30() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test31() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test32() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test33() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test34() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test35() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test36() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test37() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test38() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test39() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test40() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test41() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test42() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test43() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test44() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test45() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test46() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test47() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test48() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
public void test49() {
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
hs.add(new Object());
}
}
</file>
</fixedFiles>
</bug>
<bug id="59596" transactionid="69347">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-null O-== T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I tried to add an Aspect to java.awt.Label. I compile the aspect via:
ajc -inpath /usr/local/j2sdk_nb/j2sdk1.4.2/jre/lib/rt.jar Timestamp.java

Here is the aspect Timestamp.java:

aspect Timestamp {

    private int java.awt.Label._ts_read = 0;
    private int java.awt.Label._ts_write = 0;

    pointcut writeOp():
    call (void java.awt.Label.setText (String));

    pointcut readOp():
    call (String java.awt.Label.getText());
	
    after (java.awt.Label b) returning: readOp() &amp;&amp; target (b)
    {
	b._ts_read++;
    }
    
    after (java.awt.Label b) returning: writeOp() &amp;&amp; target (b)
    {
	b._ts_write++;
	System.out.println (b._ts_write);
    }

    public static void main (String[] args)
    {
	java.awt.Label b1 = new java.awt.Label();
	b1.setText ("abc");
    }
}

Here is the error message I get from ajc:

null
java.lang.NullPointerException
        at
org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext(EclipseAdapterUtils.java:50)
        at
org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation(EclipseAdapterUtils.java:120)
        at
org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:129)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:663)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.acceptResult(AjCompilerAdapter.java:178)
        at
org.aspectj.ajdt.internal.compiler.WeaverAdapter.finishedWith(WeaverAdapter.java:203)
        at
org.aspectj.ajdt.internal.compiler.WeaverAdapter.weaveCompleted(WeaverAdapter.java:167)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:570)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
        at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:600)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
        at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
        at org.aspectj.tools.ajc.Main.run(Main.java:280)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
        at org.aspectj.tools.ajc.Main.main(Main.java:79)


1 fail|abort</bugreport>
<pre-fix-testcases failing="109" file="output/59596/pre-fix/testresults.xml" passing="1179" size="1288"/>
<post-fix-testcases failing="109" file="output/59596/post-fix/testresults.xml" passing="1179" size="1288"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java" revision="1.7" state="changed">43c43,44
&lt;             || ((startPosition &lt;= 0) &amp;&amp; (endPosition &lt;= 0)))
---
&gt;             || ((startPosition &lt;= 0) &amp;&amp; (endPosition &lt;= 0))
&gt;             || compilationUnit==null)
</file>
</fixedFiles>
</bug>
<bug id="59895" transactionid="71197">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P2"/>
<property name="severity" value="major"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-null T V</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>NPE when updating an aspect in incremental mode.
Find test case in incremental/full-rebuild.

AjBuildManager.java:208 finally clause runs after 
every iteration:

     ret = !handler.hasErrors();
     handler = null;

But at AjBuildManager.java:124, handler is only set if 
there is not a complete rebuild: 

    if (!canIncremental &amp;&amp; !batch) { // retry as batch?
        return doBuild(buildConfig, baseHandler, true);
    }
    this.handler = ...

Since result is set by return doBuild..), could say

    if (null != handler) {
        ret = !handler.hasErrors();
    }

(Seems to have been introduced in a month ago in 1.44.  Our test coverage of
incremental mode is awful.)</bugreport>
<testsforfix ID="59895" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml"/>
  </testsforfix>
<pre-fix-testcases failing="110" file="output/59895/pre-fix/testresults.xml" passing="1179" size="1289"/>
<post-fix-testcases failing="110" file="output/59895/post-fix/testresults.xml" passing="1180" size="1290"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.52" state="changed">208c208,209
&lt;             handler = null;
---
&gt;             // bug 59895, don't release reference to handler as may be needed by a nested call
&gt;             //handler = null;
</file>
<file name="org.aspectj/modules/tests/ajcTestsFailing.xml" revision="1.86" state="changed">136,150c136
&lt;     &lt;ajc-test dir="incremental/full-rebuild"
&lt;     	pr="59895"
&lt; 		title="incremental with aspect-driven full rebuild"&gt;
&lt;         &lt;compile 
&lt; 			staging="true" 
&lt; 			sourceroots="src"
&lt; 			options="-incremental"&gt;
&lt;         	&lt;message kind="error" line="3" file="Aspect.java"/&gt;
&lt;         	&lt;/compile&gt;
&lt;         &lt;inc-compile tag="20"&gt;
&lt;         	&lt;message kind="warning" line="4" file="Main.java"/&gt;
&lt;         	&lt;/inc-compile&gt;
&lt;         &lt;run class="Main"/&gt;
&lt;     &lt;/ajc-test&gt;
&lt; 
---
&gt;   
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.155" state="changed">7667a7668,7682
&gt; 
&gt;   &lt;ajc-test dir="incremental/full-rebuild"
&gt;     	pr="59895"
&gt; 		title="incremental with aspect-driven full rebuild"&gt;
&gt;         &lt;compile 
&gt; 			staging="true" 
&gt; 			sourceroots="src"
&gt; 			options="-incremental"&gt;
&gt;         	&lt;message kind="error" line="3" file="Aspect.java"/&gt;
&gt;         	&lt;/compile&gt;
&gt;         &lt;inc-compile tag="20"&gt;
&gt;         	&lt;message kind="warning" line="4" file="Main.java"/&gt;
&gt;         	&lt;/inc-compile&gt;
&gt;         &lt;run class="Main"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="59909" transactionid="69737">
<property name="files-churned" value="6"/>
<property name="java-files-churned" value="6"/>
<property name="classes-churned" value="6"/>
<property name="methods-churned" value="6"/>
<property name="hunks" value="13"/>
<property name="lines-added" value="186"/>
<property name="lines-deleted" value="6"/>
<property name="lines-modified" value="51"/>
<property name="lines-churned" value="243"/>
<property name="priority" value="P2"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-else K-false K-for K-if K-import K-interface K-new K-null K-package K-return M O-== O-&gt; O-&gt;= O-|| O-! O-!= O-/ O-() O-++ O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>Problem:
The current implementation of CFlowStack (Version 1.1-till 1.2 rc1) stores all 
threads in a hashtable. These Threads are removes after several calls to the 
methods getThreadStack(). (In our cases &gt;70 calls.)

In our project, this cycle is much to long. We have soveral long running 
threads, which grap quite a lot of lot of memory. This memory can only be freed 
after the threads have been removed from the CFlowStack. 
In our production code we sum up to more than 300 Threads stored in different 
CFlowStack Varaibles. Often this results in out of memory Errors.

Added patch provides an improved freeing scheme.

It checks if the size of the table has grown, if it has, it checks if it can 
remove some threads.</bugreport>
<pre-fix-testcases failing="109" file="output/59909/pre-fix/testresults.xml" passing="1181" size="1290"/>
<post-fix-testcases failing="108" file="output/59909/post-fix/testresults.xml" passing="1182" size="1290"/>
<fixedFiles>
<file name="org.aspectj/modules/lib/test/aspectjrt.jar" revision="1.10" state="changed"/>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/internal/CFlowStack.java" revision="1.5" state="changed">16a17,18
&gt; import java.util.Stack;
&gt; 
19,22c21,51
&lt; 
&lt; import java.util.Stack;
&lt; import java.util.Hashtable;
&lt; import java.util.Enumeration;
---
&gt; import org.aspectj.runtime.internal.cflowstack.ThreadStack;
&gt; import org.aspectj.runtime.internal.cflowstack.ThreadStackFactory;
&gt; import org.aspectj.runtime.internal.cflowstack.ThreadStackFactoryImpl;
&gt; import org.aspectj.runtime.internal.cflowstack.ThreadStackFactoryImpl11;
&gt; 
&gt; /*
&gt;  * How we benefit from ThreadLocal when it is available at runtime:
&gt;  * 
&gt;  * When the CFlowStack class is loaded, we run its static initializer.  This checks the JVM
&gt;  * version number and loads an appropriate implementation of the ThreadStackFactory.
&gt;  * There are two possible implementations depending on whether this is a 1.1 or 1.2+ JVM.
&gt;  * Rather than doing a Class.forName for ThreadLocal and catching a ClassNotFoundEx in order
&gt;  * to determine the JVM version, we look at the java class version which I believe can help
&gt;  * us identify the Java level.
&gt;  * 
&gt;  * In the 1.1 JVM case we use a factory implementation that does not use ThreadLocal storage.
&gt;  * In the 1.2+ JVM case we use a factory implementation that does use ThreadLocal storage.
&gt;  * 
&gt;  * Once we have the factory set, whenever someone builds a CFlowStack object, we ask the 
&gt;  * factory for a new stack proxy - this is an object that can return us the right stack
&gt;  * that we should use on a particular thread.  The reason we create the proxy in the ctor and
&gt;  * not lazily in the getThreadStack() method is because it means the getThreadStack() method in
&gt;  * this class does not have to be synchronized.
&gt;  * 
&gt;  * When any of the methods in CFlowStack need to operate on the stack (peek/pop/etc), they 
&gt;  * all delegate to getThreadStack() which asks the proxy for the right stack.  Depending on the
&gt;  * factory loaded to build the proxy, the call to proxy.getThreadStack() will return a threadlocal
&gt;  * based stack or it will call the original implementation of getThreadStack() which manages
&gt;  * a Hashtable of threads-&gt;stacks.  
&gt;  * 
&gt;  */
25,56c54,67
&lt;     private Hashtable stacks = new Hashtable();
&lt;     private Thread cached_thread;
&lt;     private Stack cached_stack;
&lt;     private int change_count = 0;
&lt;     private static final int COLLECT_AT = 20000;
&lt;     private static final int MIN_COLLECT_AT = 100;
&lt; 
&lt;     private synchronized Stack getThreadStack() {
&lt;         if (Thread.currentThread() != cached_thread) {
&lt;             cached_thread = Thread.currentThread();
&lt;             cached_stack = (Stack)stacks.get(cached_thread);
&lt;             if (cached_stack == null) {
&lt;                 cached_stack = new Stack();
&lt;                 stacks.put(cached_thread, cached_stack);
&lt;             }
&lt;             change_count++;
&lt;             // Collect more often if there are many threads, but not *too* often
&lt;             int size = Math.max(1, stacks.size()); // should be &gt;1 b/c always live threads, but...
&lt;             if (change_count &gt; Math.max(MIN_COLLECT_AT, COLLECT_AT/size)) {
&lt;                 Stack dead_stacks = new Stack();
&lt;                 for (Enumeration e = stacks.keys(); e.hasMoreElements(); ) {
&lt;                     Thread t = (Thread)e.nextElement();
&lt;                     if (!t.isAlive()) dead_stacks.push(t);
&lt;                 }
&lt;                 for (Enumeration e = dead_stacks.elements(); e.hasMoreElements(); ) {
&lt;                     Thread t = (Thread)e.nextElement();
&lt;                     stacks.remove(t);
&lt;                 }
&lt;                 change_count = 0;
&lt;             }
&lt;         }
&lt;         return cached_stack;
---
&gt; 
&gt; 	private static ThreadStackFactory tsFactory;
&gt; 	private ThreadStack stackProxy;
&gt; 
&gt; 	static {
&gt; 		selectFactoryForVMVersion();
&gt; 	}
&gt; 	
&gt; 	public CFlowStack() {
&gt; 		stackProxy = tsFactory.getNewThreadStack();
&gt; 	}
&gt; 	
&gt;     private Stack getThreadStack() {
&gt;     	return stackProxy.getThreadStack();
107a119,145
&gt;         
&gt; 	private static ThreadStackFactory getThreadLocalStackFactory()      { return new ThreadStackFactoryImpl(); }
&gt; 	private static ThreadStackFactory getThreadLocalStackFactoryFor11() { return new ThreadStackFactoryImpl11(); }
&gt;     
&gt; 	private static void selectFactoryForVMVersion() {
&gt; 		String override = System.getProperty("aspectj.runtime.cflowstack.usethreadlocal","unspecified");
&gt; 		boolean useThreadLocalImplementation = false;
&gt; 		if (override.equals("unspecified")) {
&gt; 			String v = System.getProperty("java.class.version","0.0");
&gt; 			// Java 1.2 is version 46.0 and above
&gt; 			useThreadLocalImplementation = (v.compareTo("46.0") &gt;= 0);
&gt; 		} else {
&gt; 			useThreadLocalImplementation = override.equals("yes") || override.equals("true");
&gt; 		}
&gt; 		// System.err.println("Trying to use thread local implementation? "+useThreadLocalImplementation);
&gt; 		if (useThreadLocalImplementation) {
&gt; 			tsFactory = getThreadLocalStackFactory();
&gt; 		} else {
&gt; 			tsFactory = getThreadLocalStackFactoryFor11();
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	//  For debug ...
&gt; 	public static String getThreadStackFactoryClassName() {
&gt; 		return tsFactory.getClass().getName();
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStack.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/

package org.aspectj.runtime.internal.cflowstack;

import java.util.Stack;

public interface ThreadStack {

	public Stack getThreadStack();

}
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactory.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
package org.aspectj.runtime.internal.cflowstack;

public interface ThreadStackFactory {
	
  public ThreadStack getNewThreadStack();  
  
}
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackImpl11.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * 					   Copied from bits of original CFlowStack
 * ******************************************************************/
package org.aspectj.runtime.internal.cflowstack;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;

public class ThreadStackImpl11 implements ThreadStack {
	private Hashtable stacks = new Hashtable();
	private Thread cached_thread;
	private Stack cached_stack;
	private int change_count = 0;
	private static final int COLLECT_AT = 20000;
	private static final int MIN_COLLECT_AT = 100; 

	public synchronized Stack getThreadStack() {
		if (Thread.currentThread() != cached_thread) {
			cached_thread = Thread.currentThread();
			cached_stack = (Stack)stacks.get(cached_thread);
			if (cached_stack == null) {
				cached_stack = new Stack();
				stacks.put(cached_thread, cached_stack);
			}
			change_count++;
			// Collect more often if there are many threads, but not *too* often
			int size = Math.max(1, stacks.size()); // should be &gt;1 b/c always live threads, but...
			if (change_count &gt; Math.max(MIN_COLLECT_AT, COLLECT_AT/size)) {
				Stack dead_stacks = new Stack();
				for (Enumeration e = stacks.keys(); e.hasMoreElements(); ) {
					Thread t = (Thread)e.nextElement();
					if (!t.isAlive()) dead_stacks.push(t);
				}
				for (Enumeration e = dead_stacks.elements(); e.hasMoreElements(); ) {
					Thread t = (Thread)e.nextElement();
					stacks.remove(t);
				}
				change_count = 0;
			}
		}
		return cached_stack;
	}

}
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl11.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
package org.aspectj.runtime.internal.cflowstack;


public class ThreadStackFactoryImpl11 implements ThreadStackFactory {

	public ThreadStack getNewThreadStack() {
		return new ThreadStackImpl11();
	}

}
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
package org.aspectj.runtime.internal.cflowstack;

import java.util.Stack;

public class ThreadStackFactoryImpl implements ThreadStackFactory {

	private static class ThreadStackImpl extends ThreadLocal implements ThreadStack {
		public Object initialValue() {
		  return new Stack();
		}
		public Stack getThreadStack() {
			return (Stack)get();
		}
	}

	public ThreadStack getNewThreadStack() {
		return new ThreadStackImpl();
	}

}
</file>
</fixedFiles>
</bug>
<bug id="60015" transactionid="68835">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="5"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-return M O-&amp;&amp; T V Y Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>(This is an incomplete bug report -- sorry no time not to further isolate.)

Running AJDT 1.1.6, I get dozens of these warnings:

----------
Warning does not match because declaring type is java.lang.Object, if match
desired use target(st.ata.mc.exim.DatastoreReader)
[Xlint:unmatchedSuperTypeInCall] Blah.aj project/src/package/dir line 22
----------

for something like this code:

----------
import pack.Interface;
...
pointcut dsrCall() : call(* Interface.*(..)); // WARNING HERE
...
----------

Each warning points to the pointcut (not the join point shadow).

NPE running from the command-line with the latest tree (will attach).</bugreport>
<testsforfix ID="60015" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="NPE, Incorrect XLint:unmatchedSuperTypeInCall warning"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="81" file="output/60015/pre-fix/testresults.xml" passing="698" size="779"/>
<post-fix-testcases failing="116" file="output/60015/post-fix/testresults.xml" passing="1214" size="1330"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java" revision="1.11" state="changed">116a117,121
&gt; 		
&gt; 		// PR60015 - Don't report the warning if the declaring type is object and 'this' is an interface
&gt; 		if (exactDeclaringType.isInterface(world) &amp;&amp; shadowDeclaringType.equals(world.resolve("java.lang.Object"))) {
&gt; 			return;
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.168" state="changed">7842a7843,7848
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="60015"
&gt;       title="NPE, Incorrect XLint:unmatchedSuperTypeInCall warning"&gt;
&gt;       &lt;compile files="IncorrectXlintOnInterface.java"&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/IncorrectXlintOnInterface.java" revision="1.1" state="new">interface ILib { void run(); }

class UnmatchedCallSupertype implements ILib {
	public static void main(String[] args) {
		new UnmatchedCallSupertype().run();
	}
	public void run() {
		  System.err.println(this.toString());
		  System.err.println(this.toString());
		  System.err.println(this.toString());
		  System.err.println(this.toString());
		}
}

aspect X {

	pointcut runCall() : call(* ILib.*(..));
	pointcut monitor() : call(String clone(String)) || runCall();

	before() : monitor() {
		System.err.println(thisJoinPointStaticPart.getSignature().getDeclaringType().getName());
	}
}

class Client {
	public static void main(String[] args) { new Lib().run(); }
	static class Lib implements ILib { public void run() {} }
}

</file>
</fixedFiles>
</bug>
<bug id="61411" transactionid="69832">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="18"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="trivial"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M Y</fullfingerprint>
<bugreport>Using AspectJ 1.2rc1 on Windows XP

This report highlights a problem that I've seen using ajdoc.bat on Windows but
the issue applies equally to the ajc.bat and ajbrowser.bat files as well.

The %ASPECTJ_HOME%\bin\ajdoc.bat file that users run to launch the ajdoc tool
imposes a limit of only 9 command line arguments that may be passed to the
class org.aspectj.tools.ajdoc.Main. In scenarios where there the -sourcepath,
-classpath, -d etc options are used it is easy for these to "eat up" the list
of arguments that are passed into the JVM. A long list of packages entered
at the end of the ajdoc.bat command can be truncated or possibly even ignored
(in which case an error message will be output telling the user that no
classes or packages have been specified).

In order to prevent a limit being put on the number of arguments passed to
the launched JVM, the invocation line needs to end with %* rather than the
%1 %2 %3 %4 %5 %6 %7 %8 %9 list it currently uses.

The proposed fix also *seems* (could somebody else confirm this ?) to sort
out another problem regarding the ajdoc.bat file which is this : long semi-
colon delimited paths supplied as the arguments for the -sourcepath and 
-classpath options seem to get split apart and passed into the JVM as separate 
arguments unless the entire path list is supplied inside quotes. This should
not be necessary. It seems that the batch file processor interprets the
semi-colons in a path list as delimiters between arguments. Consequently
each element in the path list is treated as a separate argument instead
of being part of one big string representing the sourcepath or classpath.</bugreport>
<pre-fix-testcases failing="108" file="output/61411/pre-fix/testresults.xml" passing="1189" size="1297"/>
<post-fix-testcases failing="109" file="output/61411/post-fix/testresults.xml" passing="1188" size="1297"/>
<fixedFiles>
<file name="org.aspectj/modules/build/src/$installer$/org/aspectj/Main.java" revision="1.9" state="changed">698c698,700
&lt;         return getOS().equals("Windows NT") || getOS().equals("Windows 2000");
---
&gt; 		return getOS().equals("Windows NT")
&gt; 			|| getOS().equals("Windows 2000")
&gt; 			|| getOS().equals("Windows XP");
</file>
<file name="org.aspectj/modules/lib/build/build.jar" revision="1.17" state="changed"/>
</fixedFiles>
</bug>
<bug id="61536" transactionid="68726">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="14"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="15"/>
<property name="priority" value="P4"/>
<property name="severity" value="minor"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-new K-null K-throw K-true M O-== O-! O-!= O-() O-&amp;&amp; T V Y Z-if Z-throw</fullfingerprint>
<bugreport>See following code:

public class Test2 {
  public static void main(String args[])
    { System.out.println("Hi");
    }
}

aspect Aspect2 {
  // shouldn't one have to say,  java..* instead of java.. in the following??
  // Note that the first advice (incorrect one) passes the front-end, but does
  // not match,  whereas the second one does match.   I believe the front-end
  // should reject the first one.
  before () : call( * java..(..)) &amp;&amp; within(Test2)
    { System.out.println(
        "Incorrect One: Before a call of method in a java package ");
    }

  before () : call( * java..*(..)) &amp;&amp; within(Test2)
    { System.out.println(
        "Correct One: Before a call of method in a java package ");
    }
}</bugreport>
<testsforfix ID="61536" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Front-end bug, shouldn't allow patterns of the form foo.., should be foo..*"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="105" file="output/61536/pre-fix/testresults.xml" passing="1208" size="1313"/>
<post-fix-testcases failing="105" file="output/61536/post-fix/testresults.xml" passing="1209" size="1314"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PatternParser.java" revision="1.9" state="changed">450a451,453
&gt; 		boolean justProcessedEllipsis = false; // Remember if we just dealt with an ellipsis (PR61536)
&gt; 		boolean justProcessedDot = false; 
&gt; 		boolean onADot = false;
452c455
&lt; 			IToken tok;
---
&gt; 			IToken tok = null;
455a459
&gt; 				if (previous !=null &amp;&amp; previous.getString().equals(".")) justProcessedDot = true;
456a461
&gt; 				onADot = (tok.getString().equals("."));
483a489,495
&gt; 			if (buf.length() == 0 &amp;&amp; justProcessedEllipsis) {
&gt; 				throw new ParserException("name pattern cannot finish with ..", tok);
&gt; 			}
&gt; 			if (buf.length() == 0 &amp;&amp; justProcessedDot &amp;&amp; !onADot) {
&gt; 					throw new ParserException("name pattern cannot finish with .", tok);
&gt; 			}
&gt; 			
485a498
&gt; 				justProcessedEllipsis = true;
490a504
&gt; 				justProcessedEllipsis = false;
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.166" state="changed">7821a7822,7834
&gt;     &lt;ajc-test dir="bugs"
&gt; 		pr="61536" title="Front-end bug, shouldn't allow patterns of the form foo.., should be foo..*"&gt;
&gt;         &lt;compile files="EllipsesStar.java"&gt;
&gt;           &lt;message kind="error" line="3" text="Syntax error on token"/&gt;
&gt;           &lt;message kind="error" line="4" text="Syntax error on token"/&gt;
&gt;           &lt;message kind="error" line="5" text="Syntax error on token"/&gt;
&gt;           &lt;message kind="error" line="6" text="Syntax error on token"/&gt;
&gt;           &lt;message kind="error" line="8" text="Syntax error on token"/&gt;
&gt;           &lt;message kind="error" line="10" text="Syntax error on token"/&gt;
&gt;           &lt;message kind="error" line="12" text="Syntax error on token"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs/EllipsesStar.java" revision="1.1" state="new">// Name patterns can't end with '..'
aspect A {
	pointcut endsDot(): call(* java.(..));
	pointcut p1(): call(* java.lang..(..));
	pointcut p2(): call((Integer || java.lang..) m(..));
	pointcut p3(): call(* m() throws java.lang..);
	
	pointcut p4(): call(* a..b..c..d..(..));
	
	pointcut p5(): call(* a....(..));
	
	pointcut p6(): call(java. m());
}</file>
</fixedFiles>
</bug>
<bug id="62227" transactionid="69931">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="11"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="13"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="19"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-import K-return M O-== O-+ T V Y Z-if</fullfingerprint>
<bugreport>The message handler in the weaving adapter for load time weaving says:

public boolean handleMessage(IMessage message) throws AbortException {
  if (!isIgnoring(message.getKind())) {
    if (verbose) System.err.println(message.getMessage());
    throw new AbortException(message);
  }
  return true;
}

This means for warnings it goes bang.  So, even a declare warning that is 
meant to tell the user something informational during a LTW will cause the 
code to blow up.  The fix is straightforward and simply to log warning 
messages and only fail for error messages.  I am waiting for a testcase from 
Matthew before checking in the fix.</bugreport>
<testsforfix ID="62227" type="new">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java">
      <test NAME="testWeaveDeclareWarningAdvice"/>
      <test NAME="testWeaveDeclareErrorAdvice"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="109" file="output/62227/pre-fix/testresults.xml" passing="1186" size="1295"/>
<post-fix-testcases failing="109" file="output/62227/post-fix/testresults.xml" passing="1188" size="1297"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java" revision="1.2" state="changed">20,23d19
&lt; import java.net.URLClassLoader;
&lt; import java.net.URLConnection;
&lt; import java.net.URLStreamHandler;
&lt; import java.net.URLStreamHandlerFactory;
31,32c27,28
&lt; import org.aspectj.util.UtilClassLoader;
&lt; import org.aspectj.weaver.tools.*;
---
&gt; import org.aspectj.weaver.tools.WeavingAdaptor;
&gt; import org.aspectj.weaver.tools.WeavingClassLoader;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.2" state="changed">21,22d20
&lt; import java.util.Arrays;
&lt; import java.util.Enumeration;
24d21
&lt; import java.util.HashSet;
29d25
&lt; import java.util.Set;
31,32d26
&lt; import java.util.jar.JarEntry;
&lt; import java.util.jar.JarFile;
37d30
&lt; import org.aspectj.bridge.MessageHandler;
43d35
&lt; import org.aspectj.weaver.bcel.BcelObjectType;
46d37
&lt; import org.aspectj.weaver.bcel.LazyClassGen;
274,275c265,266
&lt; 				if (verbose) System.err.println(message.getMessage());
&lt; 				throw new AbortException(message);
---
&gt; 				System.err.println(message.getSourceLocation()+": "+message.getKind()+" "+message.getMessage());
&gt; 				if (message.getKind() == IMessage.ERROR) throw new AbortException(message);
281c272,273
&lt; 			return ((kind == IMessage.INFO) || (kind == IMessage.DEBUG));
---
&gt; 			if (verbose) return false;
&gt; 			else         return ((kind == IMessage.INFO) || (kind == IMessage.DEBUG));
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java" revision="1.11" state="changed">234a235,258
&gt; 		 * Declare warning advice
&gt; 		 */
&gt; 		args = new ArrayList();
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../weaver/testdata/ltw-dwaspects.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWDeclareWarning.aj");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 
&gt; 		/*
&gt; 		 * Declare error advice
&gt; 		 */
&gt; 		args = new ArrayList();
&gt; 		args.add("-classpath"); 
&gt; 		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
&gt; 		   File.pathSeparator + System.getProperty("aspectjrt.path"));
&gt; 		args.add("-outjar");
&gt; 		args.add("../weaver/testdata/ltw-deaspects.jar");
&gt; 		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWDeclareError.aj");
&gt; 		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
&gt; 
&gt; 		/*
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java" revision="1.3" state="changed">37a38,39
&gt; 	private final static String DW_ADVICE_ASPECTS = BcweaverTests.TESTDATA_PATH + "/ltw-dwaspects.jar";
&gt; 	private final static String DE_ADVICE_ASPECTS = BcweaverTests.TESTDATA_PATH + "/ltw-deaspects.jar";
119a122,150
&gt; 	public void testWeaveDeclareWarningAdvice () {
&gt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DW_ADVICE_ASPECTS);
&gt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DW_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
&gt; 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
&gt; 
&gt; 		try {
&gt; 			Class clazz = loader.loadClass("LTWHelloWorld");
&gt; 			invokeMain(clazz,new String[] {} ); 
&gt; 		}
&gt; 		catch (Exception ex) {
&gt; 			fail(ex.toString());
&gt; 		}
&gt; 	}
&gt; 
&gt; 	public void testWeaveDeclareErrorAdvice () {
&gt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DE_ADVICE_ASPECTS);
&gt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DE_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
&gt; 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
&gt; 
&gt; 		try {
&gt; 			Class clazz = loader.loadClass("LTWHelloWorld");
&gt; 			invokeMain(clazz,new String[] {} ); 
&gt; 			fail("Expecting org.aspectj.bridge.AbortException");
&gt; 		}
&gt; 		catch (Exception ex) {
&gt; 			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex,(ex instanceof AbortException));
&gt; 		}
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LTWDeclareError.aj" revision="1.1" state="new">public aspect LTWDeclareError {&#13;
	&#13;
	pointcut method () :&#13;
		execution(* LTWHelloWorld.println(..));&#13;
	&#13;
	declare error : method () :&#13;
		"LTWDeclareError.println()";&#13;
&#13;
}&#13;
</file>
<file name="org.aspectj/modules/weaver/testdata/ltw-deaspects.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/src1/LTWDeclareWarning.aj" revision="1.1" state="new">public aspect LTWDeclareWarning {&#13;
	&#13;
	pointcut method () :&#13;
		execution(* LTWHelloWorld.println(..));&#13;
	&#13;
	declare warning : method () :&#13;
		"LTWDeclareWarning.println()";&#13;
&#13;
}&#13;
</file>
<file name="org.aspectj/modules/weaver/testdata/ltw-dwaspects.jar" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="62642" transactionid="69017">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="18"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="18"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new K-this M O-cast T V Y Z-cast Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>When a &lt;clinit&gt; of a class contains after throwing advice that may catch
ExceptionInInitializer errors due to an embedded advice aspectOf() that
fails,  the ExceptionInIntializer error does not get properly reported.

For the example below:

public class Main {
  static int x = 13;
  int y;

  public Main() {
     y= 14;
  }

  public static void main(String args[])
    { Main m = new Main();
      m.y = 3;
      System.out.println("hi");
    }
}


aspect Aspect {

  before () :  within(*)
    { System.out.println("BEFORE " + thisJoinPointStaticPart.getKind() +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
    }

  after ()  : within(*)
    { System.out.println("AFTER " + thisJoinPointStaticPart.getKind() +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
    }
}


....  

when compiled with ajc, and then run,  the following exception is given,

Exception in thread "main" java.lang.NoClassDefFoundError
        at Main.&lt;clinit&gt;(Main.java:1)

when really one wants the following:

Exception in thread "main" java.lang.ExceptionInInitializerError
        at Main. ...
Caused by: org.aspectj.lang.NoAspectBoundException: Aspect
        at Aspect.aspectOf ..
        

-------------

Here is a fix ... I give the decompiled &lt;clinit&gt; for Main.java and indicate with
comments,
  look for ***LJH ****,  what can be woven to fix it.   Basically, the catch
block for after throwing,  when in &lt;clinit&gt;,  should first check if the
caught exception if a ExceptionInInitializerError, and if so just throw it.

----------- static
    {
        org.aspectj.runtime.reflect.Factory r1;
        java.lang.Throwable r2, r31;
        int $i0;

        r1 = new Factory("Main.java", Class.forName("Main"));
        ajc$tjp_0 = r1.makeSJP("field-set", r1.makeFieldSig("8-x-Main-int-"), 2);
        ajc$tjp_1 = r1.makeSJP("staticinitialization",
r1.makeInitializerSig("8--Main-"), 2);
        ajc$tjp_10 = r1.makeSJP("preinitialization",
r1.makeConstructorSig("1--Main----"), 5);
        ajc$tjp_2 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 6);
        ajc$tjp_3 = r1.makeSJP("constructor-execution",
r1.makeConstructorSig("1--Main----"), 6);
        ajc$tjp_4 = r1.makeSJP("constructor-call",
r1.makeConstructorSig("1--Main----"), 10);
        ajc$tjp_5 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 11);
        ajc$tjp_6 = r1.makeSJP("field-get",
r1.makeFieldSig("19-out-java.lang.System-java.io.PrintStream-"), 12);
        ajc$tjp_7 = r1.makeSJP("method-call",
r1.makeMethodSig("1-println-java.io.PrintStream-java.lang.String:-arg0:--void-"),
12);
        ajc$tjp_8 = r1.makeSJP("method-execution",
r1.makeMethodSig("9-main-Main-[Ljava.lang.String;:-args:--void-"), 10);
        ajc$tjp_9 = r1.makeSJP("initialization",
r1.makeConstructorSig("1--Main----"), 6);

 try
        {
            Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_1);
            $i0 = 13;

            try
            {
                Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_0);
                x = $i0;
            }
            catch (Throwable $r30)
            {
                /*** LJH insert here *****/
                if ($r30 instanceof ExceptionInIntializerError) //***
                  throw($r30); //***
                /***********/
                r31 = $r30;
                Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0);
                throw r31;
            }

            Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0);
        }
        catch (Throwable $r36)
        {
           /*** LJH insert here *****/
           if ($r36 instanceof ExceptionInIntializerError) //***
           throw($r36); //***
           /***********/
            r2 = $r36;
            Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1);
            throw r2;
        }

        Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1);
    }</bugreport>
<testsforfix ID="62642" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test043_pr62642_ExceptionInInitializerError"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="proper handling of ExceptionInIntializer inside clinit in presence of after throwing advice"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/62642/pre-fix/testresults.xml" passing="1260" size="1372"/>
<post-fix-testcases failing="113" file="output/62642/post-fix/testresults.xml" passing="1260" size="1373"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.38" state="changed">1203a1204,1221
&gt;         // pr62642
&gt;         // I will now jump through some firey BCEL hoops to generate a trivial bit of code:
&gt;         // if (exc instanceof ExceptionInInitializerError) 
&gt;         //    throw (ExceptionInInitializerError)exc;
&gt;         if (this.getEnclosingMethod().getName().equals("&lt;clinit&gt;")) {
&gt;             ResolvedTypeX eiieType = world.resolve("java.lang.ExceptionInInitializerError");
&gt;             ObjectType eiieBcelType = (ObjectType)BcelWorld.makeBcelType(eiieType);
&gt;         	InstructionList ih = new InstructionList(InstructionConstants.NOP);
&gt;         	handler.append(exceptionVar.createLoad(fact));
&gt;         	handler.append(fact.createInstanceOf(eiieBcelType));
&gt;         	BranchInstruction bi = 
&gt;                 InstructionFactory.createBranchInstruction(Constants.IFEQ,ih.getStart());
&gt;         	handler.append(bi);
&gt;         	handler.append(exceptionVar.createLoad(fact));
&gt;         	handler.append(fact.createCheckCast(eiieBcelType));
&gt;         	handler.append(InstructionConstants.ATHROW);
&gt;         	handler.append(ih);
&gt;         }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.17" state="changed">331a332,339
&gt; 	
&gt; 	&lt;ajc-test dir="bugs" pr="62642"
&gt; 	  	title="proper handling of ExceptionInIntializer inside clinit in presence of after throwing advice"&gt;
&gt; 		&lt;compile files="pr62642.java"/&gt;
&gt; 		&lt;run class="pr62642"&gt;
&gt; 			&lt;message kind="error"/&gt;
&gt; 		&lt;/run&gt;
&gt; 	&lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.16" state="changed">228c228,236
&lt; 
---
&gt;   
&gt;   public void test043_pr62642_ExceptionInInitializerError() {
&gt;     runTest("proper handling of ExceptionInIntializer inside clinit in presence of after throwing advice");
&gt;     String s = getLastRunResult().getStdErr();
&gt;     assertTrue("Output should contain java.lang.ExceptionInInitializerError but is '"+s+"'",
&gt;             s.indexOf("java.lang.ExceptionInInitializerError")!=-1);
&gt;     assertTrue("Output should contain 'CAUSE=org.aspectj.lang.NoAspectBoundException' but is '"+s+"'",
&gt;             s.indexOf("CAUSE=org.aspectj.lang.NoAspectBoundException")!=-1);
&gt;   }
</file>
<file name="org.aspectj/modules/tests/bugs/pr62642.java" revision="1.1" state="new">class C {
	  static int x = 13;
	  int y;

	  public C() {
	    y= 14;
	  }

	  public static void main(String args[]) { 
        
        	C m = new C();
        	m.y = 3;
        	System.out.println("hi");
	  }
}

public class pr62642 {
    public static void main(String[] args) {
        try {
         C.main(null);   
        } catch (ExceptionInInitializerError eiie) {
        	System.err.println("EIIE="+eiie.toString());
            System.err.println("CAUSE="+eiie.getCause().toString());
        }
	}
}


aspect Aspect {

    before () :  within(*) &amp;&amp; !within(pr62642) { 
        System.out.println("BEFORE "+ thisJoinPointStaticPart.getKind() +
	                         " at " + thisJoinPointStaticPart.getSourceLocation());
	}

	after ()  : within(*) &amp;&amp; !within(pr62642)  { 
        System.out.println("AFTER " + thisJoinPointStaticPart.getKind() +
	                         " at " + thisJoinPointStaticPart.getSourceLocation());
	}
}</file>
</fixedFiles>
</bug>
<bug id="64069" transactionid="70608">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="17"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-noop K-return K-this K-true M O-|| O-! O-() T V Z-if</fullfingerprint>
<bugreport>When weaving into source, ITDs for constructors and methods
override private members of the same signature: it is as if
the private member never existed. This is illustrated
by the example in Dups.java. The same example, when the classes
are compiled separately and using bytecode weaving, gives a
ClassFormatError upon execution. 

The situation for fields is different: the compiler flags an error 
when an ITD tries to introduce a public x where a private x already 
existed. The error is however flagged only when x is used in the
class. Without any uses, such a clashing field is passed by the compiler,
but when the program is run, java throws a ClassFormatError.
This behaviour is illustrated in DupField.java

The above seems to be a bug: the behaviour should
be consistent in all situations.

Request: make it always legal to introduce a new member by ITD that
has the same name/signature as a private member. Mangle the private 
member and all its uses. 

/* ---------------------------------------------------------------
   Dups.java

   When weaving into source, ITDs for constructors and methods
   override private members of the same name. Using bytecode weaving
   (and separate class files for each of the classes) this example
   gives a ClassFormatError upon execution.

*/

aspect Aspect {

    public A.new() { 
       super();
       System.out.println("ITD A()");
    }

    public void A.bar() {
       System.out.println("ITD bar");
   }

}

class A {

    void foo() {
        A a = new A(); 
	bar(); 
    }

    private A() {
	super();
	System.out.println("private A()");
    }

    private void bar() {
	System.out.println("private bar");
    }

}

public class Dups { 

    static public void main(String[] args) {
	new A().foo();
    }
}

/* ------------------------------------------------------------------
   DupField.java
The compiler flags an error when an ITD tries to introduce a public x 
where a private x already existed. The error is however flagged only 
when x is used in the class. Without any uses, such a clashing field 
is passed by the compiler, but when the program is run, java throws 
a ClassFormatError. This behaviour is illustrated in DupField.java:
to see the ClassFormatError, comment out the assignment "x=0" in foo().
*/


aspect Aspect {

    public int A.x;
}

class A {
    private int x;

    void foo() {
        // when the line below is commented, we get a runtime error
	x=0;  // error: The field x is ambiguous
    }
}

public class DupField { 

    static public void main(String[] args) {
	new A();
    }

}</bugreport>
<testsforfix ID="64069" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test044_ITDnameClashes"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="ITD name clashes with private members"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/64069/pre-fix/testresults.xml" passing="1261" size="1373"/>
<post-fix-testcases failing="112" file="output/64069/post-fix/testresults.xml" passing="1262" size="1374"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.31" state="changed">1143,1144c1143,1148
&lt; 				} else {
&lt; 					//interTypeMungers.add(munger);
---
&gt; 				} else if (isDuplicateMemberWithinTargetType(existingMember,this,sig)) {
&gt; 				    	getWorld().getMessageHandler().handleMessage(
&gt; 							MessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_MEMBER_CONFLICT,munger.getAspectType().getName(),
&gt; 									existingMember),
&gt; 							munger.getSourceLocation())
&gt; 						);;
1151a1156,1172
&gt; 	// we know that the member signature matches, but that the member in the target type is not visible to the aspect.
&gt; 	// this may still be disallowed if it would result in two members within the same declaring type with the same
&gt; 	// signature AND more than one of them is concrete AND they are both visible within the target type.
&gt; 	private boolean isDuplicateMemberWithinTargetType(ResolvedMember existingMember, ResolvedTypeX targetType,ResolvedMember itdMember) {
&gt; 	    if ( (existingMember.isAbstract() || itdMember.isAbstract())) return false;
&gt; 	    TypeX declaringType = existingMember.getDeclaringType();
&gt; 	    if (!targetType.equals(declaringType)) return false;
&gt; 	    // now have to test that itdMember is visible from targetType
&gt; 	    if (itdMember.isPrivate()) return false;
&gt; 	    if (itdMember.isPublic()) return true;
&gt; 	    // must be in same package to be visible then...
&gt; 	    if (!targetType.getPackageName().equals(itdMember.getDeclaringType().getPackageName())) return false;
&gt; 	    
&gt; 	    // trying to put two members with the same signature into the exact same type..., and both visible in that type.
&gt; 	    return true;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.17" state="changed">236a237,241
&gt;   
&gt;   public void test044_ITDnameClashes() {
&gt;     	runTest("ITD name clashes with private members");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.19" state="changed">337a338,347
&gt; 
&gt; 	&lt;ajc-test dir="bugs" pr="64069"
&gt; 	  	title="ITD name clashes with private members"&gt;
&gt; 		&lt;compile files="PR64069.aj"&gt;
&gt; 			&lt;message kind="error" line="5" text="conflicts with existing member"/&gt;
&gt; 			&lt;message kind="error" line="10" text="conflicts with existing member"/&gt;
&gt; 			&lt;message kind="error" line="14" text="conflicts with existing member"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs/PR64069.aj" revision="1.1" state="new">

aspect Aspect {

    public A.new() {    // CE L5 
       super();
       System.out.println("ITD A()");
    }

    public void A.bar() {  // CE L10
       System.out.println("ITD bar");
   }
    
    public int A.x;  // CE L14

}

class A {

    void foo() {
        A a = new A(); 
        bar(); 
    }

    private int x;
    
    private A() {
        super();
        System.out.println("private A()");
    }

    private void bar() {
        System.out.println("private bar");
    }

}

public class PR64069 { 

    static public void main(String[] args) {
        new A().foo();
    }
}</file>
</fixedFiles>
</bug>
<bug id="64331" transactionid="69212">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="9"/>
<property name="lines-added" value="13"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="10"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-new K-null K-throw M O-== O-- O-!= O-++ O-cast T V Y Z-cast Z-if Z-throw</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I've got an java.lang.NullPointerException while running the aspectJ 1.2
compiler. That's the stack trace:
     [iajc] If you don't find the exception below in a bug, please add a new bug
     [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
     [iajc] To make the bug a priority, please include a test program
     [iajc] that can reproduce this exception.
     [iajc] null
     [iajc] java.lang.NullPointerException
     [iajc]     at
org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.buildSeeAlsoProblems(WeaverMessageHandler.java:172)
     [iajc]     at
org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.handleMessage(WeaverMessageHandler.java:100)
     [iajc]     at
org.aspectj.weaver.ResolvedTypeX.checkInterTypeMungers(ResolvedTypeX.java:989)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:716)
     [iajc]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:689)
     [iajc]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:615)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
     [iajc]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)
     [iajc]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)
     [iajc]     at
org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
     [iajc]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:601)
     [iajc]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)
     [iajc]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:280)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:217)
     [iajc]     at
org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1157)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:954)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at
org.apache.tools.ant.taskdefs.Sequential.execute(Sequential.java:117)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at net.sf.antcontrib.logic.IfTask.execute(Unknown Source)
     [iajc]     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     [iajc]     at
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
     [iajc]     at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
     [iajc]     at java.lang.reflect.Method.invoke(Method.java:324)
     [iajc]     at org.apache.tools.ant.TaskAdapter.execute(TaskAdapter.java:147)
     [iajc]     at
org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:193)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:309)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:336)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1339)
     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1255)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:609)
     [iajc]     at org.apache.tools.ant.Main.start(Main.java:196)
     [iajc]     at org.apache.tools.ant.Main.main(Main.java:235)

       [if] Error in class net.sf.antcontrib.logic.IfTask


Sorry, i have no simple test case for that problem...</bugreport>
<testsforfix ID="64331" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="java.lang.NullPointerException in WeaverMessageHandler class"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="105" file="output/64331/pre-fix/testresults.xml" passing="1204" size="1309"/>
<post-fix-testcases failing="105" file="output/64331/post-fix/testresults.xml" passing="1205" size="1310"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java" revision="1.4" state="changed">12a13
&gt; import java.util.ArrayList;
167,169c168,169
&lt; 		int probLength = sourceLocations.size();
&lt; 		if (usedBinarySourceFileName) probLength++;
&lt; 		IProblem[] ret = new IProblem[probLength];
---
&gt; 		List ret = new ArrayList();
&gt; 
172c172,174
&lt; 			ret[i] = new DefaultProblem(loc.getSourceFile().getPath().toCharArray(),
---
&gt; 			if (loc != null ) {
&gt; 			  	DefaultProblem dp = 
&gt; 			  		new DefaultProblem( loc.getSourceFile().getPath().toCharArray(),
179a182,185
&gt; 			  ret.add(dp);
&gt; 			} else {
&gt; 				throw new RuntimeException("Internal Compiler Error: Unexpected null source location passed as 'see also' location.");
&gt; 			}
182c188
&lt; 			ret[ret.length -1] = new DefaultProblem(problemSource.fileName,"see also",0,new String[] {},
---
&gt; 			DefaultProblem dp = new DefaultProblem(problemSource.fileName,"see also",0,new String[] {},
184a191
&gt; 			ret.add(dp);
186c193,194
&lt; 		return ret;
---
&gt; 		IProblem[] retValue = (IProblem[])ret.toArray(new IProblem[]{});
&gt; 		return retValue;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.28" state="changed">988a989,995
&gt;             	ISourceLocation xtraLocation = element.getSourceLocation();
&gt;             	if (xtraLocation == null) {
&gt;             		// Until intertype mungers remember where they came from, the source location
&gt;             		// for the element is null when binary weaving.  In these cases uses the
&gt;             		// source location for the aspect containing the ITD
&gt;      				xtraLocation = element.getAspectType().getSourceLocation();
&gt;             	}
992c999
&lt;                         new ISourceLocation[] { element.getSourceLocation() }));
---
&gt;                         new ISourceLocation[] { xtraLocation }));
</file>
<file name="org.aspectj/modules/tests/bugs/abstractITDs/C.java" revision="1.1" state="new">public class C extends A {
}</file>
<file name="org.aspectj/modules/tests/bugs/abstractITDs/A.java" revision="1.1" state="new">public abstract class A {
}
</file>
<file name="org.aspectj/modules/tests/bugs/abstractITDs/B.aj" revision="1.1" state="new">public aspect B {&#13;
	abstract public void A.foo();&#13;
}</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.163" state="changed">7797a7798,7804
&gt;     &lt;ajc-test dir="bugs/abstractITDs"
&gt; 		pr="64331" title="java.lang.NullPointerException in WeaverMessageHandler class"&gt;
&gt;         &lt;compile files="A.java,C.java" aspectpath="B.jar"&gt;
&gt;           &lt;message kind="error" line="1" text="must implement abstract inter-type declaration: void A.foo()"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs/abstractITDs/B.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/bugs/abstractITDs/buildBJar.bat" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="65319" transactionid="68725">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="9"/>
<property name="lines-added" value="33"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="7"/>
<property name="lines-churned" value="40"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-continue K-if K-import K-instanceof K-new K-null K-return K-true M O-!= O-?: O-() O-+ O-cast O-instanceof T V Y Z-cast Z-cond Z-if</fullfingerprint>
<bugreport>class Test
{  
	public static void main(String args[])
	{		
		new Test().method();
	}
	public void method()
	{
		new Test2().method2();
	}
}
class Test2 {
	public void method2() {}
}
aspect Plain {
	before(Test x):  call(void *.* (..)) &amp;&amp; (this(x) || target(x))
	{
	}
}</bugreport>
<testsforfix ID="65319" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test026_bindingThisAndTargetToTheSameFormal"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="ajc crashes when compiling the following program (binding this() and target())"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/65319/pre-fix/testresults.xml" passing="1241" size="1353"/>
<post-fix-testcases failing="112" file="output/65319/post-fix/testresults.xml" passing="1242" size="1354"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java" revision="1.12" state="changed">20a21,22
&gt; import org.aspectj.bridge.ISourceLocation;
&gt; import org.aspectj.bridge.Message;
126c128,145
&lt; 		Var var = isThis ? shadow.getThisVar() : shadow.getTargetVar();
---
&gt; 		Var var = isThis ? shadow.getThisVar() : shadow.getTargetVar();	
&gt; 
&gt; 		if (type instanceof BindingTypePattern) {
&gt; 		  BindingTypePattern btp = (BindingTypePattern)type;
&gt; 		  // Check if we have already bound something to this formal
&gt; 		  if (state.get(btp.getFormalIndex())!=null) {
&gt; 		  	ISourceLocation pcdSloc = getSourceLocation(); 
&gt; 		  	ISourceLocation shadowSloc = shadow.getSourceLocation();
&gt; 			Message errorMessage = new Message(
&gt; 				"Cannot use "+(isThis?"this()":"target()")+" to match at this location and bind a formal to type '"+var.getType()+
&gt; 				"' - the formal is already bound to type '"+state.get(btp.getFormalIndex()).getType()+"'"+
&gt; 				".  The secondary source location points to the problematic "+(isThis?"this()":"target()")+".",
&gt; 				shadowSloc,true,new ISourceLocation[]{pcdSloc}); 
&gt; 			shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
&gt; 			state.setErroneousVar(btp.getFormalIndex());
&gt; 			//return null;
&gt; 		  }
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java" revision="1.16" state="changed">293a294
&gt;         	if (exposedState.isErroneousVar(i)) continue; // Erroneous vars have already had error msgs reported!
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ExposedState.java" revision="1.5" state="changed">23a24
&gt; 	private boolean[] erroneousVars;
28a30
&gt; 		erroneousVars = new boolean[size];
38c40,44
&lt; 		// Check (1) added to call of set(), verifies we aren't binding twice to the same formal
---
&gt; 		// Some checks added in ArgsPointcut and ThisOrTargetPointcut
&gt; //		if (vars[i]!=null) {
&gt; //			if (!var.getType().equals(vars[i].getType())) 
&gt; //			  throw new RuntimeException("Shouldn't allow a slot to change type! Currently="+var.getType()+"   New="+vars[i].getType());
&gt; //		}
58a65,74
&gt; 
&gt; 	// Set to true if we have reported an error message against it,
&gt; 	// prevents us blowing up in later code gen.
&gt; 	public void setErroneousVar(int formalIndex) {
&gt; 		erroneousVars[formalIndex]=true;
&gt; 	}
&gt; 	
&gt; 	public boolean isErroneousVar(int formalIndex) {
&gt; 		return erroneousVars[formalIndex];
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java" revision="1.15" state="changed">176c176,177
&lt;                     " using args(..) at this line.  Use one args(..) per matched join point,"+"" +&#13;                    " see secondary source location for location of extraneous args(..)",
---
&gt;                     " using args(..) at this line - formal is already bound"+
&gt;                     ".  See secondary source location for location of args(..)",
178a180
&gt; 				state.setErroneousVar(btp.getFormalIndex());
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.7" state="changed">12a13
&gt; 
13a15
&gt; 
141a144,148
&gt;   
&gt;   public void test026_bindingThisAndTargetToTheSameFormal() {
&gt;   	runTest("ajc crashes when compiling the following program (binding this() and target())");
&gt;   }
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.7" state="changed">204c204,218
&lt;    	&lt;/ajc-test&gt;
\ Kein Zeilenumbruch am Dateiende.
---
&gt;    	&lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs/oxford" pr="65319"
&gt; 	  	title="ajc crashes when compiling the following program (binding this() and target())"&gt;
&gt; 		&lt;compile files="PR65319.java"&gt;
&gt; 			&lt;message kind="error" line="7" text="Cannot use target() to match at this"/&gt;
&gt; 			&lt;message kind="error" line="7" text="Cannot use this() to match at this"/&gt;
&gt; 			&lt;message kind="error" line="11" text="Cannot use target() to match at this"/&gt;
&gt; 			&lt;message kind="error" line="11" text="Cannot use this() to match at this"/&gt;
&gt; 			&lt;message kind="error" line="11" text="Ambiguous binding of type Test"/&gt;
&gt; 			&lt;message kind="error" line="15" text="Cannot use target() to match at this"/&gt;
&gt; 			&lt;message kind="error" line="15" text="Cannot use this() to match at this"/&gt;
&gt; 			&lt;message kind="error" line="15" text="Ambiguous binding of type Test"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/oxford/PR65319.java" revision="1.1" state="new">class Test
{  
	public static void main(String args[]) {		
		new Test().method();
	}
	public void method() {
		new Test2().method2();
	}
	
	public void method3() {
		new Test2().method3(new Test());
	}
	
	public void method4(Test t) {
		new Test().method4(new Test());
	}
}
class Test2 {
	public void method2() {}
	public void method3(Test t) {}
}
aspect Plain {
	before(Test x):  call(void *.* (..)) &amp;&amp; (target(x) || this(x)) {}

	before(Test x):  call(void *.* (..)) &amp;&amp; (this(x) || target(x)){}
	
	before(Test x):  call(void *.*(..)) &amp;&amp; (this(x) || args(x)) {}
	
	before(Test x):  call(void *.*(..)) &amp;&amp; (args(x) || target(x)) {}
}</file>
</fixedFiles>
</bug>
<bug id="67592" transactionid="71252">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new K-null M O-== T V Y Z-if</fullfingerprint>
<bugreport>In ajc a use of thisJoinPoint corresponds to an object of type JoinPoint, where
a JoinPoint object has four components, which can be retrieved using
accessor methods.

  this                   getThis()
  target                 getTarget()
  args                   getArgs()
  staticJoinPoint        getStaticPart()

In the case of args, the object returned is an Object array.  This means
that an advice decl can overwrite the args,  and then another advice which
shares the same JoinPoint will see the changed args.   Here is a
small example.  In this aspect the
before advice changes arg[0] to always be "Laurie" and then the after
advice will always say that "Laurie won a million pounds".

Is this the behaviour that is intended?   I would have thought that the
interface to args[] should be such that the values can only be read.  Otherwise
very strange interactions between advice decls could occur.

---------------------------------------------------------------------

public class Main {

  public static Main v = new Main();

  void lottery ( String arg )
    { System.out.println("The arg in lottery is " + arg);
    }

  public static void main (String args[])
    { v.lottery("Oege");
      v.lottery("Ganesh");
    }

}

---------------------------------------------------------------------

public aspect Aspect {

  // This pair of advice decls demonstrates that an advice can change to
  //   the args of a join point.

  before () : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect)
    { System.out.println("BEFORE " + thisJoinPoint +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
      Object args[] = thisJoinPoint.getArgs();
      System.out.println("arg[0] is " + args[0]);
      args[0] = "Laurie";
      System.out.println("... now it is " + thisJoinPoint.getArgs()[0]);
    }


  after ()  : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect)
    { System.out.println("AFTER " + thisJoinPoint +
                         " at " + thisJoinPointStaticPart.getSourceLocation());
      if (thisJoinPoint.getArgs()[0].equals("Laurie"))
        System.out.println("Laurie wins 1 million pounds!");
    }

}</bugreport>
<testsforfix ID="67592" type="new">
    <file LOCATION="org.aspectj/modules/runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.java">
      <test NAME="testGetArgs"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/67592/pre-fix/testresults.xml" passing="1237" size="1349"/>
<post-fix-testcases failing="113" file="output/67592/post-fix/testresults.xml" passing="1237" size="1350"/>
<fixedFiles>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/JoinPointImpl.java" revision="1.2" state="changed">65c65,70
&lt;     public Object[] getArgs() { return args; }
---
&gt;     public Object[] getArgs() {
&gt;     	if (args == null) { args = new Object[0]; }
&gt;     	Object[] argsCopy = new Object[args.length];
&gt;     	System.arraycopy(args,0,argsCopy,0,args.length);
&gt;     	return argsCopy; 
&gt;     }
</file>
<file name="org.aspectj/modules/runtime/testsrc/RuntimeModuleTests.java" revision="1.6" state="changed">18a19
&gt; import org.aspectj.runtime.reflect.JoinPointImplTest;
28a30
&gt;         suite.addTestSuite(JoinPointImplTest.class);
</file>
<file name="org.aspectj/modules/runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.java" revision="1.1" state="new">/*
 * Created on 09-Aug-2004
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
package org.aspectj.runtime.reflect;

import junit.framework.TestCase;

/**
 * @author colyer
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class JoinPointImplTest extends TestCase {

	public void testGetArgs() {
	    String arg1 = "abc";
	    StringBuffer arg2 = new StringBuffer("def");
	    Object arg3 = new Object();
		Object[] args = new Object[] { arg1, arg2, arg3 };
		JoinPointImpl jpi = new JoinPointImpl(null,null,null,args);
		
		Object[] retrievedArgs = jpi.getArgs();
		assertEquals("First arg unchanged",arg1,retrievedArgs[0]);
		assertEquals("Second arg unchanged",arg2,retrievedArgs[1]);
		assertEquals("Third arg unchanged",arg3,retrievedArgs[2]);
		retrievedArgs[0] = "xyz";
		((StringBuffer)retrievedArgs[1]).append("ghi");
		retrievedArgs[2] = "jkl";
		Object[] afterUpdateArgs = jpi.getArgs();
		assertEquals("Object reference not changed",arg1,afterUpdateArgs[0]);
		assertEquals("Object reference unchanged",arg2,afterUpdateArgs[1]);
		assertEquals("state of referenced object updated","defghi",afterUpdateArgs[1].toString());
		assertEquals("Object reference not changed",arg3,afterUpdateArgs[2]);
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="67774" transactionid="69188">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-return M O-== Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Hi,
I am getting null-pointer-exceptions whenever I try to specify a pointcut with 
a "withincode(Signature)" clause. E.g.:

public aspect DetectSystemOutErrorUsage 
{
pointcut allSystemOutAndSystemErrAccesses(): 
	(get(* System.out) || get(* System.err))
	;

declare warning: 
	allSystemOutAndSystemErrAccesses() 
	&amp;&amp; !adviceexecution()
	&amp;&amp; !within(com.tivoli.act..Test*)
	&amp;&amp; !within(com.tivoli.act.log..*)
	&amp;&amp; !execution(* com.tivoli.act..*.main(..))
	&amp;&amp; !execution(* com.tivoli.act..*.usage())
	// &amp;&amp; !withincode(* com.tivoli.act..*.main(..))
	// &amp;&amp; !withincode(* com.tivoli.act..*.usage())
	: "Warning: use of System.out or System.err - consider logging 
instead!";
}

In the above example excluding main() and usage() methods from the pointcut 
using an execution(...)-clause (shows) works but using a withincode()-clause 
(as commented) always yields an NPE:

trouble in:
null
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.SignaturePattern.matches
(SignaturePattern.java:87)
        at org.aspectj.weaver.patterns.WithincodePointcut.match
(WithincodePointcut.java:42)
        at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62)
        at org.aspectj.weaver.Checker.match(Checker.java:48)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:1121)
        at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit
(BcelClassWeaver.java:895)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:793)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:343)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:80)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump
(BcelWeaver.java:689)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
(BcelWeaver.java:615)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:601)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:94)
        at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:108)
        at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)
!SESSION Jun 18, 2004 10:49:48.666 ---------------------------------------------
eclipse.buildId=I200406110010
java.version=1.4.2_03
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=de_CH

!ENTRY org.eclipse.ajdt.ui 4 0 Jun 18, 2004 10:49:48.666
!MESSAGE NullPointerException thrown: null
!STACK 0
java.lang.NullPointerException
        at org.aspectj.weaver.patterns.SignaturePattern.matches
(SignaturePattern.java:87)
        at org.aspectj.weaver.patterns.WithincodePointcut.match
(WithincodePointcut.java:42)
        at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42)
        at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62)
        at org.aspectj.weaver.Checker.match(Checker.java:48)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:1121)
        at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit
(BcelClassWeaver.java:895)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match
(BcelClassWeaver.java:793)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:343)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave
(BcelClassWeaver.java:80)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump
(BcelWeaver.java:689)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
(BcelWeaver.java:615)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:239)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:114)
        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)
        at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:601)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:160)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
(AjBuildManager.java:94)
        at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:108)
        at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:165)


Michael</bugreport>
<testsforfix ID="67774" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Nullpointer-Exception when defining a withincode() pointcut"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="103" file="output/67774/pre-fix/testresults.xml" passing="1212" size="1315"/>
<post-fix-testcases failing="103" file="output/67774/post-fix/testresults.xml" passing="1213" size="1316"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.34" state="changed">1017a1018,1021
&gt;     	} else if (getKind() == Shadow.PreInitialization) {
&gt;           // PreInit doesn't enclose code but its signature
&gt;           // is correctly the signature of the ctor.
&gt;     	  return getSignature();
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.167" state="changed">7834a7835,7842
&gt;     &lt;ajc-test dir="bugs"
&gt; 		pr="67774" title="Nullpointer-Exception when defining a withincode() pointcut"&gt;
&gt;         &lt;compile files="WithincodeNPE01.java"&gt;
&gt;           &lt;!-- there are 3 join points that result in decw match, but 2 are on the same line! --&gt;
&gt;           &lt;message kind="warning" line="2" text="In String ctor"/&gt;
&gt;           &lt;message kind="warning" line="11" text="In String ctor"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/WithincodeNPE01.java" revision="1.1" state="new">aspect B {
  public A.new(String s) { }
  public void A.foo() { int i = 1; }
  
  declare warning: withincode(void main(..)): "X"; // Would NPE without the fix for PR67774
  
  declare warning: withincode(A.new(String)): "In String ctor";
  
}

class A {
  private final static String name = A.class.getName();
}</file>
</fixedFiles>
</bug>
<bug id="68494" transactionid="74136">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="9"/>
<property name="lines-added" value="10"/>
<property name="lines-deleted" value="28"/>
<property name="lines-modified" value="10"/>
<property name="lines-churned" value="48"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-return M O-== O-|| O-- O-() O-&amp;&amp; O-+ T V Y Z-if</fullfingerprint>
<bugreport>In addition to accepting .java source files ajdoc needs to accept .aj files.</bugreport>
<pre-fix-testcases failing="105" file="output/68494/pre-fix/testresults.xml" passing="1201" size="1306"/>
<post-fix-testcases failing="105" file="output/68494/post-fix/testresults.xml" passing="1201" size="1306"/>
<fixedFiles>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java" revision="1.5" state="changed">44,45c44,46
&lt;             PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(signatureFile.getCanonicalPath())));
&lt;             
---
&gt;         	String path = StructureUtil.translateAjPathName(signatureFile.getCanonicalPath());
&gt;             PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(path)));
&gt;              
</file>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/Main.java" revision="1.15" state="changed">112c112
&lt;                 inputFiles[i]     = findFile((String)filenames.elementAt(i));
---
&gt;                 inputFiles[i]     = new File((String)filenames.elementAt(i));
194c194
&lt;                     javadocargs[options.size() + k] = signatureFiles[k].getCanonicalPath();
---
&gt;                     javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
274,298d273
&lt;     /**
&lt;      * If the file doesn't exist on the specified path look for it in all the other
&lt;      * paths specified by the "sourcepath" option.
&lt;      */
&lt;     static File findFile( String filename ) throws IOException {
&lt; 
&lt;         return new File( filename );
&lt;         /*
&lt;         File file = new File(filename);
&lt;         if (file.exists()) {
&lt;             return file;
&lt;         }
&lt;         else {
&lt;             for ( int i = 0; i &lt; sourcePath.size(); i++ ) {
&lt;                 File currPath = new File((String)sourcePath.elementAt(i));
&lt;                 File currFile = new File(currPath + "/" + filename); // !!!
&lt;                 if ( file.exists()) {
&lt;                     return file;
&lt;                 }
&lt;             }
&lt;         }
&lt;         throw new IOException("couldn't find source file: " + filename);
&lt;         */
&lt;     }
&lt; 
428,429d402
&lt; 
&lt;         	
472c445
&lt;             String arg = (String)vargs.get(i);
---
&gt;             String arg = (String)vargs.get(i);  
584,586c557,560
&lt;                 if ((arg.endsWith(".java") &amp;&amp; entryName.indexOf('.') == entryName.length()-5) ||
&lt;                      arg.endsWith(".lst") &amp;&amp;
&lt;                      arg != null ) {
---
&gt;                 if ((arg.endsWith(".java") &amp;&amp; entryName.indexOf('.') == entryName.length()-5) 
&gt;                 	|| (arg.endsWith(".aj") &amp;&amp; entryName.indexOf('.') == entryName.length()-3) 	
&gt;                 	|| arg.endsWith(".lst") 
&gt; 					&amp;&amp; arg != null ) {
614c588,589
&lt;                                         (name.substring(index1, index2).equals( ".java" ) ) ) {
---
&gt;                                         (name.substring(index1, index2).equals( ".java" )
&gt; 										 || name.substring(index1, index2).equals( ".aj" ))) {
645,646c620
&lt;         }
&lt; 
---
&gt;         }        
</file>
<file name="org.aspectj/modules/ajdoc/testdata/coverage/foo/UseThisAspectForLinkCheck.java" revision="1.2" state="deleted"/>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java" revision="1.4" state="changed">111a112,121
&gt; 
&gt; 	/**
&gt; 	 * @return	same path, but ending in ".java" instead of ".aj"
&gt; 	 */
&gt; 	public static String translateAjPathName(String path) {
&gt;     	if (path.endsWith(".aj")) {
&gt;     		path = path.substring(0, path.lastIndexOf(".aj")) + ".java";
&gt;     	} 
&gt;     	return path;
&gt; 	}
</file>
<file name="org.aspectj/modules/ajdoc/.classpath" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java" revision="1.5" state="changed">29c29
&lt; 		File aspect1 = new File("testdata/coverage/foo/UseThisAspectForLinkCheck.java");
---
&gt; 		File aspect1 = new File("testdata/coverage/foo/UseThisAspectForLinkCheck.aj");
38c38
&lt; 		
---
&gt; 		    
46c46
&lt; 			aspect1.getAbsolutePath(),
---
&gt; 			aspect1.getAbsolutePath(),  
</file>
<file name="org.aspectj/modules/ajdoc/testdata/coverage/foo/UseThisAspectForLinkCheck.aj" revision="1.1" state="new">&#13;
package foo;&#13;
&#13;
import fluffy.*;&#13;
import fluffy.bunny.*;&#13;
import fluffy.bunny.rocks.*;&#13;
&#13;
public aspect UseThisAspectForLinkCheck {&#13;
	&#13;
	int foo;&#13;
	&#13;
	pointcut allExecutions(): execution(* *..*(..));&#13;
	&#13;
	before(): allExecutions() {&#13;
		System.err.println("yo");&#13;
	}&#13;
 &#13;
	after(): allExecutions() {&#13;
		System.err.println("go");&#13;
	}&#13;
} </file>
</fixedFiles>
</bug>
<bug id="68991" transactionid="69918">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="15"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-new K-this M T V Z-if</fullfingerprint>
<bugreport>/* initialisers of intertype fields should match field set pointcuts.

   In the example below, the output should be

set field set(int C.n)
set field set(int C.m)
get field get(int C.n)
set field set(int C.n)

   but the first field set (of C.n) is not picked up.
*/



aspect Aspect {

    private int C.n = 13;

    before() : get(* C.*) {
	System.out.println("get field "+thisJoinPointStaticPart);
    }

    before() : set(* C.*)  {
	System.out.println("set field "+thisJoinPointStaticPart);
    }

    public void C.foo() {
	n++;
    }

}

class C {
    int m = 20;
}

public class ITFieldsAdvice {

    public static void main(String[] args) {
	C c = new C();
	c.foo();
    }

}</bugreport>
<testsforfix ID="68991" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test026_bindingThisAndTargetToTheSameFormal"/>
      <test NAME="test030_privateITDinitialisersBeingMatched"/>
      <test NAME="test031_privateITDinitialisersBeingMatched_OxfordTest"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="intertype initialisers should match field set pointcuts"/>
      <test NAME="intertype initialisers should match field set pointcuts (oxford testcase)"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/68991/pre-fix/testresults.xml" passing="1244" size="1356"/>
<post-fix-testcases failing="112" file="output/68991/post-fix/testresults.xml" passing="1246" size="1358"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java" revision="1.10" state="changed">102,107c102,118
&lt; 			FieldBinding interField = world.makeFieldBinding(
&lt; 				AjcMemberMaker.interFieldClassField(sig, aspectType));
&lt; 			Reference ref = new KnownFieldReference(interField, 0);
&lt; 			this.statements = new Statement[] {
&lt; 				new Assignment(ref, initialization, initialization.sourceEnd),
&lt; 			};
---
&gt; 			MethodBinding writeMethod = world.makeMethodBinding(
&gt; 					AjcMemberMaker.interFieldSetDispatcher(sig,aspectType));
&gt; 			// For the body of an intertype field initalizer, generate a call to the inter field set dispatcher
&gt; 			// method as that casts the shadow of a field set join point.
&gt; 			if (Modifier.isStatic(declaredModifiers)) {
&gt; 					this.statements = new Statement[] {
&gt; 						new KnownMessageSend(writeMethod, 
&gt; 								AstUtil.makeNameReference(writeMethod.declaringClass),
&gt; 								new Expression[] {initialization}),
&gt; 					};
&gt; 			} else {
&gt; 				this.statements = new Statement[] {
&gt; 						new KnownMessageSend(writeMethod, 
&gt; 								AstUtil.makeNameReference(writeMethod.declaringClass),
&gt; 								new Expression[] {AstUtil.makeLocalVariableReference(arguments[0].binding),initialization}),
&gt; 					};
&gt; 			}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.11" state="changed">205a206
&gt; 
244a246,257
&gt; 
&gt;    	&lt;ajc-test dir="bugs/PR68991" pr="68991"
&gt;     	title="intertype initialisers should match field set pointcuts"&gt;
&gt;     	&lt;compile files="Simple.java"/&gt;
&gt;     	&lt;run class="Simple"/&gt;
&gt;    	&lt;/ajc-test&gt;
&gt;    	 	
&gt;    	&lt;ajc-test dir="bugs/PR68991" pr="68991"
&gt;     	title="intertype initialisers should match field set pointcuts (oxford testcase)"&gt;
&gt;     	&lt;compile files="Oxford.java"/&gt;
&gt;     	&lt;run class="Oxford"/&gt;
&gt;    	&lt;/ajc-test&gt;
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.11" state="changed">13d12
&lt; 
15d13
&lt; 
144,145c142
&lt;   
&lt;   public void test026_bindingThisAndTargetToTheSameFormal() {
---
&gt;     public void test026_bindingThisAndTargetToTheSameFormal() {
159a157,169
&gt;   
&gt;   public void test030_privateITDinitialisersBeingMatched() {
&gt;     runTest("intertype initialisers should match field set pointcuts");
&gt;   }
&gt; 
&gt;   public void test031_privateITDinitialisersBeingMatched_OxfordTest() {
&gt;     runTest("intertype initialisers should match field set pointcuts (oxford testcase)");
&gt;     //System.err.println("&gt;"+getLastRunResult().getStdErr());
&gt;     String exp = ":set field set(int C.n):set field set(int C.m):get field get(int C.n):set field set(int C.n)";
&gt;     assertTrue("Expected output '"+exp+"' but got "+getLastRunResult().getStdErr(),
&gt;     		getLastRunResult().getStdErr().equals(exp));
&gt;   }
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs/PR68991/Oxford.java" revision="1.1" state="new">/* initialisers of intertype fields should match field set pointcuts.

In the example below, the output should be

set field set(int C.n)
set field set(int C.m)
get field get(int C.n)
set field set(int C.n)

but the first field set (of C.n) is not picked up.
*/



aspect Aspect {
	

 private int C.n = 13;

 before() : get(* C.*) {
	System.err.print(":get field "+thisJoinPointStaticPart);
 }

 before() : set(* C.*)  {
	System.err.print(":set field "+thisJoinPointStaticPart);
 }

 public void C.foo() {
	n++;
 }

}

class C {
 int m = 20;
}

public class Oxford {

 public static void main(String[] args) {
	C c = new C();
	c.foo();
 }

}</file>
<file name="org.aspectj/modules/tests/bugs/PR68991/Simple.java" revision="1.1" state="new">import java.util.*;

aspect Aspect {
	
	public static List tjps = new ArrayList();
	public static List values = new ArrayList();
	public static List ejps = new ArrayList();
	
	public  int C.m = 13;
    private int C.n = 13;

    before() : get(* C.*) {
    	tjps.add(thisJoinPointStaticPart.toString());
    	ejps.add(thisEnclosingJoinPointStaticPart.toString());
    	//System.out.println("get field "+thisJoinPointStaticPart);
    }

    before(int x) : set(* C.*) &amp;&amp; args(x)  {
    	tjps.add(thisJoinPointStaticPart.toString());
    	ejps.add(thisEnclosingJoinPointStaticPart.toString());
    	values.add(new String(thisJoinPointStaticPart+"="+new Integer(x)));
    	//System.err.println("set field "+thisJoinPointStaticPart);
    }
    
    public void C.foo() {
    	m++;
    	n++;
    }

}

class C {
  //  int m = 20;
}

public class Simple {

    public static void main(String[] args) {
    	C c = new C();
    	c.foo();
    	System.err.println("\nSummaryJPs:"+Aspect.tjps);
    	System.err.println("\nSummaryEJPs:"+Aspect.ejps);
    	System.err.println("\nSummaryVals:"+Aspect.values);
    	// Ought to have a nicer signature for the ejpsp in the case of an initializer ...
    	chkNext(Aspect.tjps,"set(int C.m)");chkNext(Aspect.values,"set(int C.m)=13");chkNext(Aspect.ejps,"execution(void Aspect.ajc$interFieldInit$Aspect$C$m(C))");
    	chkNext(Aspect.tjps,"set(int C.n)");chkNext(Aspect.values,"set(int C.n)=13");chkNext(Aspect.ejps,"execution(void Aspect.ajc$interFieldInit$Aspect$C$n(C))");
    	chkNext(Aspect.tjps,"get(int C.m)");                                         chkNext(Aspect.ejps,"execution(void C.foo())");
    	chkNext(Aspect.tjps,"set(int C.m)");chkNext(Aspect.values,"set(int C.m)=14");chkNext(Aspect.ejps,"execution(void C.foo())");
    	chkNext(Aspect.tjps,"get(int C.n)");                                         chkNext(Aspect.ejps,"execution(void C.foo())");
    	chkNext(Aspect.tjps,"set(int C.n)");chkNext(Aspect.values,"set(int C.n)=14");chkNext(Aspect.ejps,"execution(void C.foo())");
    }
    
    public static void chkNext(List l,String expected) {
    	String s = (String)l.remove(0);
    	if (!s.equals(expected)) throw new RuntimeException("Expected next thing on list to be '"+expected+"' but it was '"+s+"'");
    }

}</file>
</fixedFiles>
</bug>
<bug id="69011" transactionid="74228">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="minor"/>
<concisefingerprint>Z</concisefingerprint>
<fullfingerprint>O-!= O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>When trying to document classes that are in the default package, the following 
error occurs:

&gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc...
Loading source file C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java...
C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java:1: &lt;identifier&gt; expected
package ;
        ^
1 error
&gt; Decorating html files...
&gt; Decorating C:\doc\classX.html...
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:            
                                                                 
       aspectj-dev@eclipse.org                           
                                                                 

java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the 
file specified)
java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the 
file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
	at java.io.FileReader.&lt;init&gt;(FileReader.java:55)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile
(HtmlDecorator.java:142)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl
(HtmlDecorator.java:115)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls
(HtmlDecorator.java:54)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles
(HtmlDecorator.java:43)
	at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</bugreport>
<testsforfix ID="69011" type="changed">
    <file LOCATION="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
      <test NAME="testCoverage"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="105" file="output/69011/pre-fix/testresults.xml" passing="1201" size="1306"/>
<post-fix-testcases failing="105" file="output/69011/post-fix/testresults.xml" passing="1201" size="1306"/>
<fixedFiles>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java" revision="1.6" state="changed">49c49
&lt;             if (packageName != null ) {
---
&gt;             if (packageName != null &amp;&amp; packageName != "") {
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java" revision="1.6" state="changed">27a28
&gt; 		File file0 = new File("testdata/coverage/InDefaultPackage.java");
46c47,48
&lt; 			aspect1.getAbsolutePath(),  
---
&gt; 			aspect1.getAbsolutePath(), 
&gt; 			file0.getAbsolutePath(), 
</file>
<file name="org.aspectj/modules/ajdoc/testdata/coverage/InDefaultPackage.java" revision="1.1" state="new">
/**
 * Test class.  This is a comment.
 */  
public abstract class InDefaultPackage {
	
	/**
	 * Mumble field.
	 */
	public String mumble = "xxx";
	public int pubfield;
	private String privfield = "mumble";
}</file>
</fixedFiles>
</bug>
<bug id="69459" transactionid="69936">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="11"/>
<property name="lines-churned" value="11"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-null M O-! O-&amp;&amp; O-+ T V Y Z-if</fullfingerprint>
<bugreport>Using Introduction it is possible to hide instance methods by static methods.
Example:

class Super {
  public void m(){};
}
class Sub {}

aspect A {
  public static void Sub.m(){}
}

Acccording to the Java Language Specification this is not allowed. Is this
behaviour desired ??

It is also possible to override static methods by instance methods, wich causes
a compile time error in java.</bugreport>
<testsforfix ID="69459" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="Hiding of Instance Methods by static methods"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="105" file="output/69459/pre-fix/testresults.xml" passing="1203" size="1308"/>
<post-fix-testcases failing="105" file="output/69459/post-fix/testresults.xml" passing="1204" size="1309"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.27" state="changed">1110c1110
&lt; 			
---
&gt; 			//System.err.println("Comparing munger: "+sig+" with member "+existingMember);
1112c1112
&lt; 				//System.err.println("conflict: " + existingMember + " with " + munger);
---
&gt; 				//System.err.println("conflict: existingMember=" + existingMember + "   typeMunger=" + munger);
1194c1194,1202
&lt; 		
---
&gt; 		if (parent.isStatic() &amp;&amp; !child.isStatic()) {
&gt; 			world.showMessage(IMessage.ERROR,
&gt; 			  child.toString()+" cannot override "+parent.toString()+"; overridden method is static",
&gt; 			  child.getSourceLocation(),null);
&gt; 		} else if (child.isStatic() &amp;&amp; !parent.isStatic()) {
&gt; 			world.showMessage(IMessage.ERROR,
&gt; 			  child.toString()+" cannot override "+parent.toString()+"; overriding method is static",
&gt; 			  child.getSourceLocation(),null);
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/IntertypeOverrides2.java" revision="1.1" state="new">class Super {
  public static void m(){};
}

class Sub extends Super {}

aspect A {
  public void Sub.m(){}
}
</file>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/Superclass.class" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/IntertypeOverrides.java" revision="1.1" state="new">class Super {
  public void m(){};
}

class Sub extends Super {}

aspect A {
  public static void Sub.m(){}
}
</file>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/Aspect1.java" revision="1.1" state="new">aspect Aspect1 {
  public void Subclass.staticMethod() {};
}
</file>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/Superclass.java" revision="1.1" state="new">class Superclass {
  public static void staticMethod(){} {}
  public void nonstaticMethod() {};
}
</file>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/Subclass.class" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.162" state="changed">7778a7779,7797
&gt;     
&gt;     &lt;ajc-test dir="bugs/intertypeOverrides"
&gt; 		pr="69459" title="Hiding of Instance Methods by static methods"&gt;
&gt;         &lt;compile files="IntertypeOverrides.java"&gt;
&gt;           &lt;message kind="error" line="8" text="void Sub.m() cannot override void Super.m(); overriding method is static"/&gt;
&gt;         &lt;/compile&gt;
&gt;         &lt;compile files="IntertypeOverrides2.java"&gt;
&gt;           &lt;message kind="error" line="8" text="void Sub.m() cannot override void Super.m(); overridden method is static"/&gt;
&gt;         &lt;/compile&gt;
&gt;         &lt;compile files="Superclass.java,Subclass.java,Aspect1.java"&gt;
&gt;           &lt;message file="Aspect1.java" kind="error" line="2" 
&gt;              text="void Subclass.staticMethod() cannot override void Superclass.staticMethod(); overridden method is static"/&gt;
&gt;         &lt;/compile&gt;
&gt;         &lt;compile files="Superclass.java,Subclass.java,Aspect2.java"&gt;
&gt;           &lt;message file="Aspect2.java" kind="error" line="2"
&gt;              text="void Subclass.nonstaticMethod() cannot override void Superclass.nonstaticMethod(); overriding method is static"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/Aspect2.java" revision="1.1" state="new">aspect Aspect2 {
  public static void Subclass.nonstaticMethod() {};
}
</file>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/Aspect1.class" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/Aspect2.class" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/Subclass.java" revision="1.1" state="new">class Subclass extends Superclass {
}
</file>
<file name="org.aspectj/modules/tests/bugs/intertypeOverrides/Super.class" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="70008" transactionid="74088">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="8"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-return M O-! T V Z-if</fullfingerprint>
<bugreport>Using the spacewar example, the following works fine:
    ajdoc -private -d doc spacewar coordination
but the following breaks:
    ajdoc -public -d doc spacewar coordination

The end of the failing output is below. Display.html and
Display.DisplayAspect.html were not generated as the types are not public, so
presumably the decorator shouldn't be looking for them in this case.

&gt; Decorating html files...
&gt; Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Debug.html...
&gt; Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Display.DisplayAspect.html.
..
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:

       aspectj-dev@eclipse.org


java.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.D
isplayAspect.html (The system cannot find the file specified)
java.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.D
isplayAspect.html (The system cannot find the file specified)
        at java.io.FileInputStream.open(Native Method)
        at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
        at java.io.FileReader.&lt;init&gt;(FileReader.java:55)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.
java:142)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecora
tor.java:115)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecor
ator.java:54)
        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(Html
Decorator.java:43)
        at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</bugreport>
<testsforfix ID="70008" type="new">
    <file LOCATION="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
      <test NAME="testCoveragePublicMode"/>
    </file>
    <file LOCATION="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java">
      <test NAME="testPublicModeExample"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="106" file="output/70008/pre-fix/testresults.xml" passing="1200" size="1306"/>
<post-fix-testcases failing="105" file="output/70008/post-fix/testresults.xml" passing="1201" size="1306"/>
<fixedFiles>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java" revision="1.12" state="changed">114a115
&gt;                     
139a141,144
&gt;     /**
&gt;      * Skips files that are public in the model but not public in the source,
&gt;      * e.g. nested aspects.
&gt;      */
141,142c146,150
&lt;         System.out.println( "&gt; Decorating " + file.getCanonicalPath() + "..." );
&lt;         BufferedReader reader = new BufferedReader(new FileReader(file));
---
&gt; 	    if (!file.exists()) return;
&gt; 	    
&gt; 	    System.out.println( "&gt; Decorating " + file.getCanonicalPath() + "..." );
&gt; 	    BufferedReader reader = new BufferedReader(new FileReader(file));
&gt; 	    
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java" revision="1.7" state="changed">23a24,37
&gt; 
&gt; 	File file0 = new File("testdata/coverage/InDefaultPackage.java");
&gt; 	File file1 = new File("testdata/coverage/foo/ClassA.java");
&gt; 	File aspect1 = new File("testdata/coverage/foo/UseThisAspectForLinkCheck.aj");
&gt; 	File file2 = new File("testdata/coverage/foo/InterfaceI.java");
&gt; 	File file3 = new File("testdata/coverage/foo/PlainJava.java");
&gt; 	File file4 = new File("testdata/coverage/foo/ModelCoverage.java");
&gt; 	File file5 = new File("testdata/coverage/fluffy/Fluffy.java");
&gt; 	File file6 = new File("testdata/coverage/fluffy/bunny/Bunny.java");
&gt; 	File file7 = new File("testdata/coverage/fluffy/bunny/rocks/Rocks.java");
&gt; 	File file8 = new File("testdata/coverage/fluffy/bunny/rocks/UseThisAspectForLinkCheckToo.java");
&gt; 	File file9 = new File("testdata/coverage/foo/PkgVisibleClass.java");
&gt; 	 
&gt; 	File outdir = new File("testdata/coverage/doc");
26,39c40
&lt; 		  
&lt; //		System.err.println(new File("testdata/figures-demo").exists());
&lt; 		File file0 = new File("testdata/coverage/InDefaultPackage.java");
&lt; 		File file1 = new File("testdata/coverage/foo/ClassA.java");
&lt; 		File aspect1 = new File("testdata/coverage/foo/UseThisAspectForLinkCheck.aj");
&lt; 		File file2 = new File("testdata/coverage/foo/InterfaceI.java");
&lt; 		File file3 = new File("testdata/coverage/foo/PlainJava.java");
&lt; 		File file4 = new File("testdata/coverage/foo/ModelCoverage.java");
&lt; 		File file5 = new File("testdata/coverage/fluffy/Fluffy.java");
&lt; 		File file6 = new File("testdata/coverage/fluffy/bunny/Bunny.java");
&lt; 		File file7 = new File("testdata/coverage/fluffy/bunny/rocks/Rocks.java");
&lt; 		File file8 = new File("testdata/coverage/fluffy/bunny/rocks/UseThisAspectForLinkCheckToo.java");
&lt; 		File outdir = new File("testdata/coverage/doc");
&lt; 		    
---
&gt; 		outdir.delete();
56c57,58
&lt; 			file8.getAbsolutePath()
---
&gt; 			file8.getAbsolutePath(),
&gt; 			file9.getAbsolutePath()
58d59
&lt; 		
61a63,76
&gt; 	public void testCoveragePublicMode() {
&gt; 		outdir.delete();
&gt; 		String[] args = { 
&gt; 			"-public",
&gt; 			"-source", 
&gt; 			"1.4",
&gt; 			"-d", 
&gt; 			outdir.getAbsolutePath(),
&gt; 			file3.getAbsolutePath(),
&gt; 			file9.getAbsolutePath() 
&gt; 		};
&gt; 		org.aspectj.tools.ajdoc.Main.main(args);
&gt; 	}
&gt; 	
63,65c78
&lt; //		File file1 = new File("testdata/coverage/foo/PlainJava.java");
&lt; //		File outdir = new File("testdata/coverage/doc");
&lt; //		
---
&gt; //		outdir.delete();
68,69c81
&lt; //				file1.getAbsolutePath() };
&lt; //		
---
&gt; //				file3.getAbsolutePath() };
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java" revision="1.3" state="changed">22a23,27
&gt; 	protected void setUp() throws Exception {
&gt; 		super.setUp();
&gt; 		new File("testdata/spacewar/docdir").delete();
&gt; 	}
&gt;     
24,25d28
&lt; 		
&lt; //		System.err.println(new File("testdata/figures-demo").exists());
37d39
&lt; 		
41,42c43,57
&lt; 	protected void setUp() throws Exception {
&lt; 		super.setUp();
---
&gt; 	public void testPublicModeExample() {
&gt; 		File outdir = new File("testdata/spacewar/docdir");
&gt; 		File sourcepath = new File("testdata/spacewar");
&gt; 		
&gt; 		String[] args = { 
&gt; 		        "-public",
&gt; 		        "-d", 
&gt; 				outdir.getAbsolutePath(),
&gt; 				"-sourcepath",
&gt; 				sourcepath.getAbsolutePath(),
&gt; 				"spacewar",
&gt; 				"coordination" };
&gt; 		
&gt; 		org.aspectj.tools.ajdoc.Main.main(args);
&gt; 		assertTrue(true);
</file>
<file name="org.aspectj/modules/ajdoc/testdata/coverage/foo/PkgVisibleClass.java" revision="1.1" state="new">/**
 * @author Mik Kersten
 */
class PkgVisibleClass {

    static class NestedClass { } 
    
    static aspect NestedAspect { } 
  
    private static aspect PrivateNestedAspect { } 
     
}
</file>
</fixedFiles>
</bug>
<bug id="70241" transactionid="68380">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="3"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-new M O-() O-cast T V Y Z-cast</fullfingerprint>
<bugreport>See screenshots.</bugreport>
<testsforfix ID="70241" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/ExtensionTests.java">
      <test NAME="testInnerClassesInASM"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="117" file="output/70241/pre-fix/testresults.xml" passing="1251" size="1368"/>
<post-fix-testcases failing="116" file="output/70241/post-fix/testresults.xml" passing="1253" size="1369"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java" revision="1.15" state="changed">282c282,283
&lt; 			fullName = new String(memberTypeDeclaration.binding.constantPoolName());
---
&gt; 			// Create a name something like 'new Runnable() {..}'
&gt; 			fullName = "new "+memberTypeDeclaration.allocation.type.toString()+"() {..}";
284,286d284
&lt; 		 
&lt; 		int dollar = fullName.indexOf('$');
&lt; 		fullName = fullName.substring(dollar+1);
301,302c299,300
&lt; 		//??? we add this to the compilation unit
&lt; 		findEnclosingClass(stack).addChild(peNode);
---
&gt; 
&gt; 		((IProgramElement)stack.peek()).addChild(peNode);
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/ExtensionTests.java" revision="1.2" state="changed">12a13
&gt; import java.util.Iterator;
13a15
&gt; import java.util.Properties;
15a18,19
&gt; import org.aspectj.asm.AsmManager;
&gt; import org.aspectj.asm.IProgramElement;
52a57,128
&gt; 	public void testInnerClassesInASM() {
&gt; 		String[] args = new String[] {"InnerClasses.java","-emacssym"};
&gt; 		CompilationResult result = ajc(baseDir,args);
&gt; 		List l = result.getWarningMessages();
&gt; 		Properties p = AsmManager.ModelInfo.summarizeModel().getProperties();
&gt; 		System.out.println("Structure Model for InnerClasses.java:");
&gt; 		walkit(AsmManager.getDefault().getHierarchy().getRoot(),0);
&gt; 		foundNode = null;
&gt; 		findChild("main",AsmManager.getDefault().getHierarchy().getRoot());
&gt; 		assertTrue("Should have found node 'main' in the model",foundNode!=null);
&gt; 		IProgramElement runnableChild = getChild(foundNode,"new Runnable() {..}");
&gt; 		assertTrue("'main' should have a child 'new Runnable() {..}'",
&gt; 				runnableChild!=null);
&gt; 		assertTrue("'new Runnable() {..}' should have a 'run' child",
&gt; 				getChild(runnableChild,"run")!=null);
&gt; 		
&gt; 		/* Left hand side is before the fix, right hand side is after:
&gt; &lt;root&gt;
&gt;   InnerClasses.java
&gt;     import declarations
&gt;     InnerClasses
&gt;       A							A
&gt;         method						method
&gt;         1								new Runnable() {..}
&gt;           run								run
&gt;       main						main
&gt;       2								new Runnable() {..}
&gt;       	  run							run
&gt;       3 							new Object() {..}
&gt;         toString						toString
&gt;       4								new Runnable
&gt;         run								run
&gt; 		 */
&gt; 
&gt; 	}
&gt; 	
&gt; 	private IProgramElement getChild(IProgramElement parent,String s) {
&gt; 		List kids = parent.getChildren();
&gt; 		for (Iterator iter = kids.iterator(); iter.hasNext();) {
&gt; 			IProgramElement element = (IProgramElement) iter.next();
&gt; 			if (element.getName().indexOf(s)!=-1) return element;
&gt; 		}
&gt; 		return null;
&gt; 	}
&gt; 	
&gt; 	private IProgramElement foundNode = null;
&gt; 	
&gt; 	private void findChild(String s,IProgramElement ipe) {
&gt; 		if (ipe == null) return;
&gt; 		if (ipe.getName().indexOf(s)!=-1) {foundNode = ipe; return;}
&gt; 		if (ipe.getChildren()!=null) {
&gt; 			List kids = ipe.getChildren();
&gt; 			for (Iterator iter = kids.iterator(); iter.hasNext();) {
&gt; 				IProgramElement element = (IProgramElement) iter.next();
&gt; 				findChild(s,element);
&gt; 			}
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	public void walkit(IProgramElement ipe,int indent) {
&gt; 	  if (ipe!=null) {
&gt; 	  	for (int i = 0 ;i&lt;indent;i++) System.out.print(" ");
&gt; 	  	System.out.println(ipe.toLabelString());//getName());
&gt; 	    if (ipe.getChildren()!=null) {
&gt; 	    	List kids = ipe.getChildren();
&gt; 	    	for (Iterator iter = kids.iterator(); iter.hasNext();) {
&gt; 				IProgramElement element = (IProgramElement) iter.next();
&gt; 				walkit(element,indent+2);
&gt; 			}
&gt; 	    }
&gt; 	  }
&gt; 	}
</file>
<file name="org.aspectj/modules/ajde/testdata/extensions/InnerClasses.java" revision="1.1" state="new">public class InnerClasses {
	
	public static void main(String[] args) {
		Runnable r = new Runnable() {
			public void run() {

			}
		};
		
		r.run();
		
		new Object() {
			public String toString() {
				return "a";
			}
		};
		
		new Runnable() {
			public void run() {

			}
		}.run();
	}
	
	
	static class A {
		public void method() {
			Runnable r = new Runnable() {
				public void run() {

				}
			};
		}
	}
}</file>
</fixedFiles>
</bug>
<bug id="70619" transactionid="68706">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new K-null K-throw K-true M O-== O-+ T V Y Z-if Z-throw</fullfingerprint>
<bugreport>The following program causes ajc 1.2 to abort:

public class Conflict { public static void main(String[] args) { } }

aspect Conflict1 {
  declare precedence: Conflict1, Conflict2;

   before(): execution(* *(..)) { }
}

aspect Conflict2 {
  declare precedence: Conflict2, Conflict1;


  after(): execution(* *(..)) { }
}</bugreport>
<testsforfix ID="70619" type="new">
    <file LOCATION="org.aspectj/modules/tests/ajcTests.xml">
      <test NAME="compiler aborts with 'conflicting dominates orders' with circular declare precedences"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="105" file="output/70619/pre-fix/testresults.xml" passing="1201" size="1306"/>
<post-fix-testcases failing="105" file="output/70619/post-fix/testresults.xml" passing="1202" size="1307"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.17" state="changed">302a303
&gt; 		DeclarePrecedence orderer = null; // Records the declare precedence statement that gives the first ordering
307a309
&gt; 				if (orderer==null) orderer = d;
309c311,318
&lt; 					throw new BCException("conflicting dominates orders");
---
&gt; 					ISourceLocation[] isls = new ISourceLocation[2];
&gt; 					isls[0]=orderer.getSourceLocation();
&gt; 					isls[1]=d.getSourceLocation();
&gt; 					Message m = 
&gt; 					  new Message("conflicting declare precedence orderings for aspects: "+
&gt; 					              aspect1.getName()+" and "+aspect2.getName(),null,true,isls);
&gt; 					messageHandler.handleMessage(m);
&gt; 					// throw new BCException("conflicting dominates orders"+d.getSourceLocation());
</file>
<file name="org.aspectj/modules/tests/bugs/bug70619/Order2.aj" revision="1.1" state="new">aspect Conflict2 {&#13;
	after(): execution(* *(..)) { }&#13;
  declare precedence: Conflict2, Conflict1;&#13;
&#13;
 &#13;
}</file>
<file name="org.aspectj/modules/tests/bugs/bug70619/Order1.aj" revision="1.1" state="new">aspect Conflict1 {&#13;
  &#13;
  &#13;
  &#13;
  declare precedence: Conflict1, Conflict2;&#13;
&#13;
   before(): execution(* *(..)) { }&#13;
}</file>
<file name="org.aspectj/modules/tests/bugs/bug70619/Conflict.java" revision="1.1" state="new">
class Conflict { 
	public static void main(String[] args) { } 
}
	
</file>
<file name="org.aspectj/modules/tests/ajcTests.xml" revision="1.160" state="changed">7758a7759,7771
&gt;     
&gt;     &lt;ajc-test dir="bugs/bug70619"
&gt; 		pr="70619" title="compiler aborts with 'conflicting dominates orders' with circular declare precedences"&gt;
&gt;         &lt;compile files="Precedence.java"&gt;
&gt;           &lt;message kind="error" line="0" text="conflicting declare precedence"/&gt;
&gt;         &lt;/compile&gt;
&gt;         &lt;compile files="Conflict.java,Order2.aj,Order1.aj"&gt;        
&gt;           &lt;message kind="error" line="0" text="conflicting declare precedence"/&gt;
&gt;         &lt;/compile&gt;
&gt;         &lt;compile files="Conflict.java,Order1.aj,Order2.aj"&gt;
&gt;           &lt;message kind="error" line="0" text="conflicting declare precedence"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/bug70619/Precedence.java" revision="1.1" state="new">class Conflict { public static void main(String[] args) { } }

aspect Conflict1 {
  declare precedence: Conflict1,Conflict2;

  before(): execution(* *(..)) { }
}

aspect Conflict2 {
  declare precedence: Conflict2, Conflict1;

  after(): execution(* *(..)) { }
}</file>
</fixedFiles>
</bug>
<bug id="70658" transactionid="73944">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="18"/>
<property name="lines-added" value="49"/>
<property name="lines-deleted" value="110"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="162"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-else K-false K-if K-import K-instanceof K-new K-null K-return K-this K-true K-try K-while M O-== O-! O-!= O-() O-&amp;&amp; O-+ O-cast O-instanceof T V Y Z-cast Z-if Z-while</fullfingerprint>
<bugreport>For AJDT 1.1.11 I have found that in the aTrack project sometimes the gutter 
annotation and context menu are missing in places where a method execution is 
advised. E.g., see the attached screen snapshot. This happens in some classes, 
but not consistently. Note that all the aspects are internal to the project 
(i.e., this isn't a library jar issue).</bugreport>
<pre-fix-testcases failing="112" file="output/70658/pre-fix/testresults.xml" passing="1294" size="1406"/>
<post-fix-testcases failing="112" file="output/70658/post-fix/testresults.xml" passing="1294" size="1406"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJContentOutlinePage.java" revision="1.4" state="changed">2c2
&lt; Copyright (c) 2002 IBM Corporation and others.
---
&gt; Copyright (c) 2002-2004 IBM Corporation and others.
8a9,10
&gt; Sian January - removed advice marker update methods as part of the fix 
&gt; 	for bug 70658
13,16d14
&lt; import java.util.ArrayList;
&lt; import java.util.Iterator;
&lt; import java.util.List;
&lt; 
95,99d92
&lt; 	/**
&lt; 	 * The last config file we loaded
&lt; 	 */
&lt; 	private static String lastLoadedConfigFile = "";
&lt; 	
103,112d95
&lt; 	 * During a compile, this list is extended with instances of outline page
&lt; 	 * that have been 'updated' via the callback from the compiler.  Once the
&lt; 	 * compiler has completed, we iterate through entries in this list and
&lt; 	 * update all the advice markers.  We do it this way because we can't 
&lt; 	 * touch resource markers whilst the compile is in progress (due to thread
&lt; 	 * locking problems.
&lt; 	 */
&lt; 	private static List outlinesWithPendingAdviceMarkerUpdates = null;
&lt; 	
&lt; 	/**
151,152d133
&lt; //		updateAdviceMarkers(true);
&lt; 
167,168d147
&lt; 		updateAdviceMarkers(true);//(AJDTStructureViewNode)outline);
&lt; 
202d180
&lt;             updateAdviceMarkers(false);
209,279d186
&lt; 	
&lt; 	/**
&lt; 	 * Called whenever the advice markers (which appear in the left hand ruler) need
&lt; 	 * to be updated.  This might be when an editor is first opened for editing a
&lt; 	 * file or during a compile, when the compiler makes a callback to the outline view.
&lt; 	 * 
&lt; 	 * In either case we do the same thing, we add the instance of the outline page
&lt; 	 * that received the callback to the list of pending outline updates.  A list
&lt; 	 * is used so that we can defer marker updates until the end of a compile run, 
&lt; 	 * however when an editor is first opened on a resource, it is ok to immediately 
&lt; 	 * update the advice markers - hence the right_now flag can be supplied to this 
&lt; 	 * function, if set to true then the markers are updated immediately.  
&lt; 	 * If right_now is false then the updates will only occur when the static method
&lt; 	 * performPendingAdviceMarkerUpdates is called.  This static method is called from 
&lt; 	 * the builder code once the compile completes.
&lt; 	 * 
&lt; 	 * @param right_now Should the advice markers be updated immediately.
&lt; 	 */
&lt; 	
&lt; 	public void updateAdviceMarkers(boolean right_now) {
&lt;     	if (outlinesWithPendingAdviceMarkerUpdates == null) 
&lt;     	  outlinesWithPendingAdviceMarkerUpdates = new ArrayList();
&lt;      	outlinesWithPendingAdviceMarkerUpdates.add(this);
&lt;     	
&lt;     	if (right_now) performPendingAdviceMarkerUpdates();
&lt;     }
&lt;     
&lt;     
&lt;     /**
&lt;      * This method goes through the list of outline pages that need their associated
&lt;      * resource to have its' advice markers updated.  The list is built up during or
&lt;      * compile or when an editor is opened on a resource.
&lt;      * For each entry in the list, it calls the AspectJEditor to do an update - this
&lt;      * will involve a thread being kicked off that deletes existing markers for a file
&lt;      * and then adds the new ones.
&lt;      * 
&lt;      */
&lt;     public static void performPendingAdviceMarkerUpdates() {
&lt;     	
&lt;     	// Check if any updates are pending ...
&lt;     	if (outlinesWithPendingAdviceMarkerUpdates == null) return;
&lt;     	
&lt;     	Iterator it = outlinesWithPendingAdviceMarkerUpdates.iterator();
&lt;     	while (it.hasNext()) {
&lt;     		final AspectJContentOutlinePage page = (AspectJContentOutlinePage)it.next();
&lt;     	    final AJDTStructureViewNode root_final = (AJDTStructureViewNode)page.view.getRootNode();
&lt; 			
&lt; 			// Andys words of wisdom: Chapter #1
&lt; 			// Sometimes, due to race conditions we can get entries in the List that don't refer to
&lt; 			// resources that exist.  For example.  If I delete 'ABC.java' whilst I have an editor
&lt; 			// open on it, there is a race between the incremental builder logic and the editor
&lt; 			// disposal logic.  If the builder gets done first, it can start trying to update
&lt; 			// the editor for the resource that isnt there anymore.  So we guard in the logic
&lt; 			// below to protect from this.
&lt; 			
&lt; 			
&lt;             // Could possibly assert this, theres no way it should be in the list if it
&lt;             // is page.editor is not an AspectJEditor.
&lt; 			if (page.editor            instanceof AspectJEditor) {
&lt; 				if (page.editor.getEditorInput() != null) 
&lt; 					((AspectJEditor)page.editor).forceUpdateOfAdviceMarkers();
&lt; 				else AJDTEventTrace.generalEvent("INFO message: Compiler made attempt to update outline for a currently (possibly temporarily) non-existent resource: "+page.editor.getTitle());
&lt; 
&lt; 			}
&lt;     	}	
&lt;       
&lt;        // Null out the list to indicate they have all been processed.
&lt;        outlinesWithPendingAdviceMarkerUpdates = null;
&lt; 	  
&lt;     }	
&lt; 	
371d277
&lt; 		updateActiveConfig( );
396,408d301
&lt; 	 * update active config
&lt; 	 */
&lt; 	private void updateActiveConfig( ) {
&lt; 		IProject project = input.getProject();
&lt; 		String configFile = AspectJUIPlugin.getBuildConfigurationFile(project);
&lt; 		if ( !configFile.equals( lastLoadedConfigFile ) ) {
&lt; 			AJDTEventTrace.buildConfigSelected( configFile, project );
&lt; 			Ajde.getDefault().getConfigurationManager().setActiveConfigFile( configFile );
&lt; 			lastLoadedConfigFile = configFile;
&lt; 		}				
&lt; 	}
&lt; 
&lt; 	/**
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJEditor.java" revision="1.5" state="changed">18a19
&gt; import org.aspectj.ajde.Ajde;
400a402
&gt; 			updateActiveConfig(fInput);
461a464,475
&gt; 	
&gt; 	/**
&gt; 	 * Update active config in AJDE.  Added as part of the fix for bug 70658.
&gt; 	 */
&gt; 	private void updateActiveConfig(IFileEditorInput fInput ) {
&gt; 		IProject project = fInput.getFile().getProject();
&gt; 		String configFile = AspectJUIPlugin.getBuildConfigurationFile(project);
&gt; 		if ( !configFile.equals( Ajde.getDefault().getConfigurationManager().getActiveConfigFile()) ) {
&gt; 			AJDTEventTrace.buildConfigSelected( configFile, project );
&gt; 			Ajde.getDefault().getConfigurationManager().setActiveConfigFile( configFile );
&gt; 		}				
&gt; 	}
728a743,775
&gt; 	 * Sian - added as part of the fix for bug 70658
&gt; 	 * Force marker updates for any editors open on files in the project,
&gt; 	 * or on all editors if project is null.
&gt; 	 * @param project
&gt; 	 */
&gt; 	public static void forceMarkerUpdates(final IProject project) {
&gt; 		final Iterator editorIter = activeEditorList.iterator();
&gt; 		AspectJUIPlugin.getDefault().getDisplay().asyncExec(new Runnable() {
&gt; 			public void run() {
&gt; 				try {
&gt; 					while (editorIter.hasNext()) {
&gt; 						AspectJEditor ajed = (AspectJEditor) editorIter.next();
&gt; 						IEditorInput iei = ajed.getEditorInput();
&gt; 						boolean updateThisEditor = true;
&gt; 						if (project != null
&gt; 								&amp;&amp; (iei instanceof IFileEditorInput)) {
&gt; 							IFileEditorInput ifei = (IFileEditorInput) iei;
&gt; 							if (!(ifei.getFile().getProject().getName()
&gt; 									.equals(project.getName())))
&gt; 								updateThisEditor = false;
&gt; 						}
&gt; 						if (updateThisEditor) {
&gt; 							ajed.forceUpdateOfAdviceMarkers();							
&gt; 						}
&gt; 					}
&gt; 				} catch (Exception e) {
&gt; 				}
&gt; 			}
&gt; 		});
&gt; 	}
&gt; 
&gt; 	
&gt; 	/**
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/builder/Builder.java" revision="1.9" state="changed">37d36
&lt; import org.eclipse.ajdt.internal.ui.editor.AspectJContentOutlinePage;
361c360
&lt; 			// Tell the outline view to perform any marker updates pending from
---
&gt; 			// Tell the editor to perform any marker updates pending from
363c362
&lt; 			AspectJContentOutlinePage.performPendingAdviceMarkerUpdates();
---
&gt; 			AspectJEditor.forceMarkerUpdates(project);
</file>
</fixedFiles>
</bug>
<bug id="70773" transactionid="69387">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="18"/>
<property name="lines-churned" value="19"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-for K-true K-while M O-&gt; T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>In AspectJ 1.1.11 for Eclipse, build ID 1.2.0 (and also in the previous 1.1.10)
on Eclipse version 3.0.0, build ID 200406351208: If I enable incremental
compilation and make a change to a file (typing a space and deleting it, or
editing a comment), I get a "ConncurrentModificationException thrown: null" error.</bugreport>
<pre-fix-testcases failing="103" file="output/70773/pre-fix/testresults.xml" passing="1212" size="1315"/>
<post-fix-testcases failing="103" file="output/70773/post-fix/testresults.xml" passing="1212" size="1315"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.21" state="changed">387c387,389
&lt; 	boolean inBinaryTypeCreation = false;
---
&gt; 	boolean inBinaryTypeCreationAndWeaving = false;
&gt; 	boolean processingTheQueue = false;
&gt; 	
393c395,396
&lt; 		if (inBinaryTypeCreation) {
---
&gt; 
&gt; 		if (inBinaryTypeCreationAndWeaving) {
402,403c405
&lt; 		
&lt; 		inBinaryTypeCreation = true;
---
&gt; 		inBinaryTypeCreationAndWeaving = true;
409,410c411
&lt; 			weaveInterTypeDeclarations(ret);
&lt; 			
---
&gt; 			weaveInterTypeDeclarations(ret);			
413,416c414,423
&lt; 			inBinaryTypeCreation = false;
&lt; 			if (!pendingTypesToFinish.isEmpty()) {
&lt; 				for (Iterator i = pendingTypesToFinish.iterator(); i.hasNext(); ) {
&lt; 					weaveInterTypeDeclarations((BinaryTypeBinding)i.next());
---
&gt; 			inBinaryTypeCreationAndWeaving = false;
&gt; 			
&gt; 			// Start processing the list...
&gt; 			if (pendingTypesToFinish.size()&gt;0) {
&gt; 				processingTheQueue = true;
&gt; 				while (!pendingTypesToFinish.isEmpty()) {
&gt; 					BinaryTypeBinding nextVictim = (BinaryTypeBinding)pendingTypesToFinish.remove(0);
&gt; 					// During this call we may recurse into this method and add 
&gt; 					// more entries to the pendingTypesToFinish list.
&gt; 					weaveInterTypeDeclarations(nextVictim);
418c425
&lt; 				pendingTypesToFinish.clear();
---
&gt; 				processingTheQueue = false;
</file>
</fixedFiles>
</bug>
<bug id="71377" transactionid="68876">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="22"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="27"/>
<property name="lines-churned" value="49"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-new K-null K-return K-true M O-|| O-!= O-&amp;&amp; O-+ T V Y Z-if</fullfingerprint>
<bugreport>Pointcuts should match call joint points in advice. However AspectJ does not 
match calls to _private_ methods in around advice. The same applies to get/set 
pointcuts for _private fields. This is probably because in the testcase below 
a call to "privateMethod()" in the body of the around advice is a call to an 
accessor method:

        
ajc$inlineAccessMethod$bug_nnnn_JoinPointInAroundAdvice$bug_nnnn_JoinPointInAro
undAdvice$privateMethod("around");

public aspect JoinPointInAroundAdvice {

	private static Set privateCalls = new HashSet();
	private static Set publicCalls = new HashSet();
	
	pointcut internalCall () :
		call(* JoinPointInAroundAdvice.privateMethod(..));
	
	before () : internalCall () {
		privateCalls.add(thisJoinPoint);
	}

	pointcut externalCall () :
		call(* JoinPointInAroundAdvice.publicMethod(..));
	
	before () : externalCall () {
		publicCalls.add(thisJoinPoint);
	}
	
	pointcut execTest () :
		execution(* JoinPointInAroundAdvice.test());
	
	before () : execTest () {
		privateMethod("before");
		publicMethod("before");
	}
	
	void around () : execTest () {
		privateMethod("around");
		publicMethod("around");
		proceed();
	}
	
//	void around () : execTest () {
//		Runnable runnable = new Runnable () {
//			public void run () {
//				privateMethod("around closure");
//				publicMethod;
//				proceed();
//			}
//		};
//		runnable.run();
//	}
	
	after () : execTest () {
		privateMethod("after");
		publicMethod("after");
	}
	
	private static void privateMethod (String from) {
		System.out.println("? privateMethod() " + from);
	}
	
	public static void publicMethod (String from) {
		System.out.println("? publicMethod() " + from);
	}
	
	public static void test () {
		System.out.println("? test()");
		privateMethod("test");
		publicMethod("test");
	}
	
	public static void main (String[] args) {
		test();
		
		if (privateCalls.size() != publicCalls.size()) {
			throw new RuntimeException("Missing join point");
		}
		else {
			System.out.println("Success.");
		}
	}
}</bugreport>
<testsforfix ID="71377" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test017_PrivateMethodCallsInAroundAdvice"/>
      <test NAME="test018_PrivateFieldSetsInAroundAdvice"/>
      <test NAME="test019_PrivateFieldGetsInAroundAdvice"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/bugs/AroundAdviceJPs/JoinPointInAroundAdvice.java">
      <test NAME="test"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/bugs/AroundAdviceJPs/FieldGetJoinPointsInAroundAdvice.java">
      <test NAME="test"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/bugs/AroundAdviceJPs/FieldJoinPointsInAroundAdvice.java">
      <test NAME="test"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="Cannot advise private method call in around advice"/>
      <test NAME="Cannot advise private field sets in around advice"/>
      <test NAME="Cannot advise private field gets in around advice"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="113" file="output/71377/pre-fix/testresults.xml" passing="1233" size="1346"/>
<post-fix-testcases failing="112" file="output/71377/post-fix/testresults.xml" passing="1237" size="1349"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java" revision="1.22" state="changed">648c648,663
&lt; 		if (getType().isInterface()) {
---
&gt; 		
&gt; 		// XXX - Do we ever inline before or after advice? If we do, then we
&gt; 		// better include them in the check below. (or just change it to
&gt; 		// shadow.getEnclosingMethod().getCanInline())
&gt; 		
&gt; 		// If the enclosing method is around advice, we could inline the join point
&gt; 		// that has led to this shadow.  If we do that then the TJP we are creating
&gt; 		// here must be PUBLIC so it is visible to the type in which the 
&gt; 		// advice is inlined. (PR71377)
&gt; 		LazyMethodGen encMethod = shadow.getEnclosingMethod();
&gt; 		boolean shadowIsInAroundAdvice = false;
&gt; 		if (encMethod!=null &amp;&amp; encMethod.getName().startsWith(NameMangler.PREFIX+"around")) {
&gt; 			shadowIsInAroundAdvice = true;
&gt; 		}
&gt; 		
&gt; 		if (getType().isInterface() || shadowIsInAroundAdvice) {
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java" revision="1.28" state="changed">290a291,308
&gt; 		generateMethod(classFile,methodBinding,null,gen);
&gt; 	}
&gt; 	
&gt; 	protected List makeEffectiveSignatureAttribute(ResolvedMember sig,Shadow.Kind kind,boolean weaveBody) {
&gt; 		List l = new ArrayList(1);
&gt; 		l.add(new EclipseAttributeAdapter(
&gt; 				new AjAttribute.EffectiveSignatureAttribute(sig, kind, weaveBody)));
&gt; 		return l;
&gt; 	}
&gt; 	
&gt; 	/*
&gt; 	 * additionalAttributes allows us to pass some optional attributes we want to attach to the method we generate.
&gt; 	 * Currently this is used for inline accessor methods that have been generated to allow private field references or
&gt; 	 * private method calls to be inlined (PR71377).  In these cases the optional attribute is an effective signature
&gt; 	 * attribute which means calls to these methods are able to masquerade as any join point (a field set, field get or
&gt; 	 * method call).  The effective signature attribute is 'unwrapped' in BcelClassWeaver.matchInvokeInstruction()
&gt; 	 */
&gt; 	private void generateMethod(ClassFile classFile, MethodBinding methodBinding, List additionalAttributes/*ResolvedMember realMember*/, BodyGenerator gen) {
294c312,322
&lt; 		int attributeNumber = classFile.generateMethodInfoAttribute(methodBinding, AstUtil.getAjSyntheticAttribute());
---
&gt; 		
&gt; 		int attributeNumber;
&gt; 		if (additionalAttributes!=null) { // mini optimization
&gt; 			List attrs = new ArrayList();
&gt; 			attrs.addAll(AstUtil.getAjSyntheticAttribute());
&gt; 			attrs.addAll(additionalAttributes);
&gt; 			attributeNumber = classFile.generateMethodInfoAttribute(methodBinding, attrs);
&gt; 		} else {
&gt; 			attributeNumber = classFile.generateMethodInfoAttribute(methodBinding, AstUtil.getAjSyntheticAttribute());
&gt; 		}
&gt; 
647,649c675,679
&lt; 		final FieldBinding fieldBinding = factory.makeFieldBinding(field);
&lt; 		generateMethod(classFile, accessField.reader, 
&lt; 		new BodyGenerator() {
---
&gt; 		final FieldBinding fieldBinding = factory.makeFieldBinding(field);			
&gt; 			
&gt; 		generateMethod(classFile, accessField.reader,
&gt; 		  makeEffectiveSignatureAttribute(field,Shadow.FieldGet,false),
&gt; 		  new BodyGenerator() {
664c694,695
&lt; 		new BodyGenerator() {
---
&gt; 		  makeEffectiveSignatureAttribute(field,Shadow.FieldSet,false),
&gt; 		  new BodyGenerator() {
684,685c715,717
&lt; 		generateMethod(classFile, accessMethod, 
&lt; 		new BodyGenerator() {
---
&gt; 		generateMethod(classFile, accessMethod,
&gt; 		  makeEffectiveSignatureAttribute(method, Shadow.MethodCall, false),
&gt; 		  new BodyGenerator() {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.3" state="changed">28c28
&lt;     runTest("false ambigous binding error (introduced in 1.2rc2)");
---
&gt;     runTest("false ambiguous binding error (introduced in 1.2rc2)");
101a102,116
&gt;   
&gt;   public void test017_PrivateMethodCallsInAroundAdvice() {
&gt;     runTest("Cannot advise private method call in around advice");
&gt;     System.err.println(getLastRunResult().getStdErr());
&gt;   }
&gt;   
&gt;   public void test018_PrivateFieldSetsInAroundAdvice() {
&gt;     runTest("Cannot advise private field sets in around advice");
&gt;     System.err.println(getLastRunResult().getStdErr());
&gt;   }
&gt;   
&gt;   public void test019_PrivateFieldGetsInAroundAdvice() {
&gt;     runTest("Cannot advise private field gets in around advice");
&gt;     System.err.println(getLastRunResult().getStdErr());
&gt;   }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.3" state="changed">5c5
&lt; 		pr="62073" title="false ambigous binding error (introduced in 1.2rc2)"&gt;
---
&gt; 		pr="62073" title="false ambiguous binding error (introduced in 1.2rc2)"&gt;
140a141,157
&gt;     &lt;ajc-test dir="bugs/AroundAdviceJPs" pr="71377"
&gt;     	title="Cannot advise private method call in around advice"&gt;
&gt;     	&lt;compile files="JoinPointInAroundAdvice.java"/&gt;
&gt;     	&lt;run class="JoinPointInAroundAdvice"/&gt;
&gt;    	&lt;/ajc-test&gt;
&gt;     
&gt;    &lt;ajc-test dir="bugs/AroundAdviceJPs" pr="71377"
&gt;     	title="Cannot advise private field sets in around advice"&gt;
&gt;     	&lt;compile files="FieldJoinPointsInAroundAdvice.java"/&gt;
&gt;     	&lt;run class="FieldJoinPointsInAroundAdvice"/&gt;
&gt;    	&lt;/ajc-test&gt;
&gt;    	
&gt;    	&lt;ajc-test dir="bugs/AroundAdviceJPs" pr="71377"
&gt;     	title="Cannot advise private field gets in around advice"&gt;
&gt;     	&lt;compile files="FieldGetJoinPointsInAroundAdvice.java"/&gt;
&gt;     	&lt;run class="FieldGetJoinPointsInAroundAdvice"/&gt;
&gt;    	&lt;/ajc-test&gt;
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.aspectj/modules/tests/bugs/AroundAdviceJPs/JoinPointInAroundAdvice.java" revision="1.1" state="new">import java.util.*;

public aspect JoinPointInAroundAdvice {

	static int i = 0;
	static int j = 0;
	
	before () : call(* JoinPointInAroundAdvice.privateMethod(..)) {	i++; tjps.add(thisJoinPoint.getSourceLocation());}
	before () : call(* JoinPointInAroundAdvice.publicMethod(..))  { j++;}
	
	pointcut execTest () : execution(* JoinPointInAroundAdvice.test());
	
	before () : execTest() {
		privateMethod("before");
		publicMethod("before");
	}
	
	void around () : execTest() {
		privateMethod("around");
		publicMethod("around");
		proceed();
	}
	
	after () : execTest () {
		privateMethod("after");
		publicMethod("after");
	}
	
	private static List tjps = new ArrayList();
	
	private static void privateMethod(String from) { }//System.out.println("? privateMethod() " + from); }
	public  static void publicMethod(String from)  { }//System.out.println("? publicMethod() " + from);  }
	
	public static void test () {
      System.out.println("? test()");
	}
	
	public static void main (String[] args) {
		test();		
		if (i!=j || i!=3) throw new RuntimeException("Missing join point: private="+i+" public="+j);
		//System.err.println(tjps);
	}
}

</file>
<file name="org.aspectj/modules/tests/bugs/AroundAdviceJPs/FieldJoinPointsInAroundAdvice.java" revision="1.1" state="new">import java.util.*;

public aspect FieldJoinPointsInAroundAdvice {

	private static int secretField1;
	private int        secretField2;
	public  static int nonsecretField3;
	public  int        nonsecretField4;
	
	
	static int privateNonstaticFieldSets = 0;
	static int privateStaticFieldSets = 0;
	static int publicNonstaticFieldSets = 0;
	static int publicStaticFieldSets = 0;
	
	before () : cflow(adviceexecution()) &amp;&amp; set(private !static * *secret*)         { privateNonstaticFieldSets++; tjps.add(thisJoinPoint.getSourceLocation());}
	before () : cflow(adviceexecution()) &amp;&amp; set(private static * *secret*)  { privateStaticFieldSets++; tjps.add(thisJoinPoint.getSourceLocation());}
	before () : cflow(adviceexecution()) &amp;&amp; set(public !static * *secret*)         { publicNonstaticFieldSets++;}
	before () : cflow(adviceexecution()) &amp;&amp; set(public static * *secret*)  { publicStaticFieldSets++;}
	
	pointcut execTest () : execution(* FieldJoinPointsInAroundAdvice.test());
	
	before () : execTest() {
		secretField1++;
		secretField2++;
		nonsecretField3++;
		nonsecretField4++;
	}
	
	void around () : execTest() {
		secretField1++;
		secretField2++;
		nonsecretField3++;
		nonsecretField4++;
		proceed();
	}
	
	after () : execTest () {
		secretField1++;
		secretField2++;
		nonsecretField3++;
		nonsecretField4++;
	}
	
	private static List tjps = new ArrayList();
	
	public static void test () {
      System.out.println("? test()");
	}
	
	public static void main (String[] args) {
		test();		
		if (privateNonstaticFieldSets!=privateStaticFieldSets || 
		    privateStaticFieldSets!=publicStaticFieldSets ||
			publicStaticFieldSets!=publicNonstaticFieldSets) throw new RuntimeException(
					"\n privateNonstaticFieldSets="+privateNonstaticFieldSets+
					"\n publicNonstaticFieldSets="+publicNonstaticFieldSets+
					"\n privateStaticFieldSets="+privateStaticFieldSets+
					"\n publicStaticFieldSets="+publicStaticFieldSets);
		//System.err.println(tjps);
	}
}</file>
<file name="org.aspectj/modules/tests/bugs/AroundAdviceJPs/FieldGetJoinPointsInAroundAdvice.java" revision="1.1" state="new">import java.util.*;

public aspect FieldGetJoinPointsInAroundAdvice {

	private static int secretField1;
	private int        secretField2;
	public  static int nonsecretField3;
	public  int        nonsecretField4;
	
	
	static int privateNonstaticFieldGets = 0;
	static int privateStaticFieldGets = 0;
	static int publicNonstaticFieldGets = 0;
	static int publicStaticFieldGets = 0;
	
	before () : cflow(adviceexecution()) &amp;&amp; get(private !static * *secret*)         { privateNonstaticFieldGets++; tjps.add(thisJoinPoint.getSourceLocation());}
	before () : cflow(adviceexecution()) &amp;&amp; get(private static * *secret*)  { privateStaticFieldGets++;}
	before () : cflow(adviceexecution()) &amp;&amp; get(public !static * *secret*)         { publicNonstaticFieldGets++;}
	before () : cflow(adviceexecution()) &amp;&amp; get(public static * *secret*)  { publicStaticFieldGets++;}
	
	pointcut execTest () : execution(* FieldGetJoinPointsInAroundAdvice.test());
	
	before () : execTest() {
		int i = secretField1;
		i=secretField2;
		i=nonsecretField3;
		i=nonsecretField4;
	}
	
	void around () : execTest() {
		int i=secretField1;
		i=secretField2;
		i=nonsecretField3;
		i=nonsecretField4;
		proceed();
	}
	
	after () : execTest () {
		int i=secretField1;
		i=secretField2;
		i=nonsecretField3;
		i=nonsecretField4;
	}
	
	private static List tjps = new ArrayList();
	
	public static void test () {
      System.out.println("? test()");
	}
	
	public static void main (String[] args) {
		test();		
		if (privateNonstaticFieldGets!=privateStaticFieldGets || 
		    privateStaticFieldGets!=publicStaticFieldGets ||
			publicStaticFieldGets!=publicNonstaticFieldGets) throw new RuntimeException(
					"\n privateNonstaticFieldGets="+privateNonstaticFieldGets+
					"\n publicNonstaticFieldGets="+publicNonstaticFieldGets+
					"\n privateStaticFieldGets="+privateStaticFieldGets+
					"\n publicStaticFieldGets="+publicStaticFieldGets);
		//System.err.println(tjps);
	}
}</file>
</fixedFiles>
</bug>
<bug id="71723" transactionid="70988">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="0"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="0"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-false K-if K-noop K-return O-!= T V Z-if</fullfingerprint>
<bugreport>When introducing new member functions to existing classes via inter-type
declarations, the scoping rules that apply to the ITD bodies are the same as for
the aspect - for example, private members of the target class cannot be accessed
unless the aspect is privileged.

Similarly, protected members of classes in different packages should not be
visible in ITDs unless the aspect is privileged.

This rule is only enforced for protected members declared in the target class -
protected members that are inherited are visible from ITDs in aspects in
different packages.

The following is an example of this:

----------------------
package foo;

public class Foo extends AncientFoo {
    protected int i() { return 42; }
    public static void main(String[] args) {
	new Foo().doStuff();
    }
    public void doStuff() { }
    protected int ancientI() { return 42; }
}

class AncientFoo {
    protected int ancientI() { return -42; }
    protected int ancientJ() { return 0; }
}
----------

package bar;
import foo.Foo;

aspect Bar {
    public void Foo.doing() {
	try {
	    System.out.println(i()); // fails in ajc
	    System.out.println(ancientI()); // fails in ajc
	    System.out.println(ancientJ()); // succeeds
	    System.out.println(clone()); // succeeds
	}
	catch(Throwable t) { }
    }
    before(Foo f) : call(* doStuff(..)) &amp;&amp; target(f) {
	f.doing();
    }
}
-------------------

All four calls in Foo.doing() should fail, as they refer to protected members of
foo.Foo from package bar. However, only the first 2 - the ones directly
declared/overridden in foo.Foo - are detected as errors, and removing them makes
the rest compile and execute.

Best wishes,
Pavel</bugreport>
<pre-fix-testcases failing="113" file="output/71723/pre-fix/testresults.xml" passing="1262" size="1375"/>
<post-fix-testcases failing="112" file="output/71723/post-fix/testresults.xml" passing="1264" size="1376"/>
<fixedFiles>
<file name="org.aspectj/modules/org.eclipse.jdt.core/jdtcore-for-aspectj.jar" revision="1.17" state="changed"/>
<file name="org.aspectj/modules/org.eclipse.jdt.core/jdtcore-for-aspectj-src.zip" revision="1.17" state="changed"/>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.19" state="changed">239d238
&lt;   
243a243,246
&gt;   public void test045_ITDprotectedVisibility() {
&gt;   	runTest("Inconsistency in scoping of protected members in ITDs");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.20" state="changed">347a348,357
&gt; 	&lt;ajc-test dir="bugs/pr71723" pr="71723"
&gt; 	  	title="Inconsistency in scoping of protected members in ITDs"&gt;
&gt; 		&lt;compile files="foo/Foo.java,bar/Bar.aj"&gt;
&gt; 			&lt;message kind="error" line="8" text="The method i() from the type Foo is not visible"/&gt;
&gt; 			&lt;message kind="error" line="9" text="The method ancientI() from the type Foo is not visible"/&gt;
&gt; 			&lt;message kind="error" line="10" text="The method ancientJ() from the type AncientFoo is not visible"/&gt;
&gt; 			&lt;message kind="error" line="11" text="The method clone() from the type Object is not visible"/&gt;
&gt; 			&lt;message kind="error" line="12" text="The method clone() from the type Object is not static"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.aspectj/modules/tests/bugs/pr71723/bar/Bar.aj" revision="1.1" state="new">package bar;

import foo.Foo;

aspect Bar {
    public void Foo.doing() {
try {
    System.out.println(i()); // CE L8
    System.out.println(ancientI()); // CE L9
    System.out.println(ancientJ()); // CE L10
    System.out.println(this.clone()); // CE L11
    System.out.println(clone()); // CE L12
}
catch(Throwable t) { }
    }
    before(Foo f) : call(* doStuff(..)) &amp;&amp; target(f) {
        f.doing();
    }
}


privileged aspect PBar {
    public void Foo.doingMore() {
try {
    System.out.println(i());
    System.out.println(ancientI());
    System.out.println(ancientJ()); 
 }
catch(Throwable t) { }
    }
    before(Foo f) : call(* doStuff(..)) &amp;&amp; target(f) {
        f.doing();
    }
}


</file>
<file name="org.aspectj/modules/tests/bugs/pr71723/foo/Foo.java" revision="1.1" state="new">package foo;



public class Foo extends AncientFoo {
    protected int i() { return 42; }
    public static void main(String[] args) {
        new Foo().doStuff();
    }
    public void doStuff() { }
    protected int ancientI() { return 42; }
}

class AncientFoo {
    protected int ancientI() { return -42; }
    protected int ancientJ() { return 0; }
}</file>
</fixedFiles>
</bug>
<bug id="71811" transactionid="74112">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="15"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="15"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-true M T V Y Z-if</fullfingerprint>
<bugreport>ajdoc doesn't support the -encoding -docencoding and -charset options of javadoc.

Especially, it doesn't pass on the -encoding to ajc.
If your project uses a source file encoding (e.g. UTF-8) 
differing form the platform standard, and some java identifiers 
use characters byond the standard ASCII range, you won't be able 
to use ajdoc at all.</bugreport>
<testsforfix ID="71811" type="new">
    <file LOCATION="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
      <test NAME="testOptions"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="113" file="output/71811/pre-fix/testresults.xml" passing="1265" size="1378"/>
<post-fix-testcases failing="111" file="output/71811/post-fix/testresults.xml" passing="1266" size="1377"/>
<fixedFiles>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/Main.java" revision="1.17" state="changed">497a498,512
&gt;             else if ( arg.equals( "-encoding" ) ) {
&gt;                 addNextAsOption = true;
&gt;                 addNextToAJCOptions = false;
&gt;                 options.addElement( arg );
&gt;             }
&gt;             else if ( arg.equals( "-docencoding" ) ) {
&gt;                 addNextAsOption = true;
&gt;                 addNextToAJCOptions = false;
&gt;                 options.addElement( arg );
&gt;             }
&gt;             else if ( arg.equals( "-charset" ) ) {
&gt;                 addNextAsOption = true;
&gt;                 addNextToAJCOptions = false;
&gt;                 options.addElement( arg );
&gt;             }
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java" revision="1.8" state="changed">38a39,56
&gt; 	public void testOptions() {
&gt; 		outdir.delete();
&gt; 		String[] args = { 
&gt; 			"-private",
&gt; 			"-encoding",
&gt; 			"EUCJIS",
&gt; 			"-docencoding",
&gt; 			"EUCJIS",
&gt; 			"-charset",
&gt; 			"UTF-8",
&gt; 			"-d", 
&gt; 			outdir.getAbsolutePath(),
&gt; 			file0.getAbsolutePath(), 
&gt; 		};
&gt; 		org.aspectj.tools.ajdoc.Main.main(args);
&gt; 	    assertTrue(true);
&gt; 	}
&gt; 	
62c80
&lt; 
---
&gt; 	
</file>
</fixedFiles>
</bug>
<bug id="71878" transactionid="69959">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new M O-== O-- O-+ T V Y Z-if</fullfingerprint>
<bugreport>If you checkout the "JarUsingProject" project from "org.eclipse.ajdt.test/manual
testing" in the AJDT 1.1.12 tree, and look at the advised-by entries in the
outline view and the context menu of the gutter annotation, on Windows you get
"injar aspect: AbstractAspect.aj", but on Linux you get "injar aspect:
C:\eclipse30AJDTPluginTest\eclipse\workspace\JarGeneratingProject\src\p1\AbstractAspect.aj".
The Windows-style path indicates the location of the original class files in the
JAR file, which was clearly built on Windows.</bugreport>
<pre-fix-testcases failing="112" file="output/71878/pre-fix/testresults.xml" passing="1247" size="1359"/>
<post-fix-testcases failing="113" file="output/71878/post-fix/testresults.xml" passing="1246" size="1359"/>
<fixedFiles>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java" revision="1.10" state="changed">243c243,248
&lt; 		String fileName = new File(sourceFilePath).getName();
---
&gt; 		// SourceFilePath might have originated on windows on linux...
&gt; 		int lastSlash = sourceFilePath.lastIndexOf('\\');
&gt; 		if (lastSlash == -1) {
&gt; 			lastSlash = sourceFilePath.lastIndexOf('/');
&gt; 		}
&gt; 		String fileName = sourceFilePath.substring(lastSlash+1);
</file>
</fixedFiles>
</bug>
<bug id="72150" transactionid="70186">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="7"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-return M O-== O-- O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>AJC fails to find nested static classes during binary-weaving analysis if the 
classes have been previously compiled with J2SE5.0 javac compiler with 
options: -source 1.5/ - target 1.5
Note, that the nested static classes are not necessarily subject to bytecode 
weaving - AJC merely fails to detect them in the JARS for its analysis.

This issue disappears when the .java sources are pre-compiled with -
source/target 1.4, regardless if the javac compiler comes from the J2SE1.4 or 
J2SE5.0 distribution.

This issue is distinct form Bug #71548, since no 5.0 source code processing is 
required from AJC ever.

Thanks,
Hristo</bugreport>
<testsforfix ID="72150" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test051_arrayCloningInJava5"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="AJC possible bug with static nested classes"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/72150/pre-fix/testresults.xml" passing="1275" size="1387"/>
<post-fix-testcases failing="112" file="output/72150/post-fix/testresults.xml" passing="1276" size="1388"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/TypeX.java" revision="1.10" state="changed">586,587c586,592
&lt;         if (name.length() != 0)  // lots more tests could be made here...
&lt;             return "L" + name.replace('.', '/') + ";";
---
&gt;         if (name.length() != 0) {
&gt;         	// lots more tests could be made here...
&gt;         	
&gt;         	// 1) If it is already an array type, do not mess with it.
&gt;         	if (name.charAt(0)=='[' &amp;&amp; name.charAt(name.length()-1)==';') return name;
&gt;         	else return "L" + name.replace('.', '/') + ";";
&gt;         }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.25" state="changed">414a415,420
&gt; 	
&gt; 	&lt;ajc-test dir="bugs/java5/arrayCloning" pr="72150"
&gt; 	   title="AJC possible bug with static nested classes"&gt;
&gt; 	   &lt;compile files="A.java" inpath="OneFiveCode.jar"/&gt;
&gt; 	   &lt;!--run class="C"/--&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.23" state="changed">269a270,273
&gt; 
&gt;   public void test051_arrayCloningInJava5() {
&gt;     runTest("AJC possible bug with static nested classes");
&gt;   }
</file>
<file name="org.aspectj/modules/tests/bugs/java5/arrayCloning/C.java" revision="1.1" state="new">import java.lang.reflect.*;

class C {

  public static B.D[] arr = new B.D[5];

  public static void main(String[]argv) {
    arr[0] = new B.D(42);
    arr[1] = new B.D(22);
    arr[2] = new B.D(46);
    arr[3] = new B.D(50);
    arr[4] = new B.D(54);

    B.D[] arr2 = arr.clone();


    // Check the clone is OK
    if (arr2[0].i!=42) throw new RuntimeException("Call that a clone 0");
    if (arr2[1].i!=22) throw new RuntimeException("Call that a clone 1");
    if (arr2[2].i!=46) throw new RuntimeException("Call that a clone 2");
    if (arr2[3].i!=50) throw new RuntimeException("Call that a clone 3");
    if (arr2[4].i!=54) throw new RuntimeException("Call that a clone 4");
    System.err.println("Clone OK - attempting value manipulation");

    // Change the clone, check the original is OK
    arr2[2] = new B.D(1);
    if (arr[2].i == 1)  throw new RuntimeException("Shouldnt have affected original");
    if (arr2[2].i != 1) throw new RuntimeException("Should have affected clone");


    System.err.println("Clone OK - finished");
  }
}


class B {
  public static class D {
    public int i;
    D(int x) { i=x;}
  }
}
</file>
<file name="org.aspectj/modules/tests/bugs/java5/arrayCloning/OneFiveCode.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/bugs/java5/arrayCloning/explanation.txt" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/bugs/java5/arrayCloning/A.java" revision="1.1" state="new">aspect A {
  Object around(): call(* clone(..)) {
    return proceed();
  }
}

</file>
<file name="org.aspectj/modules/tests/bugs/java5/arrayCloning/rebuild.bat" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="72154" transactionid="69297">
<property name="files-churned" value="6"/>
<property name="java-files-churned" value="6"/>
<property name="classes-churned" value="6"/>
<property name="methods-churned" value="6"/>
<property name="hunks" value="20"/>
<property name="lines-added" value="405"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="18"/>
<property name="lines-churned" value="424"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-else K-false K-finally K-for K-if K-import K-instanceof K-interface K-new K-null K-package K-return K-this K-throw K-true K-try K-while M O-&lt; O-== O-&gt; O-|| O-! O-!= O-() O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-cond Z-for Z-if Z-throw Z-vardecl</fullfingerprint>
<bugreport>When the compiler terminates abnormally (exception) or behaves unexpectedly 
(warning/error/abort) a simple dump of the compiler state should be produced 
to aid problem diagnosis. The content and conditions under which the dump is 
produced should be configurable by the user but the facility should be enabled 
by default for exceptions. Consequently its inclusion should have negligible 
impact on compiler performance and footprint. The file should be attached to 
bug reports to give a complete and objective description of the users 
environment and support problem resolution where a testcase cannot be provided.

One approach is to write a uniquely name file (using date &amp; time) in the 
current directory e.g ajcore.20040818.105200.txt which should be human 
readable (it can be zipped if large) to allow the user to potentially diagnose 
their own problems or remove potentially sensitive data before submission. It 
should contain basic information such as AspectJ version, system properties 
and command line as well as failure information such as _full_ exception stack 
trace, compiler messages and internal compiler state.</bugreport>
<testsforfix ID="72154" type="new">
    <file LOCATION="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.java">
      <test NAME="testDump"/>
      <test NAME="testDumpWithWarnings"/>
      <test NAME="testWithErrors"/>
    </file>
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/DumpTestCase.java">
      <test NAME="testSetDumpOnException"/>
      <test NAME="testSetDumpOnExit"/>
      <test NAME="testDump"/>
      <test NAME="testDumpWithException"/>
      <test NAME="testDumpOnExit"/>
      <test NAME="testDumpOnExitExcluded"/>
      <test NAME="testDumpOnExitIncluded"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/72154/pre-fix/testresults.xml" passing="1265" size="1377"/>
<post-fix-testcases failing="112" file="output/72154/post-fix/testresults.xml" passing="1273" size="1385"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.21" state="changed">15a16
&gt; import java.util.ArrayList;
18a20
&gt; import java.util.LinkedList;
33c35
&lt; public abstract class World {
---
&gt; public abstract class World implements Dump.INode {
46a49,50
&gt;     
&gt;     private List dumpState_cantFindTypeExceptions = null;
49a54
&gt;         Dump.registerNode(this.getClass(),this);
59a65,76
&gt;     
&gt;     public void accept (Dump.IVisitor visitor) {
&gt; 		visitor.visitString("Shadow mungers:");
&gt; 		visitor.visitList(crosscuttingMembersSet.getShadowMungers());
&gt; 		visitor.visitString("Type mungers:");
&gt; 		visitor.visitList(crosscuttingMembersSet.getTypeMungers());
&gt;         if (dumpState_cantFindTypeExceptions!=null) {
&gt;           visitor.visitString("Cant find type problems:");
&gt;           visitor.visitList(dumpState_cantFindTypeExceptions);
&gt;           dumpState_cantFindTypeExceptions = null;
&gt;         }
&gt;     }
113d129
&lt;             	//Thread.currentThread().dumpStack();
116c132,135
&lt;                 // + " on classpath " + classPath);
---
&gt;                 if (dumpState_cantFindTypeExceptions==null) {
&gt;                   dumpState_cantFindTypeExceptions = new ArrayList();   
&gt;                 }
&gt;                 dumpState_cantFindTypeExceptions.add(new RuntimeException("Can't find type "+ty.getName()));
226,237c245,256
&lt;     public static final World EMPTY = new World() {
&lt;         public List getShadowMungers() { return Collections.EMPTY_LIST; }
&lt;         public ResolvedTypeX.ConcreteName resolveObjectType(ResolvedTypeX.Name ty) {
&lt;             return null;
&lt;         }
&lt;         public Advice concreteAdvice(AjAttribute.AdviceAttribute attribute, Pointcut p, Member m) {
&lt;             throw new RuntimeException("unimplemented");
&lt;         }
&lt;         public ConcreteTypeMunger concreteTypeMunger(ResolvedTypeMunger munger, ResolvedTypeX aspectType) {
&lt;             throw new RuntimeException("unimplemented");
&lt;         }        
&lt;     };
---
&gt; //    public static final World EMPTY = new World() {
&gt; //        public List getShadowMungers() { return Collections.EMPTY_LIST; }
&gt; //        public ResolvedTypeX.ConcreteName resolveObjectType(ResolvedTypeX.Name ty) {
&gt; //            return null;
&gt; //        }
&gt; //        public Advice concreteAdvice(AjAttribute.AdviceAttribute attribute, Pointcut p, Member m) {
&gt; //            throw new RuntimeException("unimplemented");
&gt; //        }
&gt; //        public ConcreteTypeMunger concreteTypeMunger(ResolvedTypeMunger munger, ResolvedTypeX aspectType) {
&gt; //            throw new RuntimeException("unimplemented");
&gt; //        }        
&gt; //    };
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java" revision="1.17" state="changed">17a18
&gt; import org.aspectj.weaver.Dump;
108,111c109,114
&lt;             return ((repeat 
&lt;                         ? buildManager.incrementalBuild(config, handler)
&lt;                         : buildManager.batchBuild(config, handler))
&lt;                     &amp;&amp; !counter.hasErrors());
---
&gt;             boolean result = ((repeat 
&gt;                         		? buildManager.incrementalBuild(config, handler)
&gt;                         		: buildManager.batchBuild(config, handler))
&gt;                     		   &amp;&amp; !counter.hasErrors());
&gt; 			Dump.dumpOnExit();
&gt; 			return result;
121a125
&gt; 			Dump.dumpWithException(t);
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java" revision="1.27" state="changed">34a35
&gt; import org.aspectj.weaver.Dump;
270a272
&gt;     	Dump.saveMessageHolder(holder);
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.29" state="changed">22a23
&gt; import org.aspectj.weaver.Dump;
110c111,112
&lt; 	public AjBuildConfig populateBuildConfig(AjBuildConfig buildConfig, String[] args, boolean setClasspath, File configFile) {		
---
&gt; 	public AjBuildConfig populateBuildConfig(AjBuildConfig buildConfig, String[] args, boolean setClasspath, File configFile) {
&gt; 		Dump.saveCommandLine(args);	
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.60" state="changed">32a33
&gt; import org.aspectj.weaver.Dump;
650a652
&gt; 		Dump.saveFullClasspath(cps);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/DumpTestCase.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster 
 *******************************************************************************/
package org.aspectj.weaver;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.sql.Savepoint;

import org.aspectj.bridge.IMessage;
import org.aspectj.bridge.IMessageHolder;
import org.aspectj.bridge.Message;
import org.aspectj.bridge.MessageHandler;
import org.aspectj.util.FileUtil;

import sun.security.krb5.internal.crypto.d;

import junit.framework.TestCase;

/**
 * @author websterm
 *
 * Test Dump facility. Ensure it can be configured and files contain expected contents. Testcase 
 * returns Dump configuration to orginal state.
 */
public class DumpTestCase extends TestCase {

	private File dumpFile;
	private IMessage.Kind savedDumpCondition;

	public DumpTestCase(String name) {
		super(name);
	}

	protected void setUp() throws Exception {
		super.setUp();
		
		dumpFile = null;
		savedDumpCondition = Dump.getDumpOnExit();
	}

	protected void tearDown() throws Exception {
		super.tearDown();
		
		if (dumpFile != null &amp;&amp; dumpFile.exists()) {
			boolean deleted = dumpFile.delete();
			assertTrue("Dump file '" + dumpFile.getPath() + "' could not be deleted",deleted);
		} 
		Dump.setDumpOnExit(savedDumpCondition);
	}

	public void testSetDumpOnException () {
		Dump.setDumpOnException(true);
		assertTrue("DumpOnException should be true",Dump.getDumpOnException());
	}
	
	public void testSetDumpOnExit () {
		assertTrue("Should be able to set condition 'error'",Dump.setDumpOnExit("error"));
		assertTrue("Should be able to set condition 'warning'",Dump.setDumpOnExit("warning"));
		assertFalse("Should not be able to set condition 'junk'",Dump.setDumpOnExit("junk"));
	}
	
	public void testDump () {
		String fileName = Dump.dump("testDump()");
		dumpFile = new File(fileName);
		assertTrue("Dump file '" + fileName + "' should exist",dumpFile.exists());
	}
	
	public void testDumpWithException () {
		String message = "testDumpWithException()";
		String fileName = recursiveCall(message,100);
		dumpFile = new File(fileName);
		assertContents(dumpFile,"Exception Information",message);
	}
	
	public void testDumpOnExit () {
		Dump.setDumpOnExit("abort");
		Dump.saveMessageHolder(null);
		String fileName = Dump.dumpOnExit();
		dumpFile = new File(fileName);
		assertTrue("Dump file '" + fileName + "' should exist",dumpFile.exists());
	}
	
	public void testDumpOnExitExcluded () {
		Dump.setDumpOnExit("abort");
		IMessageHolder holder = new MessageHandler();
		Dump.saveMessageHolder(holder);
		holder.handleMessage(new Message("testDumpOnExitExcluded()",IMessage.ERROR,null,null));
		String fileName = Dump.dumpOnExit();
		dumpFile = new File(fileName);
		assertEquals("Dump '" + fileName + "' should be excluded",Dump.DUMP_EXCLUDED,fileName);
	}
	
	public void testDumpOnExitIncluded () {
		Dump.setDumpOnExit("error");
		IMessageHolder holder = new MessageHandler();
		Dump.saveMessageHolder(holder);
		IMessage error = new Message("testDumpOnExitIncluded()",IMessage.ERROR,null,null);
		holder.handleMessage(error);
		String fileName = Dump.dumpOnExit();
		dumpFile = new File(fileName);
		assertContents(dumpFile,"Compiler Messages",error.getMessage());
	}
	
	/* Ensure dump file exists and contains certain contents under a given heading */
	public static void assertContents (File dumpFile, String heading, String contents) {
		assertTrue("Dump file '" + dumpFile.getPath() + "' should exist",dumpFile.exists());
		assertTrue("Dump file '" + dumpFile.getPath()+ "' should contain '" + contents + "'",fileContains(dumpFile,heading,contents));
	}
	
	private static boolean fileContains (File dumpFile, String heading, String contents) {
		boolean result = false;
		
		try { 
			BufferedReader reader = new BufferedReader(new FileReader(dumpFile));
			String currentHeading = "";
			String record;
			while ((null != (record = reader.readLine())) &amp;&amp; (result == false)) {
				if (record.startsWith("----")) currentHeading = record;
				else if ((record.indexOf(contents) != -1) &amp;&amp; currentHeading.indexOf(heading) != -1) result = true;
			}
			reader.close();
		}
		catch (IOException ex) {
			fail(ex.toString());
		}
		
		return result;
	}
	
	/* Generate a big stack trace */
	private String recursiveCall (String message, int depth) {
		if (depth == 0) {
			Throwable th = new RuntimeException(message);
			return Dump.dumpWithException(th);
		}
		else {
			return recursiveCall(message,--depth);
		}
	}

}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java" revision="1.6" state="changed">33a34
&gt;         suite.addTestSuite(CompilerDumpTestCase.class); 
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package org.aspectj.ajdt.internal.compiler.batch;

import java.io.File;

import org.aspectj.bridge.IMessage;
import org.aspectj.tools.ajc.AjcTestCase;
import org.aspectj.tools.ajc.CompilationResult;
import org.aspectj.weaver.Dump;

import junit.framework.TestCase;

public class CompilerDumpTestCase extends AjcTestCase {

	public static final String PROJECT_DIR = "DumpTestCase";

	private File baseDir;
	private File dumpFile;
	private IMessage.Kind savedDumpCondition;
	
	protected void setUp() throws Exception {
		super.setUp();

		baseDir = new File("../org.aspectj.ajdt.core/testdata",PROJECT_DIR);
		dumpFile = null;
		savedDumpCondition = Dump.getDumpOnExit();
	}

	protected void tearDown() throws Exception {
		super.tearDown();
		
		if (dumpFile != null &amp;&amp; dumpFile.exists()) {
			boolean deleted = dumpFile.delete();
			assertTrue("Dump file '" + dumpFile.getPath() + "' could not be deleted",deleted);
		} 
		Dump.setDumpOnExit(savedDumpCondition);
	}

	/**
	 * Aim: Dump after successful compile to ensure it contains the command 
	 * line information.
	 * 
	 * Inputs to the compiler:
	 *   HelloWorld.java Pointcuts.aj Aspect.aj
	 * 
	 * Expected result = Compile succeeds.
	 */
	public void testDump () {
		String[] args = new String[] { "src/HelloWorld.java", "src/Pointcuts.aj", "src/Aspect.aj" };
		CompilationResult result = ajc(baseDir,args);
		assertNoMessages(result);
		String fileName = Dump.dump("DumpTestCase.testDump()");
		dumpFile = new File(fileName);
		org.aspectj.weaver.DumpTestCase.assertContents(dumpFile,"Command Line","HelloWorld.java");
	}
	
	/**
	 * Aim: Dump after successful compile to ensure it contains warning 
	 * messages. 
	 * 
	 * Inputs to the compiler:
	 *   HelloWorld.java Pointcuts.aj Aspect.aj DeclareWarning.aj
	 * 
	 * Expected result = Compile succeeds.
	 */
	public void testDumpWithWarnings () {
		String[] args = new String[] { "src/HelloWorld.java", "src/Pointcuts.aj", "src/DeclareWarning.aj" };
		CompilationResult result = ajc(baseDir,args);
		String fileName = Dump.dump("DumpTestCase.testDumpWithWarnings()");
		dumpFile = new File(fileName);
		org.aspectj.weaver.DumpTestCase.assertContents(dumpFile,"Compiler Messages","warning");
	}
	
	/**
	 * Aim: Dump due to errors. 
	 * 
	 * Inputs to the compiler:
	 *   HelloWorld.java Pointcuts.aj Aspect.aj DeclareError.aj
	 * 
	 * Expected result = Compile fails and dump file created.
	 */
	public void testWithErrors () {
		Dump.setDumpOnExit(IMessage.ERROR);
		String previousFileName = Dump.getLastDumpFileName();
		String[] args = new String[] { "src/HelloWorld.java", "src/Pointcuts.aj", "src/DeclareError.aj" };
		CompilationResult result = ajc(baseDir,args);
		String fileName = Dump.getLastDumpFileName();
		assertTrue("Dump file should be created",!fileName.equals(previousFileName));
		dumpFile = new File(fileName);
		org.aspectj.weaver.DumpTestCase.assertContents(dumpFile,"Compiler Messages","error");
	}

}
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/BcweaverTests.java" revision="1.8" state="changed">56a57
&gt; 		suite.addTestSuite(DumpTestCase.class);
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/DumpTestCase/src/HelloWorld.java" revision="1.1" state="new">public class HelloWorld {

	public static void main(String[] args) {
		System.out.println("Hello World!");
	}
}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/DumpTestCase/src/Pointcuts.aj" revision="1.1" state="new">public class Pointcuts {&#13;
	&#13;
	public pointcut main () :&#13;
		execution(void main(String[]));&#13;
}&#13;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Dump.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster 
 * ******************************************************************/
package org.aspectj.weaver;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.aspectj.bridge.IMessage;
import org.aspectj.bridge.IMessageHolder;
import org.aspectj.bridge.Version;

/**
 * @author websterm
 *
 * To change the template for this generated type comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
public class Dump {

	/* Format for unique filename based on date &amp; time */
	private static final String FILENAME_PREFIX = "ajcore";
	private static final DateFormat dateFormat = new SimpleDateFormat("yyyyMMdd"); 
	private static final DateFormat timeFormat = new SimpleDateFormat("HHmmss.SSS"); 
	private static final String FILENAME_SUFFIX = "txt";
	
	public static final String UNKNOWN_FILENAME = "Unknown";
	public static final String DUMP_EXCLUDED = "Excluded";
	public static final String NULL_OR_EMPTY = "Empty";
	
	private static Class exceptionClass;
	private static IMessage.Kind conditionKind = IMessage.ABORT;

	private String reason;
	private String fileName;
	private PrintStream print;
	
	private static String[] savedCommandLine;
	private static List savedFullClasspath;
	private static IMessageHolder savedMessageHolder;
	
	private static Map nodes = new HashMap();
	private static String lastDumpFileName = UNKNOWN_FILENAME;
	
	/*
	 * Dump methods
	 */
	public static String dump (String reason) {
		String fileName = UNKNOWN_FILENAME;
		Dump dump = null;
		try {
			dump = new Dump(reason);
			fileName = dump.getFileName();
			dump.dumpDefault();
		}
		finally {
			if (dump != null) dump.close();
		}
		return fileName;
	}
	
	public static String dumpWithException (Throwable th) {
		String fileName = UNKNOWN_FILENAME;
		Dump dump = null;
		try {
			dump = new Dump(th.getClass().getName());
			fileName = dump.getFileName();
			dump.dumpException(th);
		}
		finally {
			if (dump != null) dump.close();
		}
		return fileName;
	}

	public static String dumpOnExit () {
		if (!shouldDumpOnExit()) return DUMP_EXCLUDED;
		
		String fileName = UNKNOWN_FILENAME;
		Dump dump = null;
		try {
			dump = new Dump(conditionKind.toString());
			fileName = dump.getFileName();
			dump.dumpDefault();
		}
		finally {
			if (dump != null) dump.close();
		}
		return fileName;
	}

	private static boolean shouldDumpOnExit () {
		return (savedMessageHolder == null) || savedMessageHolder.hasAnyMessage(conditionKind,true);
	}

	/*
	 * Dump configuration
	 */
	public static void setDumpOnException (boolean b) {
		if (b) {
			exceptionClass = java.lang.Throwable.class;
		}
		else {
			exceptionClass = null;
		}
	}
	
	public static boolean getDumpOnException () {
		return (exceptionClass != null);
	}

	public static boolean setDumpOnExit (IMessage.Kind condition) {
		conditionKind = condition;
		return true;
	}

	public static boolean setDumpOnExit (String condition) {
		for (Iterator i = IMessage.KINDS.iterator(); i.hasNext();) {
			IMessage.Kind kind = (IMessage.Kind)i.next();
			if (kind.toString().equals(condition)) {
				return setDumpOnExit(kind);
			}
		}
		return false;
	}
	
	public static IMessage.Kind getDumpOnExit () {
		return conditionKind; 
	}
	
	public static String getLastDumpFileName () {
		return lastDumpFileName;
	}

	/*
	 * Dump registration
	 */
	public static void saveCommandLine (String[] args) {
		savedCommandLine = new String[args.length];
		System.arraycopy(args,0,savedCommandLine,0,args.length); 
	}

	public static void saveFullClasspath (List list) {
		savedFullClasspath = list;
	}

	public static void saveMessageHolder (IMessageHolder holder) {
		savedMessageHolder = holder;
	}

	public static void registerNode (Class module, INode newNode) {
		nodes.put(module,newNode);
	}
	
	/*
	 * Dump methods
	 */
	private Dump (String reason) {
		this.reason = reason;
		
		openDump();
		dumpAspectJProperties();
		dumpDumpConfiguration();
	}

	public String getFileName() {
		return fileName;
	}
	
	private void dumpDefault () {
		dumpSytemProperties();
		dumpCommandLine();
		dumpFullClasspath();
		dumpCompilerMessages();
		
		/*
		 * Dump registered nodes
		 */
		IVisitor dumpVisitor = new IVisitor() {

			public void visitString (String s) {
				println(s);
			}

			public void visitList (List list) {
				println(list);
			}
		};
		for (Iterator i = nodes.keySet().iterator(); i.hasNext();) {
			Class module = (Class)i.next();
			println("---- " + module.getName() + " ----");
			INode dumpNode = (INode)nodes.get(module);
			try {
				dumpNode.accept(dumpVisitor); 
			}
			catch (Exception ex) {
				println(ex.toString());
			}
		}
	}
	
	private void dumpException (Throwable th) {
		println("---- Exception Information ---");
		println(th);
		dumpDefault();
	}
	
	private void dumpAspectJProperties () {
		println("---- AspectJ Properties ---");
		println("AspectJ Compiler " + Version.text + " built on " + Version.time_text);
	}
	
	private void dumpDumpConfiguration () {
		println("---- Dump Properties ---");
		println("Dump file: " + fileName);
		println("Dump reason: " + reason);
		println("Dump on exception: " + (exceptionClass != null));
		println("Dump at exit condition: " + conditionKind);
	}
	
	private void dumpFullClasspath () {
		println("---- Full Classpath ---");
		if (savedFullClasspath != null &amp;&amp; savedFullClasspath.size() &gt; 0) {
			for (Iterator iter = savedFullClasspath.iterator(); iter.hasNext(); ) {
				String fileName = (String)iter.next();
				File file = new File(fileName);
				println(file);
			}
		}
		else {
			println(NULL_OR_EMPTY);
		}
	}
	
	private void dumpSytemProperties () {
		println("---- System Properties ---");
		Properties props = System.getProperties();
		println(props);
	}
	
	private void dumpCommandLine () {
		println("---- Command Line ---");
		println(savedCommandLine);
	}
	
	private void dumpCompilerMessages () {
		println("---- Compiler Messages ---");
		if (savedMessageHolder != null) for (Iterator i = savedMessageHolder.getUnmodifiableListView().iterator(); i.hasNext(); ) {
			IMessage message = (IMessage)i.next();
			println(message.toString());
		}
		else {
			println(NULL_OR_EMPTY);
		}
	}

	/*
	 * Dump output
	 */	
	private void openDump () {
		if (print != null) return;
		
		Date now = new Date();
		fileName = FILENAME_PREFIX + "."
			+ dateFormat.format(now) + "."
			+ timeFormat.format(now) + "."
			+ FILENAME_SUFFIX;
		try {
			print = new PrintStream(new FileOutputStream(fileName),true);
			System.out.println("Dumping to " + fileName);
		}
		catch (FileNotFoundException ex) {
			print = System.err;
			System.out.println("Dumping to stderr");
			fileName = UNKNOWN_FILENAME;
		}
		
		lastDumpFileName = fileName;
	}
	
	public void close () {
		print.close();
	}
	
	private void println (String s) {
		print.println(s);
	}
	
	private void println (Object[] array) {
		if (array == null) {
			println(NULL_OR_EMPTY);
			return;
		}
		
		for (int i = 0; i &lt; array.length; i++) {
			print.println(array[i]);
		}
	}
	
	private void println (Properties props) {
		Iterator iter = props.keySet().iterator();
		while (iter.hasNext()) {
			String key = (String)iter.next();
			String value = props.getProperty(key);
			print.println(key + "=" + value);
		}
	}
	
	private void println (Throwable th) {
		th.printStackTrace(print);
	}
	
	private void println (File file) {
		print.print(file.getAbsolutePath());
		if (!file.exists()) {
			println("(missing)");			
		}
		else if (file.isDirectory()) {
			int count = file.listFiles().length;
			println("(" + count + " entries)");			
		}
		else {
			println("(" + file.length() + " bytes)");			
		}
	}
	
	private void println (List list) {
		if (list == null || list.isEmpty()) println(NULL_OR_EMPTY);
		else for (Iterator i = list.iterator(); i.hasNext();) {
            Object o = i.next();
            if (o instanceof Exception) {
                println((Exception)o);
            } else {
            	println(i.next().toString());
            }
		}
	}
	
	static {
		String exceptionName = System.getProperty("org.aspectj.weaver.Dump.exception","true");
		if (!exceptionName.equals("false")) setDumpOnException(true);
		
		String conditionName = System.getProperty("org.aspectj.weaver.Dump.condition","true");
		setDumpOnExit(conditionName);
	}

	public interface INode {
		
		public void accept (IVisitor visior);
		
	}

	public interface IVisitor {
		
		public void visitString (String s);
		public void visitList (List list);
	}
}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/DumpTestCase/src/Aspect.aj" revision="1.1" state="new">public aspect Aspect {&#13;
	&#13;
	after () returning : Pointcuts.main () &amp;&amp; within(HelloWorld) {&#13;
		System.out.println(thisJoinPoint);&#13;
	}&#13;
}&#13;
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/DumpTestCase/src/DeclareError.aj" revision="1.1" state="new">public aspect DeclareError {&#13;
	&#13;
	declare error : Pointcuts.main() &amp;&amp; within(HelloWorld) :&#13;
		"main()";&#13;
&#13;
}&#13;
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testdata/DumpTestCase/src/DeclareWarning.aj" revision="1.1" state="new">public aspect DeclareWarning {&#13;
	&#13;
	declare warning : Pointcuts.main() &amp;&amp; within(HelloWorld) :&#13;
		"main()";&#13;
}&#13;
</file>
</fixedFiles>
</bug>
<bug id="72157" transactionid="70486">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-instanceof K-null K-return K-super M O-== O-() O-&amp;&amp; O-instanceof T V Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>Compiling the program below results in the constructor for the class SCE2
throwing Exception, which it is not declared to throw either in the source code
or in the generated bytecode. If the 'declare soft' statement is removed, then
the super() call in the SCE2 constructor is correctly reported as throwing an
undeclared exception; it seems that the 'declare soft' statement turns off the
exception checking of the super() call despite there being no join point which
covers this call that would actually soften the exception.

I'm using 'DEVELOPMENT built on Monday Aug 16, 2004 at 13:50:47 GMT'.

public class SuperConsExc {
    public SuperConsExc() throws Exception {
	throw new Exception();
    }

    public static void main(String[] args) {
	new SCE2();
    }
}

class SCE2 extends SuperConsExc {
    public SCE2() {
	super();
    }
}

aspect SCEAspect {
    declare soft: Exception: within(SCE2);
}</bugreport>
<testsforfix ID="72157" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test057_decSoftWithSuper"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="declare soft can cause programs with invalid exception behaviour to be generated"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/72157/pre-fix/testresults.xml" passing="1278" size="1390"/>
<post-fix-testcases failing="112" file="output/72157/post-fix/testresults.xml" passing="1279" size="1391"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java" revision="1.19" state="changed">35a36
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
76a78,83
&gt; 			// PR 72157 - calls to super / this within a constructor are not part of the cons join point.
&gt; 			if ((callSite == null) &amp;&amp; (enclosingExec.getKind() == Shadow.ConstructorExecution)
&gt; 			        &amp;&amp; (location instanceof ExplicitConstructorCall)) {
&gt; 				super.unhandledException(exceptionType, location);
&gt; 				return;
&gt; 			}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.30" state="changed">451a452,458
&gt; 
&gt;     &lt;ajc-test dir="bugs" pr="72157"
&gt; 		title="declare soft can cause programs with invalid exception behaviour to be generated"&gt;
&gt; 		&lt;compile files="PR72157.java"&gt;
&gt;  	      &lt;message kind="error" line="13" text="Unhandled"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.28" state="changed">308a309,311
&gt;   public void test057_decSoftWithSuper() {
&gt;       runTest("declare soft can cause programs with invalid exception behaviour to be generated");
&gt;     }
</file>
<file name="org.aspectj/modules/tests/bugs/ConvertToUnchecked.java" revision="1.3" state="changed">38c38
&lt; 	Root(String s) throws IOException {
---
&gt; 	Root(String s) /*throws IOException*/ {
</file>
<file name="org.aspectj/modules/tests/bugs/PR72157.java" revision="1.1" state="new">public class PR72157 {
    public PR72157() throws Exception {
        throw new Exception();
    }

    public static void main(String[] args) {
        new SCE2();
    }
}

class SCE2 extends PR72157 {
    public SCE2() {  
        super();    // CE L13?
    }
    
}

class Foo {
    
    public Foo() throws Exception {
        throw new Exception();
    }
    
}

class Goo {
    public Goo() {
        new Foo();
    }
}

aspect SCEAspect {
    declare soft: Exception: within(SCE2);
    declare soft: Exception: within(Goo);
}</file>
</fixedFiles>
</bug>
<bug id="72528" transactionid="69639">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="71"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="73"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-instanceof K-new K-return K-throw K-while M O-== O-|| O-! O-&amp;&amp; O-+ O-cast O-instanceof T V Y Z-cast Z-if Z-throw Z-while</fullfingerprint>
<bugreport>I have an aspect that captures around() a pcd and returns an Object[], though
the actual methods being instrumented might return any valid POJO array, i
understand that AspectJ will take care of casting at assignment.

I expected the following code to work properly, but at runtime i get a
java.lang.VerifyError as shown below:

F:\wd\Hello&gt;ajbrowser HelloWorld.lst
java.lang.VerifyError: (class: de/rohith/PrinterWorld, method: returnArrayWithCl
oning signature: ()[Ljava/lang/Integer;) Incompatible argument to function
        at de.rohith.HelloWorld.main(HelloWorld.java:18)
Exception in thread "main"

I suspect the compiler fails to notice the return types of the methods being
caught at compile time.

I have tested this code with both ajbrowser as well as AJDT, both result in the
same error output.

-----------HelloWorldAspect.java---------------
package de.rohith;

import java.lang.Object;

public aspect HelloWorldAspect {
    
	private int callDepth = -1;

    public HelloWorldAspect() {
    }
    
    pointcut hello(): !within(HelloWorldAspect);
    
    pointcut method(): execution(public (*[]) de..*(..));
    
    pointcut cloning(): call(* java.lang.Object.clone());

    declare warning: method() &amp;&amp; hello(): "*[] returning method called" ;
    
    Object[] around(): cflow(method()) &amp;&amp; cloning() &amp;&amp; hello() {
    	print("", thisEnclosingJoinPointStaticPart);
    	Object[] ret = proceed(); 
    	return (Object[])ret.clone();
    }

    private void print(String prefix, Object message) {
        for (int i = 0, spaces = callDepth * 2; i &lt; spaces; i++) {
            System.out.print(" ");
        }
        System.out.println(prefix + message);
    }

}


-----------PrinterWorld.java------------
package de.rohith;
public class PrinterWorld {
	private Integer[] intArray = new Integer[2];
	public PrinterWorld() {
		
	}
    public void print() {
        System.out.println("Hello World!"); 
    }
    
    public Integer returnInt() {
    	return new Integer(3);
    }
    
    public Integer[] returnArrayWithCloning() {
    	for (int i = 0; i &lt; intArray.length; i++) {
			intArray[i] = new Integer(i++);
		}
    	return (Integer[])intArray.clone();
    }
    
    public Integer[] returnArrayWithoutCloning() {
    	return intArray;
    }
}

-----------HelloWorld.java------------
package de.rohith;

public class HelloWorld {

    public static void main(String[] args) {
        PrinterWorld p = new PrinterWorld();
        p.print(); 
        Integer i = p.returnInt();
        Integer[] intArray = p.returnArrayWithCloning();
        Integer[] array2 = p.returnArrayWithoutCloning();
    }
}</bugreport>
<testsforfix ID="72528" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test056_arrayCloning"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="around advice throws java.lang.VerifyError at runtime"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="111" file="output/72528/pre-fix/testresults.xml" passing="1278" size="1389"/>
<post-fix-testcases failing="111" file="output/72528/post-fix/testresults.xml" passing="1279" size="1390"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.42" state="changed">23a24
&gt; import org.aspectj.apache.bcel.generic.ANEWARRAY;
38a40,41
&gt; import org.aspectj.apache.bcel.generic.LoadInstruction;
&gt; import org.aspectj.apache.bcel.generic.MULTIANEWARRAY;
1112a1116
&gt;             type = ensureTargetTypeIsCorrect(type);
1117a1122,1182
&gt;     
&gt;     /* PR 72528
&gt;      * This method double checks the target type under certain conditions.  The Java 1.4
&gt;      * compilers seem to take calls to clone methods on array types and create bytecode that
&gt;      * looks like clone is being called on Object.  If we advise a clone call with around
&gt;      * advice we extract the call into a helper method which we can then refer to.  Because the
&gt;      * type in the bytecode for the call to clone is Object we create a helper method with
&gt;      * an Object parameter - this is not correct as we have lost the fact that the actual
&gt;      * type is an array type.  If we don't do the check below we will create code that fails
&gt;      * java verification.  This method checks for the peculiar set of conditions and if they
&gt;      * are true, it has a sneak peek at the code before the call to see what is on the stack.
&gt;      */
&gt;     public TypeX ensureTargetTypeIsCorrect(TypeX tx) {
&gt;     	if (tx.equals(ResolvedTypeX.OBJECT) &amp;&amp; getKind() == MethodCall &amp;&amp; 
&gt;     	    getSignature().getReturnType().equals(ResolvedTypeX.OBJECT) &amp;&amp; 
&gt; 			getSignature().getArity()==0 &amp;&amp; 
&gt; 			getSignature().getName().charAt(0) == 'c' &amp;&amp;
&gt; 			getSignature().getName().equals("clone")) {
&gt;     		
&gt;     		// Lets go back through the code from the start of the shadow
&gt;             InstructionHandle searchPtr = range.getStart().getPrev();
&gt;             while (Range.isRangeHandle(searchPtr) || 
&gt;             	   searchPtr.getInstruction() instanceof StoreInstruction) { // ignore this instruction - it doesnt give us the info we want
&gt;             	searchPtr = searchPtr.getPrev();  
&gt;             }
&gt;             
&gt;             // A load instruction may tell us the real type of what the clone() call is on
&gt;             if (searchPtr.getInstruction() instanceof LoadInstruction) {
&gt;             	LoadInstruction li = (LoadInstruction)searchPtr.getInstruction();
&gt;             	li.getIndex();
&gt;             	LocalVariableTag lvt = LazyMethodGen.getLocalVariableTag(searchPtr,li.getIndex());
&gt;             	return lvt.getType();
&gt;             }
&gt;             // A field access instruction may tell us the real type of what the clone() call is on
&gt;             if (searchPtr.getInstruction() instanceof FieldInstruction) {
&gt;             	FieldInstruction si = (FieldInstruction)searchPtr.getInstruction();
&gt;             	Type t = si.getFieldType(getEnclosingClass().getConstantPoolGen());
&gt;             	return BcelWorld.fromBcel(t);
&gt;             } 
&gt;             // A new array instruction obviously tells us it is an array type !
&gt;             if (searchPtr.getInstruction() instanceof ANEWARRAY) {
&gt;             	//ANEWARRAY ana = (ANEWARRAY)searchPoint.getInstruction();
&gt;             	//Type t = ana.getType(getEnclosingClass().getConstantPoolGen());
&gt;             	// Just use a standard java.lang.object array - that will work fine
&gt;             	return BcelWorld.fromBcel(new ArrayType(Type.OBJECT,1));
&gt;             }
&gt;             // A multi new array instruction obviously tells us it is an array type !
&gt;             if (searchPtr.getInstruction() instanceof MULTIANEWARRAY) {
&gt;             	MULTIANEWARRAY ana = (MULTIANEWARRAY)searchPtr.getInstruction();
&gt;                 // Type t = ana.getType(getEnclosingClass().getConstantPoolGen());
&gt;             	// t = new ArrayType(t,ana.getDimensions());
&gt;             	// Just use a standard java.lang.object array - that will work fine
&gt;             	return BcelWorld.fromBcel(new ArrayType(Type.OBJECT,ana.getDimensions()));
&gt;             }
&gt;             throw new BCException("Can't determine real target of clone() when processing instruction "+
&gt;               searchPtr.getInstruction());
&gt;     	}
&gt;     	return tx;
&gt;     }
&gt;     
&gt;     
2210a2276
&gt;             targetType = ensureTargetTypeIsCorrect(targetType);
2211a2278
&gt;             
2213c2280,2281
&lt;             	!samePackage(targetType.getPackageName(), getEnclosingType().getPackageName()))
---
&gt;             	!samePackage(targetType.getPackageName(), getEnclosingType().getPackageName()) &amp;&amp;
&gt; 				!resolvedMember.getName().equals("clone"))
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.34" state="changed">727c727,731
&lt;             return ResolvedMember.NONE;
---
&gt;             // If it ever does, here is the code:
&gt;             //  ResolvedMember cloneMethod =
&gt;             //    new ResolvedMember(Member.METHOD,this,Modifier.PUBLIC,TypeX.OBJECT,"clone",new TypeX[]{});
&gt;             //  return new ResolvedMember[]{cloneMethod};
&gt;         	return ResolvedMember.NONE;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.27" state="changed">303a304,307
&gt;   
&gt;   public void test056_arrayCloning() {
&gt;     runTest("around advice throws java.lang.VerifyError at runtime");
&gt;   }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.29" state="changed">445a446,451
&gt; 	
&gt;     &lt;ajc-test dir="bugs" pr="72528"
&gt; 		title="around advice throws java.lang.VerifyError at runtime"&gt;
&gt; 		&lt;compile files="ArrayCloning.java"/&gt;
&gt; 		&lt;run class="ArrayCloning"/&gt;
&gt; 	&lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/ArrayCloning.java" revision="1.1" state="new">
public class ArrayCloning {

    public static void main(String[] args) {
        ArrayCloning ArrayCloning = new ArrayCloning();
        Integer[] clonedStaticField = ArrayCloning.clone1();
        checkIdentical(clonedStaticField,ArrayCloning.staticField);
    
        Integer[] clonedField = ArrayCloning.clone2();
        checkIdentical(clonedField,ArrayCloning.nonStaticField);

        Integer[] clown = null;

        clown = ArrayCloning.clone3();
        clown = ArrayCloning.clone4();
        Integer[][] ArrayCloningArrayCloning = ArrayCloning.clone5();
    }

    public static void checkIdentical(Integer[] one, Integer[] two) {
      if (one[0]!=two[0]) throw new RuntimeException("Not the same (a)");
      if (one[1]!=two[1]) throw new RuntimeException("Not the same (b)");
    }

    private static Integer[] staticField = new Integer[2];

    private Integer[] nonStaticField = new Integer[2];

    public ArrayCloning() {
      nonStaticField[0] = new Integer(32);
      nonStaticField[1] = new Integer(64);
    }

    static {
      staticField[0] = new Integer(1);
      staticField[1] = new Integer(2);
    }
    
    public Integer[] clone1() {
      System.err.println("Clone call on a static field");
      return (Integer[])staticField.clone();
    }

    public Integer[] clone2() {
       System.err.println("Clone call on a non-static field");
       return (Integer[])nonStaticField.clone();
    }

    public Integer[] clone3() {
       System.err.println("Clone call on a local variable");
       Integer[] ArrayCloningArrayCloning = staticField;
       return (Integer[])ArrayCloningArrayCloning.clone();
    }


    // Clone call on anonymous 'thing' !
    public Integer[] clone4() {
      System.err.println("Clone call on a 1 dimensional anonymous integer array");
      return (Integer[])new Integer[5].clone();
    }

    // Sick
    public Integer[][] clone5() {
      System.err.println("Clone call on a 2 dimensional anonymous integer array");
      return (Integer[][])new Integer[5][3].clone();
    }


}

aspect HelloWorldAspect {
    Object[] around(): call(* java.lang.Object.clone()) &amp;&amp; within(ArrayCloning) {
  	Object[] ret = proceed(); 
	return (Object[])ret.clone();
    }
}
</file>
</fixedFiles>
</bug>
<bug id="72531" transactionid="70607">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="19"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="19"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-return K-true K-while M O-== O-&gt; O-- O-!= O-() O-+ O-++ T V Y Z-if Z-while</fullfingerprint>
<bugreport>I have a "declare warning" declaration that warns on usage of any method that
returns an array of any POJO type, this should point to the methods that in
reality return an array, but i see warnings at points other than these array
returning methods, and also those that have void in their signature. In the
attached files i get a warning at statements like:

&gt;        PrinterWorld p = new PrinterWorld();[in main()method]
&gt;        System.out.println("Hello World!"); 
&gt;    	 return new Integer(3);

and these being the first/only lines in their respective methods.</bugreport>
<testsforfix ID="72531" type="new">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java">
      <test NAME="testArrayMatch"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test050_typePatternMatchingWithArrays"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="declare warning warns at wrong points"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="111" file="output/72531/pre-fix/testresults.xml" passing="1274" size="1385"/>
<post-fix-testcases failing="113" file="output/72531/post-fix/testresults.xml" passing="1274" size="1387"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java" revision="1.15" state="changed">98a99,115
&gt; 		if (isStar()) {
&gt; 			// we match if the dimensions match
&gt; 			int numDimensionsInTargetType = 0;
&gt; 			if (dim &gt; 0) {
&gt; 				int index;
&gt; 				while((index = targetTypeName.indexOf('[')) != -1) {
&gt; 					numDimensionsInTargetType++;
&gt; 					targetTypeName = targetTypeName.substring(index+1);
&gt; 				}
&gt; 				if (numDimensionsInTargetType == dim) {
&gt; 					return true;
&gt; 				} else {
&gt; 					return false;
&gt; 				}
&gt; 			}
&gt; 		}
&gt; 		
311c328,330
&lt; 			return TypePattern.ANY;  //??? loses source location
---
&gt;     		if (dim == 0) { // pr72531
&gt;     			return TypePattern.ANY;  //??? loses source location
&gt;     		} 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.24" state="changed">406a407,415
&gt; 	
&gt; 	&lt;ajc-test dir="bugs/pr72531" pr="72531"
&gt; 	  	title="declare warning warns at wrong points"&gt;
&gt; 		&lt;compile files="de/rohith/HelloWorld.java,de/rohith/HelloWorldAspect.java,de/rohith/PrinterWorld.java"&gt;
&gt; 			&lt;message kind="warning" line="15" text="*[] returning method called"/&gt;
&gt; 			&lt;message kind="warning" line="22" text="*[] returning method called"/&gt;
&gt; 		&lt;/compile&gt;
&gt; 	&lt;/ajc-test&gt;
&gt; 	
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.22" state="changed">266a267,269
&gt;   public void test050_typePatternMatchingWithArrays() {
&gt;   	runTest("declare warning warns at wrong points");
&gt;   }
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java" revision="1.6" state="changed">203a204,217
&gt;   	
&gt;   	public void testArrayMatch() {
&gt;   		world = new BcelWorld();
&gt;   		checkMatch("*[][]","java.lang.Object",false);
&gt;   		checkMatch("*[]","java.lang.Object[]",true);
&gt;   		checkMatch("*[][]","java.lang.Object[][]",true);
&gt;   		checkMatch("java.lang.Object[]","java.lang.Object",false);
&gt;   		checkMatch("java.lang.Object[]","java.lang.Object[]",true);
&gt;   		checkMatch("java.lang.Object[][]","java.lang.Object[][]",true);
&gt;   		checkMatch("java.lang.String[]","java.lang.Object",false);
&gt;   		checkMatch("java.lang.String[]","java.lang.Object[]",false);
&gt;   		checkMatch("java.lang.String[][]","java.lang.Object[][]",false);
&gt;   		checkMatch("java.lang.Object+[]","java.lang.String[]",true);
&gt;   	}
</file>
<file name="org.aspectj/modules/tests/bugs/pr72531/de/rohith/HelloWorldAspect.java" revision="1.1" state="new">package de.rohith;
import java.lang.Object;

public aspect HelloWorldAspect {
    
	private int callDepth = -1;

    public HelloWorldAspect() {
    }
    
    pointcut hello(): !within(HelloWorldAspect);
    
    pointcut method(): execution(public (*[]) de..*(..));
    
    pointcut cloning(): call(* java.lang.Object.clone());

    declare warning: method() &amp;&amp; hello(): "*[] returning method called" ;
    
    Object[] around(): cflow(method()) &amp;&amp; cloning() &amp;&amp; hello() {
    	print("", thisEnclosingJoinPointStaticPart);
    	Object[] ret = proceed(); 
    	return (Object[])ret.clone();
    }

    private void print(String prefix, Object message) {
        for (int i = 0, spaces = callDepth * 2; i &lt; spaces; i++) {
            System.out.print(" ");
        }
        System.out.println(prefix + message);
    }
}
</file>
<file name="org.aspectj/modules/tests/bugs/pr72531/de/rohith/PrinterWorld.java" revision="1.1" state="new">package de.rohith;
public class PrinterWorld {
	private Integer[] intArray = new Integer[2];
	public PrinterWorld() {
		
	}
    public void print() {
        System.out.println("Hello World!"); 
    }
    
    public Integer returnInt() {
    	return new Integer(3);
    }
    
    public Integer[] returnArrayWithCloning() {
    	for (int i = 0; i &lt; intArray.length; i++) {
			intArray[i] = new Integer(i++);
		}
    	return (Integer[])intArray.clone();
    }
    
    public Integer[] returnArrayWithoutCloning() {
    	return intArray;
    }
}
</file>
<file name="org.aspectj/modules/tests/bugs/pr72531/de/rohith/HelloWorld.java" revision="1.1" state="new">package de.rohith;
public class HelloWorld {

    public static void main(String[] args) {
        PrinterWorld p = new PrinterWorld();
        p.print(); 
        Integer i = p.returnInt();
        Integer[] intArray = p.returnArrayWithCloning();
        Integer[] array2 = p.returnArrayWithoutCloning();
    }
}
</file>
</fixedFiles>
</bug>
<bug id="72671" transactionid="69608">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="16"/>
<property name="lines-added" value="44"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="19"/>
<property name="lines-churned" value="64"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new K-return K-this K-while M O-&lt; O-! O-+ T V Y Z-if Z-vardecl Z-while</fullfingerprint>
<bugreport>I have following bug running  eclipse 3.0 and ajdt 1.1.12

I have following class:
 
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

import org.w3c.dom.DOMConfiguration;
import org.w3c.dom.DOMError;
import org.w3c.dom.DOMErrorHandler;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.NodeList;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSInput;
import org.w3c.dom.ls.LSOutput;
import org.w3c.dom.ls.LSParser;

import com.dcbank.common.DOMImplementationLSSingleton;

public class DOMHelper {

   public static final String CLASS_ID = "%full_filespec:
DOMHelper.java~1:java:1 %";
   
   public static void save(Document document, String filename)
   throws ClassNotFoundException, InstantiationException,  
IllegalAccessException, FileNotFoundException {
   
      document.normalizeDocument();
   }

}

which compiles very fine with JDK 1.4.2_02 on Windows XP, 
as soon as the  dom2-xml-apis.jar and dom3-xercesImpl.jar are added at the
beginning of the jre container, or are included in
the jar-library list before the system jar. 

As soon as I convert this project to an AspectJ project, the code does not
compile anymore. The aspectJ compiler does not find the  normalizeDocument,
which is included in the one of the two additional jars.
method any more.

kind regards
Arno Schmidmeier</bugreport>
<testsforfix ID="72671" type="changed">
    <file LOCATION="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java">
      <test NAME="testBootclasspath"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="111" file="output/72671/pre-fix/testresults.xml" passing="1279" size="1390"/>
<post-fix-testcases failing="112" file="output/72671/post-fix/testresults.xml" passing="1278" size="1390"/>
<fixedFiles>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java" revision="1.24" state="changed">498d497
&lt;      * &lt;li&gt;New bootclasspath entries are ignored XXX&lt;/li&gt;
508c507,508
&lt;         String propcp = properties.getClasspath(); // XXX omitting bootclasspath...
---
&gt; 		// Handle regular classpath
&gt;         String propcp = properties.getClasspath();
527c527,550
&lt; 
---
&gt;        
&gt;         // Handle boot classpath
&gt;         propcp = properties.getBootClasspath();
&gt;         if (!LangUtil.isEmpty(propcp)) {
&gt;             StringTokenizer st = new StringTokenizer(propcp, File.pathSeparator);
&gt;             List configClasspath = config.getBootclasspath();
&gt;             ArrayList toAdd = new ArrayList();
&gt;             while (st.hasMoreTokens()) {
&gt;                 String entry = st.nextToken();
&gt;                 if (!configClasspath.contains(entry)) {
&gt;                     toAdd.add(entry);
&gt;                 }
&gt;             }
&gt;             if (0 &lt; toAdd.size()) {
&gt;                 ArrayList both = new ArrayList(configClasspath.size() + toAdd.size());
&gt;                 both.addAll(configClasspath);
&gt;                 both.addAll(toAdd);
&gt;                 config.setBootclasspath(both);
&gt;                 Ajde.getDefault().logEvent("building with boot classpath: " + both);
&gt;             }
&gt;         }
&gt;        
&gt;         
&gt;         
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.61" state="changed">488c488,490
&lt; 		bcelWorld = new BcelWorld(buildConfig.getClasspath(), handler, null);
---
&gt; 		List cp = buildConfig.getBootclasspath();
&gt; 		cp.addAll(buildConfig.getClasspath());
&gt; 		bcelWorld = new BcelWorld(cp, handler, null);
828c830
&lt; 		if (buildConfig == null || buildConfig.getClasspath() == null) return "";
---
&gt; 		if (buildConfig == null || buildConfig.getFullClasspath() == null) return "";
831c833
&lt; 		for (Iterator it = buildConfig.getClasspath().iterator(); it.hasNext(); ) {
---
&gt; 		for (Iterator it = buildConfig.getFullClasspath().iterator(); it.hasNext(); ) {
852,853c854,855
&lt; 		if (buildConfig == null || buildConfig.getClasspath() == null) return "no classpath specified";
&lt; 		for (Iterator it = buildConfig.getClasspath().iterator(); it.hasNext(); ) {
---
&gt; 		if (buildConfig == null || buildConfig.getFullClasspath() == null) return "no classpath specified";
&gt; 		for (Iterator it = buildConfig.getFullClasspath().iterator(); it.hasNext(); ) {
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.30" state="changed">179a180
&gt; 				buildConfig.setBootclasspath(getBootclasspath(parser));
286a288,297
&gt; 	public List getBootclasspath(AjcConfigParser parser) {
&gt; 		List ret = new ArrayList();
&gt;     	
&gt;     	if (parser.bootclasspath == null) {
&gt;     		addClasspath(System.getProperty("sun.boot.class.path", ""), ret);
&gt;     	} else {  
&gt;     		addClasspath(parser.bootclasspath, ret);
&gt;     	}
&gt;     	return ret;
&gt; 	}
295,299c306,310
&lt;     	if (parser.bootclasspath == null) {
&lt;     		addClasspath(System.getProperty("sun.boot.class.path", ""), ret);
&lt;     	} else {  
&lt;     		addClasspath(parser.bootclasspath, ret);
&lt;     	}
---
&gt; //    	if (parser.bootclasspath == null) {
&gt; //    		addClasspath(System.getProperty("sun.boot.class.path", ""), ret);
&gt; //    	} else {  
&gt; //    		addClasspath(parser.bootclasspath, ret);
&gt; //    	}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java" revision="1.23" state="changed">34c34
&lt; public class AjBuildConfig { // XXX needs bootclasspath?
---
&gt; public class AjBuildConfig {
52a53
&gt; 	private List/*String*/ bootclasspath = new ArrayList();
140c141
&lt; 	 * This includes all entries from -bootclasspath, -extdirs, -classpath, 
---
&gt; 	 * This does not include -bootclasspath but includes -extdirs and -classpath
148a150,157
&gt; 	
&gt; 	public List getBootclasspath() {
&gt; 		return bootclasspath;
&gt; 	}
&gt; 	
&gt; 	public void setBootclasspath(List bootclasspath) {
&gt; 		this.bootclasspath = bootclasspath;
&gt; 	}
228,230c237,238
&lt;      * @return List (String) classpath of injars, inpath, aspectpath 
&lt;      *   entries, specified classpath (bootclasspath, extdirs, and 
&lt;      *   classpath), and output dir or jar
---
&gt;      * @return List (String) classpath of bootclasspath, injars, inpath, aspectpath 
&gt;      *   entries, specified classpath (extdirs, and classpath), and output dir or jar
233a242
&gt;         full.addAll(getBootclasspath()); // XXX Is it OK that boot classpath overrides inpath/injars/aspectpath?
241c250
&lt;             full.add(((File)i.next()).getAbsolutePath());
---
&gt;             full.add(((File)i.next()).getAbsolutePath());        
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java" revision="1.18" state="changed">115c115
&lt; 		List classpath = config.getClasspath();
---
&gt; 		List classpath = config.getFullClasspath();
303,304c303,304
&lt; 		assertTrue("Should find '" + PATH + "' contained in the first entry of '" + config.getClasspath().toString(),
&lt; 				((String)config.getClasspath().get(0)).indexOf(PATH) != -1); 
---
&gt; 		assertTrue("Should find '" + PATH + "' contained in the first entry of '" + config.getBootclasspath().toString(),
&gt; 				((String)config.getBootclasspath().get(0)).indexOf(PATH) != -1); 
309c309
&lt; 		assertTrue(config.getClasspath().toString(), !config.getClasspath().get(0).equals(PATH)); 
---
&gt; 		assertTrue(config.getBootclasspath().toString(), !config.getBootclasspath().get(0).equals(PATH)); 
</file>
</fixedFiles>
</bug>
<bug id="72699" transactionid="69868">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="27"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="30"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-new K-null K-return K-super K-this K-true M O-== O-! O-?: O-&amp;&amp; O-+ T V Y Z-cond Z-if</fullfingerprint>
<bugreport>When attempting to compile the following aspect the resulting error message 
should say something like "The abstract method pointcut tracingScope in type 
Tracing can only be defined by an abstract aspect"

public aspect Tracing {
	public abstract pointcut tracingScope();

}</bugreport>
<testsforfix ID="72699" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test052_bogusMessage1"/>
      <test NAME="test053_bogusMessage2"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (1)"/>
      <test NAME="Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (2)"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="111" file="output/72699/pre-fix/testresults.xml" passing="1277" size="1388"/>
<post-fix-testcases failing="111" file="output/72699/post-fix/testresults.xml" passing="1277" size="1388"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java" revision="1.14" state="changed">79,86c79,93
&lt; 		if (Modifier.isAbstract(this.declaredModifiers) &amp;&amp; 
&lt; 			!(typeDec instanceof AspectDeclaration))
&lt; 		{
&lt; 			typeDec.scope.problemReporter().signalError(sourceStart, sourceEnd, 
&lt; 				"The abstract pointcut " + new String(declaredName) +
&lt; 				" can only be defined in an aspect");
&lt; 			ignoreFurtherInvestigation = true;
&lt; 			return;
---
&gt; 		if (Modifier.isAbstract(this.declaredModifiers)) {
&gt; 			if (!(typeDec instanceof AspectDeclaration)) {
&gt; 				typeDec.scope.problemReporter().signalError(sourceStart, sourceEnd, 
&gt; 						"The abstract pointcut " + new String(declaredName) +
&gt; 						" can only be defined in an aspect");
&gt; 				ignoreFurtherInvestigation = true;
&gt; 				return;
&gt; 			} else if (!Modifier.isAbstract(typeDec.modifiers)) {
&gt; 				typeDec.scope.problemReporter().signalError(sourceStart, sourceEnd, 
&gt; 						"The abstract pointcut " + new String(declaredName) +
&gt; 						" can only be defined in an abstract aspect");
&gt; 
&gt; 				ignoreFurtherInvestigation = true;
&gt; 				return;
&gt; 			}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java" revision="1.17" state="changed">33a34
&gt; import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
43a45
&gt; import org.eclipse.jdt.core.compiler.IProblem;
223a226,242
&gt;     
&gt;     public void abstractMethodInAbstractClass(SourceTypeBinding type, AbstractMethodDeclaration methodDecl) {
&gt; 
&gt;     	String abstractMethodName = new String(methodDecl.selector);
&gt;     	if (abstractMethodName.startsWith("ajc$pointcut")) {
&gt;     		// This will already have been reported, see: PointcutDeclaration.postParse()
&gt;     		return;
&gt;     	}
&gt;     	String[] arguments = new String[] {new String(type.sourceName()), abstractMethodName};
&gt;     	super.handle(
&gt;     		IProblem.AbstractMethodInAbstractClass,
&gt;     		arguments,
&gt;     		arguments,
&gt;     		methodDecl.sourceStart,
&gt;     		methodDecl.sourceEnd,this.referenceContext, 
&gt; 			this.referenceContext == null ? null : this.referenceContext.compilationResult());
&gt;     }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.24" state="changed">273a274,281
&gt;   
&gt;   public void test052_bogusMessage1() {
&gt;     runTest("Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (1)");
&gt;   }
&gt;   
&gt;   public void test053_bogusMessage2() {
&gt;     runTest("Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (2)");
&gt;   }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.26" state="changed">420a421,435
&gt; 
&gt;     &lt;ajc-test dir="bugs" pr="72699"
&gt; 	   title="Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (1)"&gt;
&gt; 	   &lt;compile files="BogusMessage.java"&gt;
&gt; 	     &lt;message kind="error" line="2" text="The abstract pointcut tracingScope can only be defined in an abstract aspect"/&gt;
&gt; 	   &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="72699"
&gt; 	   title="Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (2)"&gt;
&gt; 	   &lt;compile files="BogusMessage2.java"&gt;
&gt; 	     &lt;message kind="error" line="2" text="The abstract pointcut tracingScope can only be defined in an aspect"/&gt;
&gt; 	   &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs/BogusMessage2.java" revision="1.1" state="new">public class BogusMessage2 {
	public abstract pointcut tracingScope();
}</file>
<file name="org.aspectj/modules/tests/bugs/BogusMessage.java" revision="1.1" state="new">public aspect BogusMessage {
	public abstract pointcut tracingScope();

}</file>
</fixedFiles>
</bug>
<bug id="73433" transactionid="69856">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-|| T V Y Z-if</fullfingerprint>
<bugreport>Discovered by Andy Brodie.

-cp is a shorthand for -classpath supported by the JDT compiler.  AspectJ does
not correctly support -cp option.  Look at this example:

C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -cp lib\aspectjrt.jar
[error] can't find type org.aspectj.lang.JoinPoint


1 error

C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -classpath lib\aspectjrt.jar

This is due to the arg parser in AspectJ only recognizing -classpath.  It
doesn't fail when it encounters -cp, it just ignores it and passes it down to
JDT for processing.  The fix is to recognize -cp too.</bugreport>
<pre-fix-testcases failing="114" file="output/73433/pre-fix/testresults.xml" passing="1276" size="1390"/>
<post-fix-testcases failing="111" file="output/73433/post-fix/testresults.xml" passing="1279" size="1390"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.32" state="changed">570c570
&lt; 			} else if (arg.equals("-classpath")) {
---
&gt; 			} else if (arg.equals("-classpath") || arg.equals("-cp")) {
</file>
</fixedFiles>
</bug>
<bug id="73859" transactionid="69430">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="23"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-import K-null K-true M O-! O-() O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>If Eclipse is runnning with 'Build Automatically' on then changing the 
aspectpath, inpath or outjar for a project should trigger a rebuild.</bugreport>
<pre-fix-testcases failing="112" file="output/73859/pre-fix/testresults.xml" passing="1290" size="1402"/>
<post-fix-testcases failing="113" file="output/73859/post-fix/testresults.xml" passing="1289" size="1402"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/AspectJProjectPropertiesPage.java" revision="1.2" state="changed">18a19
&gt; import org.eclipse.core.resources.IncrementalProjectBuilder;
567a569,574
&gt; 		    boolean outjarChanged = false;
&gt; 		    if (AspectJUIPlugin.getWorkspace().getDescription().isAutoBuilding() &amp;&amp; 
&gt; 		            !(retrieveSettingString(BuildOptionsAdapter.OUTPUTJAR).equals(outputJarEditor.getStringValue()))) {
&gt; 		        outjarChanged = true;
&gt;             }
&gt; 		    
592a600,605
&gt; 			
&gt; 			// build the project if the outjar setting has changed
&gt; 		    if (outjarChanged) {
&gt; 				thisProject.build(IncrementalProjectBuilder.FULL_BUILD,"org.eclipse.ajdt.ui.ajbuilder", null,null);  
&gt;             }
&gt; 		    
612a626,631
&gt; 		    boolean outjarChanged = false;
&gt; 		    if (AspectJUIPlugin.getWorkspace().getDescription().isAutoBuilding() &amp;&amp; 
&gt; 		            !(retrieveSettingString(BuildOptionsAdapter.OUTPUTJAR).equals(""))) {
&gt; 		        outjarChanged = true;
&gt;             }
&gt; 		    
633a653,656
&gt; 			// build the project if the outjar setting has changed
&gt; 			if (outjarChanged) {
&gt; 				thisProject.build(IncrementalProjectBuilder.FULL_BUILD,"org.eclipse.ajdt.ui.ajbuilder", null,null);  
&gt;             }
</file>
</fixedFiles>
</bug>
<bug id="73895" transactionid="70541">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-() O-cast Z-cast</fullfingerprint>
<bugreport>class: org.aspectj.weaver.ResolvedTypeX$Name
method: isCoerceableFrom(..)

I am having trouble with the line:

ResolvedMember[] b = ((Name)other).getDeclaredMethods(); //??? is this cast
always safe

As the comment suggests this cast is NOT always safe. In my case the cast is not
safe because I have some additional implementations for ResolvedTypeX (some
optimizations).

Solution: just remove the cast since the method "getDeclaredMethods" is already
defined abstract in the type of "other" (ResolvedTypeX). So the cast seems to be
obsolete anyway.</bugreport>
<pre-fix-testcases failing="113" file="output/73895/pre-fix/testresults.xml" passing="1252" size="1365"/>
<post-fix-testcases failing="114" file="output/73895/post-fix/testresults.xml" passing="1289" size="1403"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedTypeX.java" revision="1.35" state="changed">553c553
&lt;             ResolvedMember[] b = ((Name)other).getDeclaredMethods();  //??? is this cast always safe
---
&gt;             ResolvedMember[] b = other.getDeclaredMethods();  //??? is this cast always safe
</file>
</fixedFiles>
</bug>
<bug id="74238" transactionid="68916">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="20"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="22"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKM</concisefingerprint>
<fullfingerprint>H K-catch K-return K-try M T V</fullfingerprint>
<tag>exception</tag>
<bugreport>When I used cflow pointcut for my applet, I couldn't launch the Applet.

java.lang.ExceptionInInitializerError
        at SandAspect.ajc$preClinit(SandAspect.aj)
        at SandAspect.&lt;clinit&gt;(SandAspect.aj)
        at SandApplet.init(SandApplet.java)
        at sun.applet.AppletPanel.run(AppletPanel.java:353)
        at java.lang.Thread.run(Thread.java:534)
Caused by: java.security.AccessControlException: access denied (java.util.Proper
tyPermission aspectj.runtime.cflowstack.usethreadlocal read)
        at java.security.AccessControlContext.checkPermission(AccessControlConte
xt.java:269)
        at java.security.AccessController.checkPermission(AccessController.java:
401)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:524)
        at java.lang.SecurityManager.checkPropertyAccess(SecurityManager.java:12
76)
        at java.lang.System.getProperty(System.java:612)
        at org.aspectj.runtime.internal.CFlowStack.selectFactoryForVMVersion(CFl
owStack.java:124)
        at org.aspectj.runtime.internal.CFlowStack.&lt;clinit&gt;(CFlowStack.java:59)
        ... 5 more

It because CFlowStack uses System.getProperty method with no try..catch block. 
Applet doesn't have permission to read system property:
"aspectj.runtime.cflowstack.usethreadlocal".

workaround:
modify CFlowStack.java(1.5) line 123,124 like this
-----
private static String getSystemPropertyWithNoSecurityException(
  String aPropertyName, String aDefaultValue){
  try{
    return System.getProperty(aPropertyName, aDefaultValue);
  } catch(java.lang.SecurityException e){
    return aDefaultValue;
  }
}

private static void selectFactoryForVMVersion() {
  String override = getSystemPropertyWithNoSecurityException(
    "aspectj.runtime.cflowstack.usethreadlocal"
    , "unspecified"
  );
-----
I think defining getSystemPropertyWithNoSecurityException(or more
simple name :-)) method in some utility class and using it where you call
System.getProperty are better way.</bugreport>
<testsforfix ID="74238" type="changed">
    <file LOCATION="org.aspectj/modules/ajde/testdata/SecurityManagerTest/build.xml"/>
  </testsforfix>
<pre-fix-testcases failing="111" file="output/74238/pre-fix/testresults.xml" passing="1292" size="1403"/>
<post-fix-testcases failing="112" file="output/74238/post-fix/testresults.xml" passing="1291" size="1403"/>
<fixedFiles>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/internal/CFlowCounter.java" revision="1.2" state="changed">53c53
&lt; 		String override = System.getProperty("aspectj.runtime.cflowstack.usethreadlocal","unspecified");
---
&gt; 		String override = getSystemPropertyWithoutSecurityException("aspectj.runtime.cflowstack.usethreadlocal","unspecified");
69a70,79
&gt; 	
&gt; 	private static String getSystemPropertyWithoutSecurityException (String aPropertyName, String aDefaultValue) {
&gt; 		try {
&gt; 			return System.getProperty(aPropertyName, aDefaultValue);
&gt; 		}
&gt; 		catch (SecurityException ex) {
&gt; 			return aDefaultValue;
&gt; 		}
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/internal/CFlowStack.java" revision="1.6" state="changed">124c124
&lt; 		String override = System.getProperty("aspectj.runtime.cflowstack.usethreadlocal","unspecified");
---
&gt; 		String override = getSystemPropertyWithoutSecurityException("aspectj.runtime.cflowstack.usethreadlocal","unspecified");
140a141,150
&gt; 	private static String getSystemPropertyWithoutSecurityException (String aPropertyName, String aDefaultValue) {
&gt; 		try {
&gt; 			return System.getProperty(aPropertyName, aDefaultValue);
&gt; 		}
&gt; 		catch (SecurityException ex) {
&gt; 			return aDefaultValue;
&gt; 		}
&gt; 	}
&gt; 
&gt; 	
</file>
<file name="org.aspectj/modules/lib/test/aspectjrt.jar" revision="1.16" state="changed"/>
<file name="org.aspectj/modules/ajde/testdata/SecurityManagerTest/build.xml" revision="1.1" state="new">&lt;project name="SecurityManagerTest" default="all" basedir="."&gt;

	&lt;property name="aspectj" value="j:\eclipse\aspectj_ws\aj-build\dist\tools\lib"/&gt;
	&lt;property name="aspectjrt" value="${aspectj}/aspectjrt.jar" /&gt;
	&lt;property name="aspectjtools" value="${aspectj}/aspectjtools.jar" /&gt;

	&lt;taskdef resource="org/aspectj/tools/ant/taskdefs/aspectjTaskdefs.properties"&gt;
		&lt;classpath&gt;
			&lt;pathelement path="${aspectjtools}"/&gt;
		&lt;/classpath&gt;
	&lt;/taskdef&gt;

	&lt;target name="compile"&gt;
		&lt;iajc
			srcdir="${basedir}/src"
			classpath="${aspectjrt}"
			destdir="${basedir}/bin"
			verbose="true"

	       	fork="true"
	       	forkclasspath="${aspectjtools}"
		&gt;
		&lt;/iajc&gt;
	&lt;/target&gt;
	
	&lt;target name="run"&gt;
		&lt;java
			classname="HelloWorld"
			classpath="${basedir}/../../../runtime/bin;${basedir}/bin"
			fork="yes"
		&gt;
			&lt;jvmarg value="-Djava.security.manager"/&gt;
		&lt;/java&gt;
	&lt;/target&gt;
	
	&lt;target name="all" depends="compile, run"/&gt;

&lt;/project&gt;
</file>
<file name="org.aspectj/modules/ajde/testdata/SecurityManagerTest/src/HelloWorld.java" revision="1.1" state="new">/*
 * Created on 28-Sep-2004
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */

/**
 * @author websterm
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class HelloWorld {

	public static void println () {
		System.out.println("Hello World!");
	}
	
	public static void main(String[] args) {
		println();
//		System.getProperty("foo");
	}
}
</file>
<file name="org.aspectj/modules/ajde/testdata/SecurityManagerTest/src/Aspect.aj" revision="1.1" state="new">/*&#13;
 * Created on 28-Sep-2004&#13;
 *&#13;
 * TODO To change the template for this generated file go to&#13;
 * Window - Preferences - Java - Code Style - Code Templates&#13;
 */&#13;
&#13;
&#13;
&#13;
/**
 * @author websterm
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */&#13;
public aspect Aspect {&#13;
&#13;
	pointcut method () :&#13;
		execution(* println(..)) &amp;&amp; within(HelloWorld) &amp;&amp; cflow(execution(* main(..)));&#13;
	&#13;
	before () : method () {&#13;
		System.out.println(thisJoinPoint.getSignature());&#13;
	}&#13;
}&#13;
</file>
</fixedFiles>
</bug>
<bug id="74426" transactionid="72891">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="14"/>
<property name="lines-added" value="77"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="77"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-false K-if K-import K-new K-null K-return K-super K-true K-try K-while M O-== O-() O-cast T V Y Z-cast Z-if Z-while</fullfingerprint>
<bugreport>when trying to delete an aj file in the package explorer, the confirmation 
dialog pops up as usual, but confirming the deletion has no effect.

Maybe we can solve this problem by using the extension point
org.eclipse.ltk.core.refactoring.deleteParticipant</bugreport>
<testsforfix ID="74426" type="new">
    <file LOCATION="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/javamodel/elements/AJCompilationUnitTest2.java">
      <test NAME="testDeletingAJCompilationUnits"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="113" file="output/74426/pre-fix/testresults.xml" passing="1423" size="1536"/>
<post-fix-testcases failing="114" file="output/74426/post-fix/testresults.xml" passing="1422" size="1536"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/plugin.xml" revision="1.6" state="changed">43a44
&gt;       &lt;import plugin="org.eclipse.ltk.core.refactoring"/&gt;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src30/org/eclipse/ajdt/core/javaelements/AJCompilationUnit.java" revision="1.4" state="changed">27a28
&gt; import org.eclipse.core.resources.IContainer;
28a30
&gt; import org.eclipse.core.resources.IFolder;
30a33
&gt; import org.eclipse.core.runtime.CoreException;
33a37
&gt; import org.eclipse.jdt.core.ICompilationUnit;
40a45
&gt; import org.eclipse.jdt.core.JavaCore;
565a571,602
&gt; 	public String getHandleIdentifier() {
&gt; 		final String deletionClass = "org.eclipse.jdt.internal.corext.refactoring.changes.DeleteSourceManipulationChange"; //$NON-NLS-1$
&gt; 		String callerName = (new RuntimeException()).getStackTrace()[1]
&gt; 				.getClassName();
&gt; 		// are we being called in the context of a delete operation?
&gt; 		if (callerName.equals(deletionClass)) {
&gt; 			// neeed to perform the delete ourselves (bug 74426)
&gt; 			IResource res = getResource();
&gt; 			IContainer parent = res.getParent();
&gt; 			if (parent.getType() == IResource.FOLDER) {
&gt; 				IFolder folder = (IFolder) parent;
&gt; 				String newName = CompilationUnitTools
&gt; 						.convertAJToJavaFileName(res.getName());
&gt; 				IFile dummyFile = folder.getFile(newName);
&gt; 				while (dummyFile.exists()) {
&gt; 					newName = newName.substring(0, newName.lastIndexOf('.'))
&gt; 							.concat("9").concat(".java"); //$NON-NLS-1$ //$NON-NLS-2$
&gt; 					dummyFile = folder.getFile(newName);
&gt; 				}
&gt; 				try {
&gt; 					dummyFile.create(null, false, null);
&gt; 					// delete the real .aj file
&gt; 					res.delete(true, null);
&gt; 				} catch (CoreException e) {
&gt; 				}
&gt; 				ICompilationUnit dummyUnit = JavaCore
&gt; 						.createCompilationUnitFrom(dummyFile);
&gt; 				return dummyUnit.getHandleIdentifier();
&gt; 			}
&gt; 		}
&gt; 		return super.getHandleIdentifier();
&gt; 	}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src31/org/eclipse/ajdt/core/javaelements/AJCompilationUnit.java" revision="1.4" state="changed">27a28
&gt; import org.eclipse.core.resources.IContainer;
28a30
&gt; import org.eclipse.core.resources.IFolder;
30a33
&gt; import org.eclipse.core.runtime.CoreException;
35a39
&gt; import org.eclipse.jdt.core.ICompilationUnit;
41a46
&gt; import org.eclipse.jdt.core.JavaCore;
419a425
&gt; 	
422a429
&gt; 		System.out.println("AJ delete");
569a577,609
&gt; 	public String getHandleIdentifier() {
&gt; 		final String deletionClass = "org.eclipse.jdt.internal.corext.refactoring.changes.DeleteSourceManipulationChange"; //$NON-NLS-1$
&gt; 		String callerName = (new RuntimeException()).getStackTrace()[1]
&gt; 				.getClassName();
&gt; 		// are we being called in the context of a delete operation?
&gt; 		if (callerName.equals(deletionClass)) {
&gt; 			// neeed to perform the delete ourselves (bug 74426)
&gt; 			IResource res = getResource();
&gt; 			IContainer parent = res.getParent();
&gt; 			if (parent.getType() == IResource.FOLDER) {
&gt; 				IFolder folder = (IFolder) parent;
&gt; 				String newName = CompilationUnitTools
&gt; 						.convertAJToJavaFileName(res.getName());
&gt; 				IFile dummyFile = folder.getFile(newName);
&gt; 				while (dummyFile.exists()) {
&gt; 					newName = newName.substring(0, newName.lastIndexOf('.'))
&gt; 							.concat("9").concat(".java"); //$NON-NLS-1$ //$NON-NLS-2$
&gt; 					dummyFile = folder.getFile(newName);
&gt; 				}
&gt; 				try {
&gt; 					dummyFile.create(null, false, null);
&gt; 					// delete the real .aj file
&gt; 					res.delete(true, null);
&gt; 				} catch (CoreException e) {
&gt; 				}
&gt; 				ICompilationUnit dummyUnit = JavaCore
&gt; 						.createCompilationUnitFrom(dummyFile);
&gt; 				return dummyUnit.getHandleIdentifier();
&gt; 			}
&gt; 		}
&gt; 		return super.getHandleIdentifier();
&gt; 	}
&gt; 	
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/test/AllTests.java" revision="1.24" state="changed">18a19
&gt; import org.eclipse.ajdt.buildconfigurator.ProjectBuildConfigurationTest2;
47a49
&gt; import org.eclipse.ajdt.javamodel.elements.AJCompilationUnitTest2;
73a76
&gt; 		suite.addTest(new TestSuite(ProjectBuildConfigurationTest2.class));
124a128
&gt; 		suite.addTest(new TestSuite(AJCompilationUnitTest2.class));
145,149c149,157
&lt; 	
&lt; 	// prevents AJDTPrefWizard from popping up during tests
&lt; 	// and simulates normal usage by closing the welcome page, and opening the
&lt; 	// java perspective
&lt; 	private static void setupAJDTPlugin(){
---
&gt; 		
&gt; 	/**
&gt; 	 * Prevents AJDTPrefWizard from popping up during tests and simulates normal
&gt; 	 * usage by closing the welcome page, and opening the java perspective
&gt; 	 */
&gt; 	public static synchronized void setupAJDTPlugin() {
&gt; 		if (setupDone) {
&gt; 			return;
&gt; 		}
152,154c160,163
&lt; 		
&lt; 		IWorkbenchWindow window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();
&lt; 		
---
&gt; 
&gt; 		IWorkbenchWindow window = PlatformUI.getWorkbench()
&gt; 				.getActiveWorkbenchWindow();
&gt; 
156,157c165,167
&lt; 		IIntroPart intro = PlatformUI.getWorkbench().getIntroManager().getIntro();
&lt; 		if (intro!=null) {
---
&gt; 		IIntroPart intro = PlatformUI.getWorkbench().getIntroManager()
&gt; 				.getIntro();
&gt; 		if (intro != null) {
160c170
&lt; 		
---
&gt; 
163c173,174
&lt; 			PlatformUI.getWorkbench().showPerspective(JavaUI.ID_PERSPECTIVE,window);
---
&gt; 			PlatformUI.getWorkbench().showPerspective(JavaUI.ID_PERSPECTIVE,
&gt; 					window);
166c177
&lt; 		
---
&gt; 
172c183
&lt; 		
---
&gt; 
173a185
&gt; 		setupDone = true;
174a187,188
&gt; 
&gt; 	private static boolean setupDone = false;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/javamodel/elements/AJCompilationUnitTest2.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *     Matt Chapman - initial version
 *******************************************************************************/
package org.eclipse.ajdt.javamodel.elements;

import junit.framework.TestCase;

import org.eclipse.ajdt.core.javaelements.AJCompilationUnitManager;
import org.eclipse.ajdt.test.AllTests;
import org.eclipse.ajdt.test.utils.Utils;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.internal.corext.refactoring.reorg.IConfirmQuery;
import org.eclipse.jdt.internal.corext.refactoring.reorg.IReorgQueries;
import org.eclipse.jdt.internal.corext.refactoring.reorg.JavaDeleteProcessor;
import org.eclipse.ltk.core.refactoring.Change;
import org.eclipse.ltk.core.refactoring.participants.CheckConditionsContext;
import org.eclipse.ltk.core.refactoring.participants.ValidateEditChecker;

/**
 * 
 */
public class AJCompilationUnitTest2 extends TestCase {

	// bug 74426
	public void testDeletingAJCompilationUnits() throws Exception {
		AllTests.setupAJDTPlugin();
		IProject project = Utils
				.createPredefinedProject("Introduction Example");

		IFile file1 = (IFile) project
				.findMember("src/introduction/CloneablePoint.aj");
		assertNotNull("Couldn't find CloneablePoint.aj in project", file1);
		IFile file2 = (IFile) project
				.findMember("src/introduction/ComparablePoint.aj");
		assertNotNull("Couldn't find ComparablePoint.aj in project", file1);

		final ICompilationUnit unit1 = AJCompilationUnitManager.INSTANCE
				.getAJCompilationUnit(file1);
		assertNotNull("Couldn't obtain compilation unit for file: " + file1,
				unit1);
		ICompilationUnit unit2 = AJCompilationUnitManager.INSTANCE
				.getAJCompilationUnit(file2);
		assertNotNull("Couldn't obtain compilation unit for file: " + file2,
				unit2);

		// now try to delete these units
		Utils.waitForJobsToComplete();

		Object[] elements = new Object[] { unit1, unit2 };
		JavaDeleteProcessor processor = new JavaDeleteProcessor(elements);
		IProgressMonitor pm = new NullProgressMonitor();
		CheckConditionsContext context = new CheckConditionsContext();
		context.add(new ValidateEditChecker(context));
		IReorgQueries q = new IReorgQueries() {
			public IConfirmQuery createYesYesToAllNoNoToAllQuery(
					String queryTitle, boolean allowCancel, int queryID) {
				return null;
			}

			public IConfirmQuery createYesNoQuery(String queryTitle,
					boolean allowCancel, int queryID) {
				return null;
			}

			public IConfirmQuery createSkipQuery(String queryTitle, int queryID) {
				return null;
			}
		};
		processor.setQueries(q);
		processor.checkInitialConditions(pm);
		processor.checkFinalConditions(pm, context);
		Change change = processor.createChange(pm);
		change.perform(pm);

		Utils.waitForJobsToComplete();

		// check the corresponding files have gone
		assertFalse("File should have been deleted: " + file1, file1.exists());
		assertFalse("File should have been deleted: " + file2, file2.exists());

		Utils.deleteProject(project);
	}

}
</file>
</fixedFiles>
</bug>
<bug id="74952" transactionid="68402">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="15"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="17"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if M O-== T V Y Z-if Z-throw</fullfingerprint>
<bugreport>Reference: "cflow(within(C)) vs (within(C)||cflowbelow(within(C)) in
aspectj-users mailing list.

The aspect TraceClass below doesn't print any message when the pointcut is
defined to "!cflow(within(Trace*))". The other defintion "!(within(Trace*) ||
cflowbelow(within(Trace*)))" works fine. Wes Isberg in his reply explained that
cflow should never be used alone but he thought "there is a bug or two in here"

class SomeClass 
{
    static public void main (String [] args) {
    }
} // SomeClass

aspect TraceClass {

    // members
    static private int level = 0;

    static private void offset() {
        int i;
        for (i = 0; i &lt; level; ++i) {
            System.out.print("  ");
        }
    } // offset

    pointcut pc() : 
        !cflow(within(Trace*))
//        !(within(Trace*) || cflowbelow(within(Trace*)))
        ;
    before () : pc() {
        offset();
        System.out.println("-&gt; " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.out.println("&lt;- " + thisJoinPoint);
    }
} // TraceClass

In order to try to figure out what is happening within TraceClass, I added a
second aspect, TraceTrace, just to trace TraceClass.

aspect TraceTrace {

    // members
    static private int level = 0;

    static private void offset() {
        int i;
        for (i = 0; i &lt; level; ++i) {
            System.out.print("  ");
        }
    } // offset

    pointcut pc() : within(TraceClass);
    before () : pc() {
        offset();
        System.out.println("=&gt; " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.out.println("&lt;= " + thisJoinPoint);
    }
} // TraceTrace

Here is what TraceTrace prints when TraceClass uses "!cflow(within(Trace*))"

=&gt; staticinitialization(TraceClass.&lt;clinit&gt;)
  =&gt; set(int TraceClass.level)
  &lt;= set(int TraceClass.level)
  =&gt; preinitialization(TraceClass())
    =&gt; initialization(TraceClass())
      =&gt; execution(TraceClass())
      &lt;= execution(TraceClass())
    &lt;= initialization(TraceClass())
  &lt;= staticinitialization(TraceClass.&lt;clinit&gt;)

The after advice is not executed for preinitialization.</bugreport>
<testsforfix ID="74952" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test065"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="before,after not (cflow(within(Trace*))) prints nothing"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/74952/pre-fix/testresults.xml" passing="1290" size="1402"/>
<post-fix-testcases failing="112" file="output/74952/post-fix/testresults.xml" passing="1291" size="1403"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.44" state="changed">242a243,245
&gt; 		} else if (getKind() == PreInitialization) { // pr74952
&gt; 			ShadowRange range = getRange();
&gt; 			range.insert(InstructionConstants.NOP,Range.InsideAfter); 
1261a1265,1276
&gt;         	/*
&gt;         	 * 
&gt;  27:  getstatic       #72; //Field ajc$cflowCounter$0:Lorg/aspectj/runtime/internal/CFlowCounter;
&gt;  30:  invokevirtual   #87; //Method org/aspectj/runtime/internal/CFlowCounter.dec:()V
&gt;  33:  aload   6
&gt;  35:  athrow
&gt;  36:  nop
&gt;  37:  getstatic       #72; //Field ajc$cflowCounter$0:Lorg/aspectj/runtime/internal/CFlowCounter;
&gt;  40:  invokevirtual   #87; //Method org/aspectj/runtime/internal/CFlowCounter.dec:()V
&gt;  43:  d2i
&gt;  44:  invokespecial   #23; //Method java/lang/Object."&lt;init&gt;":()V
&gt;         	 */
1298c1313
&lt;         } else {
---
&gt;         } else {            
1452c1467
&lt; 						throw new RuntimeException("Oncorrectly attempting counter operation on stacked cflow");
---
&gt; 						throw new RuntimeException("Incorrectly attempting counter operation on stacked cflow");
1490d1504
&lt; 						
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.35" state="changed">497a498,502
&gt;     
&gt;     &lt;ajc-test dir="bugs" pr="74952" title="before,after not (cflow(within(Trace*))) prints nothing"&gt;
&gt;         &lt;compile files="WhatsGoingOn.java"/&gt;
&gt;         &lt;run class="WhatsGoingOn"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.33" state="changed">22a23,25
&gt; 
&gt; 
&gt; 	  
339a343,361
&gt;   
&gt;   private int countLines(String s) {
&gt;     int lines = 0;
&gt;     int idx = 0;
&gt;     while (s.indexOf("\n",idx)!=-1) {
&gt;     	lines++;
&gt;     	idx = s.indexOf("\n",idx)+1;
&gt;     }
&gt;     return lines;
&gt;   }
&gt;   
&gt;   public void test065() {
&gt;   	runTest("before,after not (cflow(within(Trace*))) prints nothing");
&gt;   	String s = getLastRunResult().getStdErr();
&gt;   	int lines = countLines(s);
&gt; 	assertTrue("The actual output does not match the expected output.  Expected 102 lines but got "+
&gt; 			   lines+" lines.  Actual output =\n"+s,lines==102);
&gt; 	// IF YOU WANT TO SEE THE EXPECTED OUTPUT, LOOK IN THE TEST PROGRAM bugs/WhatsGoingOn.java
&gt;   }
</file>
<file name="org.aspectj/modules/tests/bugs/WhatsGoingOn.java" revision="1.1" state="new">public class WhatsGoingOn {
    static public void main (String [] args) { }
}

aspect TraceClass {
    static private int level = 0;

    static private void offset() {
        for (int i = 0; i &lt; level; ++i)  System.err.print("  ");
    }

    pointcut pc() : 
        !cflow(within(Trace*))
//        !(within(Trace*) || cflowbelow(within(Trace*)))
        ;
    before () : pc() {
        offset();
        System.err.println("-&gt; " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.err.println("&lt;- " + thisJoinPoint);
    }
} 

aspect TraceTrace {

    static private int level = 0;

    static private void offset() {
        for (int i = 0; i &lt; level; ++i)         System.err.print("  ");
    }
    
    pointcut pc() : within(TraceClass);
    before () : pc() {
        offset();
        System.err.println("=&gt; " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.err.println("&lt;= " + thisJoinPoint);
    }
}

//Expected output:
//"=&gt; staticinitialization(TraceClass.&lt;clinit&gt;)\n"+
//"  =&gt; set(int TraceClass.level)\n"+
//"  &lt;= set(int TraceClass.level)\n"+
//"  =&gt; preinitialization(TraceClass())\n"+
//"  &lt;= preinitialization(TraceClass())\n"+
//"  =&gt; initialization(TraceClass())\n"+
//"    =&gt; execution(TraceClass())\n"+
//"    &lt;= execution(TraceClass())\n"+
//"  &lt;= initialization(TraceClass())\n"+
//"&lt;= staticinitialization(TraceClass.&lt;clinit&gt;)\n"+
//"=&gt; execution(ADVICE: void TraceClass.ajc$before$TraceClass$1$346234(JoinPoint))\n"+
//"  =&gt; call(void TraceClass.offset())\n"+
//"    =&gt; execution(void TraceClass.offset())\n"+
//"      =&gt; get(int TraceClass.level)\n"+
//"      &lt;= get(int TraceClass.level)\n"+
//"    &lt;= execution(void TraceClass.offset())\n"+
//"  &lt;= call(void TraceClass.offset())\n"+
//"  =&gt; get(PrintStream java.lang.System.err)\n"+
//"  &lt;= get(PrintStream java.lang.System.err)\n"+
//"  =&gt; call(java.lang.StringBuffer(String))\n"+
//"  &lt;= call(java.lang.StringBuffer(String))\n"+
//"  =&gt; call(StringBuffer java.lang.StringBuffer.append(Object))\n"+
//"  &lt;= call(StringBuffer java.lang.StringBuffer.append(Object))\n"+
//"  =&gt; call(String java.lang.StringBuffer.toString())\n"+
//"  &lt;= call(String java.lang.StringBuffer.toString())\n"+
//"  =&gt; call(void java.io.PrintStream.println(String))\n"+
//"-&gt; staticinitialization(WhatsGoingOn.&lt;clinit&gt;)\n"+
//"  &lt;= call(void java.io.PrintStream.println(String))\n"+
//"  =&gt; get(int TraceClass.level)\n"+
//"  &lt;= get(int TraceClass.level)\n"+
//"  =&gt; set(int TraceClass.level)\n"+
//"  &lt;= set(int TraceClass.level)\n"+
//"&lt;= execution(ADVICE: void TraceClass.ajc$before$TraceClass$1$346234(JoinPoint))\n"+
//"=&gt; execution(ADVICE: void TraceClass.ajc$after$TraceClass$2$346234(JoinPoint))\n"+
//"  =&gt; get(int TraceClass.level)\n"+
//"  &lt;= get(int TraceClass.level)\n"+
//"  =&gt; set(int TraceClass.level)\n"+
//"  &lt;= set(int TraceClass.level)\n"+
//"  =&gt; call(void TraceClass.offset())\n"+
//"    =&gt; execution(void TraceClass.offset())\n"+
//"      =&gt; get(int TraceClass.level)\n"+
//"      &lt;= get(int TraceClass.level)\n"+
//"    &lt;= execution(void TraceClass.offset())\n"+
//"  &lt;= call(void TraceClass.offset())\n"+
//"  =&gt; get(PrintStream java.lang.System.err)\n"+
//"  &lt;= get(PrintStream java.lang.System.err)\n"+
//"  =&gt; call(java.lang.StringBuffer(String))\n"+
//"  &lt;= call(java.lang.StringBuffer(String))\n"+
//"  =&gt; call(StringBuffer java.lang.StringBuffer.append(Object))\n"+
//"  &lt;= call(StringBuffer java.lang.StringBuffer.append(Object))\n"+
//"  =&gt; call(String java.lang.StringBuffer.toString())\n"+
//"  &lt;= call(String java.lang.StringBuffer.toString())\n"+
//"  =&gt; call(void java.io.PrintStream.println(String))\n"+
//"&lt;- staticinitialization(WhatsGoingOn.&lt;clinit&gt;)\n"+
//"  &lt;= call(void java.io.PrintStream.println(String))\n"+
//"&lt;= execution(ADVICE: void TraceClass.ajc$after$TraceClass$2$346234(JoinPoint))\n"+
//"=&gt; execution(ADVICE: void TraceClass.ajc$before$TraceClass$1$346234(JoinPoint))\n"+
//"  =&gt; call(void TraceClass.offset())\n"+
//"    =&gt; execution(void TraceClass.offset())\n"+
//"      =&gt; get(int TraceClass.level)\n"+
//"      &lt;= get(int TraceClass.level)\n"+
//"    &lt;= execution(void TraceClass.offset())\n"+
//"  &lt;= call(void TraceClass.offset())\n"+
//"  =&gt; get(PrintStream java.lang.System.err)\n"+
//"  &lt;= get(PrintStream java.lang.System.err)\n"+
//"  =&gt; call(java.lang.StringBuffer(String))\n"+
//"  &lt;= call(java.lang.StringBuffer(String))\n"+
//"  =&gt; call(StringBuffer java.lang.StringBuffer.append(Object))\n"+
//"  &lt;= call(StringBuffer java.lang.StringBuffer.append(Object))\n"+
//"  =&gt; call(String java.lang.StringBuffer.toString())\n"+
//"  &lt;= call(String java.lang.StringBuffer.toString())\n"+
//"  =&gt; call(void java.io.PrintStream.println(String))\n"+
//"-&gt; execution(void WhatsGoingOn.main(String[]))\n"+
//"  &lt;= call(void java.io.PrintStream.println(String))\n"+
//"  =&gt; get(int TraceClass.level)\n"+
//"  &lt;= get(int TraceClass.level)\n"+
//"  =&gt; set(int TraceClass.level)\n"+
//"  &lt;= set(int TraceClass.level)\n"+
//"&lt;= execution(ADVICE: void TraceClass.ajc$before$TraceClass$1$346234(JoinPoint))\n"+
//"=&gt; execution(ADVICE: void TraceClass.ajc$after$TraceClass$2$346234(JoinPoint))\n"+
//"  =&gt; get(int TraceClass.level)\n"+
//"  &lt;= get(int TraceClass.level)\n"+
//"  =&gt; set(int TraceClass.level)\n"+
//"  &lt;= set(int TraceClass.level)\n"+
//"  =&gt; call(void TraceClass.offset())\n"+
//"    =&gt; execution(void TraceClass.offset())\n"+
//"      =&gt; get(int TraceClass.level)\n"+
//"      &lt;= get(int TraceClass.level)\n"+
//"    &lt;= execution(void TraceClass.offset())\n"+
//"  &lt;= call(void TraceClass.offset())\n"+
//"  =&gt; get(PrintStream java.lang.System.err)\n"+
//"  &lt;= get(PrintStream java.lang.System.err)\n"+
//"  =&gt; call(java.lang.StringBuffer(String))\n"+
//"  &lt;= call(java.lang.StringBuffer(String))\n"+
//"  =&gt; call(StringBuffer java.lang.StringBuffer.append(Object))\n"+
//"  &lt;= call(StringBuffer java.lang.StringBuffer.append(Object))\n"+
//"  =&gt; call(String java.lang.StringBuffer.toString())\n"+
//"  &lt;= call(String java.lang.StringBuffer.toString())\n"+
//"  =&gt; call(void java.io.PrintStream.println(String))\n"+
//"&lt;- execution(void WhatsGoingOn.main(String[]))\n"+
//"  &lt;= call(void java.io.PrintStream.println(String))\n"+
//"&lt;= execution(ADVICE: void TraceClass.ajc$after$TraceClass$2$346234(JoinPoint))\n");</file>
</fixedFiles>
</bug>
<bug id="76055" transactionid="71122">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="10"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-return T V</fullfingerprint>
<bugreport>In order to find out which other pointcuts are referenced by a pointcut definition  
i need to access the private members of the CflowPointcut, IfPointcut and
NotPointcut PatternNodes found in the weaver module.

Unlike the OrPointcut and AndPointcut classes, they are missing the appropriate
getter methods.</bugreport>
<pre-fix-testcases failing="112" file="output/76055/pre-fix/testresults.xml" passing="1429" size="1541"/>
<post-fix-testcases failing="113" file="output/76055/post-fix/testresults.xml" passing="1428" size="1541"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/IfPointcut.java" revision="1.21" state="changed">79a80,84
&gt; 	// enh 76055
&gt; 	public Pointcut getResidueSource() {
&gt; 		return residueSource;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java" revision="1.21" state="changed">74a75,79
&gt; 	// enh 76055
&gt; 	public Pointcut getEntry() {
&gt; 		return entry; 
&gt; 	}
&gt; 	
</file>
</fixedFiles>
</bug>
<bug id="76061" transactionid="73884">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="minor"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null M O-== T V Z-if</fullfingerprint>
<bugreport>Hi, when right clicking in the gutter on an advice marker annotation and 
selecting an aspect which is affecting the line of code the marker appears on I 
get the following error in the status bar: "could not find resource".
My project is set up so that the core system (non-AJ) is in one directory tree, 
and aspects are in a different, parallel structure.
This occurrs on Eclipse 3.0.1.
All the Java compiler settings are such that debug info, etc is added to the 
source files.
Also, I've managed to reproduce the problem with the Spacewar example, by 
creating a SpaceAspects directory on the root of my D: drive (eclipse is also on 
D:) and moving the contents of the coordination package into it (obviously, also 
creating a new source folder in the project, linked to SpaceAspects).
The project still builds and runs correctly, but when trying to navigate from a 
class in the original "src" dir to any aspect in the coordination package which 
advises it is not possible.</bugreport>
<pre-fix-testcases failing="113" file="output/76061/pre-fix/testresults.xml" passing="1290" size="1403"/>
<post-fix-testcases failing="114" file="output/76061/post-fix/testresults.xml" passing="1289" size="1403"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AdviceActionDelegate.java" revision="1.2" state="changed">291c291
&lt;                 final IResource ir = AspectJUIPlugin.getDefault()
---
&gt;                 IResource r = AspectJUIPlugin.getDefault()
293c293,297
&lt; 
---
&gt;                 if(r == null) {
&gt;                 	r = AspectJUIPlugin.getDefault().getAjdtProjectProperties().findResource(filepath, AspectJUIPlugin.getDefault().getCurrentProject());
&gt;                 }
&gt;                 final IResource ir = r;
&gt;                 
</file>
</fixedFiles>
</bug>
<bug id="76096" transactionid="69853">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="11"/>
<property name="lines-churned" value="12"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-null M O-! T V Z-if</fullfingerprint>
<bugreport>The example below generates a compiler error, on both Linux and Windows. The
error occurs for ajdt (eclipse) as well.

The compiler error:

$ ajc -version
&gt; AspectJ Compiler 1.2 built on Friday May 21, 2004 at
&gt; 15:06:22 GMT
&gt; $ ajc ConcreteClassA.java
&gt; error can't find type $Local$
&gt; 
&gt; /home/marin/tests/ConcreteClassA.java:18 error Class
&gt; must implement the inherited abstract method
&gt; InterfaceA.a2()
&gt; InterfaceA a = new AbstractClassA() {
&gt;                    ^^^^^^^^^^^^^
&gt; 
&gt; 2 errors
&gt; --------
&gt; 


The example (in ConcreteClassA.java):


interface InterfaceA {

 public void a1();
 
 public void a2();
 
}

abstract class AbstractClassA implements InterfaceA {

 public void a1() {
  System.out.println("AbstractClassA.a()");
 }
 
}


public class ConcreteClassA extends AbstractClassA {

 public void someMethod() {
  InterfaceA a = new AbstractClassA() {
  };
 }
 
}

aspect IntroAspectA {

 public void AbstractClassA.a2() {
  System.out.println("AbstractClassA.a2() from IntroAspectA");
 }
}

------------
If you comment out the body of someMethod() (the anonymous class), the code
compiles without errors.</bugreport>
<testsforfix ID="76096" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java">
      <test NAME="test064"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml">
      <test NAME="Anonymous classes unaware of introductions into abstract classes"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="114" file="output/76096/pre-fix/testresults.xml" passing="1287" size="1401"/>
<post-fix-testcases failing="112" file="output/76096/post-fix/testresults.xml" passing="1290" size="1402"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java" revision="1.20" state="changed">17a18
&gt; import java.util.List;
159c160,170
&lt; 		ResolvedTypeX onTypeX = factory.fromEclipse(type); //abstractMethod.declaringClass);
---
&gt; 		ResolvedTypeX onTypeX = null;
&gt; 		
&gt; 		// If the type is anonymous, look at its supertype
&gt; 		if (!type.isAnonymousType()) {
&gt; 			onTypeX = factory.fromEclipse(type);
&gt; 		} else {
&gt; 			// Hmmm. If the ITD is on an interface that is being 'instantiated' using an anonymous type,
&gt; 			// we sort it out elsewhere and don't come into this method - 
&gt; 			// so we don't have to worry about interfaces, just the superclass.
&gt; 		    onTypeX = factory.fromEclipse(type.superclass()); //abstractMethod.declaringClass);
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java" revision="1.32" state="changed">336a337,340
&gt;   public void test064() {
&gt;   	runTest("Anonymous classes unaware of introductions into abstract classes");
&gt;   }
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc121/ajc121-tests.xml" revision="1.34" state="changed">492a493,497
&gt;     
&gt;     &lt;ajc-test dir="bugs/pr76096" pr="76096" title="Anonymous classes unaware of introductions into abstract classes"&gt;
&gt;         &lt;compile files="ConcreteClassA.java"/&gt;
&gt;         &lt;run class="ConcreteClassA"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs/pr76096/ConcreteClassA.java" revision="1.1" state="new">// In the ConcreteClassA.someMethod() method, the creation of the anonymous class should
// be ok as the ITD ensures that InterfaceA.a2() is implemented.

interface InterfaceA {
 public void a1();
 public void a2();
}

abstract class AbstractClassA implements InterfaceA {
  public void a1() {
    System.out.println("AbstractClassA.a()");
  }
}

public class ConcreteClassA extends AbstractClassA {
  public void someMethod() {
    InterfaceA a = new AbstractClassA() {  };
    a.a2(); 
  }
  
  public static void main(String[]argv) {
  	new ConcreteClassA().someMethod();
  	new concCB().someMethod();
  }
}

aspect IntroAspectA {
  public void AbstractClassA.a2() {
    System.out.println("AbstractClassA.a2() from IntroAspectA");
  }
}

interface IB {
	 public void m2();
}

abstract class absCB implements IB {
	public void m1() { }
}

class concCB extends absCB {
	public void someMethod() {
		IB b = new IB() {};
		b.m2();
	}
}

aspect introAspectB {
	public void IB.m2() {System.err.println("absCB.m1() from IB");}
}
</file>
</fixedFiles>
</bug>
<bug id="76365" transactionid="73160">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="5"/>
<property name="hunks" value="12"/>
<property name="lines-added" value="36"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="39"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-case K-return K-true M O-== O-|| O-() T V Y Z-if</fullfingerprint>
<bugreport>- mark a .aj resource in the package explorer
- hit CTRL+C
- mark a target package
- hit CTRL+V
-&gt; exception</bugreport>
<testsforfix ID="76365" type="changed">
    <file LOCATION="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/AJCoreTest.java">
      <test NAME="testCreateElementFromHandle"/>
      <test NAME="testCreateElementFromHandle2"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="69" file="output/76365/pre-fix/testresults.xml" passing="873" size="942"/>
<post-fix-testcases failing="69" file="output/76365/post-fix/testresults.xml" passing="873" size="942"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src30/org/eclipse/ajdt/core/javaelements/AJCompilationUnit.java" revision="1.12" state="changed">602a603,609
&gt; 	/**
&gt; 	 * @see JavaElement#getHandleMementoDelimiter()
&gt; 	 */
&gt; 	protected char getHandleMementoDelimiter() {
&gt; 		return AspectElement.JEM_ASPECT_CU;
&gt; 	}
&gt; 
622a630
&gt; 					// create an empty file
623a632,636
&gt; 
&gt; 					// this avoids exceptions caused by clients responding
&gt; 					// to the file creation
&gt; 					dummyFile.setTeamPrivateMember(true);
&gt; 										
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/javaelements/AspectElement.java" revision="1.7" state="changed">34a35
&gt; 	public static final char JEM_ASPECT_CU = '*';
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/AspectJCore.java" revision="1.6" state="changed">109,110c109,111
&lt; 			if (token.charAt(0) == JavaElement.JEM_COMPILATIONUNIT) {
&lt; 				int index = handleIdentifier
---
&gt; 			if ((token.charAt(0) == AspectElement.JEM_ASPECT_CU)
&gt; 					|| (token.charAt(0) == JavaElement.JEM_COMPILATIONUNIT)) {
&gt; 				int index1 = handleIdentifier
111a113,115
&gt; 				int index2 = handleIdentifier
&gt; 					.indexOf(AspectElement.JEM_ASPECT_CU);
&gt; 				int index = Math.max(index1,index2);
222a227,229
&gt; 	private static final String ASPECT_CU = Character
&gt; 			.toString(AspectElement.JEM_ASPECT_CU);
&gt; 
294a302,303
&gt; 		case AspectElement.JEM_ASPECT_CU:
&gt; 			return ASPECT_CU;
330a340
&gt; 			case AspectElement.JEM_ASPECT_CU:
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src31/org/eclipse/ajdt/core/javaelements/AJCompilationUnit.java" revision="1.13" state="changed">614a615,621
&gt; 		}
&gt; 	
&gt; 	/**
&gt; 	 * @see JavaElement#getHandleMementoDelimiter()
&gt; 	 */
&gt; 	protected char getHandleMementoDelimiter() {
&gt; 		return AspectElement.JEM_ASPECT_CU;
636a644
&gt; 					// create an empty file
637a646,650
&gt; 
&gt; 					// this avoids exceptions caused by clients responding
&gt; 					// to the file creation
&gt; 					dummyFile.setTeamPrivateMember(true);
&gt; 										
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/AJCoreTest.java" revision="1.9" state="changed">52c52
&lt; 					{ "=TJP Example/src&lt;tjp{GetInfo.aj", "GetInfo.aj",
---
&gt; 					{ "=TJP Example/src&lt;tjp*GetInfo.aj", "GetInfo.aj",
54c54
&lt; 					{ "=TJP Example/src&lt;tjp{GetInfo.aj}GetInfo", "GetInfo",
---
&gt; 					{ "=TJP Example/src&lt;tjp*GetInfo.aj}GetInfo", "GetInfo",
56c56
&lt; 					{ "=TJP Example/src&lt;tjp{GetInfo.aj}GetInfo~println",
---
&gt; 					{ "=TJP Example/src&lt;tjp*GetInfo.aj}GetInfo~println",
58c58
&lt; 					{ "=TJP Example/src&lt;tjp{GetInfo.aj}GetInfo&amp;around",
---
&gt; 					{ "=TJP Example/src&lt;tjp*GetInfo.aj}GetInfo&amp;around",
93c93
&lt; 							"=Bean Example/src&lt;bean{BoundPoint.aj}BoundPoint&amp;around&amp;QPoint;",
---
&gt; 							"=Bean Example/src&lt;bean*BoundPoint.aj}BoundPoint&amp;around&amp;QPoint;",
96c96
&lt; 							"=Bean Example/src&lt;bean{BoundPoint.aj}BoundPointPoint.hasListenersQString;",
---
&gt; 							"=Bean Example/src&lt;bean*BoundPoint.aj}BoundPointPoint.hasListenersQString;",
100c100
&lt; 							"=Bean Example/src&lt;bean{BoundPoint.aj}BoundPoint`declare parents",
---
&gt; 							"=Bean Example/src&lt;bean*BoundPoint.aj}BoundPoint`declare parents",
104c104
&lt; 							"=Bean Example/src&lt;bean{BoundPoint.aj}BoundPoint`declare parents!2",
---
&gt; 							"=Bean Example/src&lt;bean*BoundPoint.aj}BoundPoint`declare parents!2",
</file>
</fixedFiles>
</bug>
<bug id="76798" transactionid="69434">
<property name="files-churned" value="7"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="7"/>
<property name="hunks" value="17"/>
<property name="lines-added" value="100"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="12"/>
<property name="lines-churned" value="112"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-else K-if K-import K-instanceof K-new K-null K-return K-this K-throw M O-== O-&gt; O-!= O-+ O-cast O-instanceof T V Y Z-cast Z-if Z-throw</fullfingerprint>
<bugreport>We don't currently include a version in the class files that come out of the
weaver.  This can cause problems.  For example, if we add a new attribute to a
class file in a future version of AspectJ, then that attribute will cause older
versions of AspectJ to blow up if they encounter it.  If we include a version in
the class file we can rev the version number when we add attributes (or change
the class file form in another way), and by checking that version number in the
weaver we can better determine whether we should fail if we encounter a new
attribute (or other change), or if it is safe to continue processing.

I will add a new WeaverVersion attribute that includes 2 shorts.  Major and Minor.

Encountering a major version in a class file that is greater than the version a
particular weaver is designed to understand will cause compilation to fail.

Encountering a minor version in a class file that is greater than the minor
version a particular weaver is designed to understand will not cause compilation
to fail - we will assume it is safe to continue.</bugreport>
<pre-fix-testcases failing="113" file="output/76798/pre-fix/testresults.xml" passing="1290" size="1403"/>
<post-fix-testcases failing="112" file="output/76798/post-fix/testresults.xml" passing="1291" size="1403"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java" revision="1.25" state="changed">398c398,402
&lt;     	if (myType != null &amp;&amp; myType.getWeaverState() != null) {
---
&gt;         
&gt;         // Add a weaver version attribute to the file being produced
&gt;         myGen.addAttribute(BcelAttributes.bcelAttribute(new AjAttribute.WeaverVersionInfo(),getConstantPoolGen()));
&gt; 
&gt;         if (myType != null &amp;&amp; myType.getWeaverState() != null) {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java" revision="1.29" state="changed">442c442
&lt; 		List as = BcelAttributes.readAjAttributes(attributes, context);
---
&gt; 		List as = BcelAttributes.readAjAttributes(attributes, context,null);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelField.java" revision="1.7" state="changed">50c50
&lt; 		List as = BcelAttributes.readAjAttributes(attrs, getSourceContext(world));
---
&gt; 		List as = BcelAttributes.readAjAttributes(attrs, getSourceContext(world),world.getMessageHandler());
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java" revision="1.5" state="changed">21a22
&gt; import org.aspectj.bridge.IMessageHandler;
30c31
&lt; 	public static List readAjAttributes(Attribute[] as, ISourceContext context) {
---
&gt; 	public static List readAjAttributes(Attribute[] as, ISourceContext context,IMessageHandler msgHandler) {
38c39,40
&lt; 					l.add(AjAttribute.read(name, u.getBytes(), context));
---
&gt; 					AjAttribute attr = AjAttribute.read(name, u.getBytes(), context,msgHandler);
&gt; 					if (attr!=null) l.add(attr);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java" revision="1.16" state="changed">52a53
&gt; 	private AjAttribute.WeaverVersionInfo wvInfo = null;
166c167
&lt; 		List l = BcelAttributes.readAjAttributes(javaClass.getAttributes(), getResolvedTypeX().getSourceContext());
---
&gt; 		List l = BcelAttributes.readAjAttributes(javaClass.getAttributes(), getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler());
185a187,195
&gt; 			} else if (a instanceof AjAttribute.WeaverVersionInfo) {
&gt; 				wvInfo = (AjAttribute.WeaverVersionInfo)a;
&gt; 				if (wvInfo.getMajorVersion() &gt; wvInfo.getCurrentWeaverMajorVersion()) {
&gt; 					// The class file containing this attribute was created by a version of AspectJ that
&gt; 					// added some behavior that 'this' version of AspectJ doesn't understand.  And the
&gt; 					// class file contains changes that mean 'this' version of AspectJ cannot continue.
&gt; 					throw new BCException("Unable to continue, this version of AspectJ supports classes built with weaver version "+
&gt; 							wvInfo.toCurrentVersionString()+" but the class "+ javaClass.getClassName()+" is version "+wvInfo.toString());
&gt; 				}
281a292,295
&gt; 	
&gt; 	public AjAttribute.WeaverVersionInfo getWeaverVersionAttribute() {
&gt; 		return wvInfo;
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AjAttribute.java" revision="1.9" state="changed">21a22,23
&gt; import org.aspectj.bridge.IMessageHandler;
&gt; import org.aspectj.bridge.MessageUtil;
22a25
&gt; import org.aspectj.weaver.bcel.BcelWorld;
84c87
&lt; 	public static AjAttribute read(String name, byte[] bytes, ISourceContext context) {
---
&gt; 	public static AjAttribute read(String name, byte[] bytes, ISourceContext context,IMessageHandler msgHandler) {
93a97,98
&gt; 			} else if (name.equals(WeaverVersionInfo.AttributeName)) {
&gt; 				return WeaverVersionInfo.read(s);
111c116,119
&lt; 				throw new BCException("unknown attribute" + name);
---
&gt; 				// We have to tell the user about this...
&gt; 				if (msgHandler == null) throw new BCException("unknown attribute" + name);
&gt; 				msgHandler.handleMessage(MessageUtil.warn("unknown attribute encountered "+name));
&gt; 				return null;
179a188,263
&gt; 	public static class WeaverVersionInfo extends AjAttribute {
&gt; 		public static final String AttributeName = "org.aspectj.weaver.WeaverVersion";
&gt; 	
&gt; 		// If you change the format of an AspectJ class file, you have two options:
&gt; 		// - changing the minor version means you have not added anything that prevents
&gt; 		//   previous versions of the weaver from operating (e.g. MethodDeclarationLineNumber attribute)
&gt; 		// - changing the major version means you have added something that prevents previous
&gt; 		//   versions of the weaver from operating correctly.
&gt; 		//
&gt; 		// The user will get a warning for any org.aspectj.weaver attributes the weaver does
&gt; 		// not recognize.
&gt; 		
&gt; 		// These are the weaver major/minor numbers for AspectJ 1.2.1
&gt; 		private static short WEAVER_VERSION_MAJOR_AJ121 = 1;
&gt; 		private static short WEAVER_VERSION_MINOR_AJ121 = 0;
&gt; 		
&gt; 		// These are the weaver major/minor versions for *this* weaver
&gt; 		private static short CURRENT_VERSION_MAJOR      = WEAVER_VERSION_MAJOR_AJ121;
&gt; 		private static short CURRENT_VERSION_MINOR      = WEAVER_VERSION_MINOR_AJ121;
&gt; 		
&gt; 		// These are the versions read in from a particular class file.
&gt; 		private short major_version; 
&gt; 		private short minor_version;
&gt; 		
&gt; 		public String getNameString() {
&gt; 			return AttributeName;
&gt; 		}
&gt; 
&gt; 		// Default ctor uses the current version numbers
&gt; 		public WeaverVersionInfo() {
&gt; 			this.major_version = CURRENT_VERSION_MAJOR;
&gt; 			this.minor_version = CURRENT_VERSION_MINOR;
&gt; 		}
&gt; 		
&gt; 		public WeaverVersionInfo(short major,short minor) {
&gt; 			major_version = major;
&gt; 			minor_version = minor;
&gt; 		}
&gt; 		
&gt; 		public void write(DataOutputStream s) throws IOException {
&gt; 			s.writeShort(CURRENT_VERSION_MAJOR);
&gt; 			s.writeShort(CURRENT_VERSION_MINOR);
&gt; 		}
&gt; 		
&gt; 		public static WeaverVersionInfo read(DataInputStream s) throws IOException {
&gt; 			short major = s.readShort();
&gt; 			short minor = s.readShort();
&gt; 			return new WeaverVersionInfo(major,minor);
&gt; 		}
&gt; 		
&gt; 		public short getMajorVersion() {
&gt; 			return major_version;
&gt; 		}
&gt; 		
&gt; 		public short getMinorVersion() {
&gt; 			return minor_version;
&gt; 		}
&gt; 		
&gt; 		public static short getCurrentWeaverMajorVersion() {
&gt; 			return CURRENT_VERSION_MAJOR;
&gt; 		}
&gt; 		
&gt; 		public static short getCurrentWeaverMinorVersion() {
&gt; 			return CURRENT_VERSION_MINOR;
&gt; 		}
&gt; 		
&gt; 		public String toString() {
&gt; 			return major_version+"."+minor_version;
&gt; 		}
&gt; 		
&gt; 		public static String toCurrentVersionString() {
&gt; 			return CURRENT_VERSION_MAJOR+"."+CURRENT_VERSION_MINOR;
&gt; 		}
&gt; 		
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelMethod.java" revision="1.9" state="changed">84c84
&lt; 		List as = BcelAttributes.readAjAttributes(method.getAttributes(), getSourceContext(world));
---
&gt; 		List as = BcelAttributes.readAjAttributes(method.getAttributes(), getSourceContext(world),world.getMessageHandler());
</file>
</fixedFiles>
</bug>
<bug id="76903" transactionid="73379">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="16"/>
<property name="lines-churned" value="18"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-if K-import K-new K-try M O-- O-+ T V Y Z-if</fullfingerprint>
<bugreport>Configuration:
sun jdk 1.4.2_04
eclipse 3.0.1
AJDT 1.2.0M1

While going through the toturial at:
http://www-106.ibm.com/developerworks/java/library/j-ajdt/

I ran into some problems, when I came to the ajdoc steps . After completing the
"ajdoc wizard", when the ajdoc tool were supposed to launc I got this error message:
"java.lang.NoClassDefFoundError: org/aspectj/tools/ajdoc/Main
Exception in thread "main" "</bugreport>
<pre-fix-testcases failing="112" file="output/76903/pre-fix/testresults.xml" passing="1291" size="1403"/>
<post-fix-testcases failing="113" file="output/76903/post-fix/testresults.xml" passing="1290" size="1403"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/ajdocexport/JavadocWizard.java" revision="1.2" state="changed">25a26
&gt; import org.eclipse.ajdt.core.AspectJPlugin;
39a41
&gt; import org.eclipse.core.runtime.Platform;
300c302,317
&lt; 			String aspectjtoolsDir = aspectjrtDir.substring(0, aspectjrtDir.length() - 13).concat("aspectjtools.jar");
---
&gt; 			String aspectjtoolsDir = ""; //$NON-NLS-1$
&gt; 			URL ajdeURL = Platform.getBundle(AspectJPlugin.TOOLS_PLUGIN_ID).getEntry("ajde.jar"); //$NON-NLS-1$
&gt; 			URL coreURL = Platform.getBundle("org.eclipse.core.runtime").getEntry("runtime.jar"); //$NON-NLS-1$ //$NON-NLS-2$
&gt; 			try {
&gt; 				File ajdeFile = new File(Platform.asLocalURL(ajdeURL).getFile());
&gt; 				if (ajdeFile.exists()) {
&gt; 					aspectjtoolsDir += ajdeFile.getAbsolutePath();
&gt; 				}
&gt; 				File coreFile = new File(Platform.asLocalURL(coreURL).getFile());
&gt; 				if (coreFile.exists()) {
&gt; 					aspectjtoolsDir += File.pathSeparator + coreFile.getAbsolutePath();
&gt; 				}
&gt; 			} catch (IOException e) {
&gt; 				AspectJUIPlugin.logException(e);
&gt; 			}
&gt; 			
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/ajdoc/GenAJdoc tests.txt" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="77163" transactionid="69865">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="22"/>
<property name="lines-added" value="20"/>
<property name="lines-deleted" value="3"/>
<property name="lines-modified" value="75"/>
<property name="lines-churned" value="98"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-import K-new K-null K-return K-super K-this K-true M O-&lt;= O-== O-|| O-!= O-() O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>The default setting for the load time weaver is (as of 1.2.1rc1) to produce
weaving messages rather than ignore them.  I think the default should be changed
to ignore them.  

Also, I cannot override the default setting with -Daj.weaver.versose="False". 
This is the implied syntax from docs/examples/build.xml.  If this has changed
then build.xml should be updated.  Otherwise, the weaver should be fixed to use it!</bugreport>
<testsforfix ID="77163" type="new">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java">
      <test NAME="testWeaveAdviceWithVerbose"/>
      <test NAME="testWeaveAdviceWithWeaveInfo"/>
      <test NAME="testJunkAspectJar"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="113" file="output/77163/pre-fix/testresults.xml" passing="1290" size="1403"/>
<post-fix-testcases failing="113" file="output/77163/post-fix/testresults.xml" passing="1293" size="1406"/>
<fixedFiles>
<file name="org.aspectj/modules/docs/dist/doc/examples/build.xml" revision="1.13" state="changed">440c440
&lt;        &lt;!-- run appliaction with LTW to add tracing --&gt;
---
&gt;        &lt;!-- run application with LTW to add tracing --&gt;
449a450
&gt;        	 &lt;sysproperty key="org.aspectj.weaver.showWeaveInfo" value="True"/&gt;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.3" state="changed">16a17
&gt; import java.io.FileNotFoundException;
17a19
&gt; import java.io.PrintWriter;
21a24
&gt; import java.util.HashSet;
25a29
&gt; import java.util.Set;
30c34,35
&lt; import org.aspectj.bridge.IMessageHandler;
---
&gt; import org.aspectj.bridge.MessageUtil;
&gt; import org.aspectj.bridge.MessageWriter;
59a65
&gt; 	public static final String SHOW_WEAVE_INFO_PROPERTY = "org.aspectj.weaver.showWeaveInfo"; 
65c71
&lt; 	private IMessageHandler messageHandler = null;
---
&gt; 	private WeavingAdaptorMessageHandler messageHandler = null;
106c112
&lt; 				if (verbose) System.err.println("WeavingAdaptor: Warning - could not determine classpath for " + loader); 
---
&gt; 				warn("cannot determine classpath"); 
132c138,144
&lt; 		if (verbose) System.out.println("WeavingAdaptor: classPath='" + classPath + "'");
---
&gt; 		messageHandler = new WeavingAdaptorMessageHandler(new PrintWriter(System.err));
&gt; 		if (verbose) messageHandler.dontIgnore(IMessage.INFO);
&gt; 		else messageHandler.ignore(IMessage.INFO);
&gt; 		if (Boolean.getBoolean(SHOW_WEAVE_INFO_PROPERTY)) messageHandler.dontIgnore(IMessage.WEAVEINFO);
&gt; 		
&gt; 		info("using classpath: " + classPath); 
&gt; 		info("using aspectpath: " + aspectPath); 
134,135d145
&lt; 		// make sure the weaver can find all types...
&lt; 		messageHandler = new MessageHandler();
148a159
&gt; 		File libFile = new File(url.getPath());
150c161
&lt; 			weaver.addLibraryJarFile(new File(url.getPath()));
---
&gt; 			weaver.addLibraryJarFile(libFile);
152a164
&gt; 			warn("bad library: '" + libFile + "'");
164a177
&gt; 			info("weaving '" + name + "'");
173d185
&lt; 		if (verbose) System.out.println("WeavingAdaptor: shouldWeave('" + name + "') " + b);
212,226c224,225
&lt; 			String lib = (String)i.next();
&lt; 			File libFile = new File(lib);
&lt; 			if (libFile.isFile() &amp;&amp; lib.endsWith(".jar")) {
&lt; 				try {
&lt; 					if (verbose) System.out.println("WeavingAdaptor: adding aspect '" + lib + "' to weaver");
&lt; 					addAspectLibrary(new File(lib));
&lt; 				} catch (IOException ioEx) {
&lt; 					if (verbose) System.err.println(
&lt; 						"WeavingAdaptor: Warning - could not load aspect path entry " 
&lt; 						+ lib + " : " + ioEx);
&lt; 				}
&lt; 			} else {
&lt; 				if (verbose) System.err.println(
&lt; 					"WeavingAdaptor: Warning - ignoring aspect path entry: " + lib);
&lt; 			}
---
&gt; 			String libName = (String)i.next();
&gt; 			addAspectLibrary(libName);
241,243c240,251
&lt; 	private void addAspectLibrary(File aspectLibraryJarFile) throws IOException {
&lt; 		weaver.addLibraryJarFile(aspectLibraryJarFile);
&lt; //		weaver.prepareForWeave();
---
&gt; 	private void addAspectLibrary(String aspectLibraryName) {
&gt; 		File aspectLibrary = new File(aspectLibraryName);
&gt; 		if (aspectLibrary.isFile() &amp;&amp; aspectLibraryName.endsWith(".jar")) {
&gt; 			try {
&gt; 				info("adding aspect library: '" + aspectLibrary + "'");
&gt; 				weaver.addLibraryJarFile(aspectLibrary);
&gt; 			} catch (IOException ex) {
&gt; 				error("exception adding aspect library: '" + ex + "'");
&gt; 			}
&gt; 		} else {
&gt; 			error("bad aspect library: '" + aspectLibrary + "'");
&gt; 		}
255a264,275
&gt; 	
&gt; 	private boolean info (String message) {
&gt; 		return MessageUtil.info(messageHandler,message);
&gt; 	}
&gt; 	
&gt; 	private boolean warn (String message) {
&gt; 		return MessageUtil.warn(messageHandler,message);
&gt; 	}
&gt; 	
&gt; 	private boolean error (String message) {
&gt; 		return MessageUtil.error(messageHandler,message);
&gt; 	}
259c279
&lt; 	 * Tell weaver to abort on any non-informational error.
---
&gt; 	 * Tell weaver to abort on any message more severe than warning.
261c281,292
&lt; 	private class MessageHandler implements IMessageHandler {
---
&gt; 	private class WeavingAdaptorMessageHandler extends MessageWriter {
&gt; 
&gt; 		private Set ignoring = new HashSet();
&gt; 		private IMessage.Kind failKind;
&gt; 
&gt; 		public WeavingAdaptorMessageHandler (PrintWriter writer) {
&gt; 			super(writer,true);
&gt; 			
&gt; 			ignore(IMessage.WEAVEINFO);
&gt; 			this.failKind = IMessage.ERROR;
&gt; 
&gt; 		}
264,266c295,311
&lt; 			if (!isIgnoring(message.getKind())) {
&lt; 				System.err.println(message.getSourceLocation()+": "+message.getKind()+" "+message.getMessage());
&lt; 				if (message.getKind() == IMessage.ERROR) throw new AbortException(message);
---
&gt; 			boolean result = super.handleMessage(message);
&gt; 			if (0 &lt;= message.getKind().compareTo(failKind)) {
&gt; 				throw new AbortException(message);
&gt; 			}
&gt; 			return true;	
&gt; 		}
&gt; 
&gt; 		public boolean isIgnoring (Kind kind) {
&gt; 			return ((null != kind) &amp;&amp; (ignoring.contains(kind)));
&gt; 		}
&gt; 
&gt; 		/**
&gt; 		 * Set a message kind to be ignored from now on
&gt; 		 */
&gt; 		public void ignore (IMessage.Kind kind) { 
&gt; 			if ((null != kind) &amp;&amp; (!ignoring.contains(kind))) {
&gt; 				ignoring.add(kind);
268d312
&lt; 			return true;
271,273c315,321
&lt; 		public boolean isIgnoring(Kind kind) {
&lt; 			if (verbose) return false;
&lt; 			else         return ((kind == IMessage.INFO) || (kind == IMessage.DEBUG));
---
&gt; 		/**
&gt; 		 * Remove a message kind from the list of those ignored from now on.
&gt; 		 */
&gt; 		public void dontIgnore (IMessage.Kind kind) {
&gt; 			if (null != kind) {
&gt; 				ignoring.remove(kind);
&gt; 			}
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java" revision="1.4" state="changed">18a19,20
&gt; import java.util.Enumeration;
&gt; import java.util.Properties;
43a46,48
&gt; 	private final static String NULL = "null";
&gt; 
&gt; 	private Properties savedProperties;
47d51
&lt; 		System.setProperty(WeavingAdaptor.WEAVING_ADAPTOR_VERBOSE,"true");
51,52c55,56
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
---
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
65,66c69,70
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,WOVEN_JAR);
---
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,WOVEN_JAR);
79,80c83,84
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + WOVEN_JAR);
---
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + WOVEN_JAR);
109,110c113,144
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
---
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
&gt; 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
&gt; 
&gt; 		try {
&gt; 			Class clazz = loader.loadClass("LTWHelloWorld");
&gt; 			invokeMain(clazz,new String[] { "LTWAspect" }); 
&gt; 		}
&gt; 		catch (Exception ex) {
&gt; 			fail(ex.toString());
&gt; 		}
&gt; 	}
&gt; 
&gt; 	public void testWeaveAdviceWithVerbose () {
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
&gt; 		setSystemProperty(WeavingAdaptor.WEAVING_ADAPTOR_VERBOSE,"true");
&gt; 		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());
&gt; 
&gt; 		try {
&gt; 			Class clazz = loader.loadClass("LTWHelloWorld");
&gt; 			invokeMain(clazz,new String[] { "LTWAspect" }); 
&gt; 		}
&gt; 		catch (Exception ex) {
&gt; 			fail(ex.toString());
&gt; 		}
&gt; 	}
&gt; 
&gt; 	public void testWeaveAdviceWithWeaveInfo () {
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
&gt; 		setSystemProperty(WeavingAdaptor.SHOW_WEAVE_INFO_PROPERTY,"true");
123,124c157,158
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DW_ADVICE_ASPECTS);
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DW_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
---
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DW_ADVICE_ASPECTS);
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DW_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
137,138c171,172
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DE_ADVICE_ASPECTS);
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DE_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
---
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DE_ADVICE_ASPECTS);
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DE_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
152,153c186,187
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,AROUNDCLOSURE_ASPECTS);
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,AROUNDCLOSURE_ASPECTS + File.pathSeparator + CLASSES_JAR);
---
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,AROUNDCLOSURE_ASPECTS);
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,AROUNDCLOSURE_ASPECTS + File.pathSeparator + CLASSES_JAR);
233a268,284
&gt; 	public void testJunkAspectJar () {		
&gt; 		File junkJar = new File(JUNK_JAR);
&gt; 		assertFalse(junkJar + " should not exist",junkJar.exists());
&gt; 		
&gt; 		URL aspects = FileUtil.getFileURL(junkJar);
&gt; 		URL[] classURLs = new URL[] { aspects };
&gt; 		URL[] aspectURLs = new URL[] { aspects };
&gt; 		
&gt; 		try {
&gt; 			WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());
&gt; 			fail("Expecting org.aspectj.bridge.AbortException");
&gt; 		}
&gt; 		catch (Exception ex) {
&gt; 			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex,(ex instanceof org.aspectj.bridge.AbortException));
&gt; 		}
&gt; 	}
&gt; 
277,278c328,329
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
---
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
294,295c345,346
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
&lt; 		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
---
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
&gt; 		setSystemProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
327a379,407
&gt; 	private void setSystemProperty (String key, String value) {
&gt; 		Properties systemProperties = System.getProperties();
&gt; 		copyProperty(key,systemProperties,savedProperties);
&gt; 		systemProperties.setProperty(key,value);
&gt; 	}
&gt; 	
&gt; 	private static void copyProperty (String key, Properties from, Properties to) {
&gt; 		String value = from.getProperty(key,NULL);
&gt; 		to.setProperty(key,value);
&gt; 	}
&gt; 
&gt; 	protected void setUp() throws Exception {
&gt; 		super.setUp();
&gt; 		savedProperties = new Properties();
&gt; 	}
&gt; 
&gt; 	protected void tearDown() throws Exception {
&gt; 		super.tearDown();
&gt; 		
&gt; 		/* Restore system properties */
&gt; 		Properties systemProperties = System.getProperties();
&gt; 		for (Enumeration enum = savedProperties.keys(); enum.hasMoreElements(); ) {
&gt; 			String key = (String)enum.nextElement();
&gt; 			String value = savedProperties.getProperty(key);
&gt; 			if (value == NULL) systemProperties.remove(key);
&gt; 			else systemProperties.setProperty(key,value);
&gt; 		}
&gt; 	}
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="77199" transactionid="73096">
<property name="files-churned" value="6"/>
<property name="java-files-churned" value="6"/>
<property name="classes-churned" value="6"/>
<property name="methods-churned" value="6"/>
<property name="hunks" value="20"/>
<property name="lines-added" value="8"/>
<property name="lines-deleted" value="9"/>
<property name="lines-modified" value="34"/>
<property name="lines-churned" value="51"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-import K-new M T V</fullfingerprint>
<tag>exception</tag>
<bugreport>In ProjectProperties.getSourcePathResources() any JavaModelException is 
displayed to the user via a dialog. Unfortunately for workbench orginated 
builds e.g. repository checkout the getActiveWorkbenchWindow() call returns 
null resulting in a NullPointerException when calling "getShell()" and loss of 
the original error. The exception should be logged as close to the start of 
the catch block (aspect perhaps) to avoid secondary failure and the 
getActiveWorkbenchWindow() call checked for null response. Alternatively 
a "logAndDisplay()" method could cope with it leaving a cleaner catch block.

		} catch (JavaModelException jmEx) {
			String message = AspectJUIPlugin.getResourceString
("jmCoreException");
			Status status = new Status(Status.ERROR, 
AspectJUIPlugin.PLUGIN_ID,
					Status.OK, message, jmEx);
			Shell shell = AspectJUIPlugin.getDefault
().getActiveWorkbenchWindow()
					.getShell();
			ErrorDialog.openError(shell, AspectJUIPlugin
					.getResourceString
("ajErrorDialogTitle"), message, status);
		}</bugreport>
<pre-fix-testcases failing="113" file="output/77199/pre-fix/testresults.xml" passing="1293" size="1406"/>
<post-fix-testcases failing="112" file="output/77199/post-fix/testresults.xml" passing="1294" size="1406"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/ajde/CompilerMonitor.java" revision="1.5" state="changed">46d45
&lt; import org.eclipse.core.runtime.Status;
52d50
&lt; import org.eclipse.swt.widgets.Shell;
840,847c838,840
&lt;             String message = AspectJUIPlugin.getResourceString("jmCoreException");
&lt;             Status status = new Status(Status.ERROR, AspectJUIPlugin.PLUGIN_ID,
&lt;                     Status.OK, message, jmEx);
&lt;             Shell shell = AspectJUIPlugin.getDefault().getActiveWorkbenchWindow()
&lt;                     .getShell();
&lt;             org.eclipse.jface.dialogs.ErrorDialog.openError(shell,
&lt;                     AspectJUIPlugin.getResourceString("ajErrorDialogTitle"),
&lt;                     message, status);
---
&gt;         	AspectJUIPlugin.getDefault().getErrorHandler().handleError(
&gt; 					AspectJUIPlugin.getResourceString("ajErrorDialogTitle"),
&gt; 					AspectJUIPlugin.getResourceString("jmCoreException"), jmEx);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/ajde/ProjectProperties.java" revision="1.6" state="changed">51d50
&lt; import org.eclipse.core.runtime.Status;
59,60d57
&lt; import org.eclipse.jface.dialogs.ErrorDialog;
&lt; import org.eclipse.swt.widgets.Shell;
826,832c823,825
&lt; 			String message = AspectJUIPlugin.getResourceString("jmCoreException");
&lt; 			Status status = new Status(Status.ERROR, AspectJUIPlugin.PLUGIN_ID,
&lt; 					Status.OK, message, jmEx);
&lt; 			Shell shell = AspectJUIPlugin.getDefault().getActiveWorkbenchWindow()
&lt; 					.getShell();
&lt; 			ErrorDialog.openError(shell, AspectJUIPlugin
&lt; 					.getResourceString("ajErrorDialogTitle"), message, status);
---
&gt;         	AspectJUIPlugin.getDefault().getErrorHandler().handleError(
&gt; 					AspectJUIPlugin.getResourceString("ajErrorDialogTitle"),
&gt; 					AspectJUIPlugin.getResourceString("jmCoreException"), jmEx);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/preferences/AspectPathPropertyPage.java" revision="1.5" state="changed">39d38
&lt; import org.eclipse.jface.dialogs.ErrorDialog;
156,164c155,163
&lt;             ErrorDialog
&lt;                     .openError(
&lt;                             AspectJUIPlugin.getDefault()
&lt;                                     .getActiveWorkbenchWindow().getShell(),
&lt;                             AspectJUIPlugin
&lt;                                     .getResourceString("AspectPathProp.exceptionInitializingAspectpath.title"),
&lt;                             AspectJUIPlugin
&lt;                                     .getResourceString("AspectPathProp.exceptionInitializingAspectpath.message"),
&lt;                             ce.getStatus());
---
&gt;         	AspectJUIPlugin
&gt; 					.getDefault()
&gt; 					.getErrorHandler()
&gt; 					.handleError(
&gt; 							AspectJUIPlugin
&gt; 									.getResourceString("AspectPathProp.exceptionInitializingAspectpath.title"),
&gt; 							AspectJUIPlugin
&gt; 									.getResourceString("AspectPathProp.exceptionInitializingAspectpath.message"),
&gt; 							ce);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/ajde/ErrorHandler.java" revision="1.3" state="changed">76,77c76
&lt; 	 * Display an error dialog with exception trace, and record the error in
&lt; 	 * the log for the plugin
---
&gt; 	 * Display an error dialog with exception
79a79,86
&gt; 		handleError(AspectJUIPlugin.getResourceString("ajErrorDialogTitle"),
&gt; 				message, t);
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Display an error dialog with exception
&gt; 	 */
&gt; 	public void handleError(final String title, final String message, Throwable t) {
81d87
&lt; 		final String message_final = message;
106,107c112,113
&lt; 							AspectJUIPlugin.getResourceString("ajErrorDialogTitle"),
&lt; 							message_final,
---
&gt; 							title,
&gt; 							message,
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/core/AJDTUtils.java" revision="1.7" state="changed">49d48
&lt; import org.eclipse.jface.dialogs.ErrorDialog;
1050,1053c1049,1052
&lt; 				ErrorDialog
&lt; 						.openError(
&lt; 								AspectJUIPlugin.getDefault()
&lt; 										.getActiveWorkbenchWindow().getShell(),
---
&gt; 	        	AspectJUIPlugin
&gt; 						.getDefault()
&gt; 						.getErrorHandler()
&gt; 						.handleError(
1058c1057
&lt; 								e.getStatus());
---
&gt; 								e);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/preferences/InPathPropertyPage.java" revision="1.5" state="changed">41d40
&lt; import org.eclipse.jface.dialogs.ErrorDialog;
157,166c156,164
&lt;             ErrorDialog
&lt;                     .openError(
&lt;                             AspectJUIPlugin.getDefault()
&lt;                                     .getActiveWorkbenchWindow().getShell(),
&lt;                             AspectJUIPlugin
&lt;                                     .getResourceString("InPathProp.exceptionInitializingInpath.title"),
&lt;                             AspectJUIPlugin
&lt;                                     .getResourceString("InPathProp.exceptionInitializingInpath.message"),
&lt;                             ce.getStatus());
&lt; 
---
&gt;         	AspectJUIPlugin
&gt; 					.getDefault()
&gt; 					.getErrorHandler()
&gt; 					.handleError(
&gt; 							AspectJUIPlugin
&gt; 									.getResourceString("InPathProp.exceptionInitializingInpath.title"),
&gt; 							AspectJUIPlugin
&gt; 									.getResourceString("InPathProp.exceptionInitializingInpath.message"),
&gt; 							ce);
</file>
</fixedFiles>
</bug>
<bug id="77261" transactionid="72638">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="18"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-for K-if K-import K-return K-true M O-&lt; O-== O-! O-() O-&amp;&amp; O-++ T V Y Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport> </bugreport>
<pre-fix-testcases failing="112" file="output/77261/pre-fix/testresults.xml" passing="1291" size="1403"/>
<post-fix-testcases failing="112" file="output/77261/post-fix/testresults.xml" passing="1291" size="1403"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/build configs/Build Configurator Script.doc" revision="1.3" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/buildconfigurator/popup/actions/IncludeAction.java" revision="1.3" state="changed">21a22
&gt; import org.eclipse.core.runtime.IPath;
25a27
&gt; import org.eclipse.jdt.core.IClasspathEntry;
26a29,30
&gt; import org.eclipse.jdt.core.IJavaProject;
&gt; import org.eclipse.jdt.core.JavaCore;
63d66
&lt; 
65,68c68,86
&lt; 							.getProjectBuildConfigurator(file.getProject());
&lt; 					if (pbc != null)
&lt; 						return !pbc.getActiveBuildConfiguration().isIncluded(
&lt; 								file);
---
&gt; 						.getProjectBuildConfigurator(file.getProject());
&gt; 					if ((pbc!=null) &amp;&amp; pbc.getActiveBuildConfiguration().isIncluded(
&gt; 							file)) {
&gt; 						return false;
&gt; 					}
&gt; 					
&gt; 					// the file is not currently included but we only give the
&gt; 					// option to include it if it is contained in a source folder
&gt; 					IJavaProject jp = JavaCore.create(file.getProject());
&gt; 					IClasspathEntry[] cpes = jp.getRawClasspath();
&gt; 					IPath fp = file.getFullPath();
&gt; 					for (int i = 0; i &lt; cpes.length; i++) {
&gt; 						if (cpes[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) {
&gt; 							IPath p = cpes[i].getPath();
&gt; 							if (p.isPrefixOf(fp)) {
&gt; 								return true;
&gt; 							}
&gt; 						}
&gt; 					}
</file>
</fixedFiles>
</bug>
<bug id="77479" transactionid="75222">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="23"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-if K-import K-new K-null K-true K-try M O-!= O-() O-cast T V Y Z-cast Z-if</fullfingerprint>
<bugreport>When selecting "link with editor" in the package explorer, and you open a .aj 
file, the package explorer expands to the correct package, however, the .aj 
file isn't selected (as it is with a .java file).</bugreport>
<pre-fix-testcases failing="111" file="output/77479/pre-fix/testresults.xml" passing="1427" size="1538"/>
<post-fix-testcases failing="113" file="output/77479/post-fix/testresults.xml" passing="1425" size="1538"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/editor/EditorTests.txt" revision="1.6" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJEditor.java" revision="1.20" state="changed">12a13
&gt; import java.lang.reflect.Method;
35a37
&gt; import org.eclipse.jdt.internal.ui.packageview.PackageExplorerPart;
50a53
&gt; import org.eclipse.jface.viewers.StructuredSelection;
57a61
&gt; import org.eclipse.ui.IViewPart;
520a525,543
&gt; 		
&gt; 		// Sian: Added the code below to fix bug 77479 - link with editor does not work for .aj files 
&gt; 		if(isEditingAjFile) {
&gt; 			IViewPart view = getEditorSite().getPage().findView( PackageExplorerPart.VIEW_ID);
&gt; 			if(view != null) {
&gt; 				PackageExplorerPart packageExplorer = (PackageExplorerPart)view;
&gt; 				try {
&gt; 					Method isLinkingEnabledMethod = PackageExplorerPart.class.getDeclaredMethod("isLinkingEnabled", new Class[]{});
&gt; 					isLinkingEnabledMethod.setAccessible(true);
&gt; 					boolean linkingEnabled = ((Boolean)isLinkingEnabledMethod.invoke(packageExplorer, new Object[]{})).booleanValue();
&gt; 					if(linkingEnabled) {
&gt; 						IFileEditorInput fInput = (IFileEditorInput) input;
&gt; 						AJCompilationUnit ajc = AJCompilationUnitManager.INSTANCE.getAJCompilationUnit(fInput.getFile());
&gt; 						packageExplorer.selectReveal(new StructuredSelection(ajc));
&gt; 					}					
&gt; 				} catch (Exception e) {
&gt; 				}
&gt; 			}
&gt; 		}
</file>
</fixedFiles>
</bug>
<bug id="77705" transactionid="73154">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="10"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="9"/>
<property name="lines-modified" value="148"/>
<property name="lines-churned" value="158"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-import K-new K-null K-return K-true M O-== T V Y Z-if</fullfingerprint>
<bugreport>Unselecting the checkboxes next to aspects in the visualiser menu does nothing.</bugreport>
<pre-fix-testcases failing="113" file="output/77705/pre-fix/testresults.xml" passing="1290" size="1403"/>
<post-fix-testcases failing="114" file="output/77705/post-fix/testresults.xml" passing="1289" size="1403"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/Menu.java" revision="1.4" state="changed">27d26
&lt; import org.eclipse.jface.dialogs.InputDialog;
30,31d28
&lt; import org.eclipse.swt.events.MouseEvent;
&lt; import org.eclipse.swt.events.MouseListener;
33a31
&gt; import org.eclipse.swt.events.SelectionListener;
60,74c58,70
&lt; 	private static String markerTypes = "cmesearchmarker";
&lt; 	Button[] buttons;
&lt; 	Button[] checkboxes;
&lt; 	Label[] labels;
&lt; 	Label[] icons;
&lt; 	Shell[] shells;
&lt; 	ColorDialog[] colorDialogs;
&lt; 	Image[] colorSquares;
&lt; 	Color[] colors;
&lt; 	SelectionAdapter selectionListener;
&lt; 	MouseListener mouseListener;
&lt; 	Composite canvas;
&lt; 	ScrolledComposite scrollpane;
&lt; 	GridLayout layout = new GridLayout(4, false);
&lt; 	VisualiserPlugin plugin = VisualiserPlugin.getDefault();
---
&gt; 	private Button[] buttons;
&gt; 	private Button[] checkboxes;
&gt; 	private Label[] labels;
&gt; 	private Label[] icons;
&gt; 	private Shell[] shells;
&gt; 	private ColorDialog[] colorDialogs;
&gt; 	private Image[] colorSquares;
&gt; 	private Color[] colors;
&gt; 	private SelectionListener selectionListener;
&gt; 	private SelectionListener checkboxListener;
&gt; 	private Composite canvas;
&gt; 	private ScrolledComposite scrollpane;
&gt; 	private GridLayout layout = new GridLayout(4, false);
79,80d74
&lt; //	private String[] relationships =
&lt; //		new String[] { "Hide Search Markers", "Hide CME Markers" };
178,179c172,173
&lt; 		mouseListener = new MouseListener() {
&lt; 			public void mouseUp(MouseEvent e) {
---
&gt; 		checkboxListener = new SelectionAdapter() {
&gt; 			public void widgetSelected(SelectionEvent e) {
187,190d180
&lt; 			public void mouseDown(MouseEvent e) {
&lt; 			}
&lt; 			public void mouseDoubleClick(MouseEvent e) {
&lt; 			}
194c184
&lt; 		plugin.setMenu(this);
---
&gt; 		VisualiserPlugin.getDefault().setMenu(this);
378c368
&lt; 				checkboxes[i].addMouseListener(mouseListener);
---
&gt; 				checkboxes[i].addSelectionListener(checkboxListener);
442,570c432
&lt; 		plugin.removeMenu();
&lt; 	}
&lt; 
&lt; 	
&lt; 	/**
&lt; 	 * Create the actions for this view
&lt; 	 */
&lt; 	private void makeActions() {
&lt; 
&lt; 		IActionBars bars = getViewSite().getActionBars();
&lt; 		IMenuManager manager = bars.getMenuManager();
&lt; //		IMenuManager filterSubmenu = new MenuManager("MarkerFilters");
&lt; //		manager.add(filterSubmenu);
&lt; //
&lt; //		for (int i = 0; i &lt; this.relationships.length; i++) {
&lt; //			final String currRel = relationships[i];
&lt; //			Action action = new Action() {
&lt; //				public void run() {
&lt; //					/* Code for turning them on and off...
&lt; //						ViewerFilter filters[] = plugin.visualiser.getFilters();
&lt; //						boolean add = true;
&lt; //						for(int i=0;i &lt; filters.length;i++) {
&lt; //							RelationshipFilter filter = (RelationshipFilter)filters[i];
&lt; //							if (filter.getRelationshipName().equals(currRel)) {
&lt; //								add = false;
&lt; //								setChecked(false);
&lt; //								plugin.visualiser.removeFilter(filter);
&lt; //								break;
&lt; //							}
&lt; //						}
&lt; //						
&lt; //						if (add) {
&lt; //							plugin.visualiser.addFilter(new RelationshipFilter(currRel));
&lt; //							setChecked(true);
&lt; //						} 				
&lt; //					*/
&lt; //				}
&lt; //			};
&lt; //
&lt; //			action.setText(relationships[i]);
&lt; //			action.setChecked(false);
&lt; //			action.setToolTipText(relationships[i]);
&lt; //			filterSubmenu.add(action);
&lt; //		}
&lt; 
&lt; 		// Marker input dialog...
&lt; 		Action Taction = new Action() {
&lt; 			public void run() {
&lt; 				markerTypesDialog();
&lt; 			}
&lt; 		};
&lt; 		Taction.setText("Markers...");
&lt; 		Taction.setToolTipText("Choose displayed markers");
&lt; 		manager.add(Taction);
&lt; 		
&lt; 		groupByRel_Action = new Action() { public void run() {
&lt; 			if (isChecked()) {
&lt; 				//groupByRel_Action.setChecked(false);
&lt; 				groupByQuery_Action.setChecked(false);
&lt; 				psychedelic_Action.setChecked(false);
&lt; 			}
&lt; 			VisualiserPlugin.visualiser.updateDisplay(false);
&lt; 		}};
&lt; 		groupByRel_Action.setText("Group by relationship");
&lt; 		groupByRel_Action.setChecked(true);
&lt; 		groupByRel_Action.setToolTipText("Have one color per relationship type");
&lt; 		manager.add(groupByRel_Action);
&lt; 		
&lt; 		groupByQuery_Action = new Action() { public void run() {
&lt; 			if (isChecked()) {
&lt; 				groupByRel_Action.setChecked(false);
&lt; 				//groupByQuery_Action.setChecked(false);
&lt; 				psychedelic_Action.setChecked(false);
&lt; 			}
&lt; 			VisualiserPlugin.visualiser.updateDisplay(false);
&lt; 			
&lt; 		}};
&lt; 		groupByQuery_Action.setText("Group by query");
&lt; 		groupByQuery_Action.setChecked(false);
&lt; 		groupByQuery_Action.setToolTipText("Have one color per query");
&lt; 		manager.add(groupByQuery_Action);
&lt; 		
&lt; 		psychedelic_Action = new Action() { public void run() {
&lt; 			if (isChecked()) {
&lt; 				groupByRel_Action.setChecked(false);
&lt; 				groupByQuery_Action.setChecked(false);
&lt; 				//psychedelic_Action.setChecked(false);
&lt; 			}
&lt; 			VisualiserPlugin.visualiser.updateDisplay(false);
&lt; 		}};
&lt; 		psychedelic_Action.setText("Psychedelic");
&lt; 		psychedelic_Action.setChecked(false);
&lt; 		psychedelic_Action.setToolTipText("Press it, you know you want to...");
&lt; 		manager.add(psychedelic_Action);
&lt; 	}
&lt; 	
&lt; 	private static Action groupByRel_Action;
&lt; 	private static Action groupByQuery_Action;
&lt; 	private static Action psychedelic_Action;
&lt; 
&lt; 	public static boolean isPsychedelic() { return psychedelic_Action.isChecked();}
&lt; 	
&lt; 	public static boolean isColorPerRelationship() { return groupByRel_Action.isChecked();}
&lt; 	
&lt; 	public static boolean isColorPerQuery() { return groupByQuery_Action.isChecked();}
&lt; 
&lt; 	public static String getMarkersToDisplay() {
&lt; 		return markerTypes;
&lt; 	}
&lt; 
&lt;   
&lt;     /**
&lt;      * Input dialog, allows user to decide which set of markers are displayed
&lt;      * in the vis menu and therefore in the vis.
&lt;      */
&lt; 	private void markerTypesDialog() {
&lt; 		// Which markers to respect?
&lt; 		InputDialog dlg =
&lt; 			new InputDialog(
&lt; 				getSite().getShell(),
&lt; 				"Displayed Markers",
&lt; 				"Comma separated list of marker types (e.g. 'cmesearchmarker')",
&lt; 				markerTypes,
&lt; 				null);
&lt; 		dlg.open();
&lt; 		if (dlg.getReturnCode() == InputDialog.OK) {
&lt; 			markerTypes = dlg.getValue();
&lt; 			VisualiserPlugin.visualiser.updateDisplay(false);
&lt; 		}
---
&gt; 		VisualiserPlugin.getDefault().removeMenu();
</file>
</fixedFiles>
</bug>
<bug id="77799" transactionid="74212">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-null O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Calling Ajde.getDefault().getStructureSearchManager().findMatches(...)
for an AspectJ project that has not been built results in a NullPointerException
in StructureSearchManager.findMatchesHelper(...) (line 58)

Simple patch is attached.</bugreport>
<pre-fix-testcases failing="113" file="output/77799/pre-fix/testresults.xml" passing="1290" size="1403"/>
<post-fix-testcases failing="113" file="output/77799/post-fix/testresults.xml" passing="1290" size="1403"/>
<fixedFiles>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java" revision="1.9" state="changed">58c58
&lt; 		if (node.getChildren() != null) {
---
&gt; 		if (node != null &amp;&amp; node.getChildren() != null) {
</file>
</fixedFiles>
</bug>
<bug id="78182" transactionid="74768">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="14"/>
<property name="lines-added" value="162"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="164"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-else K-for K-if K-import K-interface K-new K-null K-package K-return K-this M O-== O-! O-!= O-&amp;&amp; O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>If you have a .aj file which has compiler errors (or warnings) against it and 
open it in the editor, then the tab at the top of the editor view doesn't show 
this error or warning (although it does show up in the package explorer and 
problems view).</bugreport>
<pre-fix-testcases failing="112" file="output/78182/pre-fix/testresults.xml" passing="1425" size="1537"/>
<post-fix-testcases failing="112" file="output/78182/post-fix/testresults.xml" passing="1425" size="1537"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJEditor.java" revision="1.17" state="changed">77a78,79
&gt; 	private AspectJEditorErrorTickUpdater aspectJEditorErrorTickUpdater;
&gt; 
91a94,96
&gt; 		
&gt; 		// Bug 78182
&gt; 		aspectJEditorErrorTickUpdater= new AspectJEditorErrorTickUpdater(this);
342,344c347,351
&lt; 		IDocument document = getDocumentProvider().getDocument(getEditorInput());
&lt; 		ISourceViewer sourceViewer= getSourceViewer();
&lt; 		sourceViewer.setDocument(document, annotationModel);
---
&gt; 		if(annotationModel != null) {
&gt; 			IDocument document = getDocumentProvider().getDocument(getEditorInput());
&gt; 			ISourceViewer sourceViewer= getSourceViewer();		
&gt; 			sourceViewer.setDocument(document, annotationModel);
&gt; 		}
356d362
&lt; 
358c364,365
&lt; 						.getAJCompilationUnitFromCache(fInput.getFile());
---
&gt; 					.getAJCompilationUnitFromCache(fInput.getFile());
&gt; 		
374a382
&gt; 				aspectJEditorErrorTickUpdater.updateEditorImage(unit);				
395d402
&lt; 
432a440,443
&gt; 		if (aspectJEditorErrorTickUpdater != null) {
&gt; 			aspectJEditorErrorTickUpdater.dispose();
&gt; 			aspectJEditorErrorTickUpdater = null;
&gt; 		}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/ajde/CompilerTaskListManager.java" revision="1.4" state="changed">81a82,83
&gt;     
&gt;     private static List problemChangedListeners = new ArrayList();
308a311
&gt;                     notifyListeners(affectedResources);
580a584,605
&gt; 
&gt;     
&gt;     /*
&gt;      * Sian - Added listener capabilities as part of the fix for bug 78182
&gt;      */
&gt;     
&gt;     public void addListener(IProblemChangedListener listener) {
&gt;     	if(!problemChangedListeners.contains(listener)) {
&gt;     		problemChangedListeners.add(listener);
&gt;     	}
&gt;     }
&gt;     
&gt;     public void removeListener(IProblemChangedListener listener) {
&gt;     	problemChangedListeners.remove(listener);
&gt;     }
&gt;     
&gt;     private void notifyListeners(Set changedResources) {
&gt;     	for (Iterator iter = problemChangedListeners.iterator(); iter.hasNext();) {
&gt; 			IProblemChangedListener listener = (IProblemChangedListener) iter.next();
&gt; 			listener.problemsChanged(changedResources);
&gt; 		}
&gt;     }
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/ajde/IProblemChangedListener.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others. All rights reserved. This
 * program and the accompanying materials are made available under the terms of
 * the Common Public License v1.0 which accompanies this distribution, and is
 * available at http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors: Sian January - initial version
 ******************************************************************************/
package org.eclipse.ajdt.internal.ui.ajde;

import java.util.Set;

/*
 * Sian - Added as part of the fix for bug 78182
 */
/**
 * A listener for problem changes
 */
public interface IProblemChangedListener {

    /**
     * The listener is notified that problems have changed
     * @param changedResources Set of IResources
     */
	void problemsChanged(Set changedResources);
	
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJEditorErrorTickUpdater.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others. All rights reserved. This
 * program and the accompanying materials are made available under the terms of
 * the Common Public License v1.0 which accompanies this distribution, and is
 * available at http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors: Sian January - initial version
 ******************************************************************************/
package org.eclipse.ajdt.internal.ui.editor;

import java.util.Set;

import org.eclipse.ajdt.buildconfigurator.ImageDecorator;
import org.eclipse.ajdt.core.javaelements.AJCompilationUnitManager;
import org.eclipse.ajdt.internal.ui.ajde.CompilerTaskListManager;
import org.eclipse.ajdt.internal.ui.ajde.IProblemChangedListener;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.internal.ui.viewsupport.JavaElementImageProvider;
import org.eclipse.jdt.internal.ui.viewsupport.JavaUILabelProvider;
import org.eclipse.jface.text.Assert;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.IEditorInput;

/*
 * Sian - Added as part of the fix for bug 78182
 */
/**
 * The &lt;code&gt;AspectJEditorErrorTickUpdater&lt;/code&gt; will register as a IProblemChangedListener
 * to listen on problem changes of the editor's input. It updates the title image when the annotation
 * model changed.
 */
public class AspectJEditorErrorTickUpdater implements IProblemChangedListener {

	
	private JavaUILabelProvider labelProvider;
	private AspectJEditor editor;

	public AspectJEditorErrorTickUpdater(AspectJEditor editor) {
		Assert.isNotNull(editor);
		this.editor = editor;
		labelProvider=  new JavaUILabelProvider(0, JavaElementImageProvider.SMALL_ICONS);
		labelProvider.addLabelDecorator(new ImageDecorator());
		CompilerTaskListManager.getInstance().addListener(this);
	}
	
	/* (non-Javadoc)
	 * @see org.eclipse.ajdt.internal.ui.ajde.IProblemChangedListener#problemsChanged(java.util.List)
	 */
	public void problemsChanged(Set changedResources) {
		IEditorInput input= editor.getEditorInput();
		if (input != null) {
			IJavaElement jElement = (IJavaElement)input.getAdapter(IJavaElement.class);
			if(jElement != null) {
				IResource resource = jElement.getResource();
				if(changedResources.contains(resource)) {
					updateEditorImage(jElement);
				}
			} else {
				IFile file = (IFile) input.getAdapter(IFile.class);
				if(changedResources.contains(file)) {
					updateEditorImage(AJCompilationUnitManager.INSTANCE.getAJCompilationUnit(file));				
				}
			}
		}
	}	
			
	public void updateEditorImage(IJavaElement jelement) {
		Image titleImage= editor.getTitleImage();
		if (titleImage == null) {
			return;
		}
		Image newImage= labelProvider.getImage(jelement);
		if (titleImage != newImage) {
			postImageChange(newImage);
		}
	}
	
	private void postImageChange(final Image newImage) {
		Shell shell= editor.getEditorSite().getShell();
		if (shell != null &amp;&amp; !shell.isDisposed()) {
			shell.getDisplay().syncExec(new Runnable() {
				public void run() {
					editor.updatedTitleImage(newImage);
				}
			});
		}
	}	
	
	public void dispose() {
		labelProvider.dispose();
		CompilerTaskListManager.getInstance().removeListener(this);
	}

}
</file>
</fixedFiles>
</bug>
<bug id="78263" transactionid="73115">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V</fullfingerprint>
<bugreport>Creating a new Java project prompts a perspective switch dialog (if not in the
Java perspective already of course).
Creating a new AspectJ project should do the same.
We used to do this, but it happened too often - whenever aj nature was added to
a project. It should happen only when a new project is created.</bugreport>
<pre-fix-testcases failing="112" file="output/78263/pre-fix/testresults.xml" passing="1294" size="1406"/>
<post-fix-testcases failing="112" file="output/78263/post-fix/testresults.xml" passing="1294" size="1406"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/AspectJProjectWizard.java" revision="1.4" state="changed">132c132
&lt; 
---
&gt; 		BasicNewProjectResourceWizard.updatePerspective(fConfigElement);
</file>
</fixedFiles>
</bug>
<bug id="78264" transactionid="74822">
<property name="files-churned" value="6"/>
<property name="java-files-churned" value="5"/>
<property name="classes-churned" value="5"/>
<property name="methods-churned" value="5"/>
<property name="hunks" value="28"/>
<property name="lines-added" value="468"/>
<property name="lines-deleted" value="174"/>
<property name="lines-modified" value="83"/>
<property name="lines-churned" value="725"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-else K-false K-finally K-for K-if K-import K-new K-null K-package K-return K-super K-throw K-true K-try M O-&lt; O-== O-&gt; O-|| O-! O-!= O-() O-&amp;&amp; O-+ O-++ O-cast T V Y Z-cast Z-for Z-if Z-throw Z-vardecl</fullfingerprint>
<bugreport>The New AspectJ Project wizard used to look the same as the New Java Project
wizard, but it hasn't kept pace with it. The New AspectJ Project wizard should
look much the same and offer the same options as the New Java Project wizard in
Eclipse 3.0.</bugreport>
<pre-fix-testcases failing="112" file="output/78264/pre-fix/testresults.xml" passing="1424" size="1536"/>
<post-fix-testcases failing="111" file="output/78264/post-fix/testresults.xml" passing="1425" size="1536"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/resources/AspectJPluginResources.properties" revision="1.15" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/AspectJWizardNewProjectCreationPage.java" revision="1.4" state="deleted"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/internal/ui/wizards/AspectJProjectWizardExtension.java" revision="1.4" state="changed">2c2
&lt;  * Copyright (c) 2004 IBM Corporation and others. All rights reserved. This
---
&gt;  * Copyright (c) 2004, 2005 IBM Corporation and others. All rights reserved. This
7a8,9
&gt;  * 	Sian January - updated when wizard was 
&gt;  * 		updated to new Java project wizard style (bug 78264)
12,13d13
&lt; import org.eclipse.ajdt.core.AspectJPlugin;
&lt; import org.eclipse.ajdt.internal.ui.resources.AspectJImages;
15,16c15,16
&lt; import org.eclipse.core.resources.IWorkspaceRoot;
&lt; import org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPage;
---
&gt; import org.eclipse.swt.widgets.Composite;
&gt; 
34,36c34
&lt; 	 * Overwrites addPages to add simulate user input.
&lt; 	 * The contents is exactly the same as super.addPages()
&lt; 	 * except from the lines indicated
---
&gt; 	 * Overridden to use JaveProjectWizardFirstPageExtension instead of JavaProjectWizardFirstPage 
40,53c38,54
&lt; 		fMainPage = new AspectJWizardNewProjectCreationPage("NewAspectjProjectCreationWizard");
&lt; 		
&lt; 		fMainPage.setTitle(
&lt; 			AspectJUIPlugin.getResourceString("NewAspectjProjectCreationWizard.MainPage.title"));
&lt; 		fMainPage.setDescription(
&lt; 			AspectJUIPlugin.getResourceString("NewAspectjProjectCreationWizard.MainPage.description"));
&lt; 		fMainPage.setImageDescriptor(AspectJImages.W_NEW_AJ_PRJ.getImageDescriptor());
&lt; 		fMainPage.setInitialProjectName(projectDefaultName);						// This line has been added
&lt; 		addPage(fMainPage);
&lt; 		IWorkspaceRoot root = AspectJPlugin.getWorkspace().getRoot();
&lt; 		fJavaPage = new NewJavaProjectWizardPage(root, fMainPage);
&lt; 		//fJavaPage.setDefaultOutputFolder(AspectJPlugin.getWorkspace().getRoot()			// This line has been added
&lt; 		//.getLocation().append("WizardTestProject" + IPath.SEPARATOR + "OutputFolder"));	// This line has been added
&lt; 		addPage(fJavaPage);
---
&gt;         fFirstPage= new JavaProjectWizardFirstPageExtension();
&gt; 		fFirstPage.setTitle(AspectJUIPlugin.getResourceString("NewAspectJProject.CreateAnAspectJProject"));
&gt; 		fFirstPage.setDescription(AspectJUIPlugin.getResourceString("NewAspectJProject.CreateAnAspectJProjectDescription"));
&gt;         addPage(fFirstPage);
&gt;         fSecondPage= new AspectJProjectWizardSecondPage(fFirstPage);
&gt;         fSecondPage.setTitle(AspectJUIPlugin.getResourceString("NewAspectJProject.BuildSettings"));
&gt;         fSecondPage.setDescription(AspectJUIPlugin.getResourceString("NewAspectJProject.BuildSettingsDescription"));
&gt;         addPage(fSecondPage);
&gt;     }
&gt; 	
&gt; 	/**
&gt; 	 * Overridden to add simulated user input
&gt; 	 */
&gt; 	public void createPageControls(Composite pageContainer) {
&gt; 		super.createPageControls(pageContainer);
&gt; 		 fFirstPage.setName(projectDefaultName);
&gt; 	     ((JavaProjectWizardFirstPageExtension)fFirstPage).fLocationGroup.fWorkspaceRadio.setSelection(true);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/AspectJProjectWizard.java" revision="1.7" state="changed">2,10c2,11
&lt; Copyright (c) 2002 IBM Corporation and others.
&lt; All rights reserved. This program and the accompanying materials
&lt; are made available under the terms of the Common Public License v1.0
&lt; which accompanies this distribution, and is available at
&lt; http://www.eclipse.org/legal/cpl-v10.html
&lt; Contributors:
&lt; Adrian Colyer, Andy Clement, Tracy Gardner - initial version
&lt; Ian McGrath - added ability to use existing project structures
&lt; ...
---
&gt;  * Copyright (c) 2002 - 2005 IBM Corporation and others.
&gt;  * All rights reserved. This program and the accompanying materials
&gt;  * are made available under the terms of the Common Public License v1.0
&gt;  * which accompanies this distribution, and is available at
&gt;  * http://www.eclipse.org/legal/cpl-v10.html
&gt;  * Contributors:
&gt;  * 		Adrian Colyer, Andy Clement, Tracy Gardner - initial version
&gt;  * 		Ian McGrath - added ability to use existing project structures
&gt;  * 		Sian January - updated to look like 3.0 new Java Project wizard
&gt;  * 		...
18d18
&lt; import org.eclipse.ajdt.core.AspectJPlugin;
24d23
&lt; import org.eclipse.core.resources.IWorkspaceRoot;
29c28
&lt; import org.eclipse.core.runtime.NullProgressMonitor;
---
&gt; import org.eclipse.core.runtime.IProgressMonitor;
32c31,33
&lt; import org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPage;
---
&gt; import org.eclipse.jdt.internal.ui.wizards.JavaProjectWizardFirstPage;
&gt; import org.eclipse.jdt.internal.ui.wizards.NewElementWizard;
&gt; import org.eclipse.jdt.internal.ui.wizards.NewWizardMessages;
35c36
&lt; import org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation;
---
&gt; import org.eclipse.swt.widgets.Shell;
37d37
&lt; import org.eclipse.core.runtime.IProgressMonitor;
42,54c42,49
&lt; public class AspectJProjectWizard
&lt; 	extends BasicNewProjectResourceWizard
&lt; 	implements IExecutableExtension {
&lt; 
&lt; 	protected NewJavaProjectWizardPage fJavaPage;
&lt; 	protected AspectJWizardNewProjectCreationPage fMainPage;
&lt; 	private IConfigurationElement fConfigElement;
&lt; 
&lt; 	/**
&lt; 	 * Create a new wizard
&lt; 	 */
&lt; 	public AspectJProjectWizard() {
&lt; 		super();
---
&gt; public class AspectJProjectWizard extends NewElementWizard implements IExecutableExtension {
&gt;     
&gt;     protected JavaProjectWizardFirstPage fFirstPage;
&gt;     protected AspectJProjectWizardSecondPage fSecondPage;
&gt;     
&gt;     private IConfigurationElement fConfigElement;
&gt;     
&gt;     public AspectJProjectWizard() {
58,77c53
&lt; 	}
&lt; 
&lt; 	/*
&lt; 	 * @see Wizard#addPages
&lt; 	 */
&lt; 	public void addPages() {
&lt; 		
&lt; 		//super.addPages();
&lt; 		fMainPage = new AspectJWizardNewProjectCreationPage("NewAspectjProjectCreationWizard");
&lt; 		fMainPage.setTitle(
&lt; 			AspectJUIPlugin.getResourceString("NewAspectjProjectCreationWizard.MainPage.title"));
&lt; 		fMainPage.setDescription(
&lt; 			AspectJUIPlugin.getResourceString("NewAspectjProjectCreationWizard.MainPage.description"));
&lt; 		fMainPage.setImageDescriptor(AspectJImages.W_NEW_AJ_PRJ.getImageDescriptor());
&lt; 		
&lt; 		addPage(fMainPage);
&lt; 		IWorkspaceRoot root = AspectJPlugin.getWorkspace().getRoot();
&lt; 		fJavaPage = new NewJavaProjectWizardPage(root, fMainPage);
&lt; 		addPage(fJavaPage);
&lt; 	}
---
&gt;    }
79,80c55,78
&lt; 	/*
&lt; 	 * @see Wizard#performFinish
---
&gt;     /*
&gt;      * @see Wizard#addPages
&gt;      */	
&gt;     public void addPages() {
&gt;         super.addPages();
&gt;         fFirstPage= new JavaProjectWizardFirstPage();
&gt;         addPage(fFirstPage);
&gt;         fFirstPage.setTitle(AspectJUIPlugin.getResourceString("NewAspectJProject.CreateAnAspectJProject"));
&gt; 		fFirstPage.setDescription(AspectJUIPlugin.getResourceString("NewAspectJProject.CreateAnAspectJProjectDescription"));
&gt;         fSecondPage= new AspectJProjectWizardSecondPage(fFirstPage);
&gt;         fSecondPage.setTitle(AspectJUIPlugin.getResourceString("NewAspectJProject.BuildSettings"));
&gt;         fSecondPage.setDescription(AspectJUIPlugin.getResourceString("NewAspectJProject.BuildSettingsDescription"));
&gt;         addPage(fSecondPage);
&gt;     }		
&gt;     
&gt;     /* (non-Javadoc)
&gt;      * @see org.eclipse.jdt.internal.ui.wizards.NewElementWizard#finishPage(org.eclipse.core.runtime.IProgressMonitor)
&gt;      */
&gt;     protected void finishPage(IProgressMonitor monitor) throws InterruptedException, CoreException {
&gt;     	fSecondPage.performFinish(monitor); // use the full progress monitor
&gt;     }
&gt;     
&gt; 	/* (non-Javadoc)
&gt; 	 * @see org.eclipse.jface.wizard.IWizard#performFinish()
83,102c81,87
&lt; 		BasicNewProjectResourceWizard.updatePerspective(fConfigElement);
&lt; 		IProject project = fJavaPage.getNewJavaProject().getProject();
&lt; 		boolean useExisting = fMainPage.useExistingProjectStructure();
&lt; 		
&lt; 		if(!useExisting) {	//overwrite any existing structure
&lt; 			IRunnableWithProgress op =
&lt; 				new WorkspaceModifyDelegatingOperation(fJavaPage.getRunnable());
&lt; 			try {
&lt; 				getContainer().run(false, true, op);
&lt; 			} catch (InvocationTargetException e) {
&lt; 				String title = AspectJUIPlugin.getResourceString("NewAspectjProjectCreationWizard.op_error.title");
&lt; 				String message = AspectJUIPlugin.getResourceString("NewAspectjProjectCreationWizard.op_error.message");
&lt; 				ExceptionHandler.handle(e, getShell(), title, message);
&lt; 				return false;
&lt; 				
&lt; 			} catch (InterruptedException e) {
&lt; 				return false;
&lt; 			}
&lt; 			
&lt; 			project = fJavaPage.getNewJavaProject().getProject();
---
&gt; 		boolean res= super.performFinish();
&gt; 		if (res) {
&gt; 	        BasicNewProjectResourceWizard.updatePerspective(fConfigElement);
&gt; 	 		IProject project = fSecondPage.getJavaProject().getProject();
&gt; 	 		selectAndReveal(project);
&gt; 			boolean completed = finalizeNewProject(project, fFirstPage.getDetect());
&gt; 			res = completed;
104,134c89
&lt; 
&lt; 		else {	//use existing structure
&lt; 			
&lt; 			if(!fMainPage.hasCorrectCapitalisation()) { //auto correct the users capitalization
&lt; 				//To correct the name of the project a separate wizard is required so the text field
&lt; 				//can be set
&lt; 				IWorkspaceRoot root = AspectJPlugin.getWorkspace().getRoot();
&lt; 				AspectJWizardNewProjectCreationPage TempMainPage =
&lt; 					new AspectJWizardNewProjectCreationPage("NewAspectjProjectCreationWizard");
&lt; 				TempMainPage.setInitialProjectName(fMainPage.getCorrectCapitalization());
&lt; 				NewJavaProjectWizardPage TempJavaPage = new NewJavaProjectWizardPage(root, TempMainPage);
&lt; 				project = TempJavaPage.getNewJavaProject().getProject();
&lt; 				
&lt; 				//disable the buttons of the wizard
&lt; 				fMainPage.setPageComplete(false);
&lt; 				fJavaPage.setPageComplete(false);
&lt; 			}
&lt; 			
&lt; 			IProgressMonitor monitor = new NullProgressMonitor();
&lt; 			try {
&lt; 				project.create(monitor);
&lt; 				project.open(monitor);
&lt; 			} catch (CoreException e) {	
&lt; 		        String title = AspectJUIPlugin.getResourceString("NewAspectjProjectCreationWizard.build_error.title");
&lt; 		        String message = AspectJUIPlugin.getResourceString("NewAspectjProjectCreationWizard.build_error.message");
&lt; 		        ExceptionHandler.handle(e, getShell(), title, message);
&lt; 		        return false;
&lt; 			}
&lt; 		}
&lt; 		boolean completed = finalizeNewProject(project, useExisting);
&lt; 		return completed;
---
&gt; 		return res;
135a91,119
&gt;     
&gt;     protected void handleFinishException(Shell shell, InvocationTargetException e) {
&gt;         String title= NewWizardMessages.getString("JavaProjectWizard.op_error.title"); //$NON-NLS-1$
&gt;         String message= NewWizardMessages.getString("JavaProjectWizard.op_error_create.message");			 //$NON-NLS-1$
&gt;         ExceptionHandler.handle(e, getShell(), title, message);
&gt;     }	
&gt;     
&gt;     /*
&gt;      * Stores the configuration element for the wizard.  The config element will be used
&gt;      * in &lt;code&gt;performFinish&lt;/code&gt; to set the result perspective.
&gt;      */
&gt;     public void setInitializationData(IConfigurationElement cfig, String propertyName, Object data) {
&gt;         fConfigElement= cfig;
&gt;     }
&gt;     
&gt;     /* (non-Javadoc)
&gt;      * @see IWizard#performCancel()
&gt;      */
&gt;     public boolean performCancel() {
&gt;         fSecondPage.performCancel();
&gt;         return super.performCancel();
&gt;     }
&gt;     
&gt;     /* (non-Javadoc)
&gt;      * @see org.eclipse.jface.wizard.IWizard#canFinish()
&gt;      */
&gt;     public boolean canFinish() {
&gt;         return super.canFinish();
&gt;     }
137d120
&lt; 	
201,211d183
&lt; 	
&lt; 	/*
&lt; 	 * Stores the configuration element for the wizard.  The config element will be used
&lt; 	 * in &lt;code&gt;performFinish&lt;/code&gt; to set the result perspective.
&lt; 	 */
&lt; 	public void setInitializationData(
&lt; 		IConfigurationElement cfig,
&lt; 		String propertyName,
&lt; 		Object data) {
&lt; 		fConfigElement = cfig;
&lt; 	}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/buildconfigurator/propertypage/BuildPathsBlock.java" revision="1.5" state="changed">220c220
&lt; 				}else
---
&gt; 				} else
226c226,229
&lt; 			}
---
&gt; 			} 
&gt; 		} else { // Sian - added this else block so that this class can be used in the new Aspectj project wizard (bug 78264)
&gt; 			fSourceContainerPage= new BCContainerWorkbookPage(fWorkspaceRoot,
&gt; 					 fClassPathList, fBuildPathDialogField);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/internal/ui/wizards/AspectJProjectWizardTest.java" revision="1.5" state="changed">38a39
&gt; import org.eclipse.jdt.internal.ui.wizards.JavaProjectWizardFirstPage;
52c53
&lt; 	AspectJWizardNewProjectCreationPage testPage;
---
&gt; 	JavaProjectWizardFirstPage testPage;
54c55
&lt; 	AspectJWizardNewProjectCreationPage secondTestPage;
---
&gt; 	AspectJProjectWizardSecondPage secondTestPage;
101,108c102,109
&lt; 		IWizardPage AJPage = projectWizard
&lt; 				.getPage("NewAspectjProjectCreationWizard");
&lt; 		IWizardPage JPage = projectWizard.getPage("NewJavaProjectWizardPage");
&lt; 
&lt; 		if (AJPage == null)
&lt; 			fail("addPages() has failed to add an AspectJWizardNewProjectCreationPage at the correct location.");
&lt; 		if (JPage == null)
&lt; 			fail("addPages() has failed to add a NewJavaProjectWizardPage at the correct location.");
---
&gt; 		IWizardPage firstPage = projectWizard
&gt; 				.getPage("SimpleProjectFirstPage");
&gt; 		IWizardPage secondPage = projectWizard.getPage("JavaCapabilityConfigurationPage");
&gt; 
&gt; 		if (firstPage == null)
&gt; 			fail("addPages() has failed to add a JavaProjectWizardFirstPage at the correct location.");
&gt; 		if (secondPage == null)
&gt; 			fail("addPages() has failed to add an AspectJProjectWizardSecondPage at the correct location.");
111c112
&lt; 			AJTitleCorrect = AJPage
---
&gt; 			AJTitleCorrect = firstPage
115,116c116,117
&lt; 									.getResourceString("NewAspectjProjectCreationWizard.MainPage.title"));
&lt; 			AJDescriptionCorrect = AJPage
---
&gt; 									.getResourceString("NewAspectJProject.CreateAnAspectJProject"));
&gt; 			AJDescriptionCorrect = firstPage
120c121
&lt; 									.getResourceString("NewAspectjProjectCreationWizard.MainPage.description"));
---
&gt; 									.getResourceString("NewAspectJProject.CreateAnAspectJProjectDescription"));
137c138
&lt; 	public void testProjectWizardPerformFinish() {
---
&gt; 	public void testProjectWizardPerformFinish() throws Exception {
206d206
&lt; 		
261c261
&lt; 		AspectJWizardNewProjectCreationPage curPage = (AspectJWizardNewProjectCreationPage) dialog
---
&gt; 		JavaProjectWizardFirstPage curPage = (JavaProjectWizardFirstPage) dialog
263a264
&gt; 		
265c266
&lt; 		testProjectWizard.getNewProject();
---
&gt; //		testProjectWizard.getNewProject();
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/internal/ui/wizards/JavaProjectWizardFirstPageExtension.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2000, 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.eclipse.ajdt.internal.ui.wizards;

import java.io.File;
import java.util.Observable;
import java.util.Observer;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.jdt.internal.ui.JavaPlugin;
import org.eclipse.jdt.internal.ui.preferences.NewJavaProjectPreferencePage;
import org.eclipse.jdt.internal.ui.preferences.PreferencePageSupport;
import org.eclipse.jdt.internal.ui.wizards.JavaProjectWizardFirstPage;
import org.eclipse.jdt.internal.ui.wizards.NewWizardMessages;
import org.eclipse.jdt.internal.ui.wizards.dialogfields.DialogField;
import org.eclipse.jdt.internal.ui.wizards.dialogfields.IDialogFieldListener;
import org.eclipse.jdt.internal.ui.wizards.dialogfields.IStringButtonAdapter;
import org.eclipse.jdt.internal.ui.wizards.dialogfields.LayoutUtil;
import org.eclipse.jdt.internal.ui.wizards.dialogfields.SelectionButtonDialogField;
import org.eclipse.jdt.internal.ui.wizards.dialogfields.StringButtonDialogField;
import org.eclipse.jdt.internal.ui.wizards.dialogfields.StringDialogField;
import org.eclipse.jdt.ui.JavaUI;
import org.eclipse.jdt.ui.PreferenceConstants;
import org.eclipse.jface.dialogs.Dialog;
import org.eclipse.jface.dialogs.IDialogConstants;
import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.DirectoryDialog;
import org.eclipse.swt.widgets.Group;
import org.eclipse.swt.widgets.Text;

/**
 * Copied JavaProjectWizardFirstPage to enable access to private fields for testing
 */
public class JavaProjectWizardFirstPageExtension extends JavaProjectWizardFirstPage {



	/**
	 * Request a project name. Fires an event whenever the text field is
	 * changed, regardless of its content.
	 */
	protected final class NameGroup extends Observable implements IDialogFieldListener {

		private final StringDialogField fNameField;

		public NameGroup(Composite composite, String initialName) {
			final Composite nameComposite= new Composite(composite, SWT.NONE);
			nameComposite.setFont(composite.getFont());
			nameComposite.setLayout(initGridLayout(new GridLayout(2, false), false));
			nameComposite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));

			// text field for project name
			fNameField= new StringDialogField();
			fNameField.setLabelText(NewWizardMessages.getString("JavaProjectWizardFirstPage.NameGroup.label.text")); //$NON-NLS-1$
			fNameField.setDialogFieldListener(this);

			setName(initialName);

			fNameField.doFillIntoGrid(nameComposite, 2);
			LayoutUtil.setHorizontalGrabbing(fNameField.getTextControl(null));
		}
		
		private void fireEvent() {
			setChanged();
			notifyObservers();
		}

		public String getName() {
			return fNameField.getText().trim();
		}

		public void postSetFocus() {
			fNameField.postSetFocusOnDialogField(getShell().getDisplay());
		}
		
		public void setName(String name) {
			fNameField.setText(name);
		}

		/* (non-Javadoc)
		 * @see org.eclipse.jdt.internal.ui.wizards.dialogfields.IDialogFieldListener#dialogFieldChanged(org.eclipse.jdt.internal.ui.wizards.dialogfields.DialogField)
		 */
		public void dialogFieldChanged(DialogField field) {
			fireEvent();
		}
		
	}

	/**
	 * Request a location. Fires an event whenever the checkbox or the location
	 * field is changed, regardless of whether the change originates from the
	 * user or has been invoked programmatically.
	 */
	protected final class LocationGroup extends Observable implements Observer, IStringButtonAdapter, IDialogFieldListener {

		protected final SelectionButtonDialogField fWorkspaceRadio;
		private final SelectionButtonDialogField fExternalRadio;
		private final StringButtonDialogField fLocation;
		
		private String fPreviousExternalLocation;
		
		private static final String DIALOGSTORE_LAST_EXTERNAL_LOC= JavaUI.ID_PLUGIN + ".last.external.project"; //$NON-NLS-1$

		public LocationGroup(Composite composite) {

			final int numColumns= 3;

			final Group group= new Group(composite, SWT.NONE);
			group.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
			group.setLayout(initGridLayout(new GridLayout(numColumns, false), true));
			group.setText(NewWizardMessages.getString("JavaProjectWizardFirstPage.LocationGroup.title")); //$NON-NLS-1$

			fWorkspaceRadio= new SelectionButtonDialogField(SWT.RADIO);
			fWorkspaceRadio.setDialogFieldListener(this);
			fWorkspaceRadio.setLabelText(NewWizardMessages.getString("JavaProjectWizardFirstPage.LocationGroup.workspace.desc")); //$NON-NLS-1$

			fExternalRadio= new SelectionButtonDialogField(SWT.RADIO);
			fExternalRadio.setLabelText(NewWizardMessages.getString("JavaProjectWizardFirstPage.LocationGroup.external.desc")); //$NON-NLS-1$

			fLocation= new StringButtonDialogField(this);
			fLocation.setDialogFieldListener(this);
			fLocation.setLabelText(NewWizardMessages.getString("JavaProjectWizardFirstPage.LocationGroup.locationLabel.desc")); //$NON-NLS-1$
			fLocation.setButtonLabel(NewWizardMessages.getString("JavaProjectWizardFirstPage.LocationGroup.browseButton.desc")); //$NON-NLS-1$

			fExternalRadio.attachDialogField(fLocation);
			
			fWorkspaceRadio.setSelection(true);
			fExternalRadio.setSelection(false);
			
			fPreviousExternalLocation= ""; //$NON-NLS-1$

			fWorkspaceRadio.doFillIntoGrid(group, numColumns);
			fExternalRadio.doFillIntoGrid(group, numColumns);
			fLocation.doFillIntoGrid(group, numColumns);
			LayoutUtil.setHorizontalGrabbing(fLocation.getTextControl(null));
		}
				
		private void fireEvent() {
			setChanged();
			notifyObservers();
		}

		private String getDefaultPath(String name) {
			final IPath path= Platform.getLocation().append(name);
			return path.toOSString();
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.util.Observer#update(java.util.Observable,
		 *      java.lang.Object)
		 */
		public void update(Observable o, Object arg) {
			if (isInWorkspace()) {
				fLocation.setText(getDefaultPath(fNameGroup.getName()));
			}
			fireEvent();
		}

		public IPath getLocation() {
			if (isInWorkspace()) {
				return Platform.getLocation();
			}
			return new Path(fLocation.getText().trim());
		}

		public boolean isInWorkspace() {
			return fWorkspaceRadio.isSelected();
		}

		/* (non-Javadoc)
		 * @see org.eclipse.jdt.internal.ui.wizards.dialogfields.IStringButtonAdapter#changeControlPressed(org.eclipse.jdt.internal.ui.wizards.dialogfields.DialogField)
		 */
		public void changeControlPressed(DialogField field) {
			final DirectoryDialog dialog= new DirectoryDialog(getShell());
			dialog.setMessage(NewWizardMessages.getString("JavaProjectWizardFirstPage.directory.message")); //$NON-NLS-1$
			String directoryName = fLocation.getText().trim();
			if (directoryName.length() == 0) {
				String prevLocation= JavaPlugin.getDefault().getDialogSettings().get(DIALOGSTORE_LAST_EXTERNAL_LOC);
				if (prevLocation != null) {
					directoryName= prevLocation;
				}
			}
		
			if (directoryName.length() &gt; 0) {
				final File path = new File(directoryName);
				if (path.exists())
					dialog.setFilterPath(new Path(directoryName).toOSString());
			}
			final String selectedDirectory = dialog.open();
			if (selectedDirectory != null) {
				fLocation.setText(selectedDirectory);
				JavaPlugin.getDefault().getDialogSettings().put(DIALOGSTORE_LAST_EXTERNAL_LOC, selectedDirectory);
			}
		}

		/* (non-Javadoc)
		 * @see org.eclipse.jdt.internal.ui.wizards.dialogfields.IDialogFieldListener#dialogFieldChanged(org.eclipse.jdt.internal.ui.wizards.dialogfields.DialogField)
		 */
		public void dialogFieldChanged(DialogField field) {
			if (field == fWorkspaceRadio) {
				final boolean checked= fWorkspaceRadio.isSelected();
				if (checked) {
					fPreviousExternalLocation= fLocation.getText();
					fLocation.setText(getDefaultPath(fNameGroup.getName()));
				} else {
					fLocation.setText(fPreviousExternalLocation);
				}
			}
			fireEvent();
		}
	}

	/**
	 * Request a project layout.
	 */
	private final class LayoutGroup implements Observer, IDialogFieldListener {

		private final SelectionButtonDialogField fStdRadio, fSrcBinRadio, fConfigureButton;
		private final Group fGroup;
		
		public LayoutGroup(Composite composite) {
			
			fGroup= new Group(composite, SWT.NONE);
			fGroup.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
			fGroup.setLayout(initGridLayout(new GridLayout(), true));
			fGroup.setText(NewWizardMessages.getString("JavaProjectWizardFirstPage.LayoutGroup.title")); //$NON-NLS-1$
			
			fStdRadio= new SelectionButtonDialogField(SWT.RADIO);
			fStdRadio.setLabelText(NewWizardMessages.getString("JavaProjectWizardFirstPage.LayoutGroup.option.oneFolder")); //$NON-NLS-1$
			
			fSrcBinRadio= new SelectionButtonDialogField(SWT.RADIO);
			fSrcBinRadio.setLabelText(NewWizardMessages.getString("JavaProjectWizardFirstPage.LayoutGroup.option.separateFolders")); //$NON-NLS-1$
			
			fStdRadio.doFillIntoGrid(fGroup, 1);
			fSrcBinRadio.doFillIntoGrid(fGroup, 1);
			
			fConfigureButton= new SelectionButtonDialogField(SWT.PUSH);
			fConfigureButton.setLabelText(NewWizardMessages.getString("JavaProjectWizardFirstPage.LayoutGroup.configure")); //$NON-NLS-1$
			fConfigureButton.setDialogFieldListener(this);

			
			fConfigureButton.doFillIntoGrid(composite, 1);
			fConfigureButton.getSelectionButton(null).setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_END));
			
			boolean useSrcBin= PreferenceConstants.getPreferenceStore().getBoolean(PreferenceConstants.SRCBIN_FOLDERS_IN_NEWPROJ);
			fSrcBinRadio.setSelection(useSrcBin);
			fStdRadio.setSelection(!useSrcBin);
		}

		public void update(Observable o, Object arg) {
			final boolean detect= fDetectGroup.mustDetect();
			fStdRadio.setEnabled(!detect);
			fSrcBinRadio.setEnabled(!detect);
			fGroup.setEnabled(!detect);
		}
		
		public boolean isSrcBin() {
			return fSrcBinRadio.isSelected();
		}

		/* (non-Javadoc)
		 * @see org.eclipse.jdt.internal.ui.wizards.dialogfields.IDialogFieldListener#dialogFieldChanged(org.eclipse.jdt.internal.ui.wizards.dialogfields.DialogField)
		 */
		public void dialogFieldChanged(DialogField field) {
			if (field == fConfigureButton) {
				PreferencePageSupport.showPreferencePage(getShell(), NewJavaProjectPreferencePage.ID, new NewJavaProjectPreferencePage());
			}
		}
	}

	/**
	 * Show a warning when the project location contains files.
	 */
	private final class DetectGroup extends Observable implements Observer {

		private final Text fText;
		private boolean fDetect;
		
		public DetectGroup(Composite composite) {
			fText= new Text(composite, SWT.MULTI | SWT.READ_ONLY | SWT.WRAP);
			final GridData gd= new GridData(GridData.FILL_HORIZONTAL | GridData.VERTICAL_ALIGN_FILL);
			gd.widthHint= 0;
			gd.heightHint= convertHeightInCharsToPixels(6);
			fText.setLayoutData(gd);
			fText.setFont(composite.getFont());
			fText.setText(NewWizardMessages.getString("JavaProjectWizardFirstPage.DetectGroup.message")); //$NON-NLS-1$
			fText.setVisible(false);
		}

		public void update(Observable o, Object arg) {
			if (fLocationGroup.isInWorkspace()) {
				String name= getProjectName();
				if (name.length() == 0 || JavaPlugin.getWorkspace().getRoot().findMember(name) != null) {
					fDetect= false;
				} else {
					final File directory= fLocationGroup.getLocation().append(getProjectName()).toFile();
					fDetect= directory.isDirectory();
				}
			} else {
				final File directory= fLocationGroup.getLocation().toFile();
				fDetect= directory.isDirectory();
			}
			fText.setVisible(fDetect);
			setChanged();
			notifyObservers();
		}
		
		public boolean mustDetect() {
			return fDetect;
		}
	}

	/**
	 * Validate this page and show appropriate warnings and error NewWizardMessages.
	 */
	private final class Validator implements Observer {

		public void update(Observable o, Object arg) {

			final IWorkspace workspace= JavaPlugin.getWorkspace();

			final String name= fNameGroup.getName();

			// check wether the project name field is empty
			if (name.length() == 0) { //$NON-NLS-1$
				setErrorMessage(null);
				setMessage(NewWizardMessages.getString("JavaProjectWizardFirstPage.Message.enterProjectName")); //$NON-NLS-1$
				setPageComplete(false);
				return;
			}

			// check whether the project name is valid
			final IStatus nameStatus= workspace.validateName(name, IResource.PROJECT);
			if (!nameStatus.isOK()) {
				setErrorMessage(nameStatus.getMessage());
				setPageComplete(false);
				return;
			}

			// check whether project already exists
			final IProject handle= getProjectHandle();
			if (handle.exists()) {
				setErrorMessage(NewWizardMessages.getString("JavaProjectWizardFirstPage.Message.projectAlreadyExists")); //$NON-NLS-1$
				setPageComplete(false);
				return;
			}

			final String location= fLocationGroup.getLocation().toOSString();

			// check whether location is empty
			if (location.length() == 0) {
				setErrorMessage(null);
				setMessage(NewWizardMessages.getString("JavaProjectWizardFirstPage.Message.enterLocation")); //$NON-NLS-1$
				setPageComplete(false);
				return;
			}

			// check whether the location is a syntactically correct path
			if (!Path.EMPTY.isValidPath(location)) { //$NON-NLS-1$
				setErrorMessage(NewWizardMessages.getString("JavaProjectWizardFirstPage.Message.invalidDirectory")); //$NON-NLS-1$
				setPageComplete(false);
				return;
			}

			// check whether the location has the workspace as prefix
			IPath projectPath= new Path(location);
			if (!fLocationGroup.isInWorkspace() &amp;&amp; Platform.getLocation().isPrefixOf(projectPath)) {
				setErrorMessage(NewWizardMessages.getString("JavaProjectWizardFirstPage.Message.cannotCreateInWorkspace")); //$NON-NLS-1$
				setPageComplete(false);
				return;
			}

			// If we do not place the contents in the workspace validate the
			// location.
			if (!fLocationGroup.isInWorkspace()) {
				final IStatus locationStatus= workspace.validateProjectLocation(handle, projectPath);
				if (!locationStatus.isOK()) {
					setErrorMessage(locationStatus.getMessage());
					setPageComplete(false);
					return;
				}
			}
			
			setPageComplete(true);

			setErrorMessage(null);
			setMessage(null);
		}

	}

	private NameGroup fNameGroup;
	protected LocationGroup fLocationGroup;
	private LayoutGroup fLayoutGroup;
	private DetectGroup fDetectGroup;
	private Validator fValidator;

	private String fInitialName;
	
	private static final String PAGE_NAME= NewWizardMessages.getString("JavaProjectWizardFirstPage.page.pageName"); //$NON-NLS-1$

	/**
	 * Create a new &lt;code&gt;SimpleProjectFirstPage&lt;/code&gt;.
	 */
	public JavaProjectWizardFirstPageExtension() {
		super();
		setPageComplete(false);
		setTitle(NewWizardMessages.getString("JavaProjectWizardFirstPage.page.title")); //$NON-NLS-1$
		setDescription(NewWizardMessages.getString("JavaProjectWizardFirstPage.page.description")); //$NON-NLS-1$
		fInitialName= ""; //$NON-NLS-1$
	}
	
	public void setName(String name) {
		fInitialName= name;
		if (fNameGroup != null) {
			fNameGroup.setName(name);
		}
	}

	public void createControl(Composite parent) {
		initializeDialogUnits(parent);

		final Composite composite= new Composite(parent, SWT.NULL);
		composite.setFont(parent.getFont());
		composite.setLayout(initGridLayout(new GridLayout(1, false), true));
		composite.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_FILL));

		// create UI elements
		fNameGroup= new NameGroup(composite, fInitialName);
		fLocationGroup= new LocationGroup(composite);
		fLayoutGroup= new LayoutGroup(composite);
		fDetectGroup= new DetectGroup(composite);
		
		// establish connections
		fNameGroup.addObserver(fLocationGroup);
		fDetectGroup.addObserver(fLayoutGroup);
		fLocationGroup.addObserver(fDetectGroup);

		// initialize all elements
		fNameGroup.notifyObservers();
		
		// create and connect validator
		fValidator= new Validator();
		fNameGroup.addObserver(fValidator);
		fLocationGroup.addObserver(fValidator);

		setControl(composite);
		Dialog.applyDialogFont(composite);
	}

	/**
	 * Returns the current project location path as entered by the user, or its
	 * anticipated initial value. Note that if the default has been returned
	 * the path in a project description used to create a project should not be
	 * set.
	 * 
	 * @return the project location path or its anticipated initial value.
	 */
	public IPath getLocationPath() {
		return fLocationGroup.getLocation();
	}


	/**
	 * Creates a project resource handle for the current project name field
	 * value.
	 * &lt;p&gt;
	 * This method does not create the project resource; this is the
	 * responsibility of &lt;code&gt;IProject::create&lt;/code&gt; invoked by the new
	 * project resource wizard.
	 * &lt;/p&gt;
	 * 
	 * @return the new project resource handle
	 */
	public IProject getProjectHandle() {
		return ResourcesPlugin.getWorkspace().getRoot().getProject(fNameGroup.getName());
	}
	
	public boolean isInWorkspace() {
		return fLocationGroup.isInWorkspace();
	}
	
	public String getProjectName() {
		return fNameGroup.getName();
	}

	public boolean getDetect() {
		return fDetectGroup.mustDetect();
	}
	
	public boolean isSrcBin() {
		return fLayoutGroup.isSrcBin();
	}
	
	
	/*
	 * see @DialogPage.setVisible(boolean)
	 */
	public void setVisible(boolean visible) {
//		super.setVisible(visible);
		if (visible) {
			fNameGroup.postSetFocus();
		}
	}
		
	/**
	 * Initialize a grid layout with the default Dialog settings.
	 */
	protected GridLayout initGridLayout(GridLayout layout, boolean margins) {
		layout.horizontalSpacing= convertHorizontalDLUsToPixels(IDialogConstants.HORIZONTAL_SPACING);
		layout.verticalSpacing= convertVerticalDLUsToPixels(IDialogConstants.VERTICAL_SPACING);
		if (margins) {
			layout.marginWidth= convertHorizontalDLUsToPixels(IDialogConstants.HORIZONTAL_MARGIN);
			layout.marginHeight= convertVerticalDLUsToPixels(IDialogConstants.VERTICAL_MARGIN);
		} else {
			layout.marginWidth= 0;
			layout.marginHeight= 0;
		}
		return layout;
	}
	
	/**
	 * Set the layout data for a button.
	 */
	protected GridData setButtonLayoutData(Button button) {
		return super.setButtonLayoutData(button);
	}
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/buildconfigurator/propertypage/JavaCapabilityConfigurationPage.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2000, 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

package org.eclipse.ajdt.buildconfigurator.propertypage;


import java.lang.reflect.InvocationTargetException;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.internal.ui.IJavaHelpContextIds;
import org.eclipse.jdt.internal.ui.wizards.IStatusChangeListener;
import org.eclipse.jdt.internal.ui.wizards.NewWizardMessages;
import org.eclipse.jdt.ui.wizards.NewElementWizardPage;
import org.eclipse.jface.dialogs.Dialog;
import org.eclipse.jface.operation.IRunnableWithProgress;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.ui.help.WorkbenchHelp;

/**
 * Copied from same in org.eclipse.jdt.ui.wizards.  Only change is to use
 * BuildPathsBlock in this package.
 */

public class JavaCapabilityConfigurationPage extends NewElementWizardPage {

	private static final String PAGE_NAME= "JavaCapabilityConfigurationPage"; //$NON-NLS-1$
	
	private IJavaProject fJavaProject;
	private BuildPathsBlock fBuildPathsBlock;
	
	/**
	 * Creates a wizard page that can be used in a Java project creation wizard.
	 * It contains UI to configure a the classpath and the output folder.
	 * 
	 * &lt;p&gt;
	 * After constructing, a call to &lt;code&gt;init&lt;/code&gt; is required.
	 * &lt;/p&gt;
	 */	
	public JavaCapabilityConfigurationPage() {
		super(PAGE_NAME);
		fJavaProject= null;
		
		setTitle(NewWizardMessages.getString("JavaCapabilityConfigurationPage.title")); //$NON-NLS-1$
		setDescription(NewWizardMessages.getString("JavaCapabilityConfigurationPage.description")); //$NON-NLS-1$
		
		IStatusChangeListener listener= new IStatusChangeListener() {
			public void statusChanged(IStatus status) {
				updateStatus(status);
			}
		};

		fBuildPathsBlock= new BuildPathsBlock(listener, 0);
	}
	
	/**
	 * Initializes the page with the project and default classpaths.
	 * &lt;p&gt;
	 * The default classpath entries must correspond the the given project.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * The caller of this method is responsible for creating the underlying project. The page will create the output,
	 * source and library folders if required.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * The project does not have to exist at the time of initialization, but must exist when executing the runnable
	 * obtained by &lt;code&gt;getRunnable()&lt;/code&gt;.
	 * &lt;/p&gt;
	 * @param jproject The Java project.
	 * @param defaultOutputLocation The default classpath entries or &lt;code&gt;null&lt;/code&gt; to let the page choose the default
	 * @param defaultEntries The folder to be taken as the default output path or &lt;code&gt;null&lt;/code&gt; to let the page choose the default
	 * @param defaultsOverrideExistingClasspath If set to &lt;code&gt;true&lt;/code&gt;, an existing '.classpath' file is ignored. If set to &lt;code&gt;false&lt;/code&gt;
	 * the given default classpath and output location is only used if no '.classpath' exists.
	 */
	public void init(IJavaProject jproject, IPath defaultOutputLocation, IClasspathEntry[] defaultEntries, boolean defaultsOverrideExistingClasspath) {
		if (!defaultsOverrideExistingClasspath &amp;&amp; jproject.exists() &amp;&amp; jproject.getProject().getFile(".classpath").exists()) { //$NON-NLS-1$
			defaultOutputLocation= null;
			defaultEntries= null;
		}
		fBuildPathsBlock.init(jproject, defaultOutputLocation, defaultEntries);
		fJavaProject= jproject;
	}
	

	/* (non-Javadoc)
	 * @see WizardPage#createControl
	 */	
	public void createControl(Composite parent) {
		Control control= fBuildPathsBlock.createControl(parent);
		setControl(control);
		Dialog.applyDialogFont(control);
		WorkbenchHelp.setHelp(control, IJavaHelpContextIds.NEW_JAVAPROJECT_WIZARD_PAGE);
	}
		
	/**
	 * Returns the currently configured output location. Note that the returned path 
	 * might not be a valid path.
	 * 
	 * @return the currently configured output location
	 */
	public IPath getOutputLocation() {
		return fBuildPathsBlock.getOutputLocation();
	}

	/**
	 * Returns the currently configured classpath. Note that the classpath might 
	 * not be valid.
	 * 
	 * @return the currently configured classpath
	 */	
	public IClasspathEntry[] getRawClassPath() {
		return fBuildPathsBlock.getRawClassPath();
	}
	
	/**
	 * Returns the Java project that was passed in &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if the 
	 * page has not been initialized yet.
	 * 
	 * @return the managed Java project or &lt;code&gt;null&lt;/code&gt;
	 */	
	public IJavaProject getJavaProject() {
		return fJavaProject;
	}	
	

	/**
	 * Returns the runnable that will create the Java project or &lt;code&gt;null&lt;/code&gt; if the page has 
	 * not been initialized. The runnable sets the project's classpath and output location to the values 
	 * configured in the page and adds the Java nature if not set yet. The method requires that the 
	 * project is created and opened.
	 *
	 * @return the runnable that creates the new Java project
	 */		
	public IRunnableWithProgress getRunnable() {
		if (getJavaProject() != null) {
			return new IRunnableWithProgress() {
				public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
					try {
						configureJavaProject(monitor);
					} catch (CoreException e) {
						throw new InvocationTargetException(e);
					}
				}
			};
		}
		return null;	
	}

	/**
	 * Helper method to create and open a IProject . The project location
	 * is configured. No natures are added.
	 * 
	 * @param project The handle of the project to create.
	 * @param locationPath The location of the project.
	 * @param monitor a progress monitor to report progress or &lt;code&gt;null&lt;/code&gt; if
	 * progress reporting is not desired
	 * @throws CoreException
	 * @since 2.1
	 */
	public static void createProject(IProject project, IPath locationPath, IProgressMonitor monitor) throws CoreException {
		BuildPathsBlock.createProject(project, locationPath, monitor);
	}
	
	/**
	 * Adds the Java nature to the project (if not set yet) and configures the build classpath.
	 * 
	 * @param monitor a progress monitor to report progress or &lt;code&gt;null&lt;/code&gt; if
	 * progress reporting is not desired
	 * @throws CoreException Thrown when the configuring the Java project failed.
	 * @throws InterruptedException Thrown when the operation has been cancelled.
	 */
	public void configureJavaProject(IProgressMonitor monitor) throws CoreException, InterruptedException {
		if (monitor == null) {
			monitor= new NullProgressMonitor();
		}
		
		int nSteps= 6;			
		monitor.beginTask(NewWizardMessages.getString("JavaCapabilityConfigurationPage.op_desc_java"), nSteps); //$NON-NLS-1$
		
		try {
			IProject project= getJavaProject().getProject();
			BuildPathsBlock.addJavaNature(project, new SubProgressMonitor(monitor, 1));
			fBuildPathsBlock.configureJavaProject(new SubProgressMonitor(monitor, 5));
		} catch (OperationCanceledException e) {
			throw new InterruptedException();
		} finally {
			monitor.done();
		}			
	}
	
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/AspectJProjectWizardSecondPage.java" revision="1.1" state="new">/*******************************************************************************
* Copyright (c) 2000, 2004 IBM Corporation and others.
* All rights reserved. This program and the accompanying materials 
* are made available under the terms of the Common Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/cpl-v10.html
* 
* Contributors:
*     IBM Corporation - initial API and implementation
*******************************************************************************/
package org.eclipse.ajdt.internal.ui.wizards;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.eclipse.ajdt.buildconfigurator.propertypage.JavaCapabilityConfigurationPage;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.internal.ui.util.CoreUtility;
import org.eclipse.jdt.internal.ui.util.ExceptionHandler;
import org.eclipse.jdt.internal.ui.wizards.ClassPathDetector;
import org.eclipse.jdt.internal.ui.wizards.JavaProjectWizardFirstPage;
import org.eclipse.jdt.internal.ui.wizards.NewWizardMessages;
import org.eclipse.jdt.ui.PreferenceConstants;
import org.eclipse.jface.operation.IRunnableWithProgress;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation;

/**
 * Copied from JavaProjectWizardSecondPage in package org.eclipse.jdt.internal.ui.wizards.
 * No changes, but uses AJDT version of JavaCapabilityConfigurationPage.
 */
public class AspectJProjectWizardSecondPage extends JavaCapabilityConfigurationPage {

	private final JavaProjectWizardFirstPage fFirstPage;

	protected IPath fCurrProjectLocation;
	protected IProject fCurrProject;
	
	protected boolean fKeepContent;

	/**
	 * Constructor for NewProjectCreationWizardPage.
	 */
	public AspectJProjectWizardSecondPage(JavaProjectWizardFirstPage mainPage) {
		super();
		fFirstPage= mainPage;
		fCurrProjectLocation= null;
		fCurrProject= null;
		fKeepContent= true;
	}
	
	/* (non-Javadoc)
	 * @see org.eclipse.jface.dialogs.IDialogPage#setVisible(boolean)
	 */
	public void setVisible(boolean visible) {
		if (visible) {
			changeToNewProject();
		} else {
			removeProject();
		}
		super.setVisible(visible);
	}
	
	private void changeToNewProject() {
		final IProject newProjectHandle= fFirstPage.getProjectHandle();
		final IPath newProjectLocation= fFirstPage.getLocationPath();
		
		fKeepContent= fFirstPage.getDetect();
		
		final boolean initialize= !(newProjectHandle.equals(fCurrProject) &amp;&amp; newProjectLocation.equals(fCurrProjectLocation));
		
		final IRunnableWithProgress op= new IRunnableWithProgress() {
			public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
				try {
					updateProject(initialize, monitor);
				} catch (CoreException e) {
					throw new InvocationTargetException(e);
				} catch (OperationCanceledException e) {
					throw new InterruptedException();
				}
			}
		};
	
		try {
			getContainer().run(true, false, new WorkspaceModifyDelegatingOperation(op));
		} catch (InvocationTargetException e) {
			final String title= NewWizardMessages.getString("JavaProjectWizardSecondPage.error.title"); //$NON-NLS-1$
			final String message= NewWizardMessages.getString("JavaProjectWizardSecondPage.error.message"); //$NON-NLS-1$
			ExceptionHandler.handle(e, getShell(), title, message);
		} catch  (InterruptedException e) {
			// cancel pressed
		}
	}
	
	protected void updateProject(boolean initialize, IProgressMonitor monitor) throws CoreException {
		
		fCurrProject= fFirstPage.getProjectHandle();
		fCurrProjectLocation= fFirstPage.getLocationPath();
		
		final boolean noProgressMonitor= !initialize &amp;&amp; !fFirstPage.getDetect();
		
		if (monitor == null || noProgressMonitor ) {
			monitor= new NullProgressMonitor();
		}
		try {
			monitor.beginTask(NewWizardMessages.getString("JavaProjectWizardSecondPage.operation.initialize"), 2); //$NON-NLS-1$
			if (monitor.isCanceled()) {
				throw new OperationCanceledException();
			}
			
			createProject(fCurrProject, fCurrProjectLocation, new SubProgressMonitor(monitor, 1));
			if (initialize) {
				
				IClasspathEntry[] entries= null;
				IPath outputLocation= null;
		
				if (fFirstPage.getDetect()) {
					if (!fCurrProject.getFile(".classpath").exists()) { //$NON-NLS-1$
						final ClassPathDetector detector= new ClassPathDetector(fCurrProject);
						entries= detector.getClasspath();
						outputLocation= detector.getOutputLocation();
					}
				} else if (fFirstPage.isSrcBin()) {
					IPreferenceStore store= PreferenceConstants.getPreferenceStore();
					IPath srcPath= new Path(store.getString(PreferenceConstants.SRCBIN_SRCNAME));
					IPath binPath= new Path(store.getString(PreferenceConstants.SRCBIN_BINNAME));
					
					if (srcPath.segmentCount() &gt; 0) {
						IFolder folder= fCurrProject.getFolder(srcPath);
						CoreUtility.createFolder(folder, true, true, null);
					}
					
					if (binPath.segmentCount() &gt; 0 &amp;&amp; !binPath.equals(srcPath)) {
						IFolder folder= fCurrProject.getFolder(binPath);
						CoreUtility.createFolder(folder, true, true, null);
					}
					
					final IPath projectPath= fCurrProject.getFullPath();

					// configure the classpath entries, including the default jre library.
					List cpEntries= new ArrayList();
					cpEntries.add(JavaCore.newSourceEntry(projectPath.append(srcPath)));
					cpEntries.addAll(Arrays.asList(PreferenceConstants.getDefaultJRELibrary()));
					entries= (IClasspathEntry[]) cpEntries.toArray(new IClasspathEntry[cpEntries.size()]);
					
					// configure the output location
					outputLocation= projectPath.append(binPath);
				} else {
					IPath projectPath= fCurrProject.getFullPath();
					List cpEntries= new ArrayList();
					cpEntries.add(JavaCore.newSourceEntry(projectPath));
					cpEntries.addAll(Arrays.asList(PreferenceConstants.getDefaultJRELibrary()));
					entries= (IClasspathEntry[]) cpEntries.toArray(new IClasspathEntry[cpEntries.size()]);

					outputLocation= projectPath;
				}
				if (monitor.isCanceled()) {
					throw new OperationCanceledException();
				}
				
				init(JavaCore.create(fCurrProject), outputLocation, entries, false);
			}
			monitor.worked(1);
		} finally {
			monitor.done();
		}
	}
	
	/**
	 * Called from the wizard on finish.
	 */
	public void performFinish(IProgressMonitor monitor) throws CoreException, InterruptedException {
		try {
			monitor.beginTask(NewWizardMessages.getString("JavaProjectWizardSecondPage.operation.create"), 3); //$NON-NLS-1$
			if (fCurrProject == null) {
				updateProject(true, new SubProgressMonitor(monitor, 1));
			}
			configureJavaProject(new SubProgressMonitor(monitor, 2));
		} finally {
			monitor.done();
			fCurrProject= null;
		}
	}

	private void removeProject() {
		if (fCurrProject == null || !fCurrProject.exists()) {
			return;
		}
		
		IRunnableWithProgress op= new IRunnableWithProgress() {
			public void run(IProgressMonitor monitor) throws InvocationTargetException {

				final boolean noProgressMonitor= Platform.getLocation().equals(fCurrProjectLocation);

				if (monitor == null || noProgressMonitor) {
					monitor= new NullProgressMonitor();
				}

				monitor.beginTask(NewWizardMessages.getString("JavaProjectWizardSecondPage.operation.remove"), 3); //$NON-NLS-1$

				try {
					boolean removeContent= !fKeepContent &amp;&amp; fCurrProject.isSynchronized(IResource.DEPTH_INFINITE);
					fCurrProject.delete(removeContent, false, monitor);
				} catch (CoreException e) {
					throw new InvocationTargetException(e);
				} finally {
					monitor.done();
					fCurrProject= null;
					fKeepContent= false;
				}
			}
		};
	
		try {
			getContainer().run(true, true, new WorkspaceModifyDelegatingOperation(op));
		} catch (InvocationTargetException e) {
			final String title= NewWizardMessages.getString("JavaProjectWizardSecondPage.error.remove.title"); //$NON-NLS-1$
			final String message= NewWizardMessages.getString("JavaProjectWizardSecondPage.error.remove.message"); //$NON-NLS-1$
			ExceptionHandler.handle(e, getShell(), title, message);		
		} catch  (InterruptedException e) {
			// cancel pressed
		}
	}		
			
	/**
	 * Called from the wizard on cancel.
	 */
	public void performCancel() {
		removeProject();
	}
}
</file>
</fixedFiles>
</bug>
<bug id="78378" transactionid="73552">
<property name="files-churned" value="8"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="21"/>
<property name="lines-added" value="8"/>
<property name="lines-deleted" value="376"/>
<property name="lines-modified" value="35"/>
<property name="lines-churned" value="419"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-else K-false K-for K-if K-import K-instanceof K-new K-null K-return K-synchronized K-true K-try K-while M O-&lt; O-== O-&gt; O-|| O-! O-!= O-?: O-() O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-cond Z-for Z-if Z-vardecl Z-while</fullfingerprint>
<bugreport>Currently we use our custom editor for .aj and .java files, and our custom
outline view. Using the editor for .java files causes incompatibilities compared
with the standard Java editor, and our custom outline view has confusing
differences to the standard outline view. A much cleaner solution would be to
use our editor only for .aj files, and to contribute only to the standard
outline view. This bug is for investigations into the feasibility of doing that,
including what we might lose, and what changes we might wish to request in
Eclipse. These two areas are linked, because our custom editor is used to
trigger our custom outline view.

Here is an initial list of things to investigate. Add your findings to this bug.

1. Using the standard outline view. What could we show here, by contributing to
the standard outline view? The purpose of this view in Eclipse is to show the
structure of the current document, so we can certainly do that (and it should be
the eagerly parsed version). We should also be able to add custom buttons to
toggle the display of certain items, as the Ant support in Eclipse does this.
What we might lose is the advice links - is this possible with the standard
outline view? If not, is the cross-reference view a suitable alternative?

2. Advice markers. These are currently created when a file is opened in the
AspectJ editor. Could they instead be created for all resources after a build?
This arrangement would be consistent with JDT.

3. Context menu on advice markers - the "advised by", and "aspect decl" etc menu
entries. Can we contribute these without doing so via the AspectJ editor (so
they still appear for .java files opened in the Java editor)? If not, what would
we need from Eclipse to do this?</bugreport>
<pre-fix-testcases failing="114" file="output/78378/pre-fix/testresults.xml" passing="1292" size="1406"/>
<post-fix-testcases failing="112" file="output/78378/post-fix/testresults.xml" passing="1294" size="1406"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/plugin.properties" revision="1.5" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/builder/Builder.java" revision="1.12" state="changed">367,370d366
&lt; 			// Tell the editor to perform any marker updates pending from
&lt; 			// the compile.
&lt; 			AspectJEditor.forceMarkerUpdates(project);
&lt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/build31.ajproperties" revision="1.2" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJEditor.java" revision="1.10" state="changed">15d14
&lt; import java.util.Map;
17d15
&lt; import java.util.Vector;
20,21d17
&lt; import org.aspectj.asm.IProgramElement;
&lt; import org.aspectj.bridge.ISourceLocation;
29,31d24
&lt; import org.eclipse.ajdt.ui.IAJModelMarker;
&lt; import org.eclipse.ajdt.ui.visualiser.NodeHolder;
&lt; import org.eclipse.ajdt.ui.visualiser.StructureModelUtil;
35,36d27
&lt; import org.eclipse.core.resources.IResource;
&lt; import org.eclipse.core.resources.IWorkspaceRunnable;
40d30
&lt; import org.eclipse.jdt.core.IJavaElement;
44d33
&lt; import org.eclipse.jdt.internal.ui.javaeditor.JavaOutlinePage;
85,86d73
&lt; 	private boolean markersNeedUpdating = true;
&lt; 
89,90d75
&lt; 	private IFileEditorInput currentFileInput;
&lt; 
94a80
&gt; 		
398,401c384
&lt; 			if (currentFileInput != null) {
&lt; 				removeAJDTMarkers(currentFileInput);
&lt; 			}
&lt; 			currentFileInput = fInput;
---
&gt; 
406d388
&lt; 			updateAdviceMarkers(fInput);
427,466d408
&lt; 	/**
&lt; 	 * This method forces an update of the markers (i.e. they will all be
&lt; 	 * deleted and then readded) - this is called from the build updating code
&lt; 	 * in AspectJContentOutlinePage - to ensure that every editor has the right
&lt; 	 * markers after a compilation
&lt; 	 */
&lt; 	public void forceUpdateOfAdviceMarkers() {
&lt; 		markersNeedUpdating = true;
&lt; 		updateAdviceMarkers((IFileEditorInput) getEditorInput());
&lt; 	}
&lt; 
&lt; 	/**
&lt; 	 * Adds the advice markers for a file to the left hand gutter. It kicks off
&lt; 	 * a thread that does a delete then adds all the new markers.
&lt; 	 */
&lt; 	public void updateAdviceMarkers(final IFileEditorInput fInput) {
&lt; 
&lt; 		if (!markersNeedUpdating)
&lt; 			return;
&lt; 
&lt; 		if (fInput == null) {
&lt; 			AJDTEventTrace
&lt; 					.generalEvent("AspectJEditor: FileEditorInput is null for editor with title ("
&lt; 							+ getTitle() + "): Cannot update markers on it");
&lt; 			return;
&lt; 		}
&lt; 
&lt; 		if (fInput.getFile() == null) {
&lt; 			AJDTEventTrace
&lt; 					.generalEvent("AspectJEditor: fileeditorinput.getFile() is null: see bugzilla #43662");
&lt; 			return;
&lt; 		}
&lt; 
&lt; 		removeAJDTMarkers(fInput);
&lt; 		AspectJUIPlugin.getDefault().getDisplay().asyncExec(new Runnable() {
&lt; 			public void run() {
&lt; 				addNewMarkers(fInput);
&lt; 			}
&lt; 		});
&lt; 	}
480,676d421
&lt; 	/**
&lt; 	 * Remove all the AJDT markers from the given file input.
&lt; 	 * 
&lt; 	 * @param fInput
&lt; 	 */
&lt; 	private void removeAJDTMarkers(final IFileEditorInput fInput) {
&lt; 		AspectJUIPlugin.getDefault().getDisplay().asyncExec(new Runnable() {
&lt; 			public void run() {
&lt; 				try {
&lt; 					// Wipe all the current advice markers
&lt; 					fInput.getFile().deleteMarkers(IAJModelMarker.ADVICE_MARKER,
&lt; 							true, IResource.DEPTH_INFINITE);
&lt; 					fInput.getFile().deleteMarkers(
&lt; 							IAJModelMarker.DECLARATION_MARKER, true,
&lt; 							IResource.DEPTH_INFINITE);
&lt; 				} catch (CoreException ce) {
&lt; 					//if file has been deleted, don't throw exception
&lt; 					if (fInput.getFile().exists())
&lt; 						AspectJUIPlugin.getDefault().getErrorHandler()
&lt; 								.handleError("Advice marker delete failed", ce);
&lt; 				}
&lt; 			}
&lt; 		});
&lt; 	}
&lt; 
&lt; 	/**
&lt; 	 * Adds advice markers to mark each line in the source that is affected by
&lt; 	 * advice from an aspect. It uses the StructureModelUtil code that the
&lt; 	 * visualizer also uses - to determine what aspects are in effect on a
&lt; 	 * specific source file.
&lt; 	 * 
&lt; 	 * @param fInput
&lt; 	 *            The file editor input resource against which the markers will
&lt; 	 *            be added.
&lt; 	 */
&lt; 	private void addNewMarkers(final IFileEditorInput fInput) {
&lt; 		IProject project = fInput.getFile().getProject();
&lt; 
&lt; 		// Don't add markers to resources in non AspectJ projects !
&lt; 		try {
&lt; 			if (project == null || !project.isOpen()
&lt; 					|| !project.hasNature(AspectJUIPlugin.ID_NATURE))
&lt; 				return;
&lt; 		} catch (CoreException e) {
&lt; 		}
&lt; 
&lt; 		String path = fInput.getFile().getRawLocation().toOSString(); // Copes
&lt; 																	  // with
&lt; 																	  // linked
&lt; 																	  // src
&lt; 																	  // folders.
&lt; 		// retrieve a map of line numbers to Vectors containing StructureNode
&lt; 		// objects
&lt; 		// Ask for the detailed version of the map (by specifying 'true') which
&lt; 		// maps
&lt; 		// line numbers to nodes representing advice (rather than just nodes
&lt; 		// representing
&lt; 		// aspects).
&lt; 		Map m = StructureModelUtil.getLinesToAspectMap(path, true);
&lt; 
&lt; 		if (m != null) {
&lt; 			// iterate through the line numbers in the map
&lt; 			Set keys = m.keySet();
&lt; 			Iterator i = keys.iterator();
&lt; 			while (i.hasNext()) {
&lt; 				Object o = i.next();
&lt; 				final Integer linenumberInt = (Integer) o;
&lt; 
&lt; 				// for that line, go through all the advice in effect
&lt; 				final Vector v = (Vector) m.get(o);
&lt; 				// One runnable per line advised adds the appropriate marker
&lt; 				IWorkspaceRunnable r = new IWorkspaceRunnable() {
&lt; 					public void run(IProgressMonitor monitor) {
&lt; 						try {
&lt; 							boolean sameType = true;
&lt; 							boolean runtimeTst = false;
&lt; 
&lt; 							// Apples or Oranges?
&lt; 							NodeHolder nh = (NodeHolder) v.get(0);
&lt; 							//							if
&lt; 							// (nh.node.getKind()!=IProgramElement.Kind.ADVICE)
&lt; 							// {
&lt; 							//								// probably an intertype decl - SIAN....
&lt; 							//								System.err.println("&gt;ITD:"+nh.node.toString());
&lt; 							//								
&lt; 							//							} else {
&lt; 							// advice nodes
&lt; 							if (v.size() &gt; 1) {
&lt; 								NodeHolder first = (NodeHolder) v.get(0);
&lt; 								String adviceType = first.node.getExtraInfo() == null ? null
&lt; 										: first.node.getExtraInfo()
&lt; 												.getExtraAdviceInformation();
&lt; 								for (Iterator iter = v.iterator(); iter
&lt; 										.hasNext();) {
&lt; 									NodeHolder element = (NodeHolder) iter
&lt; 											.next();
&lt; 									runtimeTst = runtimeTst
&lt; 											|| element.runtimeTest;
&lt; 									if (adviceType != null) {
&lt; 										if (element.node.getExtraInfo() == null) {
&lt; 											sameType = false;
&lt; 										} else {
&lt; 											sameType = sameType
&lt; 													&amp;&amp; adviceType
&lt; 															.equals(element.node
&lt; 																	.getExtraInfo()
&lt; 																	.getExtraAdviceInformation());
&lt; 										}
&lt; 									} else {
&lt; 										sameType = sameType
&lt; 												&amp;&amp; element.node.getExtraInfo() == null;
&lt; 									}
&lt; 								}
&lt; 							} else if (v.size() == 1) {
&lt; 								runtimeTst = ((NodeHolder) v.get(0)).runtimeTest;
&lt; 							}
&lt; 							final boolean runtimeTest = runtimeTst;
&lt; 							final boolean useDefaultAdviceMarker = !sameType;
&lt; 							for (int j = 0; j &lt; v.size(); j++) {
&lt; 								// sn will represent the advice in affect at the
&lt; 								// given line.
&lt; 								final NodeHolder noddyHolder = (NodeHolder) v
&lt; 										.get(j);
&lt; 								final IProgramElement sn = noddyHolder.node;
&lt; 								final IResource ir = (IResource) fInput
&lt; 										.getFile();
&lt; 								// Thread required to ensure marker created and
&lt; 								// set atomically
&lt; 								// (and so reflected correctly in the ruler).
&lt; 
&lt; 								ISourceLocation sl_sn = sn.getSourceLocation();
&lt; 								String label = sn.toLinkLabelString();
&lt; 								// SIAN: RUNTIMETEST local var gives you whether
&lt; 								// to put the ? on
&lt; 								// SIAN:
&lt; 								// sn.getAdviceInfo().getExtraAdviceInformation()
&lt; 								// will
&lt; 								//       tell you if its
&lt; 								// before/after/afterreturning/afterthrowing/around
&lt; 								// advice
&lt; 
&lt; 								String adviceType = sn.getName();
&lt; 								IMarker marker = createMarker(linenumberInt,
&lt; 										runtimeTest, ir, sn,
&lt; 										useDefaultAdviceMarker,
&lt; 										noddyHolder.runtimeTest);
&lt; 
&lt; 								// Crude format is "FFFF:::NNNN:::NNNN:::NNNN"
&lt; 								// Filename:::StartLine:::EndLine:::ColumnNumber
&lt; 
&lt; 								// Grab the location of the pointcut
&lt; 								ISourceLocation sLoc2 = sn.getSourceLocation();
&lt; 								// was asn
&lt; 								marker.setAttribute(IMarker.PRIORITY,
&lt; 										IMarker.PRIORITY_HIGH);
&lt; 								marker
&lt; 										.setAttribute(
&lt; 												AspectJUIPlugin.SOURCE_LOCATION_ATTRIBUTE,
&lt; 												sLoc2.getSourceFile()
&lt; 														.getAbsolutePath()
&lt; 														+ ":::"
&lt; 														+ sLoc2.getLine()
&lt; 														+ ":::"
&lt; 														+ sLoc2.getEndLine()
&lt; 														+ ":::"
&lt; 														+ sLoc2.getColumn());
&lt; 
&lt; 								//									System.err.println(
&lt; 								//									"Creating advicemarker at line="+
&lt; 								// linenumberInt.intValue() +
&lt; 								//									" advice="+ sn.getName() +
&lt; 								//									" sourcefilepath=" + sLoc2.getSourceFile() +
&lt; 								//								    " line="+ sLoc2.getLine());
&lt; 
&lt; 							}
&lt; 							//							}
&lt; 						} catch (CoreException ce) {
&lt; 							AspectJUIPlugin.getDefault().getErrorHandler()
&lt; 									.handleError(
&lt; 											"Exception creating advice marker",
&lt; 											ce);
&lt; 						}
&lt; 					}
&lt; 				};
&lt; 
&lt; 				// Kick off the thread to add the marker...
&lt; 				try {
&lt; 					AspectJUIPlugin.getWorkspace().run(r, null);
&lt; 				} catch (CoreException cEx) {
&lt; 					AspectJUIPlugin.getDefault().getErrorHandler().handleError(
&lt; 							"AJDT Error adding advice markers", cEx);
&lt; 				}
&lt; 			}
&lt; 		}
&lt; 		// Keep note that we are now up to date
&lt; 		markersNeedUpdating = false;
&lt; 	}
694d438
&lt; 		removeAJDTMarkers(currentFileInput);
745,775c489
&lt; 	/**
&lt; 	 * Sian - added as part of the fix for bug 70658
&lt; 	 * Force marker updates for any editors open on files in the project,
&lt; 	 * or on all editors if project is null.
&lt; 	 * @param project
&lt; 	 */
&lt; 	public static void forceMarkerUpdates(final IProject project) {
&lt; 		final Iterator editorIter = activeEditorList.iterator();
&lt; 		AspectJUIPlugin.getDefault().getDisplay().asyncExec(new Runnable() {
&lt; 			public void run() {
&lt; 				try {
&lt; 					while (editorIter.hasNext()) {
&lt; 						AspectJEditor ajed = (AspectJEditor) editorIter.next();
&lt; 						IEditorInput iei = ajed.getEditorInput();
&lt; 						boolean updateThisEditor = true;
&lt; 						if (project != null
&lt; 								&amp;&amp; (iei instanceof IFileEditorInput)) {
&lt; 							IFileEditorInput ifei = (IFileEditorInput) iei;
&lt; 							if (!(ifei.getFile().getProject().getName()
&lt; 									.equals(project.getName())))
&lt; 								updateThisEditor = false;
&lt; 						}
&lt; 						if (updateThisEditor) {
&lt; 							ajed.forceUpdateOfAdviceMarkers();							
&lt; 						}
&lt; 					}
&lt; 				} catch (Exception e) {
&lt; 				}
&lt; 			}
&lt; 		});
&lt; 	}
---
&gt; 
799d512
&lt; 			updateAdviceMarkers(fInput);
807,854d519
&lt; 
&lt; 	protected IJavaElement getInputJavaElement() {
&lt; 		return JavaPlugin.getDefault().getWorkingCopyManager().getWorkingCopy(getEditorInput());
&lt; 	}
&lt; 
&lt; 	/*
&lt; 	 * @see JavaEditor#setOutlinePageInput(JavaOutlinePage, IEditorInput)
&lt; 	 */
&lt; 	protected void setOutlinePageInput(JavaOutlinePage page, IEditorInput input) {
&lt; 		if (page != null) {
&lt; 			IWorkingCopyManager manager= JavaPlugin.getDefault().getWorkingCopyManager();
&lt; 			page.setInput(manager.getWorkingCopy(input));
&lt; 		}
&lt; 	}
&lt; 	
&lt; 	/**
&lt; 	 * Returns the most narrow element including the given offset.  If &lt;code&gt;reconcile&lt;/code&gt;
&lt; 	 * is &lt;code&gt;true&lt;/code&gt; the editor's input element is reconciled in advance. If it is 
&lt; 	 * &lt;code&gt;false&lt;/code&gt; this method only returns a result if the editor's input element
&lt; 	 * does not need to be reconciled.
&lt; 	 * 
&lt; 	 * @param offset the offset included by the retrieved element
&lt; 	 * @param reconcile &lt;code&gt;true&lt;/code&gt; if working copy should be reconciled
&lt; 	 * @return the most narrow element which includes the given offset
&lt; 	 */
&lt; 	protected IJavaElement getElementAt(int offset, boolean reconcile) {
&lt; 		IWorkingCopyManager manager= JavaPlugin.getDefault().getWorkingCopyManager();
&lt; 		ICompilationUnit unit= manager.getWorkingCopy(getEditorInput());
&lt; 		
&lt; 		if (unit != null) {
&lt; 			try {
&lt; 				if (reconcile) {
&lt; 					synchronized (unit) {
&lt; 						unit.reconcile(ICompilationUnit.NO_AST, false, null, null);
&lt; 					}
&lt; 					return unit.getElementAt(offset);
&lt; 				} else if (unit.isConsistent())
&lt; 					return unit.getElementAt(offset);
&lt; 					
&lt; 			} catch (JavaModelException x) {
&lt; 				if (!x.isDoesNotExist())
&lt; 				JavaPlugin.log(x.getStatus());
&lt; 				// nothing found, be tolerant and go on
&lt; 			}
&lt; 		}
&lt; 		
&lt; 		return null;
&lt; 	}
865,933d529
&lt; 	/**
&lt; 	 * @param linenumberInt
&lt; 	 * @param runtimeTest
&lt; 	 * @param ir
&lt; 	 * @param programElement
&lt; 	 * @param useDefaultAdviceMarker
&lt; 	 * @return the IMarker created
&lt; 	 * @throws CoreException
&lt; 	 */
&lt; 	private IMarker createMarker(final Integer linenumberInt,
&lt; 			final boolean runtimeTest, final IResource ir,
&lt; 			IProgramElement programElement, boolean useDefaultAdviceMarker,
&lt; 			boolean nodeRuntimeTest) throws CoreException {
&lt; 		String label = programElement.toLinkLabelString();
&lt; 		String adviceType = "";
&lt; 		if (programElement.getExtraInfo() != null) {
&lt; 			adviceType = programElement.getExtraInfo()
&lt; 					.getExtraAdviceInformation();
&lt; 		}
&lt; 		IMarker marker;
&lt; 		if (useDefaultAdviceMarker) {
&lt; 			if (runtimeTest) {
&lt; 				marker = ir
&lt; 						.createMarker(IAJModelMarker.DYNAMIC_ADVICE_MARKER);
&lt; 			} else {
&lt; 				if (adviceType == "") {
&lt; 					marker = ir.createMarker(IAJModelMarker.DECLARATION_MARKER);
&lt; 				} else {
&lt; 					marker = ir.createMarker(IAJModelMarker.ADVICE_MARKER);
&lt; 				}
&lt; 			}
&lt; 		} else if (adviceType.equals("before")) {
&lt; 			if (runtimeTest) {
&lt; 				marker = ir
&lt; 						.createMarker(IAJModelMarker.DYNAMIC_BEFORE_ADVICE_MARKER);
&lt; 			} else {
&lt; 				marker = ir
&lt; 						.createMarker(IAJModelMarker.BEFORE_ADVICE_MARKER);
&lt; 			}
&lt; 		} else if (adviceType.equals("around")) {
&lt; 			if (runtimeTest) {
&lt; 				marker = ir
&lt; 						.createMarker(IAJModelMarker.DYNAMIC_AROUND_ADVICE_MARKER);
&lt; 			} else {
&lt; 				marker = ir
&lt; 						.createMarker(IAJModelMarker.AROUND_ADVICE_MARKER);
&lt; 			}
&lt; 		} else if (adviceType.startsWith("after")) {
&lt; 			if (runtimeTest) {
&lt; 				marker = ir
&lt; 						.createMarker(IAJModelMarker.DYNAMIC_AFTER_ADVICE_MARKER);
&lt; 			} else {
&lt; 				marker = ir
&lt; 						.createMarker(IAJModelMarker.AFTER_ADVICE_MARKER);
&lt; 			}
&lt; 		} else {
&lt; 			// It's an Intertype Declaration
&lt; 			marker = ir.createMarker(IAJModelMarker.ITD_MARKER);
&lt; 		}
&lt; 		marker.setAttribute(IMarker.LINE_NUMBER, linenumberInt.intValue());
&lt; 		if (nodeRuntimeTest) {
&lt; 			label = label
&lt; 					+ " "
&lt; 					+ AspectJUIPlugin
&lt; 							.getResourceString("AspectJEditor.runtimetest");
&lt; 		}
&lt; 		marker.setAttribute(IMarker.MESSAGE, label);
&lt; 		return marker;
&lt; 	}
980a577,583
&gt; 	
&gt; 	/**
&gt; 	 * @return Returns the activeEditorList.
&gt; 	 */
&gt; 	public static Set getActiveEditorList() {
&gt; 		return activeEditorList;
&gt; 	}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/build30.ajproperties" revision="1.2" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/plugin.xml" revision="1.7" state="changed">502c502
&lt;                label=""
---
&gt;                label="%AJEditorActionsLabel"
512c512,521
&lt;                label="andyslabel"
---
&gt;                label="%AJEditorActionsLabel"
&gt;                class="org.eclipse.ajdt.internal.ui.editor.AdviceActionDelegate"
&gt;                id="org.eclipse.ajdt.ui.actions.AdviceActionDelegate"&gt;
&gt;          &lt;/action&gt;
&gt;       &lt;/editorContribution&gt;
&gt;       &lt;editorContribution
&gt;             targetID="org.eclipse.jdt.ui.CompilationUnitEditor"
&gt;             id="org.eclipse.ajdt.ui.AJEditor.AdviceRulerActions"&gt;
&gt;          &lt;action
&gt;                label="%AJEditorActionsLabel"
521c530
&lt;                label="%Dummy.label"
---
&gt;                label="%AJEditorActionsLabel"
540c549
&lt;             value="false"&gt;
---
&gt;             value="true"&gt;
554a564,566
&gt;       &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
562a575,577
&gt;       &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
570a586,588
&gt;      &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
656a675,677
&gt;       &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
664a686,688
&gt;       &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
672a697,699
&gt;       &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
680a708,710
&gt;       &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
693c723
&lt;             value="false"&gt;
---
&gt;             value="true"&gt;
705a736,738
&gt;       &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/builder/MarkerUpdating.aj" revision="1.1" state="new">/*******************************************************************************&#13;
 * Copyright (c) 2004 IBM Corporation and others. All rights reserved. This&#13;
 * program and the accompanying materials are made available under the terms of&#13;
 * the Common Public License v1.0 which accompanies this distribution, and is&#13;
 * available at http://www.eclipse.org/legal/cpl-v10.html&#13;
 * &#13;
 * Contributors: Sian January - initial version&#13;
 * ... &#13;
 ******************************************************************************/&#13;
package org.eclipse.ajdt.internal.builder;&#13;
&#13;
import java.util.Iterator;&#13;
import java.util.Map;&#13;
import java.util.Set;&#13;
import java.util.Vector;&#13;
&#13;
import org.aspectj.asm.IProgramElement;&#13;
import org.aspectj.bridge.ISourceLocation;&#13;
import org.eclipse.ajdt.ui.AspectJUIPlugin;&#13;
import org.eclipse.ajdt.ui.IAJModelMarker;&#13;
import org.eclipse.ajdt.ui.visualiser.NodeHolder;&#13;
import org.eclipse.ajdt.ui.visualiser.StructureModelUtil;&#13;
import org.eclipse.core.resources.IFile;&#13;
import org.eclipse.core.resources.IFolder;&#13;
import org.eclipse.core.resources.IMarker;&#13;
import org.eclipse.core.resources.IProject;&#13;
import org.eclipse.core.resources.IResource;&#13;
import org.eclipse.core.resources.IResourceVisitor;&#13;
import org.eclipse.core.resources.IWorkspaceRunnable;&#13;
import org.eclipse.core.runtime.CoreException;&#13;
import org.eclipse.core.runtime.IProgressMonitor;&#13;
&#13;
&#13;
/**&#13;
 * Aspect responsible for advice and declaration markers.  &#13;
 * Updates the markers for a given project when it is built.&#13;
 */&#13;
public aspect MarkerUpdating {&#13;
&#13;
	private pointcut buildPerformed(Builder builder): &#13;
		execution(* Builder.build(..)) &amp;&amp; target(builder);&#13;
	&#13;
	before(Builder builder): buildPerformed(builder) {&#13;
		IProject project = builder.getProject();&#13;
		deleteAllMarkers(project);		&#13;
	}&#13;
	&#13;
	after(Builder builder) returning: buildPerformed(builder) {&#13;
		IProject project = builder.getProject();&#13;
		addNewMarkers(project);&#13;
	}&#13;
&#13;
	/**&#13;
	 * Delete the advice markers for a project&#13;
	 */&#13;
	private void deleteAllMarkers(final IProject project) {	&#13;
		try {&#13;
			AspectJUIPlugin.getWorkspace().run(new IWorkspaceRunnable() {&#13;
				public void run(IProgressMonitor monitor) {&#13;
					// Delete all the existing markers&#13;
					try {&#13;
						project.deleteMarkers(IAJModelMarker.ADVICE_MARKER,&#13;
								true, IResource.DEPTH_INFINITE);&#13;
						project.deleteMarkers(&#13;
								IAJModelMarker.DECLARATION_MARKER, true,&#13;
								IResource.DEPTH_INFINITE);&#13;
					} catch (CoreException cEx) {}					&#13;
				}&#13;
			}, null);&#13;
		} catch (CoreException coreEx) {}&#13;
	}	&#13;
	&#13;
	/**&#13;
	 * Add new advice markers to a project&#13;
	 */&#13;
	private void addNewMarkers(final IProject project) {	&#13;
		try {&#13;
			AspectJUIPlugin.getWorkspace().run(new IWorkspaceRunnable() {&#13;
				public void run(IProgressMonitor monitor) {&#13;
					try {&#13;
						project.accept(new IResourceVisitor(){&#13;
							public boolean visit(IResource resource) {&#13;
								if(resource instanceof IFolder) {&#13;
									return true;&#13;
								} else if (resource instanceof IFile) {&#13;
									addMarkersToFile((IFile)resource);&#13;
									return false;&#13;
								} else {&#13;
									return true;&#13;
								}&#13;
							}&#13;
						});&#13;
					} catch (CoreException coreEx) {}&#13;
				}&#13;
			}, null);&#13;
		} catch (CoreException coreEx) {}&#13;
	}&#13;
&#13;
	&#13;
	/**&#13;
	 * Add markers to a file&#13;
	 */&#13;
	private void addMarkersToFile(final IFile file) {	&#13;
&#13;
		IProject project = file.getProject();&#13;
&#13;
		// Don't add markers to resources in non AspectJ projects !&#13;
		try {&#13;
			if (project == null || !project.isOpen()&#13;
					|| !project.hasNature(AspectJUIPlugin.ID_NATURE))&#13;
				return;&#13;
		} catch (CoreException e) {&#13;
		}&#13;
&#13;
		String path = file.getRawLocation().toOSString(); // Copes&#13;
																	  // with&#13;
																	  // linked&#13;
																	  // src&#13;
																	  // folders.&#13;
		// retrieve a map of line numbers to Vectors containing StructureNode&#13;
		// objects&#13;
		// Ask for the detailed version of the map (by specifying 'true') which&#13;
		// maps&#13;
		// line numbers to nodes representing advice (rather than just nodes&#13;
		// representing&#13;
		// aspects).&#13;
		Map m = StructureModelUtil.getLinesToAspectMap(path, true);&#13;
&#13;
		if (m != null) {&#13;
			// iterate through the line numbers in the map&#13;
			Set keys = m.keySet();&#13;
			Iterator i = keys.iterator();&#13;
			while (i.hasNext()) {&#13;
				Object o = i.next();&#13;
				final Integer linenumberInt = (Integer) o;&#13;
&#13;
				// for that line, go through all the advice in effect&#13;
				final Vector v = (Vector) m.get(o);&#13;
				try {&#13;
					boolean sameType = true;&#13;
					boolean runtimeTst = false;&#13;
&#13;
					NodeHolder nh = (NodeHolder) v.get(0);&#13;
					if (v.size() &gt; 1) {&#13;
						NodeHolder first = (NodeHolder) v.get(0);&#13;
						String adviceType = first.node.getExtraInfo() == null ? null&#13;
								: first.node.getExtraInfo()&#13;
										.getExtraAdviceInformation();&#13;
						for (Iterator iter = v.iterator(); iter&#13;
								.hasNext();) {&#13;
							NodeHolder element = (NodeHolder) iter&#13;
									.next();&#13;
							runtimeTst = runtimeTst&#13;
									|| element.runtimeTest;&#13;
							if (adviceType != null) {&#13;
								if (element.node.getExtraInfo() == null) {&#13;
									sameType = false;&#13;
								} else {&#13;
									sameType = sameType&#13;
											&amp;&amp; adviceType&#13;
													.equals(element.node&#13;
															.getExtraInfo()&#13;
															.getExtraAdviceInformation());&#13;
								}&#13;
							} else {&#13;
								sameType = sameType&#13;
										&amp;&amp; element.node.getExtraInfo() == null;&#13;
							}&#13;
						}&#13;
					} else if (v.size() == 1) {&#13;
						runtimeTst = ((NodeHolder) v.get(0)).runtimeTest;&#13;
					}&#13;
					final boolean runtimeTest = runtimeTst;&#13;
					final boolean useDefaultAdviceMarker = !sameType;&#13;
					for (int j = 0; j &lt; v.size(); j++) {&#13;
						// sn will represent the advice in affect at the&#13;
						// given line.&#13;
						final NodeHolder noddyHolder = (NodeHolder) v&#13;
								.get(j);&#13;
						final IProgramElement sn = noddyHolder.node;&#13;
						// Thread required to ensure marker created and&#13;
						// set atomically&#13;
						// (and so reflected correctly in the ruler).&#13;
&#13;
						ISourceLocation sl_sn = sn.getSourceLocation();&#13;
						String label = sn.toLinkLabelString();&#13;
						String adviceType = sn.getName();&#13;
						IMarker marker = createMarker(linenumberInt,&#13;
								runtimeTest, file, sn,&#13;
								useDefaultAdviceMarker,&#13;
								noddyHolder.runtimeTest);&#13;
&#13;
						// Crude format is "FFFF:::NNNN:::NNNN:::NNNN"&#13;
						// Filename:::StartLine:::EndLine:::ColumnNumber&#13;
&#13;
						// Grab the location of the pointcut&#13;
						ISourceLocation sLoc2 = sn.getSourceLocation();&#13;
						// was asn&#13;
						marker.setAttribute(IMarker.PRIORITY,&#13;
								IMarker.PRIORITY_HIGH);&#13;
						marker&#13;
								.setAttribute(&#13;
										AspectJUIPlugin.SOURCE_LOCATION_ATTRIBUTE,&#13;
										sLoc2.getSourceFile()&#13;
												.getAbsolutePath()&#13;
												+ ":::"&#13;
												+ sLoc2.getLine()&#13;
												+ ":::"&#13;
												+ sLoc2.getEndLine()&#13;
												+ ":::"&#13;
												+ sLoc2.getColumn());&#13;
&#13;
					}&#13;
				} catch (CoreException ce) {&#13;
					AspectJUIPlugin.getDefault().getErrorHandler()&#13;
							.handleError(&#13;
									"Exception creating advice marker",&#13;
									ce);&#13;
				}		&#13;
			}&#13;
		}&#13;
	}&#13;
&#13;
	/**&#13;
	 * @param linenumberInt&#13;
	 * @param runtimeTest&#13;
	 * @param ir&#13;
	 * @param programElement&#13;
	 * @param useDefaultAdviceMarker&#13;
	 * @return the IMarker created&#13;
	 * @throws CoreException&#13;
	 */&#13;
	private IMarker createMarker(final Integer linenumberInt,&#13;
			final boolean runtimeTest, final IResource ir,&#13;
			IProgramElement programElement, boolean useDefaultAdviceMarker,&#13;
			boolean nodeRuntimeTest) throws CoreException {&#13;
&#13;
		String label = programElement.toLinkLabelString();&#13;
		String adviceType = "";&#13;
		if (programElement.getExtraInfo() != null) {&#13;
			adviceType = programElement.getExtraInfo()&#13;
					.getExtraAdviceInformation();&#13;
		}&#13;
		IMarker marker;&#13;
		if (useDefaultAdviceMarker) {&#13;
			if (runtimeTest) {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.DYNAMIC_ADVICE_MARKER);&#13;
			} else {&#13;
				if (adviceType == "") {&#13;
					marker = ir.createMarker(IAJModelMarker.DECLARATION_MARKER);&#13;
				} else {&#13;
					marker = ir.createMarker(IAJModelMarker.ADVICE_MARKER);&#13;
				}&#13;
			}&#13;
		} else if (adviceType.equals("before")) {&#13;
			if (runtimeTest) {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.DYNAMIC_BEFORE_ADVICE_MARKER);&#13;
			} else {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.BEFORE_ADVICE_MARKER);&#13;
			}&#13;
		} else if (adviceType.equals("around")) {&#13;
			if (runtimeTest) {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.DYNAMIC_AROUND_ADVICE_MARKER);&#13;
			} else {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.AROUND_ADVICE_MARKER);&#13;
			}&#13;
		} else if (adviceType.startsWith("after")) {&#13;
			if (runtimeTest) {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.DYNAMIC_AFTER_ADVICE_MARKER);&#13;
			} else {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.AFTER_ADVICE_MARKER);&#13;
			}&#13;
		} else {&#13;
			// It's an Intertype Declaration&#13;
			marker = ir.createMarker(IAJModelMarker.ITD_MARKER);&#13;
		}&#13;
		marker.setAttribute(IMarker.LINE_NUMBER, linenumberInt.intValue());&#13;
		if (nodeRuntimeTest) {&#13;
			label = label&#13;
					+ " "&#13;
					+ AspectJUIPlugin&#13;
							.getResourceString("AspectJEditor.runtimetest");&#13;
		}&#13;
		marker.setAttribute(IMarker.MESSAGE, label);&#13;
		return marker;&#13;
	}&#13;
	&#13;
}&#13;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/PerEditorMarkerUpdating.aj" revision="1.1" state="new">/*******************************************************************************&#13;
 * Copyright (c) 2004 IBM Corporation and others. All rights reserved. This&#13;
 * program and the accompanying materials are made available under the terms of&#13;
 * the Common Public License v1.0 which accompanies this distribution, and is&#13;
 * available at http://www.eclipse.org/legal/cpl-v10.html&#13;
 * &#13;
 * Contributors: Sian January - initial version&#13;
 * ... &#13;
 ******************************************************************************/&#13;
package org.eclipse.ajdt.internal.ui.editor;&#13;
&#13;
import java.util.Iterator;&#13;
import java.util.Map;&#13;
import java.util.Set;&#13;
import java.util.Vector;&#13;
&#13;
import org.aspectj.asm.IProgramElement;&#13;
import org.aspectj.bridge.ISourceLocation;&#13;
import org.eclipse.ajdt.ui.AspectJUIPlugin;&#13;
import org.eclipse.ajdt.ui.IAJModelMarker;&#13;
import org.eclipse.ajdt.ui.visualiser.NodeHolder;&#13;
import org.eclipse.ajdt.ui.visualiser.StructureModelUtil;&#13;
import org.eclipse.ajdt.internal.builder.Builder;&#13;
import org.eclipse.ajdt.internal.core.AJDTEventTrace;&#13;
import org.eclipse.core.resources.IMarker;&#13;
import org.eclipse.core.resources.IProject;&#13;
import org.eclipse.core.resources.IResource;&#13;
import org.eclipse.core.resources.IWorkspaceRunnable;&#13;
import org.eclipse.core.runtime.CoreException;&#13;
import org.eclipse.core.runtime.IProgressMonitor;&#13;
import org.eclipse.ui.IEditorInput;&#13;
import org.eclipse.ui.IFileEditorInput;&#13;
&#13;
/**&#13;
 * Aspect responsible for advice and itd markers &#13;
 */&#13;
public aspect PerEditorMarkerUpdating {&#13;
&#13;
	private IFileEditorInput currentFileInput;&#13;
	&#13;
	private pointcut editorGivenNewInput():&#13;
		execution (* AspectJEditor.doSetInput(..));&#13;
&#13;
	private pointcut editorGivenFocus(): &#13;
		execution(* AspectJEditor.setFocus());&#13;
	&#13;
	private pointcut buildPerformed(): execution(* Builder.build(..));&#13;
	&#13;
	private pointcut editorClosed(): execution(* AspectJEditor.dispose());&#13;
		&#13;
	&#13;
	after(AspectJEditor editor) returning: (editorGivenFocus() || editorGivenNewInput()) &amp;&amp; target(editor) {&#13;
		if(!(editor.getEditorInput().equals(currentFileInput))) {&#13;
			currentFileInput = (IFileEditorInput)editor.getEditorInput();&#13;
			updateAdviceMarkers(currentFileInput);&#13;
		}&#13;
	}&#13;
	&#13;
	after() returning: buildPerformed(){&#13;
		forceMarkerUpdates(AspectJUIPlugin.getDefault().getCurrentProject());&#13;
	}&#13;
	&#13;
	before(AspectJEditor editor): (editorClosed() || editorGivenNewInput()) &amp;&amp; target(editor) {&#13;
		if (editor.getEditorInput() != null) {&#13;
			removeAJDTMarkers((IFileEditorInput)editor.getEditorInput());&#13;
		}&#13;
	}&#13;
&#13;
	&#13;
	/**&#13;
	 * Sian - added as part of the fix for bug 70658&#13;
	 * Force marker updates for any editors open on files in the project,&#13;
	 * or on all editors if project is null.&#13;
	 * @param project&#13;
	 */&#13;
	private void forceMarkerUpdates(final IProject project) {&#13;
		Set activeEditorList = AspectJEditor.getActiveEditorList();&#13;
		final Iterator editorIter = activeEditorList.iterator();&#13;
		AspectJUIPlugin.getDefault().getDisplay().asyncExec(new Runnable() {&#13;
			public void run() {&#13;
				try {&#13;
					while (editorIter.hasNext()) {&#13;
						AspectJEditor ajed = (AspectJEditor) editorIter.next();&#13;
						IEditorInput iei = ajed.getEditorInput();&#13;
						boolean updateThisEditor = true;&#13;
						if (project != null&#13;
								&amp;&amp; (iei instanceof IFileEditorInput)) {&#13;
							IFileEditorInput ifei = (IFileEditorInput) iei;&#13;
							if (!(ifei.getFile().getProject().getName()&#13;
									.equals(project.getName())))&#13;
								updateThisEditor = false;&#13;
						}&#13;
						if (updateThisEditor) {&#13;
							updateAdviceMarkers((IFileEditorInput)ajed.getEditorInput());							&#13;
						}&#13;
					}&#13;
				} catch (Exception e) {&#13;
				}&#13;
			}&#13;
		});&#13;
	}&#13;
	&#13;
	&#13;
	/**&#13;
	 * Adds the advice markers for a file to the left hand gutter. It kicks off&#13;
	 * a thread that does a delete then adds all the new markers.&#13;
	 */&#13;
	private void updateAdviceMarkers(final IFileEditorInput fInput) {&#13;
		if (fInput == null) {&#13;
			AJDTEventTrace&#13;
					.generalEvent("AspectJEditor: FileEditorInput is null for editor with title ("&#13;
							+ fInput.getName() + "): Cannot update markers on it");&#13;
			return;&#13;
		}&#13;
&#13;
		if (fInput.getFile() == null) {&#13;
			AJDTEventTrace&#13;
					.generalEvent("AspectJEditor: fileeditorinput.getFile() is null: see bugzilla #43662");&#13;
			return;&#13;
		}&#13;
&#13;
		removeAJDTMarkers(fInput);&#13;
		AspectJUIPlugin.getDefault().getDisplay().asyncExec(new Runnable() {&#13;
			public void run() {&#13;
				addNewMarkers(fInput);&#13;
			}&#13;
		});&#13;
	}&#13;
&#13;
	/**&#13;
	 * Adds advice markers to mark each line in the source that is affected by&#13;
	 * advice from an aspect. It uses the StructureModelUtil code that the&#13;
	 * visualizer also uses - to determine what aspects are in effect on a&#13;
	 * specific source file.&#13;
	 * &#13;
	 * @param fInput&#13;
	 *            The file editor input resource against which the markers will&#13;
	 *            be added.&#13;
	 */&#13;
	private void addNewMarkers(final IFileEditorInput fInput) {&#13;
		IProject project = fInput.getFile().getProject();&#13;
&#13;
		// Don't add markers to resources in non AspectJ projects !&#13;
		try {&#13;
			if (project == null || !project.isOpen()&#13;
					|| !project.hasNature(AspectJUIPlugin.ID_NATURE))&#13;
				return;&#13;
		} catch (CoreException e) {&#13;
		}&#13;
&#13;
		String path = fInput.getFile().getRawLocation().toOSString(); // Copes&#13;
																	  // with&#13;
																	  // linked&#13;
																	  // src&#13;
																	  // folders.&#13;
		// retrieve a map of line numbers to Vectors containing StructureNode&#13;
		// objects&#13;
		// Ask for the detailed version of the map (by specifying 'true') which&#13;
		// maps&#13;
		// line numbers to nodes representing advice (rather than just nodes&#13;
		// representing&#13;
		// aspects).&#13;
		Map m = StructureModelUtil.getLinesToAspectMap(path, true);&#13;
&#13;
		if (m != null) {&#13;
			// iterate through the line numbers in the map&#13;
			Set keys = m.keySet();&#13;
			Iterator i = keys.iterator();&#13;
			while (i.hasNext()) {&#13;
				Object o = i.next();&#13;
				final Integer linenumberInt = (Integer) o;&#13;
&#13;
				// for that line, go through all the advice in effect&#13;
				final Vector v = (Vector) m.get(o);&#13;
				// One runnable per line advised adds the appropriate marker&#13;
				IWorkspaceRunnable r = new IWorkspaceRunnable() {&#13;
					public void run(IProgressMonitor monitor) {&#13;
						try {&#13;
							boolean sameType = true;&#13;
							boolean runtimeTst = false;&#13;
&#13;
							// Apples or Oranges?&#13;
							NodeHolder nh = (NodeHolder) v.get(0);&#13;
							//							if&#13;
							// (nh.node.getKind()!=IProgramElement.Kind.ADVICE)&#13;
							// {&#13;
							//								// probably an intertype decl - SIAN....&#13;
							//								System.err.println("&gt;ITD:"+nh.node.toString());&#13;
							//								&#13;
							//							} else {&#13;
							// advice nodes&#13;
							if (v.size() &gt; 1) {&#13;
								NodeHolder first = (NodeHolder) v.get(0);&#13;
								String adviceType = first.node.getExtraInfo() == null ? null&#13;
										: first.node.getExtraInfo()&#13;
												.getExtraAdviceInformation();&#13;
								for (Iterator iter = v.iterator(); iter&#13;
										.hasNext();) {&#13;
									NodeHolder element = (NodeHolder) iter&#13;
											.next();&#13;
									runtimeTst = runtimeTst&#13;
											|| element.runtimeTest;&#13;
									if (adviceType != null) {&#13;
										if (element.node.getExtraInfo() == null) {&#13;
											sameType = false;&#13;
										} else {&#13;
											sameType = sameType&#13;
													&amp;&amp; adviceType&#13;
															.equals(element.node&#13;
																	.getExtraInfo()&#13;
																	.getExtraAdviceInformation());&#13;
										}&#13;
									} else {&#13;
										sameType = sameType&#13;
												&amp;&amp; element.node.getExtraInfo() == null;&#13;
									}&#13;
								}&#13;
							} else if (v.size() == 1) {&#13;
								runtimeTst = ((NodeHolder) v.get(0)).runtimeTest;&#13;
							}&#13;
							final boolean runtimeTest = runtimeTst;&#13;
							final boolean useDefaultAdviceMarker = !sameType;&#13;
							for (int j = 0; j &lt; v.size(); j++) {&#13;
								// sn will represent the advice in affect at the&#13;
								// given line.&#13;
								final NodeHolder noddyHolder = (NodeHolder) v&#13;
										.get(j);&#13;
								final IProgramElement sn = noddyHolder.node;&#13;
								final IResource ir = (IResource) fInput&#13;
										.getFile();&#13;
								// Thread required to ensure marker created and&#13;
								// set atomically&#13;
								// (and so reflected correctly in the ruler).&#13;
&#13;
								ISourceLocation sl_sn = sn.getSourceLocation();&#13;
								String label = sn.toLinkLabelString();&#13;
								// SIAN: RUNTIMETEST local var gives you whether&#13;
								// to put the ? on&#13;
								// SIAN:&#13;
								// sn.getAdviceInfo().getExtraAdviceInformation()&#13;
								// will&#13;
								//       tell you if its&#13;
								// before/after/afterreturning/afterthrowing/around&#13;
								// advice&#13;
&#13;
								String adviceType = sn.getName();&#13;
								IMarker marker = createMarker(linenumberInt,&#13;
										runtimeTest, ir, sn,&#13;
										useDefaultAdviceMarker,&#13;
										noddyHolder.runtimeTest);&#13;
&#13;
								// Crude format is "FFFF:::NNNN:::NNNN:::NNNN"&#13;
								// Filename:::StartLine:::EndLine:::ColumnNumber&#13;
&#13;
								// Grab the location of the pointcut&#13;
								ISourceLocation sLoc2 = sn.getSourceLocation();&#13;
								// was asn&#13;
								marker.setAttribute(IMarker.PRIORITY,&#13;
										IMarker.PRIORITY_HIGH);&#13;
								marker&#13;
										.setAttribute(&#13;
												AspectJUIPlugin.SOURCE_LOCATION_ATTRIBUTE,&#13;
												sLoc2.getSourceFile()&#13;
														.getAbsolutePath()&#13;
														+ ":::"&#13;
														+ sLoc2.getLine()&#13;
														+ ":::"&#13;
														+ sLoc2.getEndLine()&#13;
														+ ":::"&#13;
														+ sLoc2.getColumn());&#13;
&#13;
								//									System.err.println(&#13;
								//									"Creating advicemarker at line="+&#13;
								// linenumberInt.intValue() +&#13;
								//									" advice="+ sn.getName() +&#13;
								//									" sourcefilepath=" + sLoc2.getSourceFile() +&#13;
								//								    " line="+ sLoc2.getLine());&#13;
&#13;
							}&#13;
							//							}&#13;
						} catch (CoreException ce) {&#13;
							AspectJUIPlugin.getDefault().getErrorHandler()&#13;
									.handleError(&#13;
											"Exception creating advice marker",&#13;
											ce);&#13;
						}&#13;
					}&#13;
				};&#13;
&#13;
				// Kick off the thread to add the marker...&#13;
				try {&#13;
					AspectJUIPlugin.getWorkspace().run(r, null);&#13;
				} catch (CoreException cEx) {&#13;
					AspectJUIPlugin.getDefault().getErrorHandler().handleError(&#13;
							"AJDT Error adding advice markers", cEx);&#13;
				}&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	/**&#13;
	 * Remove all the AJDT markers from the given file input.&#13;
	 * &#13;
	 * @param fInput&#13;
	 */&#13;
	private void removeAJDTMarkers(final IFileEditorInput fInput) {&#13;
		AspectJUIPlugin.getDefault().getDisplay().asyncExec(new Runnable() {&#13;
			public void run() {&#13;
				try {&#13;
					// Wipe all the current advice markers&#13;
					fInput.getFile().deleteMarkers(IAJModelMarker.ADVICE_MARKER,&#13;
							true, IResource.DEPTH_INFINITE);&#13;
					fInput.getFile().deleteMarkers(&#13;
							IAJModelMarker.DECLARATION_MARKER, true,&#13;
							IResource.DEPTH_INFINITE);&#13;
				} catch (CoreException ce) {&#13;
					//if file has been deleted, don't throw exception&#13;
					if (fInput.getFile().exists())&#13;
						AspectJUIPlugin.getDefault().getErrorHandler()&#13;
								.handleError("Advice marker delete failed", ce);&#13;
				}&#13;
			}&#13;
		});&#13;
	}&#13;
&#13;
	/**&#13;
	 * @param linenumberInt&#13;
	 * @param runtimeTest&#13;
	 * @param ir&#13;
	 * @param programElement&#13;
	 * @param useDefaultAdviceMarker&#13;
	 * @return the IMarker created&#13;
	 * @throws CoreException&#13;
	 */&#13;
	private IMarker createMarker(final Integer linenumberInt,&#13;
			final boolean runtimeTest, final IResource ir,&#13;
			IProgramElement programElement, boolean useDefaultAdviceMarker,&#13;
			boolean nodeRuntimeTest) throws CoreException {&#13;
		String label = programElement.toLinkLabelString();&#13;
		String adviceType = "";&#13;
		if (programElement.getExtraInfo() != null) {&#13;
			adviceType = programElement.getExtraInfo()&#13;
					.getExtraAdviceInformation();&#13;
		}&#13;
		IMarker marker;&#13;
		if (useDefaultAdviceMarker) {&#13;
			if (runtimeTest) {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.DYNAMIC_ADVICE_MARKER);&#13;
			} else {&#13;
				if (adviceType == "") {&#13;
					marker = ir.createMarker(IAJModelMarker.DECLARATION_MARKER);&#13;
				} else {&#13;
					marker = ir.createMarker(IAJModelMarker.ADVICE_MARKER);&#13;
				}&#13;
			}&#13;
		} else if (adviceType.equals("before")) {&#13;
			if (runtimeTest) {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.DYNAMIC_BEFORE_ADVICE_MARKER);&#13;
			} else {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.BEFORE_ADVICE_MARKER);&#13;
			}&#13;
		} else if (adviceType.equals("around")) {&#13;
			if (runtimeTest) {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.DYNAMIC_AROUND_ADVICE_MARKER);&#13;
			} else {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.AROUND_ADVICE_MARKER);&#13;
			}&#13;
		} else if (adviceType.startsWith("after")) {&#13;
			if (runtimeTest) {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.DYNAMIC_AFTER_ADVICE_MARKER);&#13;
			} else {&#13;
				marker = ir&#13;
						.createMarker(IAJModelMarker.AFTER_ADVICE_MARKER);&#13;
			}&#13;
		} else {&#13;
			// It's an Intertype Declaration&#13;
			marker = ir.createMarker(IAJModelMarker.ITD_MARKER);&#13;
		}&#13;
		marker.setAttribute(IMarker.LINE_NUMBER, linenumberInt.intValue());&#13;
		if (nodeRuntimeTest) {&#13;
			label = label&#13;
					+ " "&#13;
					+ AspectJUIPlugin&#13;
							.getResourceString("AspectJEditor.runtimetest");&#13;
		}&#13;
		marker.setAttribute(IMarker.MESSAGE, label);&#13;
		return marker;&#13;
	}&#13;
&#13;
	&#13;
}&#13;
</file>
</fixedFiles>
</bug>
<bug id="78578" transactionid="73895">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P4"/>
<property name="severity" value="minor"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-import K-true M</fullfingerprint>
<bugreport>I am running Eclipse 3.0.1 with AJDT 1.2.0 on XP.  When I add the AspectJ Nature
to a project, it brings up the AJDT Preferences Configuration Wizard.  I
unselect "Make the AspectJ editor default for ".java"" and click Finish.  When I
close Eclipse and restart, and save a file in the same project, the AJDT
Preferences Configuration Wizard will appear again.</bugreport>
<pre-fix-testcases failing="114" file="output/78578/pre-fix/testresults.xml" passing="1292" size="1406"/>
<post-fix-testcases failing="113" file="output/78578/post-fix/testresults.xml" passing="1293" size="1406"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/AJDTPrefConfigPage.java" revision="1.3" state="changed">19a20
&gt; import org.eclipse.ajdt.internal.ui.preferences.AspectJPreferences;
145c146
&lt; //			AspectJPreferences.setAJDTPrefConfigDone(true);
---
&gt; 			AspectJPreferences.setAJDTPrefConfigDone(true);
</file>
</fixedFiles>
</bug>
<bug id="78962" transactionid="74010">
<property name="files-churned" value="11"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="25"/>
<property name="lines-added" value="29"/>
<property name="lines-deleted" value="9"/>
<property name="lines-modified" value="93"/>
<property name="lines-churned" value="131"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-for K-if K-new K-null K-true M O-&lt; O-== O-|| O-! O-!= O-() O-&amp;&amp; O-+ O-++ O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>Currently the target of advice is indicated in the editor with markers and
"advised by" etc entries in the context menu. The same "advised by" entries
appear in the outline view. The opposite end of the relationship, the source of
the advice, is indicated in the outline view with "advises" etc entries. But
there are no markers in the editor for this. This enhancement is therefore to
consider adding these markers. The icons used could be flipped versions of the
current ones to indicate the advice coming from the appropriate line. This would
make our exposure of the crosscutting more consistent, and would also provide a
means of navigation from the editor - particularly useful for the significant
number of eclipse users who don't have the outline view permanently onscreen.</bugreport>
<pre-fix-testcases failing="114" file="output/78962/pre-fix/testresults.xml" passing="1292" size="1406"/>
<post-fix-testcases failing="69" file="output/78962/post-fix/testresults.xml" passing="781" size="850"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/ui/IAJModelMarker.java" revision="1.2" state="changed">29c29,32
&lt; 
---
&gt; 	public static final String SOURCE_ADVICE_MARKER = "org.eclipse.ajdt.ui.sourceadvicemarker";
&gt; 	public static final String SOURCE_BEFORE_ADVICE_MARKER = "org.eclipse.ajdt.ui.sourcebeforeadvicemarker";
&gt; 	public static final String SOURCE_AFTER_ADVICE_MARKER = "org.eclipse.ajdt.ui.sourceafteradvicemarker";
&gt; 	public static final String SOURCE_AROUND_ADVICE_MARKER = "org.eclipse.ajdt.ui.sourcearoundadvicemarker";
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/ui/visualiser/NodeHolder.java" revision="1.2" state="changed">0a1,10
&gt; /*******************************************************************************
&gt;  * Copyright (c) 2000, 2004 IBM Corporation and others.
&gt;  * All rights reserved. This program and the accompanying materials 
&gt;  * are made available under the terms of the Common Public License v1.0
&gt;  * which accompanies this distribution, and is available at
&gt;  * http://www.eclipse.org/legal/cpl-v10.html
&gt;  * 
&gt;  * Contributors:
&gt;  *     IBM Corporation - initial API and implementation
&gt;  *******************************************************************************/
11c21,23
&lt; 	public NodeHolder(IProgramElement ipe, boolean b) {
---
&gt; 	public String adviceType;
&gt; 	
&gt; 	public NodeHolder(IProgramElement ipe, boolean b, String type) {
13a26,29
&gt; 		if (type == null) {
&gt; 			type = "";
&gt; 		}
&gt; 		adviceType = type;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/ui/visualiser/StructureModelUtil.java" revision="1.6" state="changed">1,24c1,10
&lt; 
&lt; /* -*- Mode: Java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
&lt;  *
&lt;  * This file is part of the IDE support for the AspectJ(tm)
&lt;  * programming language; see http://aspectj.org
&lt;  *
&lt;  * The contents of this file are subject to the Mozilla Public License
&lt;  * Version 1.1 (the "License"); you may not use this file except in
&lt;  * compliance with the License. You may obtain a copy of the License at
&lt;  * either http://www.mozilla.org/MPL/ or http://aspectj.org/MPL/.
&lt;  *
&lt;  * Software distributed under the License is distributed on an "AS IS" basis,
&lt;  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
&lt;  * for the specific language governing rights and limitations under the
&lt;  * License.
&lt;  *
&lt;  * The Original Code is AspectJ.
&lt;  *
&lt;  * The Initial Developer of the Original Code is Xerox Corporation. Portions
&lt;  * created by Xerox Corporation are Copyright (C) 1999-2002 Xerox Corporation.
&lt;  * All Rights Reserved.
&lt;  *
&lt;  * Contributor(s):
&lt;  */
---
&gt; /*******************************************************************************
&gt;  * Copyright (c) 2000, 2004 IBM Corporation and others.
&gt;  * All rights reserved. This program and the accompanying materials 
&gt;  * are made available under the terms of the Common Public License v1.0
&gt;  * which accompanies this distribution, and is available at
&gt;  * http://www.eclipse.org/legal/cpl-v10.html
&gt;  * 
&gt;  * Contributors:
&gt;  *     IBM Corporation - initial API and implementation
&gt;  *******************************************************************************/
249c235
&lt; 					List toStoreNoRuntimeTest = processTargets(advises,needIndividualNodes);
---
&gt; 					List toStoreNoRuntimeTest = processTargets(advises,needIndividualNodes,node);
254c240
&lt; 					List toStoreWithRuntimeTest = processTargets(advises,needIndividualNodes);
---
&gt; 					List toStoreWithRuntimeTest = processTargets(advises,needIndividualNodes,node);
256a243,255
&gt; 					// reverse relationships, only required for editor
&gt; 					if (needIndividualNodes) {
&gt; 						// Advice with no runtime test
&gt; 						IRelationship advisesR = irm.get(node,IRelationship.Kind.ADVICE,"advises",false,false); 
&gt; 						List toStoreNoRuntimeTestR = processTargets(advisesR,needIndividualNodes,node);
&gt; 						toStore.addAll(toStoreNoRuntimeTestR);
&gt; 					
&gt; 						// Advice with a runtime test
&gt; 						advisesR = irm.get(node,IRelationship.Kind.ADVICE,	"advises",true,false); 
&gt; 						List toStoreWithRuntimeTestR = processTargets(advisesR,needIndividualNodes,node);
&gt; 						toStore.addAll(toStoreWithRuntimeTestR);
&gt; 					}
&gt; 					
275c274
&lt; 				   	    List toStoreIntertypeDecls = processTargets(intertypeDecls,needIndividualNodes);
---
&gt; 				   	    List toStoreIntertypeDecls = processTargets(intertypeDecls,needIndividualNodes,node);
296c295,296
&lt; 	private static List processTargets(IRelationship advises,boolean needIndividualNodes) {
---
&gt; 	private static List processTargets(IRelationship advises,boolean needIndividualNodes,
&gt; 			IProgramElement sourceNode) {
306,307c306,320
&lt; 					if (pNode != null) {						
&lt; 						if (pNode.getKind() == IProgramElement.Kind.ADVICE ||
---
&gt; 					if (pNode != null) {
&gt; 						if (needIndividualNodes &amp;&amp;
&gt; 								((pNode.getKind() == IProgramElement.Kind.METHOD)
&gt; 										|| (pNode.getKind() == IProgramElement.Kind.CODE))) {
&gt; 							// source of advice rather than target
&gt; 							String adviceType = "advises";
&gt; 							// we need to determine the advice type from the source node
&gt; 							if (sourceNode.getExtraInfo() != null) {
&gt; 								adviceType += sourceNode.getExtraInfo()
&gt; 									.getExtraAdviceInformation();
&gt; 							}
&gt; 							NodeHolder noddyHolder = new NodeHolder(pNode,advises.hasRuntimeTest(),
&gt; 									adviceType);
&gt; 							aspectsAndAdvice.add(noddyHolder);
&gt; 						} else if (pNode.getKind() == IProgramElement.Kind.ADVICE ||
314c327,332
&lt; 								NodeHolder noddyHolder = new NodeHolder(pNode,advises.hasRuntimeTest());
---
&gt; 								String adviceType = "";
&gt; 								if (pNode.getExtraInfo() != null) {
&gt; 									adviceType = pNode.getExtraInfo().getExtraAdviceInformation();
&gt; 								}
&gt; 								NodeHolder noddyHolder = new NodeHolder(pNode,advises.hasRuntimeTest(),
&gt; 										adviceType);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/builder/MarkerUpdating.aj" revision="1.2" state="changed">8c8
&lt;  * ... &#13;
---
&gt;  *               Matt Chapman - add source of advice markers&#13;
63a64,65
&gt; 						project.deleteMarkers(IAJModelMarker.SOURCE_ADVICE_MARKER,&#13;
&gt; 								true, IResource.DEPTH_INFINITE);&#13;
143d144
&lt; 					NodeHolder nh = (NodeHolder) v.get(0);&#13;
181,188c182
&lt; 						// Thread required to ensure marker created and&#13;
&lt; 						// set atomically&#13;
&lt; 						// (and so reflected correctly in the ruler).&#13;
&lt; &#13;
&lt; 						ISourceLocation sl_sn = sn.getSourceLocation();&#13;
&lt; 						String label = sn.toLinkLabelString();&#13;
&lt; 						String adviceType = sn.getName();&#13;
&lt; 						IMarker marker = createMarker(linenumberInt,&#13;
---
&gt; 						createMarker(linenumberInt.intValue(),&#13;
191,212c185,186
&lt; 								noddyHolder.runtimeTest);&#13;
&lt; &#13;
&lt; 						// Crude format is "FFFF:::NNNN:::NNNN:::NNNN"&#13;
&lt; 						// Filename:::StartLine:::EndLine:::ColumnNumber&#13;
&lt; &#13;
&lt; 						// Grab the location of the pointcut&#13;
&lt; 						ISourceLocation sLoc2 = sn.getSourceLocation();&#13;
&lt; 						// was asn&#13;
&lt; 						marker.setAttribute(IMarker.PRIORITY,&#13;
&lt; 								IMarker.PRIORITY_HIGH);&#13;
&lt; 						marker&#13;
&lt; 								.setAttribute(&#13;
&lt; 										AspectJUIPlugin.SOURCE_LOCATION_ATTRIBUTE,&#13;
&lt; 										sLoc2.getSourceFile()&#13;
&lt; 												.getAbsolutePath()&#13;
&lt; 												+ ":::"&#13;
&lt; 												+ sLoc2.getLine()&#13;
&lt; 												+ ":::"&#13;
&lt; 												+ sLoc2.getEndLine()&#13;
&lt; 												+ ":::"&#13;
&lt; 												+ sLoc2.getColumn());&#13;
&lt; &#13;
---
&gt; 								noddyHolder.runtimeTest,&#13;
&gt; 								noddyHolder.adviceType);&#13;
233c207
&lt; 	private IMarker createMarker(final Integer linenumberInt,&#13;
---
&gt; 	private IMarker createMarker(int linenumberInt,&#13;
236c210
&lt; 			boolean nodeRuntimeTest) throws CoreException {&#13;
---
&gt; 			boolean nodeRuntimeTest, String adviceType) throws CoreException {&#13;
239,243d212
&lt; 		String adviceType = "";&#13;
&lt; 		if (programElement.getExtraInfo() != null) {&#13;
&lt; 			adviceType = programElement.getExtraInfo()&#13;
&lt; 					.getExtraAdviceInformation();&#13;
&lt; 		}&#13;
279a249,263
&gt; 		} else if (adviceType.startsWith("advises")) {&#13;
&gt; 			String subType = adviceType.substring("advises".length());&#13;
&gt; 			if (subType.startsWith("before")) {&#13;
&gt; 				marker = ir&#13;
&gt; 					.createMarker(IAJModelMarker.SOURCE_BEFORE_ADVICE_MARKER);&#13;
&gt; 			} else if (subType.startsWith("after")) {&#13;
&gt; 				marker = ir&#13;
&gt; 					.createMarker(IAJModelMarker.SOURCE_AFTER_ADVICE_MARKER);&#13;
&gt; 			} else if (subType.startsWith("around")) {&#13;
&gt; 				marker = ir&#13;
&gt; 				.createMarker(IAJModelMarker.SOURCE_AROUND_ADVICE_MARKER);&#13;
&gt; 			} else {&#13;
&gt; 				marker = ir&#13;
&gt; 					.createMarker(IAJModelMarker.SOURCE_ADVICE_MARKER);&#13;
&gt; 			}&#13;
284c268
&lt; 		marker.setAttribute(IMarker.LINE_NUMBER, linenumberInt.intValue());&#13;
---
&gt; 		marker.setAttribute(IMarker.LINE_NUMBER, linenumberInt);&#13;
291a276,291
&gt; 		marker.setAttribute(IMarker.PRIORITY,&#13;
&gt; 				IMarker.PRIORITY_HIGH);&#13;
&gt; 		ISourceLocation sLoc2 = programElement.getSourceLocation();&#13;
&gt; 		&#13;
&gt; 		// Crude format is "FFFF:::NNNN:::NNNN:::NNNN"&#13;
&gt; 		// Filename:::StartLine:::EndLine:::ColumnNumber&#13;
&gt; 		marker.setAttribute(&#13;
&gt; 						AspectJUIPlugin.SOURCE_LOCATION_ATTRIBUTE,&#13;
&gt; 						sLoc2.getSourceFile()&#13;
&gt; 								.getAbsolutePath()&#13;
&gt; 								+ ":::"&#13;
&gt; 								+ sLoc2.getLine()&#13;
&gt; 								+ ":::"&#13;
&gt; 								+ sLoc2.getEndLine()&#13;
&gt; 								+ ":::"&#13;
&gt; 								+ sLoc2.getColumn());&#13;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/resources/AspectJPluginResources.properties" revision="1.2" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/plugin.xml" revision="1.12" state="changed">703a704
&gt;    &lt;/extension&gt;
706d706
&lt;    &lt;/extension&gt;
729c729
&lt;     &lt;extension
---
&gt;    &lt;extension
739a740,788
&gt; &lt;!-- Markers to show the source of advice --&gt;   
&gt;     &lt;extension
&gt;    	      id="sourceadvicemarker"
&gt;    	      name="Source of Advice Marker"
&gt;    	      point="org.eclipse.core.resources.markers"&gt;
&gt;       &lt;super
&gt;             type="org.eclipse.core.resources.textmarker"&gt;
&gt;       &lt;/super&gt;
&gt;      &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
&gt;             &lt;attribute
&gt;             name="sourceLocationOfAdvice"&gt;
&gt;       &lt;/attribute&gt;     
&gt;    &lt;/extension&gt;
&gt;    &lt;extension
&gt;    	      id="sourcearoundadvicemarker"
&gt;    	      name="Source of Around Advice Marker"
&gt;    	      point="org.eclipse.core.resources.markers"&gt;
&gt;       &lt;super
&gt;             type="org.eclipse.ajdt.ui.sourceadvicemarker"&gt;
&gt;       &lt;/super&gt;
&gt;      &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
&gt;    &lt;/extension&gt;
&gt;    &lt;extension
&gt;    	      id="sourcebeforeadvicemarker"
&gt;    	      name="Source of Before Advice Marker"
&gt;    	      point="org.eclipse.core.resources.markers"&gt;
&gt;       &lt;super
&gt;             type="org.eclipse.ajdt.ui.sourceadvicemarker"&gt;
&gt;       &lt;/super&gt;
&gt;      &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
&gt;    &lt;/extension&gt;
&gt;    &lt;extension
&gt;    	      id="sourceafteradvicemarker"
&gt;    	      name="Source of After Advice Marker"
&gt;    	      point="org.eclipse.core.resources.markers"&gt;
&gt;       &lt;super
&gt;             type="org.eclipse.ajdt.ui.sourceadvicemarker"&gt;
&gt;       &lt;/super&gt;
&gt;      &lt;persistent
&gt;             value="true"&gt;
&gt;       &lt;/persistent&gt;
&gt;    &lt;/extension&gt;
&gt; 
912a962,977
&gt;       &lt;type
&gt;             super="org.eclipse.ajdt.advice"
&gt;             markerType="org.eclipse.ajdt.ui.sourceadvicemarker"
&gt;             name="org.eclipse.ajdt.sourceAdvice"/&gt;            
&gt;       &lt;type
&gt;             super="org.eclipse.ajdt.sourceAdvice"
&gt;             markerType="org.eclipse.ajdt.ui.sourcebeforeadvicemarker"
&gt;             name="org.eclipse.ajdt.sourceBeforeAdvice"/&gt;            
&gt;       &lt;type
&gt;             super="org.eclipse.ajdt.sourceAdvice"
&gt;             markerType="org.eclipse.ajdt.ui.sourceafteradvicemarker"
&gt;             name="org.eclipse.ajdt.sourceAfterAdvice"/&gt;            
&gt;       &lt;type
&gt;             super="org.eclipse.ajdt.sourceAdvice"
&gt;             markerType="org.eclipse.ajdt.ui.sourcearoundadvicemarker"
&gt;             name="org.eclipse.ajdt.sourceAroundAdvice"/&gt;            
969a1035,1050
&gt; 			annotationType="org.eclipse.ajdt.sourceAdvice"
&gt; 			icon="icons/markers/source_advice.gif"&gt;
&gt; 		&lt;/specification&gt;
&gt; 		&lt;specification
&gt; 			annotationType="org.eclipse.ajdt.sourceBeforeAdvice"
&gt; 			icon="icons/markers/source_before_advice.gif"&gt;
&gt; 		&lt;/specification&gt;
&gt; 		&lt;specification
&gt; 			annotationType="org.eclipse.ajdt.sourceAfterAdvice"
&gt; 			icon="icons/markers/source_after_advice.gif"&gt;
&gt; 		&lt;/specification&gt;
&gt; 		&lt;specification
&gt; 			annotationType="org.eclipse.ajdt.sourceAroundAdvice"
&gt; 			icon="icons/markers/source_around_advice.gif"&gt;
&gt; 		&lt;/specification&gt;
&gt; 		&lt;specification
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AdviceActionDelegate.java" revision="1.5" state="changed">11a12
&gt;                  - add support for Advises entries
101c102,103
&lt; 
---
&gt; 			Integer clickedLine = new Integer(linenumber+1);
&gt; 			
111,114c113
&lt; 			if (markers != null &amp;&amp; markers.length != 0) {
&lt; 				
&lt; 				Integer clickedLine = new Integer(linenumber+1);
&lt; 				
---
&gt; 			if (markers != null &amp;&amp; markers.length != 0) {							
116,117c115
&lt; 					IMarker m = markers[j];
&lt; 					
---
&gt; 					IMarker m = markers[j];					
141a140,163
&gt; 			
&gt; 			// Go through source of advice markers
&gt; 			IMarker sMarkers[] = ifile.findMarkers(IAJModelMarker.SOURCE_ADVICE_MARKER, true, 2);
&gt; 			MenuManager sourceAdviceSubmenu = null;
&gt; 		    boolean sourceAdviceSubmenuInitialized = false;
&gt; 			if (sMarkers != null &amp;&amp; sMarkers.length != 0) {				
&gt; 				for (int j = 0; j &lt; sMarkers.length; j++) {
&gt; 					IMarker m = sMarkers[j];
&gt; 					if (m.getAttribute(IMarker.LINE_NUMBER).equals(clickedLine)) {
&gt; 						String textLabel = ((String)m.getAttribute(IMarker.MESSAGE));
&gt; 						AJDTMenuAction ama = new AJDTMenuAction(textLabel,m);
&gt; 						// Initialize the submenu if we haven't done it already.
&gt; 						if (!sourceAdviceSubmenuInitialized) {
&gt; 							sourceAdviceSubmenu = new MenuManager(
&gt; 							  AspectJUIPlugin.getResourceString("EditorRulerContextMenu.adviceAffects"));
&gt; 							manager.add(new Separator());
&gt; 							manager.add(sourceAdviceSubmenu);			
&gt; 							sourceAdviceSubmenuInitialized = true; 
&gt; 						}
&gt; 						// Add our new action to the submenu
&gt; 						sourceAdviceSubmenu.add(ama);
&gt; 					}
&gt; 				}
&gt; 			}
143,148c165
&lt; 			// Go through the ITD markers attached to this file, if any have a line number that
&lt; 			// matches the line clicked by the user, create the submenu (if it has not already
&lt; 			// been created) and add a new submenu entry for the advice.  The data that is
&lt; 			// stored with the submenu entry gives the run() method of the inner class the
&lt; 			// ability to create a jump marker such that it can jump to the location where
&lt; 			// the advice is defined.
---
&gt; 			// Go through the ITD markers
153,155d169
&lt; 				
&lt; 				Integer clickedLine = new Integer(linenumber+1);
&lt; 				
157,158c171
&lt; 					IMarker m = decMarkers[j];
&lt; 					
---
&gt; 					IMarker m = decMarkers[j];					
160,163c173
&lt; 						String textLabel = ((String)m.getAttribute(IMarker.MESSAGE));//.substring(8);
&lt; 						// substring(8) skips the 'Advice: ' bit on the front.
&lt; 						
&lt; 						// Build a new action for our menu.  Set the text label and remember the
---
&gt; 						String textLabel = ((String)m.getAttribute(IMarker.MESSAGE));						// Build a new action for our menu.  Set the text label and remember the
173c183
&lt; 							if(!adviceSubmenuInitialized) {
---
&gt; 							if(!(adviceSubmenuInitialized || sourceAdviceSubmenuInitialized)) {
186,191c196
&lt; 			// Go through the problem markers attached to this file, if any have a line number that
&lt; 			// matches the line clicked by the user, create the submenu (if it has not already
&lt; 			// been created) and add a new submenu entry for the advice.  The data that is
&lt; 			// stored with the submenu entry gives the run() method of the inner class the
&lt; 			// ability to create a jump marker such that it can jump to the location where
&lt; 			// the advice is defined.
---
&gt; 			// Go through the problem markers 
196,197c201
&lt;                 Integer clickedLine = new Integer(linenumber + 1);
&lt;                 for (int j = 0; j &lt; probMarkers.length; j++) {
---
&gt;                  for (int j = 0; j &lt; probMarkers.length; j++) {
224c228
&lt;                                     if (!(adviceSubmenuInitialized || declarationSubmenuInitialized)) {
---
&gt;                                     if (!(adviceSubmenuInitialized || sourceAdviceSubmenuInitialized || declarationSubmenuInitialized)) {
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/icons/markers/source_advice.gif" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/icons/markers/source_before_advice.gif" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/icons/markers/source_after_advice.gif" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/icons/markers/source_around_advice.gif" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="80060" transactionid="73835">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="92"/>
<property name="lines-added" value="53"/>
<property name="lines-deleted" value="16"/>
<property name="lines-modified" value="219"/>
<property name="lines-churned" value="288"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-else K-if K-import K-new K-null K-return K-super M O-&lt; O-== O-&gt; O-- O-() O-* O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>I have about 500megs of source in my project.  Sometimes a clean/build 
takes 20 minutes other times it takes 3 hours. Often I simply get an 
"Operation in progress" dialog with no option for details.  I'm then 
forced to just wait.  I've got a 3.06 Hyperthreaded box with 2Gigs of RAM.  I've
given Eclipse 1Gig to play with.  According to Windows task manager it is only
using about 300megs.  Often 3 hours will be with no errors.  I would guess we
have a very detailed project dependency tree.  I just started at the company but
there are about 300 projects in the workspace with varying relationships.  I've
had to do clean for a number of reasons.  Today for instance I turned on the
compiler warning for unused else blocks and it has been running for hours. 
Shouldn't clean/build run the same process everytime?  I could understand if
different incremental builds take differing amounts of time.  However, shouldn't
clean just remove everything and start fresh?</bugreport>
<pre-fix-testcases failing="112" file="output/80060/pre-fix/testresults.xml" passing="1377" size="1489"/>
<post-fix-testcases failing="113" file="output/80060/post-fix/testresults.xml" passing="1376" size="1489"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/builder/Builder.java" revision="1.19" state="changed">380d379
&lt; 			//System.out.println("build finished");
382a382,385
&gt; 			if (AspectJPreferences.isAdviceDecoratorActive()) {
&gt; 				AJModelUtils.refreshOutlineViews();
&gt; 			}
&gt; 
389,391d391
&lt; 								if (AspectJPreferences.isAdviceDecoratorActive()) {
&lt; 									AJModelUtils.refreshOutlineViews();
&lt; 								}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/core/AJDTUtils.java" revision="1.10" state="changed">2c2
&lt;  Copyright (c) 2002 IBM Corporation and others.
---
&gt;  Copyright (c) 2002, 2004 IBM Corporation and others.
37a38,39
&gt; import org.eclipse.core.runtime.IProgressMonitor;
&gt; import org.eclipse.core.runtime.IStatus;
39a42,43
&gt; import org.eclipse.core.runtime.Status;
&gt; import org.eclipse.core.runtime.jobs.Job;
64a69
&gt; import org.eclipse.ui.progress.UIJob;
83a89,92
&gt; 	private static Job refreshJob;
&gt; 
&gt; 	private static int previousExecutionTime;
&gt; 	
192,194c201,205
&lt; 		IPreferenceStore store = AspectJUIPlugin.getDefault().getPreferenceStore();
&lt; 		store.setDefault(project.getName()+AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
&lt; 		
---
&gt; 		IPreferenceStore store = AspectJUIPlugin.getDefault()
&gt; 				.getPreferenceStore();
&gt; 		store.setDefault(project.getName()
&gt; 				+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
&gt; 
202c213
&lt; 			
---
&gt; 
206c217
&lt; 			if(!hasAJPluginDependency(project)) {
---
&gt; 			if (!hasAJPluginDependency(project)) {
209c220,221
&lt; 				store.setValue(project.getName()+AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, true);
---
&gt; 				store.setValue(project.getName()
&gt; 						+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, true);
215c227,228
&lt; 			store.setValue(project.getName()+AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
---
&gt; 			store.setValue(project.getName()
&gt; 					+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
218c231,232
&lt; 		// PD: current thinking is not to change project dependencies to class folder ones
---
&gt; 		// PD: current thinking is not to change project dependencies to class
&gt; 		// folder ones
230c244
&lt; 		
---
&gt; 
233c247
&lt; 		
---
&gt; 
235c249
&lt; 		
---
&gt; 
238d251
&lt; 	
248c261
&lt; 	public static void checkMyEclipseNature(IProject project){
---
&gt; 	public static void checkMyEclipseNature(IProject project) {
252c265,266
&lt; 					|| project.hasNature("com.genuitec.eclipse.j2eedt.core.ejbnature")){ //$NON-NLS-1$
---
&gt; 					|| project
&gt; 							.hasNature("com.genuitec.eclipse.j2eedt.core.ejbnature")) { //$NON-NLS-1$
254c268
&lt; 				if (!myEclipseMessageDisplayed){
---
&gt; 				if (!myEclipseMessageDisplayed) {
256,263c270,279
&lt; 					
&lt; 					IWorkbenchWindow window = AspectJUIPlugin.getDefault().getWorkbench()
&lt; 					.getActiveWorkbenchWindow();
&lt; 					MessageDialog.openInformation(window.getShell(),
&lt; 							AspectJUIPlugin
&lt; 							.getResourceString("myEclipse.natureDetected.title"), //$NON-NLS-1$
&lt; 							AspectJUIPlugin
&lt; 							.getResourceString("myEclipse.natureDetected.message")); //$NON-NLS-1$
---
&gt; 
&gt; 					IWorkbenchWindow window = AspectJUIPlugin.getDefault()
&gt; 							.getWorkbench().getActiveWorkbenchWindow();
&gt; 					MessageDialog
&gt; 							.openInformation(
&gt; 									window.getShell(),
&gt; 									AspectJUIPlugin
&gt; 											.getResourceString("myEclipse.natureDetected.title"), //$NON-NLS-1$
&gt; 									AspectJUIPlugin
&gt; 											.getResourceString("myEclipse.natureDetected.message")); //$NON-NLS-1$
269c285
&lt; 	
---
&gt; 
284c300,301
&lt; 	 * @param IProject project
---
&gt; 	 * @param IProject
&gt; 	 *            project
293,294c310,312
&lt; 		if (referencingProjects.length == 0) return;
&lt; 		
---
&gt; 		if (referencingProjects.length == 0)
&gt; 			return;
&gt; 
316c334
&lt; 					if (entryKind == IClasspathEntry.CPE_PROJECT 
---
&gt; 					if (entryKind == IClasspathEntry.CPE_PROJECT
322c340,341
&lt; 							for (Iterator iter = outputLocationPaths.iterator(); iter.hasNext();) {
---
&gt; 							for (Iterator iter = outputLocationPaths.iterator(); iter
&gt; 									.hasNext();) {
325,326c344,345
&lt; 										.newLibraryEntry(outputLocationPath, null,
&lt; 												null);
---
&gt; 										.newLibraryEntry(outputLocationPath,
&gt; 												null, null);
329c348
&lt; 						}		
---
&gt; 						}
351,354c370,377
&lt; 			if (project.getPersistentProperty(BuildOptionsAdapter.OUTPUTJAR) != null &amp;&amp;
&lt; 					!(project.getPersistentProperty(BuildOptionsAdapter.OUTPUTJAR).equals(""))) { 
&lt; 				IPath pathToOutjar = new Path(project.getPersistentProperty(BuildOptionsAdapter.OUTPUTJAR));
&lt; 				String outJar2 = AspectJUIPlugin.getDefault().getAjdtProjectProperties().getOutJar();
---
&gt; 			if (project.getPersistentProperty(BuildOptionsAdapter.OUTPUTJAR) != null
&gt; 					&amp;&amp; !(project
&gt; 							.getPersistentProperty(BuildOptionsAdapter.OUTPUTJAR)
&gt; 							.equals(""))) {
&gt; 				IPath pathToOutjar = new Path(project
&gt; 						.getPersistentProperty(BuildOptionsAdapter.OUTPUTJAR));
&gt; 				String outJar2 = AspectJUIPlugin.getDefault()
&gt; 						.getAjdtProjectProperties().getOutJar();
356,357c379,382
&lt; 				IProject[] classFolderReferences = (IProject[]) getDependingProjects(project).get(0);;
&lt; 				List javaElements= new ArrayList(5);
---
&gt; 				IProject[] classFolderReferences = (IProject[]) getDependingProjects(
&gt; 						project).get(0);
&gt; 				;
&gt; 				List javaElements = new ArrayList(5);
360,361c385,388
&lt; 					IJavaProject javaProject = JavaCore.create(classFolderReferences[i]);
&lt; 					if (javaProject == null) continue;
---
&gt; 					IJavaProject javaProject = JavaCore
&gt; 							.create(classFolderReferences[i]);
&gt; 					if (javaProject == null)
&gt; 						continue;
363c390,391
&lt; 						IClasspathEntry[] cpEntry = javaProject.getRawClasspath();
---
&gt; 						IClasspathEntry[] cpEntry = javaProject
&gt; 								.getRawClasspath();
367,368c395,397
&lt; 							if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {							
&lt; 								for (Iterator iter = outputLocationPaths.iterator(); iter.hasNext();) {
---
&gt; 							if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
&gt; 								for (Iterator iter = outputLocationPaths
&gt; 										.iterator(); iter.hasNext();) {
372c401,402
&lt; 											.newLibraryEntry(pathToOutjar2, null,null);	
---
&gt; 												.newLibraryEntry(pathToOutjar2,
&gt; 														null, null);
382,383c412,415
&lt; 						IClasspathEntry[] newCP = (IClasspathEntry[]) cpEntries.toArray(new IClasspathEntry[cpEntries.size()]);
&lt; 						javaProject.setRawClasspath(newCP, new NullProgressMonitor());
---
&gt; 						IClasspathEntry[] newCP = (IClasspathEntry[]) cpEntries
&gt; 								.toArray(new IClasspathEntry[cpEntries.size()]);
&gt; 						javaProject.setRawClasspath(newCP,
&gt; 								new NullProgressMonitor());
388c420,421
&lt; 				// Forcing a build here if there is an outjar - otherwise have to build the project
---
&gt; 				// Forcing a build here if there is an outjar - otherwise have
&gt; 				// to build the project
390,391c423,426
&lt; 				project.build(IncrementalProjectBuilder.FULL_BUILD,"org.eclipse.ajdt.ui.ajbuilder", null, null);
&lt; 				AspectJUIPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_INFINITE,null);
---
&gt; 				project.build(IncrementalProjectBuilder.FULL_BUILD,
&gt; 						"org.eclipse.ajdt.ui.ajbuilder", null, null);
&gt; 				AspectJUIPlugin.getWorkspace().getRoot().refreshLocal(
&gt; 						IResource.DEPTH_INFINITE, null);
394c429
&lt; 		}		
---
&gt; 		}
396c431
&lt; 	
---
&gt; 
413c448
&lt; 							.newLibraryEntry(entry.getPath(),null,null);
---
&gt; 								.newLibraryEntry(entry.getPath(), null, null);
420c455,456
&lt; 		return (IClasspathEntry[]) exportedEntries.toArray(new IClasspathEntry[exportedEntries.size()]);
---
&gt; 		return (IClasspathEntry[]) exportedEntries
&gt; 				.toArray(new IClasspathEntry[exportedEntries.size()]);
422c458
&lt; 	
---
&gt; 
438,439c474,476
&lt; 			} 
&lt; 			if (!foundSrc) return true;
---
&gt; 			}
&gt; 			if (!foundSrc)
&gt; 				return true;
442c479
&lt; 		return false;	
---
&gt; 		return false;
444c481
&lt; 	
---
&gt; 
458c495,496
&lt; 			// Have been unable to create a user scenario where the following for
---
&gt; 			// Have been unable to create a user scenario where the following
&gt; 			// for
488,493c526,530
&lt; 	 * dependencies. Also check whether the current project exports anything
&lt; 	 * and if so, check whether the entry is also on the depending project's
&lt; 	 * class path. Again, if this is the case, we remove it from
&lt; 	 * the depending project's classpath as it was added when AJ nature
&lt; 	 * was added to the project. This is used when AspectJ nature is removed 
&lt; 	 * from a project
---
&gt; 	 * dependencies. Also check whether the current project exports anything and
&gt; 	 * if so, check whether the entry is also on the depending project's class
&gt; 	 * path. Again, if this is the case, we remove it from the depending
&gt; 	 * project's classpath as it was added when AJ nature was added to the
&gt; 	 * project. This is used when AspectJ nature is removed from a project
499c536
&lt; 		
---
&gt; 
503,505c540,543
&lt; 		
&lt; 		if (cfDependingProjects.length == 0 &amp;&amp; elDependingProjects.length == 0) return;
&lt; 		
---
&gt; 
&gt; 		if (cfDependingProjects.length == 0 &amp;&amp; elDependingProjects.length == 0)
&gt; 			return;
&gt; 
519c557
&lt; 		if (cfDependingProjects.length == 0 &amp;&amp; exportedEntries.size() &gt; 0 
---
&gt; 		if (cfDependingProjects.length == 0 &amp;&amp; exportedEntries.size() &gt; 0
527c565,566
&lt; 					IClasspathEntry[] classpathEntries = javaProject.getRawClasspath();
---
&gt; 					IClasspathEntry[] classpathEntries = javaProject
&gt; 							.getRawClasspath();
529,530c568,571
&lt; 					for (Iterator iter = exportedEntries.iterator(); iter.hasNext();) {
&lt; 						IClasspathEntry exportedCPEntry = (IClasspathEntry) iter.next();
---
&gt; 					for (Iterator iter = exportedEntries.iterator(); iter
&gt; 							.hasNext();) {
&gt; 						IClasspathEntry exportedCPEntry = (IClasspathEntry) iter
&gt; 								.next();
532,534c573,578
&lt; 							if (classpathEntries[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY 
&lt; 									&amp;&amp; classpathEntries[j].getPath().equals(exportedCPEntry.getPath())) {
&lt; 								originalEntries.add(JavaCore.newProjectEntry(project.getFullPath()));								
---
&gt; 							if (classpathEntries[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY
&gt; 									&amp;&amp; classpathEntries[j].getPath().equals(
&gt; 											exportedCPEntry.getPath())) {
&gt; 								originalEntries
&gt; 										.add(JavaCore.newProjectEntry(project
&gt; 												.getFullPath()));
539c583
&lt; 						
---
&gt; 
541,542c585,588
&lt; 					IClasspathEntry[] origCP = (IClasspathEntry[]) originalEntries.toArray(new IClasspathEntry[originalEntries.size()]);
&lt; 					javaProject.setRawClasspath(origCP,new NullProgressMonitor());
---
&gt; 					IClasspathEntry[] origCP = (IClasspathEntry[]) originalEntries
&gt; 							.toArray(new IClasspathEntry[originalEntries.size()]);
&gt; 					javaProject.setRawClasspath(origCP,
&gt; 							new NullProgressMonitor());
548c594
&lt; 		
---
&gt; 
554c600,601
&lt; 			for (Iterator iterator = outputLocationPaths.iterator(); iterator.hasNext();) {
---
&gt; 			for (Iterator iterator = outputLocationPaths.iterator(); iterator
&gt; 					.hasNext();) {
565,566c612,614
&lt; 								IClasspathEntry projectEntry = JavaCore.newProjectEntry(project.getFullPath());
&lt; 								newEntries.add(projectEntry);								
---
&gt; 								IClasspathEntry projectEntry = JavaCore
&gt; 										.newProjectEntry(project.getFullPath());
&gt; 								newEntries.add(projectEntry);
584,586c632,634
&lt; 	 * Get all projects within the workspace who have a dependency
&lt; 	 * on the given project - this can either be a class folder dependency
&lt; 	 * or on a library which the project exports.
---
&gt; 	 * Get all projects within the workspace who have a dependency on the given
&gt; 	 * project - this can either be a class folder dependency or on a library
&gt; 	 * which the project exports.
588,591c636,640
&lt; 	 * @param IProject project
&lt; 	 * @return List of two IProject[] where the first is all the 
&lt; 	 *         class folder depending projects, and the second is all
&lt; 	 *         the exported library dependent projects 
---
&gt; 	 * @param IProject
&gt; 	 *            project
&gt; 	 * @return List of two IProject[] where the first is all the class folder
&gt; 	 *         depending projects, and the second is all the exported library
&gt; 	 *         dependent projects
595,596c644,646
&lt; 		
&lt; 		IProject[] projectsInWorkspace = AspectJUIPlugin.getWorkspace().getRoot().getProjects();
---
&gt; 
&gt; 		IProject[] projectsInWorkspace = AspectJUIPlugin.getWorkspace()
&gt; 				.getRoot().getProjects();
601c651
&lt; 		
---
&gt; 
603c653,654
&lt; 			if (projectsInWorkspace[i].equals(project) || !(projectsInWorkspace[i].isOpen()))
---
&gt; 			if (projectsInWorkspace[i].equals(project)
&gt; 					|| !(projectsInWorkspace[i].isOpen()))
607c658,659
&lt; 					JavaProject javaProject = (JavaProject) JavaCore.create(projectsInWorkspace[i]);
---
&gt; 					JavaProject javaProject = (JavaProject) JavaCore
&gt; 							.create(projectsInWorkspace[i]);
612c664,665
&lt; 						IClasspathEntry[] cpEntry = javaProject.getRawClasspath();
---
&gt; 						IClasspathEntry[] cpEntry = javaProject
&gt; 								.getRawClasspath();
616c669,670
&lt; 								for (Iterator iter = outputLocationPaths.iterator(); iter.hasNext();) {
---
&gt; 								for (Iterator iter = outputLocationPaths
&gt; 										.iterator(); iter.hasNext();) {
619c673,674
&lt; 										classFolderDependingProjects.add(projectsInWorkspace[i]);
---
&gt; 										classFolderDependingProjects
&gt; 												.add(projectsInWorkspace[i]);
624,625c679,682
&lt; 									if (entry.getPath().equals(exportedEntries[k].getPath())) {
&lt; 										exportedLibraryDependingProjects.add(projectsInWorkspace[i]);
---
&gt; 									if (entry.getPath().equals(
&gt; 											exportedEntries[k].getPath())) {
&gt; 										exportedLibraryDependingProjects
&gt; 												.add(projectsInWorkspace[i]);
637,638c694,697
&lt; 		projects.add(0,(IProject[]) classFolderDependingProjects.toArray(new IProject[] {}));
&lt; 		projects.add(1,(IProject[]) exportedLibraryDependingProjects.toArray(new IProject[] {}));
---
&gt; 		projects.add(0, (IProject[]) classFolderDependingProjects
&gt; 				.toArray(new IProject[] {}));
&gt; 		projects.add(1, (IProject[]) exportedLibraryDependingProjects
&gt; 				.toArray(new IProject[] {}));
642d700
&lt; 	
657,658c715,716
&lt; 		IProject[] projectsInWorkspace = AspectJUIPlugin.getWorkspace().getRoot()
&lt; 				.getProjects();
---
&gt; 		IProject[] projectsInWorkspace = AspectJUIPlugin.getWorkspace()
&gt; 				.getRoot().getProjects();
710c768,769
&lt; 			IProject[] classFolderReferences = (IProject[]) getDependingProjects(project).get(0);
---
&gt; 			IProject[] classFolderReferences = (IProject[]) getDependingProjects(
&gt; 					project).get(0);
837c896
&lt; 		
---
&gt; 
857,858c916
&lt; 	
&lt; 	
---
&gt; 
862c920
&lt; 	 */	
---
&gt; 	 */
869c927
&lt; 		.getWorkspacePluginModel(project).getPluginBase().getId();
---
&gt; 				.getWorkspacePluginModel(project).getPluginBase().getId();
874c932
&lt; 		
---
&gt; 
896c954,955
&lt; 		String version = (String)bundle.getHeaders().get(Constants.BUNDLE_VERSION);
---
&gt; 		String version = (String) bundle.getHeaders().get(
&gt; 				Constants.BUNDLE_VERSION);
918c977
&lt; 			if(dialog.open() == Window.OK) {
---
&gt; 			if (dialog.open() == Window.OK) {
934c993,994
&lt; 		//(the way it is currently implemented, this must happen before nature gets removed)
---
&gt; 		//(the way it is currently implemented, this must happen before nature
&gt; 		// gets removed)
936c996
&lt; 		
---
&gt; 
971,974c1031,1039
&lt; 			IPreferenceStore store = AspectJUIPlugin.getDefault().getPreferenceStore();
&lt; 			store.setDefault(project.getName()+AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
&lt; 			boolean AJPluginDependancySetByAddAJNature = store.getBoolean(project.getName()+AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY);
&lt; 			if(hasAJPluginDependency(project) &amp;&amp; AJPluginDependancySetByAddAJNature) {
---
&gt; 			IPreferenceStore store = AspectJUIPlugin.getDefault()
&gt; 					.getPreferenceStore();
&gt; 			store.setDefault(project.getName()
&gt; 					+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
&gt; 			boolean AJPluginDependancySetByAddAJNature = store
&gt; 					.getBoolean(project.getName()
&gt; 							+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY);
&gt; 			if (hasAJPluginDependency(project)
&gt; 					&amp;&amp; AJPluginDependancySetByAddAJNature) {
977c1042,1046
&lt; 				store.setValue(project.getName()+AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
---
&gt; 				store
&gt; 						.setValue(
&gt; 								project.getName()
&gt; 										+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY,
&gt; 								false);
984,985c1053,1056
&lt; 		// PD: current thinking is not to change project dependencies to class folder ones
&lt; 		// therefore, no need to change classfolder dependencies back to project ones.
---
&gt; 		// PD: current thinking is not to change project dependencies to class
&gt; 		// folder ones
&gt; 		// therefore, no need to change classfolder dependencies back to project
&gt; 		// ones.
988c1059
&lt; 		
---
&gt; 
991c1062
&lt; 		
---
&gt; 
1000,1001c1071,1072
&lt; 		
&lt;  		ManifestEditor manEd = getPDEManifestEditor(project);
---
&gt; 
&gt; 		ManifestEditor manEd = getPDEManifestEditor(project);
1004c1075
&lt; 		
---
&gt; 
1008,1009c1079
&lt; 		}
&lt; 		else {
---
&gt; 		} else {
1012,1014c1082,1086
&lt; 				IPackageFragmentRoot[] dependencies = JavaCore.create(project).getPackageFragmentRoots();
&lt; 				for(int i = 0; i&lt; dependencies.length; i++) {
&lt; 					if(dependencies[i].getElementName().equals(AspectJPreferences.AJDE_JAR))
---
&gt; 				IPackageFragmentRoot[] dependencies = JavaCore.create(project)
&gt; 						.getPackageFragmentRoots();
&gt; 				for (int i = 0; i &lt; dependencies.length; i++) {
&gt; 					if (dependencies[i].getElementName().equals(
&gt; 							AspectJPreferences.AJDE_JAR))
1017c1089
&lt; 			} catch(JavaModelException e) {
---
&gt; 			} catch (JavaModelException e) {
1019c1091
&lt; 			return false;	
---
&gt; 			return false;
1031c1103
&lt; 	
---
&gt; 
1043c1115,1116
&lt; 				removeImportFromPDEModel(model, AspectJUIPlugin.RUNTIME_PLUGIN_ID);
---
&gt; 				removeImportFromPDEModel(model,
&gt; 						AspectJUIPlugin.RUNTIME_PLUGIN_ID);
1046c1119
&lt; 	        	AspectJUIPlugin
---
&gt; 				AspectJUIPlugin
1135,1136c1208,1209
&lt; 		String ajrtPath = AspectJUIPlugin.getDefault().getAjdtProjectProperties()
&lt; 				.getAspectjrtClasspath();
---
&gt; 		String ajrtPath = AspectJUIPlugin.getDefault()
&gt; 				.getAjdtProjectProperties().getAspectjrtClasspath();
1216,1218c1289,1291
&lt; 	 * Decorate icon based on modifiers, errors etc.
&lt; 	 * Possible decorations are: abstract, final, synchronized, static,
&lt; 	 * runnable, warning, error, overrides, implements
---
&gt; 	 * Decorate icon based on modifiers, errors etc. Possible decorations are:
&gt; 	 * abstract, final, synchronized, static, runnable, warning, error,
&gt; 	 * overrides, implements
1220c1293,1294
&lt; 	public static ImageDescriptor decorate( ImageDescriptor base, IProgramElement pNode ) {
---
&gt; 	public static ImageDescriptor decorate(ImageDescriptor base,
&gt; 			IProgramElement pNode) {
1224c1298
&lt; 			if ( modifiers != null ) { 
---
&gt; 			if (modifiers != null) {
1227c1301
&lt; 				}  
---
&gt; 				}
1230c1304
&lt; 				} 
---
&gt; 				}
1233c1307
&lt; 				} 
---
&gt; 				}
1236,1240c1310
&lt; 				}	
&lt; 			}	
&lt; 			if ( pNode.getKind() == IProgramElement.Kind.CONSTRUCTOR ||
&lt; 				 pNode.getKind() == IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR) {
&lt; 				flags = flags | JavaElementImageDescriptor.CONSTRUCTOR;	
---
&gt; 				}
1242c1312,1316
&lt; 			if ( pNode.isRunnable( ) ) {
---
&gt; 			if (pNode.getKind() == IProgramElement.Kind.CONSTRUCTOR
&gt; 					|| pNode.getKind() == IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR) {
&gt; 				flags = flags | JavaElementImageDescriptor.CONSTRUCTOR;
&gt; 			}
&gt; 			if (pNode.isRunnable()) {
1245c1319
&lt; 			if ( pNode.isOverrider( ) ) {
---
&gt; 			if (pNode.isOverrider()) {
1248c1322
&lt; 			if ( pNode.isImplementor( ) ) {
---
&gt; 			if (pNode.isImplementor()) {
1252,1253c1326,1327
&lt; 			if ( sMessage != null ) {
&lt; 				if ( sMessage.getKind() == IMessage.ERROR ) {
---
&gt; 			if (sMessage != null) {
&gt; 				if (sMessage.getKind() == IMessage.ERROR) {
1255c1329
&lt; 				} else if ( sMessage.getKind() == IMessage.WARNING ) {
---
&gt; 				} else if (sMessage.getKind() == IMessage.WARNING) {
1260c1334
&lt; 		return decorate( base, flags );
---
&gt; 		return decorate(base, flags);
1262,1269c1336,1367
&lt; 	
&lt; 	public static void refreshPackageExplorer(){
&lt; 		//refresh package explorer (needs to be done by UI thread)
&lt; 		Runnable r = new Runnable(){
&lt; 			public void run(){
&lt; 				PackageExplorerPart pep = PackageExplorerPart.getFromActivePerspective();
&lt; 				if (pep != null)
&lt; 					pep.getTreeViewer().refresh();
---
&gt; 
&gt; 	public static void refreshPackageExplorer() {
&gt; 		int delay = 5*previousExecutionTime;
&gt; 		if (delay &lt; 100) {
&gt; 			delay = 100;
&gt; 		} else if (delay &gt; 5000) {
&gt; 			delay = 5000;
&gt; 		}
&gt; 		//System.out.println("refresh explorer: delay="+delay);
&gt; 		getRefreshPackageExplorerJob().schedule(delay);
&gt; 	}
&gt; 
&gt; 	// reuse the same Job to avoid excessive updates
&gt; 	private static Job getRefreshPackageExplorerJob() {
&gt; 		if (refreshJob == null) {
&gt; 			refreshJob = new RefreshPackageExplorerJob();
&gt; 		}
&gt; 		return refreshJob;
&gt; 	}
&gt; 
&gt; 	private static class RefreshPackageExplorerJob extends UIJob {
&gt; 		RefreshPackageExplorerJob() {
&gt; 			super(AspectJUIPlugin
&gt; 					.getResourceString("utils.refresh.explorer.job"));
&gt; 		}
&gt; 
&gt; 		public IStatus runInUIThread(IProgressMonitor monitor) {
&gt; 			long start = System.currentTimeMillis();
&gt; 			PackageExplorerPart pep = PackageExplorerPart
&gt; 					.getFromActivePerspective();
&gt; 			if (pep != null) {
&gt; 				pep.getTreeViewer().refresh();
1271,1272c1369,1372
&lt; 		};
&lt; 		AspectJUIPlugin.getDefault().getDisplay().asyncExec(r);
---
&gt; 			previousExecutionTime = (int)(System.currentTimeMillis() - start);
&gt; 			//System.out.println("refresh explorer: elapsed="+previousExecutionTime);
&gt; 			return Status.OK_STATUS;
&gt; 		}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/builder/AJModelUtils.java" revision="1.2" state="changed">16a17,21
&gt; import org.eclipse.ajdt.ui.AspectJUIPlugin;
&gt; import org.eclipse.core.runtime.IProgressMonitor;
&gt; import org.eclipse.core.runtime.IStatus;
&gt; import org.eclipse.core.runtime.Status;
&gt; import org.eclipse.core.runtime.jobs.Job;
23a29
&gt; import org.eclipse.ui.progress.UIJob;
31a38,41
&gt; 	private static Job refreshJob;
&gt; 
&gt; 	private static int previousExecutionTime;
&gt; 	
33,34c43,44
&lt; 	 * Goes through all the open editors and updates the outline page for
&lt; 	 * each (if they are using the standard Java outline page.
---
&gt; 	 * Goes through all the open editors and updates the outline page for each
&gt; 	 * (if they are using the standard Java outline page)
37,54c47,86
&lt; 		IWorkbenchWindow[] windows = PlatformUI.getWorkbench()
&lt; 				.getWorkbenchWindows();
&lt; 		for (int i = 0; i &lt; windows.length; i++) {
&lt; 			IWorkbenchPage[] pages = windows[i].getPages();
&lt; 			for (int x = 0; x &lt; pages.length; x++) {
&lt; 				IEditorReference[] editors = pages[x].getEditorReferences();
&lt; 				for (int z = 0; z &lt; editors.length; z++) {
&lt; 					IEditorPart editor = editors[z].getEditor(true);
&lt; 					if (editor != null) {
&lt; 						//IEditorInput input = editor.getEditorInput();
&lt; 						//IFile editorFile = (IFile)
&lt; 						// input.getAdapter(IFile.class);
&lt; 						//System.out.println("file="+editorFile+" opened by
&lt; 						// "+editor);
&lt; 						Object out = editor
&lt; 								.getAdapter(IContentOutlinePage.class);
&lt; 						if (out instanceof JavaOutlinePage) {
&lt; 							refreshOutline((JavaOutlinePage)out);
---
&gt; 		int delay = 5*previousExecutionTime;
&gt; 		if (delay &lt; 100) {
&gt; 			delay = 100;
&gt; 		} else if (delay &gt; 5000) {
&gt; 			delay = 5000;
&gt; 		}
&gt; 		//System.out.println("refresh outline: delay="+delay);
&gt; 		getRefreshOutlinePagesJob().schedule(delay);
&gt; 	}
&gt; 
&gt; 	// reuse the same Job to avoid excessive updates
&gt; 	private static Job getRefreshOutlinePagesJob() {
&gt; 		if (refreshJob == null) {
&gt; 			refreshJob = new RefreshOutlinePagesJob();
&gt; 		}
&gt; 		return refreshJob;
&gt; 	}
&gt; 
&gt; 	private static class RefreshOutlinePagesJob extends UIJob {
&gt; 		RefreshOutlinePagesJob() {
&gt; 			super(AspectJUIPlugin
&gt; 					.getResourceString("utils.refresh.outline.job"));
&gt; 		}
&gt; 
&gt; 		public IStatus runInUIThread(IProgressMonitor monitor) {
&gt; 			long start = System.currentTimeMillis();
&gt; 			IWorkbenchWindow[] windows = PlatformUI.getWorkbench()
&gt; 					.getWorkbenchWindows();
&gt; 			for (int i = 0; i &lt; windows.length; i++) {
&gt; 				IWorkbenchPage[] pages = windows[i].getPages();
&gt; 				for (int x = 0; x &lt; pages.length; x++) {
&gt; 					IEditorReference[] editors = pages[x].getEditorReferences();
&gt; 					for (int z = 0; z &lt; editors.length; z++) {
&gt; 						IEditorPart editor = editors[z].getEditor(true);
&gt; 						if (editor != null) {
&gt; 							Object out = editor
&gt; 									.getAdapter(IContentOutlinePage.class);
&gt; 							if (out instanceof JavaOutlinePage) {
&gt; 								refreshOutline((JavaOutlinePage) out);
&gt; 							}
58a91,93
&gt; 			previousExecutionTime = (int)(System.currentTimeMillis() - start);
&gt; 			//System.out.println("refresh outline: elapsed="+previousExecutionTime);
&gt; 			return Status.OK_STATUS;
61c96
&lt; 	
---
&gt; 
66,67c101
&lt; 			Field field = clazz
&lt; 					.getDeclaredField("fOutlineViewer");
---
&gt; 			Field field = clazz.getDeclaredField("fOutlineViewer");
74,80c108,109
&lt; 			method.invoke(outlineViewer,
&lt; 					new Object[] { Boolean.TRUE });
&lt; 			//System.out.println("refreshed outline viewer");
&lt; 			} 
&lt; 			//else {
&lt; 				//System.out.println("outline viewer was null");
&lt; 			//}
---
&gt; 				method.invoke(outlineViewer, new Object[] { Boolean.TRUE });
&gt; 			}
82,83c111
&lt; 			//e.printStackTrace();
&lt; 		}	
---
&gt; 		}
85,86c113,114
&lt; 	
&lt; }
---
&gt; 
&gt; }
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/resources/AspectJPluginResources.properties" revision="1.9" state="changed"/>
</fixedFiles>
</bug>
<bug id="80249" transactionid="70068">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="73"/>
<property name="lines-deleted" value="9"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="82"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-for K-if K-instanceof K-new K-while M O-&lt; O-&lt;= O-&gt; O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl Z-while</fullfingerprint>
<bugreport>Currently, the order in which you specify types when passing them to the
compiler can affect how they are woven:

For example, if we have class A and class B extends A - Also, an aspect that
'declare parents: A+ implements Serializable' then depending on whether we see A
first, we may or may not make B serializable.

The fix is that when we weave a type, we first weave its supertype then its
superinterfaces (if they were also passed to the compiler).

The problematic construct is declare parents - so we only process the types in a
special order if there are declare parents around.  Also, because we can't
currently do decp when binary weaving, the order processing logic is only being
put into the source weaving pipeline.</bugreport>
<testsforfix ID="80249" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="test_typeProcessingOrderWhenDeclareParents"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150-tests.xml">
      <test NAME="Order of types passed to compiler determines weaving behavior"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/80249/pre-fix/testresults.xml" passing="1316" size="1428"/>
<post-fix-testcases failing="114" file="output/80249/post-fix/testresults.xml" passing="1314" size="1428"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.27" state="changed">27,35d26
&lt; import org.aspectj.weaver.AsmRelationshipProvider;
&lt; import org.aspectj.weaver.ConcreteTypeMunger;
&lt; import org.aspectj.weaver.ResolvedTypeMunger;
&lt; import org.aspectj.weaver.ResolvedTypeX;
&lt; import org.aspectj.weaver.TypeX;
&lt; import org.aspectj.weaver.WeaverStateInfo;
&lt; import org.aspectj.weaver.World;
&lt; import org.aspectj.weaver.bcel.LazyClassGen;
&lt; import org.aspectj.weaver.patterns.DeclareParents;
50a42,50
&gt; import org.aspectj.weaver.AsmRelationshipProvider;
&gt; import org.aspectj.weaver.ConcreteTypeMunger;
&gt; import org.aspectj.weaver.ResolvedTypeMunger;
&gt; import org.aspectj.weaver.ResolvedTypeX;
&gt; import org.aspectj.weaver.TypeX;
&gt; import org.aspectj.weaver.WeaverStateInfo;
&gt; import org.aspectj.weaver.World;
&gt; import org.aspectj.weaver.bcel.LazyClassGen;
&gt; import org.aspectj.weaver.patterns.DeclareParents;
122a123,148
&gt; 		
&gt; 		// We now have some list of types to process, and we are about to apply the type mungers.
&gt; 		// There can be situations where the order of types passed to the compiler causes the
&gt; 		// output from the compiler to vary - THIS IS BAD.  For example, if we have class A
&gt; 		// and class B extends A.  Also, an aspect that 'declare parents: A+ implements Serializable'
&gt; 		// then depending on whether we see A first, we may or may not make B serializable.
&gt; 		
&gt; 		// The fix is to process them in the right order, ensuring that for a type we process its 
&gt; 		// supertypes and superinterfaces first.  This algorithm may have problems with:
&gt; 		// - partial hierarchies (e.g. suppose types A,B,C are in a hierarchy and A and C are to be woven but not B)
&gt; 		// - weaving that brings new types in for processing (see pendingTypesToWeave.add() calls) after we thought
&gt; 		//   we had the full list.
&gt; 		// 
&gt; 		// but these aren't common cases (he bravely said...)
&gt; 		boolean typeProcessingOrderIsImportant = declareParents.size()&gt;0;
&gt; 		
&gt; 		if (typeProcessingOrderIsImportant) {
&gt; 			List typesToProcess = new ArrayList();
&gt; 			for (int i=lastCompletedUnitIndex+1; i&lt;=lastUnitIndex; i++) {
&gt; 				CompilationUnitScope cus = units[i].scope;
&gt; 				SourceTypeBinding[] stbs = cus.topLevelTypes;
&gt; 				for (int j=0; j&lt;stbs.length; j++) {
&gt; 					SourceTypeBinding stb = stbs[j];
&gt; 					typesToProcess.add(stb);
&gt; 				}
&gt; 			}
124,125c150,160
&lt; 		for (int i = lastCompletedUnitIndex + 1; i &lt;= lastUnitIndex; i++) {
&lt; 			weaveInterTypeDeclarations(units[i].scope, typeMungers, declareParents);
---
&gt; 			while (typesToProcess.size()&gt;0) {
&gt; 				// A side effect of weaveIntertypes() is that the processed type is removed from the collection
&gt; 				weaveIntertypes(typesToProcess,(SourceTypeBinding)typesToProcess.get(0),typeMungers,declareParents);
&gt; 			}
&gt; 		
&gt; 		} else {
&gt; 			// Order isn't important
&gt; 			for (int i = lastCompletedUnitIndex + 1; i &lt;= lastUnitIndex; i++) {
&gt; 				//System.err.println("Working on "+new String(units[i].getFileName()));
&gt; 				weaveInterTypeDeclarations(units[i].scope, typeMungers, declareParents);
&gt; 			}
127c162
&lt;         
---
&gt; 		
148a184,212
&gt; 	
&gt; 	/**
&gt; 	 * Weave the parents and intertype decls into a given type.  This method looks at the
&gt; 	 * supertype and superinterfaces for the specified type and recurses to weave those first
&gt; 	 * if they are in the full list of types we are going to process during this compile... it stops recursing
&gt; 	 * the first time it hits a type we aren't going to process during this compile.  This could cause problems 
&gt; 	 * if you supply 'pieces' of a hierarchy, i.e. the bottom and the top, but not the middle - but what the hell
&gt; 	 * are you doing if you do that?
&gt; 	 */
&gt; 	private void weaveIntertypes(List typesToProcess,SourceTypeBinding typeToWeave,Collection typeMungers,Collection declareParents) {
&gt; 		// Look at the supertype first
&gt; 	    ReferenceBinding superType = typeToWeave.superclass();
&gt; 	    //System.err.println("Been asked to weave "+new String(typeToWeave.getFileName()));
&gt; 	    if (typesToProcess.contains(superType) &amp;&amp; superType instanceof SourceTypeBinding) {
&gt; 	    	//System.err.println("Recursing to supertype "+new String(superType.getFileName()));
&gt; 	    	weaveIntertypes(typesToProcess,(SourceTypeBinding)superType,typeMungers,declareParents);
&gt; 	    }
&gt; 	    // Then look at the superinterface list
&gt; 		ReferenceBinding[] interfaceTypes = typeToWeave.superInterfaces();
&gt; 	    for (int i = 0; i &lt; interfaceTypes.length; i++) {
&gt; 	    	ReferenceBinding binding = interfaceTypes[i];
&gt; 	    	if (typesToProcess.contains(binding) &amp;&amp; binding instanceof SourceTypeBinding) {
&gt; 		    	//System.err.println("Recursing to superinterface "+new String(binding.getFileName()));
&gt; 	    		weaveIntertypes(typesToProcess,(SourceTypeBinding)binding,typeMungers,declareParents);
&gt; 	    	}
&gt; 		}
&gt; 	    weaveInterTypeDeclarations(typeToWeave,typeMungers,declareParents,false);
&gt; 	    typesToProcess.remove(typeToWeave);
&gt; 	}
353c417
&lt; 
---
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.2" state="changed">29,30c29,34
&lt;   public void test() {
&lt;   	// placeholder for the first test...
---
&gt;   public void test_typeProcessingOrderWhenDeclareParents() {
&gt; 	try {
&gt;   		runTest("Order of types passed to compiler determines weaving behavior");
&gt; 	} finally {
&gt;   		System.err.println(ajc.getLastCompilationResult().getStandardError());
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150-tests.xml" revision="1.2" state="changed">1,2c1,3
&lt; &lt;!-- AspectJ v1.5.0 Tests: Bridge attribute on methods generated to support generics --&gt;
&lt;     
---
&gt; &lt;!-- AspectJ v1.5.0 Tests --&gt;
&gt; 
&gt;    
7a9,15
&gt; 
&gt;     &lt;ajc-test dir="decp" pr="80249" title="Order of types passed to compiler determines weaving behavior"&gt;
&gt;         &lt;compile files="A.java,B.java,AspectX.java"/&gt;
&gt;         &lt;run class="B"/&gt;
&gt;         &lt;compile files="B.java,A.java,AspectX.java"/&gt;
&gt;         &lt;run class="B"/&gt;
&gt;     &lt;/ajc-test&gt;
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.aspectj/modules/tests/decp/A.java" revision="1.1" state="new">public class A {
}
</file>
<file name="org.aspectj/modules/tests/decp/AspectX.java" revision="1.1" state="new">public aspect AspectX {
  declare parents: A+ implements java.io.Serializable;
}
</file>
<file name="org.aspectj/modules/tests/decp/B.java" revision="1.1" state="new">public class B extends A {
	
	public static void main(String[] args) {
		B b = new B();
		if (b.getClass().getInterfaces().length&gt;0) {
			throw new RuntimeException("B should not implement any interfaces: "+b.getClass().getInterfaces()[0].toString());
		}
		if (!(b instanceof java.io.Serializable)) {
			throw new RuntimeException("B should be serializable! Inherited from A");
		}
	}
}
</file>
</fixedFiles>
</bug>
<bug id="80456" transactionid="72763">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="5"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="13"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-true M T V Y</fullfingerprint>
<bugreport>Using Eclipse 3.0.1 and either of AJDT 1.1.12 or 1.2.0 M1, I was unable to 
create an Ant build from Eclipse's build.xml (after creating build.xml from 
plugin.xml).  Similarly, when I use the Export wizard to create "Deployable 
plugins and fragments with AspectJ support," it stops midstream because 
midstream in doing so, a Java Virtual Machine Launcher pops up 
indicating "Could not find the main class. Program will exit."

I use Sun's j2sdk1.4.2_04. The Export wizard settings are:
a) Selection of a single plugin - my aspect plugin project
b) Export Options - Deploy as: a single ZIP file. I keep the default build 
options which select i) Run compiler with verbose output, ii) Compile source 
with debug information.
c) Destination - Filename is a zip file (e.g., foo.zip) in Eclipse data 
directory containing aspect plugin project.</bugreport>
<pre-fix-testcases failing="112" file="output/80456/pre-fix/testresults.xml" passing="1377" size="1489"/>
<post-fix-testcases failing="113" file="output/80456/post-fix/testresults.xml" passing="1376" size="1489"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/internal/exports/AJCTask.java" revision="1.3" state="changed">34c34
&lt; 				ajScript.printProperty("aspectj.plugin.home", AJDELocation);
---
&gt; 				ajScript.printProperty("aspectj.plugin.home", AJDELocation); //$NON-NLS-1$
39,45c39,45
&lt; 			ajScript.println("&lt;taskdef resource=\"org/aspectj/tools/ant/taskdefs/aspectjTaskdefs.properties\"&gt;");
&lt; 			ajScript.printStartTag("classpath");
&lt; 			ajScript.print("&lt;pathelement");
&lt; 			ajScript.printAttribute("path", "${aspectj.plugin.home}/ajde.jar", true);
&lt; 			ajScript.println("/&gt;");
&lt; 			ajScript.printEndTag("classpath");
&lt; 			ajScript.printEndTag("taskdef");
---
&gt; 			ajScript.println("&lt;taskdef resource=\"org/aspectj/tools/ant/taskdefs/aspectjTaskdefs.properties\"&gt;"); //$NON-NLS-1$
&gt; 			ajScript.printStartTag("classpath"); //$NON-NLS-1$
&gt; 			ajScript.print("&lt;pathelement"); //$NON-NLS-1$
&gt; 			ajScript.printAttribute("path", "${aspectj.plugin.home}/ajde.jar", true); //$NON-NLS-1$
&gt; 			ajScript.println("/&gt;"); //$NON-NLS-1$
&gt; 			ajScript.printEndTag("classpath"); //$NON-NLS-1$
&gt; 			ajScript.printEndTag("taskdef"); //$NON-NLS-1$
75a76,80
&gt; 			// Add ajde.jar to this classpath too because we have forked
&gt; 			ajScript.print("&lt;pathelement"); //$NON-NLS-1$
&gt; 			ajScript.printAttribute("path", "${aspectj.plugin.home}/ajde.jar", true); //$NON-NLS-1$
&gt; 			ajScript.println("/&gt;"); //$NON-NLS-1$
&gt; 			
</file>
</fixedFiles>
</bug>
<bug id="80593" transactionid="75101">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="57"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="57"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-false K-if K-import K-new K-null K-package K-throw K-try M O-!= O-+ T V Y Z-if Z-throw</fullfingerprint>
<bugreport>If a build.xml file is created from the plugin.xml for an AspectJ plug-in 
project, it does not build the plug-in correctly.  Add support for build.xml 
files that build AspectJ plug-ins corerctly.</bugreport>
<pre-fix-testcases failing="112" file="output/80593/pre-fix/testresults.xml" passing="1424" size="1536"/>
<post-fix-testcases failing="112" file="output/80593/post-fix/testresults.xml" passing="1424" size="1536"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/plugin.properties" revision="1.9" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/plugin.xml" revision="1.18" state="changed">115c115,128
&lt;       &lt;/objectContribution&gt;      
---
&gt;       &lt;/objectContribution&gt;   
&gt;       &lt;objectContribution
&gt;             objectClass="org.eclipse.core.resources.IFile"
&gt;             nameFilter="plugin.xml"
&gt;             id="org.eclipse.pde.ui.ajpluginToolSet"&gt;      
&gt;                &lt;action
&gt;                label="%CreateAntBuildFile"
&gt;                helpContextId="org.eclipse.pde.doc.user.create_plugin_jars"
&gt;                class="org.eclipse.ajdt.internal.ui.actions.BuildPluginAction"
&gt;                menubarPath="org.eclipse.pde.ui.plugin.tools/group2"
&gt;                enablesFor="1"
&gt;                id="org.eclipse.pde.ui.BuildPluginAction"&gt;
&gt;          &lt;/action&gt;
&gt;       &lt;/objectContribution&gt;   
166a180,191
&gt;       
&gt;       &lt;objectContribution 
&gt;       		objectClass="org.eclipse.ajdt.core.javaelements.AJCompilationUnit"
&gt;             adaptable="true"
&gt;             id="ifilecontributions"&gt;
&gt;           &lt;action
&gt;           	    label="Delete"
&gt;           	    class="org.eclipse.ajdt.ui.refactoring.DeleteAction"
&gt;           	    menubarPath="edit"
&gt;           	    id="delete"&gt;
&gt;           &lt;/action&gt;
&gt;        &lt;/objectContribution&gt;
1487c1512,1523
&lt;       &lt;/renameParticipant&gt;
---
&gt;       &lt;/renameParticipant&gt;   
&gt;     &lt;/extension&gt;  
&gt;     
&gt;     &lt;extension point="org.eclipse.ltk.core.refactoring.deleteParticipants"&gt; 
&gt; 	  &lt;deleteParticipant
&gt; 		    id="org.eclipse.ajdt.deleteParticipant"
&gt; 		    name="org.eclipse.ajdt.deleteParticipant" 
&gt; 		    class="org.eclipse.ajdt.ui.refactoring.DeleteParticipant"&gt;
&gt; 	    &lt;enablement&gt;
&gt; 	        &lt;instanceof value="org.eclipse.ajdt.core.javaelements.AJCompilationUnit"/&gt;
&gt; 	    &lt;/enablement&gt;
&gt; 	 &lt;/deleteParticipant&gt;
1488a1525
&gt;    
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/actions/BuildPluginAction.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others. All rights reserved. This
 * program and the accompanying materials are made available under the terms of
 * the Common Public License v1.0 which accompanies this distribution, and is
 * available at http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors: Sian January - initial version
 * ... 
 ******************************************************************************/
package org.eclipse.ajdt.internal.ui.actions;

import java.lang.reflect.InvocationTargetException;

import org.eclipse.ajdt.internal.exports.AJModelBuildScriptGenerator;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.pde.core.plugin.IPluginModelBase;
import org.eclipse.pde.internal.build.AbstractScriptGenerator;
import org.eclipse.pde.internal.build.builder.DevClassPathHelper;
import org.eclipse.pde.internal.core.PDECore;
import org.eclipse.pde.internal.core.TargetPlatform;
import org.eclipse.pde.internal.ui.build.BaseBuildAction;
import org.eclipse.pde.internal.ui.build.ClasspathHelper;

/**
 * 
 */
public class BuildPluginAction extends BaseBuildAction {

	protected void makeScripts(IProgressMonitor monitor)
		throws InvocationTargetException, CoreException {
	
		AJModelBuildScriptGenerator generator = new AJModelBuildScriptGenerator();
		AJModelBuildScriptGenerator.setOutputFormat(AbstractScriptGenerator.getDefaultOutputFormat());
		AJModelBuildScriptGenerator.setEmbeddedSource(AbstractScriptGenerator.getDefaultEmbeddedSource());
		AJModelBuildScriptGenerator.setForceUpdateJar(AbstractScriptGenerator.getForceUpdateJarFormat());
		AJModelBuildScriptGenerator.setConfigInfo(AbstractScriptGenerator.getDefaultConfigInfos());
		
		IProject project = fManifestFile.getProject();
		generator.setWorkingDirectory(project.getLocation().toOSString());
		String url = ClasspathHelper.getDevEntriesProperties(project.getLocation().addTrailingSeparator().toString() + "dev.properties", false); //$NON-NLS-1$
		generator.setDevEntries(new DevClassPathHelper(url));
		generator.setPluginPath(TargetPlatform.createPluginPath());
		generator.setBuildingOSGi(PDECore.getDefault().getModelManager().isOSGiRuntime());
		try {
			IPluginModelBase model = PDECore.getDefault().getModelManager().findModel(project);
			if (model != null) {
				generator.setModelId(model.getPluginBase().getId());
				generator.generate();
			}
		} catch (CoreException e) {
			throw new InvocationTargetException(e);
		}
	}

}
</file>
</fixedFiles>
</bug>
<bug id="80916" transactionid="68867">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V</fullfingerprint>
<bugreport>With a project containing one class and one aspect:

public class HelloClass {

	public static void main(String[] args) {
		new HelloClass().sayHello();
	}
	
	public void sayHello() {
		System.out.println("Hello");
	}
	
}


public aspect A1 {

	pointcut test() : get(* System.out);
	
	declare warning : test() &amp;&amp; !within(A1)
		 : "test warning";
	
	pointcut anotherTest() : 
		execution(void HelloClass.sayHello(..));
	
	after() returning : anotherTest() {
		System.out.println("returning....");
	}
		
}

The following is returned from the structure model:

asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: uses 
pointcut, target: A1.anotherTest()
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: advises, 
target: HelloClass.sayHello()
asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.anotherTest(), relationship: pointcut used by, target: 
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.declare warning: "test warning", relationship: matched by, 
target: HelloClass.sayHello()

In other words, the model is saying that there are two entries the same:

asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: 
A1.afterReturning(): anotherTest..

whereas one of these should be the "matches declare" relationship relating to 
the declare warning.

Changing the aspect to be:


public aspect A1 {

	pointcut test() : get(* System.out);
	
	declare warning : test() &amp;&amp; !within(A1)
		 : "test warning";
	
	pointcut anotherTest() : 
		execution(void HelloClass.sayHello(..));
	
	after() returning : anotherTest() {
		System.out.println("returning....");
	}
	
	after() returning : test() {
		System.out.println("returning again!");
	}
	
}

means that the IRelationshipMap does now contain the "matches declare" 
relationship.

This is all with AspectJ 5 M1.</bugreport>
<pre-fix-testcases failing="113" file="output/80916/pre-fix/testresults.xml" passing="1408" size="1521"/>
<post-fix-testcases failing="112" file="output/80916/post-fix/testresults.xml" passing="1409" size="1521"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java" revision="1.12" state="changed">45a46,48
&gt; 		// Ensure a node for the target exists
&gt; 		IProgramElement targetNode = getNode(AsmManager.getDefault().getHierarchy(), shadow);
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="80920" transactionid="74387">
<property name="files-churned" value="11"/>
<property name="java-files-churned" value="10"/>
<property name="classes-churned" value="10"/>
<property name="methods-churned" value="10"/>
<property name="hunks" value="34"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="19"/>
<property name="lines-modified" value="53"/>
<property name="lines-churned" value="74"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-false K-for K-if K-import K-null K-return K-true M O-! O-!= O-() O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>When using the Resources and Markers provider for the Visualiser, whenever you 
make a selection (in the Visualiser or in an editor), the Visualiser menu 
settings are reset.

This is using ajdt build dated 1.2.0.20041213231035.</bugreport>
<pre-fix-testcases failing="111" file="output/80920/pre-fix/testresults.xml" passing="1425" size="1536"/>
<post-fix-testcases failing="111" file="output/80920/post-fix/testresults.xml" passing="1425" size="1536"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/VisualiserCanvas.java" revision="1.11" state="changed">247c247
&lt; 		onlyShowAction.setText(VisualiserPlugin.getResourceString("OnlyShow"));
---
&gt; 		onlyShowAction.setText(VisualiserPlugin.getResourceString("OnlyShow")); //$NON-NLS-1$
781c781
&lt; 				List mems = (List) ig.getMembers();
---
&gt; 				List mems = ig.getMembers();
932c932
&lt; 								throw new NullPointerException(VisualiserPlugin.getResourceString("getColorForError"));
---
&gt; 								throw new NullPointerException(VisualiserPlugin.getResourceString("getColorForError")); //$NON-NLS-1$
976d975
&lt; 		IMarkupProvider vmp = visualiser.getVisMarkupProvider();
978,988d976
&lt; 		//		List markups = vmp.getMemberMarkups(m);
&lt; 		//		if ((markups != null) &amp;&amp; (markups.size() &gt; 0)) {
&lt; 		//			for (Iterator iter = markups.iterator(); iter.hasNext();) {
&lt; 		//				Stripe s = (Stripe) iter.next();
&lt; 		//				int dp = s.getDepth();
&lt; 		//				if (dp &lt; VisualiserPreferences.getStripeHeight()) {
&lt; 		//					dp = VisualiserPreferences.getStripeHeight();
&lt; 		//				}
&lt; 		//				size += dp - 1;
&lt; 		//			}
&lt; 		//		}
1025c1013
&lt; 				doScroll((ScrollBar) event.widget, true);
---
&gt; 				redraw();
1033c1021
&lt; 				doScroll((ScrollBar) event.widget, false);
---
&gt; 				redraw();
1038,1041d1025
&lt; 	private void doScroll(ScrollBar bar, boolean isHoriz) {
&lt; 		redraw();
&lt; 	}
&lt; 
1101c1085
&lt; 				empty = ProviderManager.getCurrent().getEmptyMessage() != null ? ProviderManager.getCurrent().getEmptyMessage() : "";
---
&gt; 				empty = ProviderManager.getCurrent().getEmptyMessage() != null ? ProviderManager.getCurrent().getEmptyMessage() : ""; //$NON-NLS-1$
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/Visualiser.java" revision="1.10" state="changed">107c107
&lt; 			getSite().getPage().showView("org.eclipse.contribution.visualiser.views.Menu");
---
&gt; 			getSite().getPage().showView("org.eclipse.contribution.visualiser.views.Menu"); //$NON-NLS-1$
268c268
&lt; 				.getResourceString("Absolute_Proportions"));
---
&gt; 				.getResourceString("Absolute_Proportions")); //$NON-NLS-1$
270c270
&lt; 				.getResourceString("Absolute_Proportions"));
---
&gt; 				.getResourceString("Absolute_Proportions")); //$NON-NLS-1$
458c458
&lt; 		 		 		 redrawJob = new UIJob(VisualiserPlugin.getResourceString("Jobs.VisualiserRedraw")) {
---
&gt; 		 		 		 redrawJob = new UIJob(VisualiserPlugin.getResourceString("Jobs.VisualiserRedraw")) { //$NON-NLS-1$
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/palettes/DefaultVisualiserPalette.java" revision="1.2" state="changed">160,162c160,162
&lt; 		int r = (int) (((int) (Math.random() * (double) 40)) * 5 + 50);
&lt; 		int g = (int) (((int) (Math.random() * (double) 40)) * 5 + 50);
&lt; 		int b = (int) (((int) (Math.random() * (double) 40)) * 5 + 50);
---
&gt; 		int r = (((int) (Math.random() * 40)) * 5 + 50);
&gt; 		int g = (((int) (Math.random() * 40)) * 5 + 50);
&gt; 		int b = (((int) (Math.random() * 40)) * 5 + 50);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/jdtImpl/JDTSearchResultsContentProvider.java" revision="1.2" state="changed">30d29
&lt; 	private boolean searchViewWasClosed = true;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/Menu.java" revision="1.9" state="changed">182c182
&lt; 						kindActive.put((IMarkupKind)labels[i].getData(),new Boolean(checkboxes[i].getSelection()));	
---
&gt; 						kindActive.put(labels[i].getData(),new Boolean(checkboxes[i].getSelection()));	
246c246
&lt; 				kindActive.put((IMarkupKind)labels[i].getData(),new Boolean(checkboxes[i].getSelection()));
---
&gt; 				kindActive.put(labels[i].getData(), new Boolean(checkboxes[i].getSelection()));
260c260
&lt; 				kindActive.put((IMarkupKind)labels[i].getData(),new Boolean(false));
---
&gt; 				kindActive.put(labels[i].getData(), new Boolean(false));
282c282
&lt; 					kindActive.put((IMarkupKind)labels[i].getData(),new Boolean(true));
---
&gt; 					kindActive.put(labels[i].getData(), new Boolean(true));
285c285
&lt; 					kindActive.put((IMarkupKind)labels[i].getData(),new Boolean(false));
---
&gt; 					kindActive.put(labels[i].getData(), new Boolean(false));
346c346
&lt; 		 		 		 updateJob = new UIJob(VisualiserPlugin.getResourceString("Jobs.VisualiserMenuUpdate")){
---
&gt; 		 		 		 updateJob = new UIJob(VisualiserPlugin.getResourceString("Jobs.VisualiserMenuUpdate")){ //$NON-NLS-1$
374c374
&lt; 		 		 		 		 		 		 		 		 throw new NullPointerException(VisualiserPlugin.getResourceString("getColorForError"));
---
&gt; 		 		 		 		 		 		 		 		 throw new NullPointerException(VisualiserPlugin.getResourceString("getColorForError")); //$NON-NLS-1$
454a455
&gt; 	    canvas = null;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/utils/MarkupUtils.java" revision="1.2" state="changed">29c29
&lt; 		long start = System.currentTimeMillis();
---
&gt; //		long start = System.currentTimeMillis();
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/simpleImpl/SimpleGroup.java" revision="1.3" state="changed">144,145c144,148
&lt; 		return VisualiserPlugin.getResourceString("SimpleGroup") + ":[" + name + "] " + VisualiserPlugin.getResourceString("Size") + ":[" + getSize() + "]  Kids:["
&lt; 				+ kids.size() + "]";
---
&gt; 		return VisualiserPlugin.getResourceString("SimpleGroup") + ":[" + name //$NON-NLS-1$ //$NON-NLS-2$
&gt;                 + "] " + VisualiserPlugin.getResourceString("Size") + ":["//$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
&gt;                 + getSize() + "]  "//$NON-NLS-1$
&gt;                 + VisualiserPlugin.getResourceString("Children") + ":["//$NON-NLS-1$ //$NON-NLS-2$
&gt;                 + kids.size() + "]";//$NON-NLS-1$
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/utils/JDTUtils.java" revision="1.4" state="changed">73d72
&lt; 				String source = cUnit.getSource();
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/VisualiserPluginResources.properties" revision="1.6" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/markerImpl/ResourceContentProvider.java" revision="1.2" state="changed">17d16
&lt; import java.util.Iterator;
36c35
&lt; import org.eclipse.jface.viewers.StructuredSelection;
---
&gt; import org.eclipse.jface.viewers.IStructuredSelection;
61,67c60,75
&lt; 		if(selection instanceof StructuredSelection) {
&lt; 			StructuredSelection struct = (StructuredSelection)selection;
&lt; 			for(Iterator it = struct.iterator(); it.hasNext();) {
&lt; 				Object o = it.next();
&lt; 				if(o instanceof IResource) {
&lt; 					selectedResource = (IResource)o;
&lt; 					break;
---
&gt; 		if(!(ProviderManager.getContentProvider().equals(this))){
&gt; 			return;
&gt; 		}
&gt; 		boolean updateRequired = false;
&gt; 		if (selection instanceof IStructuredSelection) {
&gt; 			IStructuredSelection structuredSelection =
&gt; 				(IStructuredSelection) selection;
&gt; 			Object o = structuredSelection.getFirstElement();
&gt; 
&gt; 			if (o != null) {
&gt; 				if (o instanceof IResource) {
&gt; 				    IResource r = (IResource) o;
&gt; 					if (selectedResource != r) { //Fix for bug 80920 - test to see whether or not the selection has *actually* changed.
&gt; 						selectedResource = r;
&gt; 						updateRequired = true;
&gt; 					}
70,71c78,82
&lt; 						selectedResource = ((IJavaElement)o).getCorrespondingResource();
&lt; 						break;
---
&gt; 						IResource r = ((IJavaElement)o).getCorrespondingResource();
&gt; 						if (selectedResource != r) { //Fix for bug 80920 - test to see whether or not the selection has *actually* changed.
&gt; 							selectedResource = r;
&gt; 							updateRequired = true;
&gt; 						}
75c86
&lt; 				}				
---
&gt; 				}
78c89
&lt; 		if(ProviderManager.getContentProvider().equals(this) &amp;&amp; selectedResource != null) {
---
&gt; 		if(updateRequired &amp;&amp; selectedResource != null) {
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/simpleImpl/SimpleMember.java" revision="1.2" state="changed">12a13
&gt; import org.eclipse.contribution.visualiser.VisualiserPlugin;
41,42c42,45
&lt; 		return "SimpleMember:[" + fullname + "] Size:[" + size.toString() + "]";
&lt; 	}
---
&gt; 		return VisualiserPlugin.getResourceString("SimpleMember") + ":[" //$NON-NLS-1$ //$NON-NLS-2$
&gt;                 + fullname + "] " + VisualiserPlugin.getResourceString("Size") //$NON-NLS-1$ //$NON-NLS-2$
&gt;                 + ":[" + size.toString() + "]"; //$NON-NLS-1$ //$NON-NLS-2$
&gt;     }
56c59
&lt; 				fullname = containingGroup.getFullname()+"."+name;	
---
&gt; 				fullname = containingGroup.getFullname() + "." + name; //$NON-NLS-1$
</file>
</fixedFiles>
</bug>
<bug id="81846" transactionid="69357">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new K-return M O-&lt; O-&gt;= O-() O-&amp;&amp; O-+ T V Y Z-if Z-while</fullfingerprint>
<bugreport>java.lang.ArrayIndexOutOfBoundsException: 3

Unfortunately I can't provide much more information, please see the attached 
compiler dump.</bugreport>
<pre-fix-testcases failing="70" file="output/81846/pre-fix/testresults.xml" passing="872" size="942"/>
<post-fix-testcases failing="70" file="output/81846/post-fix/testresults.xml" passing="872" size="942"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java" revision="1.13" state="changed">83,84c83,84
&lt;         while (((c = extract[trimLeftIndex++]) == TAB) || (c == SPACE)) {
&lt;         };
---
&gt;         while (   (((c = extract[trimLeftIndex++]) == TAB) || (c == SPACE)) &amp;&amp; trimLeftIndex&lt;extract.length   ) { };
&gt; 		if (trimLeftIndex&gt;=extract.length) return new String(extract)+"\n";
</file>
</fixedFiles>
</bug>
<bug id="81863" transactionid="70908">
<property name="files-churned" value="7"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="12"/>
<property name="hunks" value="15"/>
<property name="lines-added" value="15"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="16"/>
<property name="lines-churned" value="31"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-instanceof K-return K-this K-true M O-! O-() O-&amp;&amp; O-instanceof T V Z-if</fullfingerprint>
<bugreport>From discussion on aspectj list:

Hi,

Well, having just done some testing, I think this even simpler case shows 
within() is not behaving correctly for annotations:

@Entity
public class myClass1 {...}

public class myClass2 {...}

public aspect myAspect {
  before():call(* *(..)) &amp;&amp; within(@Entity *) {
  }
}

The pointcut matches all the method calls in myClass1 and myClass2 
(effectively it is parsing but then ignoring the annotation specified
in the within()).

So, what you want to do is valid but AspectJ is misbehaving - you get a 
stack overflow because the perthis() clause is also matching on your aspect 
type when obviously that doesnt have the annotation and shouldnt be matched.



Andy.
---
Andy Clement
AspectJ Development



Rifflard Mickal &lt;Mickael.Rifflard@atosorigin.com&gt; 
Sent by: aspectj-users-admin@eclipse.org
22/12/2004 16:56
Please respond to
aspectj-users@eclipse.org
	
To
&lt;aspectj-users@eclipse.org&gt;
cc

Subject
[aspectj-users] Aspect instance on JDK 1.5 annotation
	

	


Hi all, 
I'm currently trying to get an aspect instance for an object instance with
specific JDK 1.5 annotation. 
Exemple : 
        Create an aspect instance for all object like that : 
        @Entity 
        public class myClass { ... } 
I try 
        public aspect myAspect perthis(within(@Entity *)) {...} 
but this aspect execution lead to a java.lang.StackOverflowError exception. 
Is it possible ? 
Thanks. 
        Mickal 
        
_______________________________________________ aspectj-users mailing list
aspectj-users@eclipse.org http://dev.eclipse.org/mailman/listinfo/aspectj-users</bugreport>
<testsforfix ID="81863" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.java">
      <test NAME="test003_Within_Code"/>
      <test NAME="test004_Within"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/81863/pre-fix/testresults.xml" passing="1408" size="1520"/>
<post-fix-testcases failing="112" file="output/81863/post-fix/testresults.xml" passing="1408" size="1520"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java" revision="1.17" state="changed">92c92,94
&lt; 		return this.type.equals(matchType);
---
&gt; 		boolean typeMatch = this.type.equals(matchType);
&gt; 		boolean annMatch = this.annotationPattern.matches(matchType).alwaysTrue();
&gt; 		return (typeMatch &amp;&amp; annMatch);
99c101,102
&lt; 		if (type.equals(ResolvedTypeX.OBJECT)) return FuzzyBoolean.YES;
---
&gt; 		if (type.equals(ResolvedTypeX.OBJECT)) 
&gt; 		    return FuzzyBoolean.YES.and(annotationPattern.matches(matchType));
102c105
&lt; 			return FuzzyBoolean.YES;
---
&gt; 			return FuzzyBoolean.YES.and(annotationPattern.matches(matchType));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/TypePattern.java" revision="1.14" state="changed">28a29
&gt; import org.aspectj.weaver.World;
94,95c95,97
&lt; 			typeMatch = FuzzyBoolean.fromBoolean(matchesStatically(type));
&lt; 			return typeMatch.and(annotationPattern.matches(type));
---
&gt; //			typeMatch = FuzzyBoolean.fromBoolean(matchesStatically(type));
&gt; //			return typeMatch.and(annotationPattern.matches(type));
&gt; 		    return FuzzyBoolean.fromBoolean(matchesStatically(type));
98c100
&lt; 			typeMatch = matchesInstanceof(type);
---
&gt; //			typeMatch = matchesInstanceof(type);
100c102,103
&lt; 			return typeMatch.and(annotationPattern.matches(type));
---
&gt; //			return typeMatch.and(annotationPattern.matches(type));
&gt; 		    return matchesInstanceof(type);
220a224,227
&gt;     public void resolve(World world) {
&gt;         annotationPattern.resolve(world);
&gt;     }
&gt;     
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java" revision="1.5" state="changed">85a86,89
&gt;     public FuzzyBoolean fastMatches(AnnotatedElement annotated) {
&gt;         return FuzzyBoolean.YES;
&gt;     }
&gt;     
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java" revision="1.18" state="changed">45c45
&lt; 			if (typePattern.matchesStatically(type)) {
---
&gt; 			if (typePattern.matchesStatically(type)) {			    
58c58,61
&lt; 		return isWithinType(info.getType());
---
&gt; 	    if (typePattern.annotationPattern instanceof AnyAnnotationTypePattern) {
&gt; 	        return isWithinType(info.getType());
&gt; 	    }
&gt; 	    return FuzzyBoolean.MAYBE;
69a73
&gt; 		typePattern.resolve(shadow.getIWorld());
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java" revision="1.11" state="changed">63a64,65
&gt; 		exceptionType.resolve(shadow.getIWorld());
&gt; 		
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java" revision="1.24" state="changed">117c117,118
&lt; 		return matchesExactlyByName(targetTypeName);
---
&gt; 		return matchesExactlyByName(targetTypeName) &amp;&amp;
&gt; 		       annotationPattern.matches(type).alwaysTrue();
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java" revision="1.11" state="changed">84c84,85
&lt; 		annotationType = annotationType.resolve(world);
---
&gt; 		if (!resolved) annotationType = annotationType.resolve(world);
&gt; 		resolved = true;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.java" revision="1.3" state="changed">48a49,70
&gt;   public void test003_Within_Code() {
&gt;   	baseDir = new File("../tests/java5/annotations/within_code");
&gt;       CompilationResult cR = binaryWeave("TestingAnnotations.jar","WithinAndWithinCodeTests.java",0,5);
&gt;       List warnings = new ArrayList();
&gt;       warnings.add(new Message(32,"@within match on non-inherited annotation"));
&gt;       warnings.add(new Message(39,"@within match on non-inherited annotation"));
&gt;       warnings.add(new Message(39,"@within match on inheritable annotation"));
&gt;       warnings.add(new Message(43,"@within match on inheritable annotation"));
&gt;       warnings.add(new Message(32,"@withincode match"));
&gt;       MessageSpec mSpec = new MessageSpec(warnings,new ArrayList());
&gt;       assertMessages(cR,mSpec); 	
&gt;   }
&gt;   
&gt;   public void test004_Within() {
&gt;     	baseDir = new File("../tests/java5/annotations/within");
&gt;         CompilationResult cR = binaryWeave("PlainWithin.jar","PlainWithinTests.java",0,2);
&gt;         List warnings = new ArrayList();
&gt;         warnings.add(new Message(21,"positive within match on annotation"));
&gt;         warnings.add(new Message(25,"negative within match on annotation"));
&gt;         MessageSpec mSpec = new MessageSpec(warnings,new ArrayList());
&gt;         assertMessages(cR,mSpec); 	
&gt;     }
51,52d72
&lt;   // 1) @within  (matches, does not match, matches inherited annotation)
&lt;   // 2) @withincode (matches, does not match)
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/AnnotationRuntimeTests.java" revision="1.6" state="changed">78,89d77
&lt;     public void test007_Within_Code() {
&lt;     	baseDir = new File("../tests/java5/annotations/within_code");
&lt;         CompilationResult cR = binaryWeave("TestingAnnotations.jar","WithinAndWithinCodeTests.java",0,5);
&lt;         List warnings = new ArrayList();
&lt;         warnings.add(new Message(32,"@within match on non-inherited annotation"));
&lt;         warnings.add(new Message(39,"@within match on non-inherited annotation"));
&lt;         warnings.add(new Message(39,"@within match on inheritable annotation"));
&lt;         warnings.add(new Message(43,"@within match on inheritable annotation"));
&lt;         warnings.add(new Message(32,"@withincode match"));
&lt;         MessageSpec mSpec = new MessageSpec(warnings,new ArrayList());
&lt;         assertMessages(cR,mSpec); 	
&lt;     }
</file>
<file name="org.aspectj/modules/tests/java5/annotations/within/PlainWithin.java" revision="1.2" state="changed">18c18
&lt; @MyClassRetententionAnnotation
---
&gt; @MyAnnotation
</file>
<file name="org.aspectj/modules/tests/java5/annotations/within/PlainWithin.jar" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="82062" transactionid="69590">
<property name="files-churned" value="5"/>
<property name="java-files-churned" value="5"/>
<property name="classes-churned" value="5"/>
<property name="methods-churned" value="5"/>
<property name="hunks" value="16"/>
<property name="lines-added" value="38"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="19"/>
<property name="lines-churned" value="58"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-import K-new K-null K-return K-this K-while M O-- O-!= O-() O-+ T V Y Z-while</fullfingerprint>
<bugreport>It would be wonderful if the WeaveMessage object would provide two additional
things:

- the affected class name
- the aspect name

I could use this to determine which aspect is woven into which class during
load-time weaving (need this for dependency management).</bugreport>
<pre-fix-testcases failing="114" file="output/82062/pre-fix/testresults.xml" passing="1407" size="1521"/>
<post-fix-testcases failing="113" file="output/82062/post-fix/testresults.xml" passing="1408" size="1521"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWorld.java" revision="1.17" state="changed">212c212
&lt; 	private BcelObjectType makeBcelObjectType(ResolvedTypeX.Name resolvedTypeX, JavaClass jc, boolean exposedToWeaver) {
---
&gt; 	protected BcelObjectType makeBcelObjectType(ResolvedTypeX.Name resolvedTypeX, JavaClass jc, boolean exposedToWeaver) {
</file>
<file name="org.aspectj/modules/bridge/src/org/aspectj/bridge/WeaveMessage.java" revision="1.3" state="changed">35a36,39
&gt; 	private String affectedtypename;
&gt; 	private String aspectname;
&gt; 
&gt; 
37c41
&lt; 	private WeaveMessage(String message) {
---
&gt; 	private WeaveMessage(String message, String affectedtypename, String aspectname) {
38a43,44
&gt; 		this.affectedtypename = affectedtypename;
&gt; 		this.aspectname = aspectname;
44a51,68
&gt;      * @return new weaving message
&gt;      */
&gt; 	public static WeaveMessage constructWeavingMessage(
&gt; 	  WeaveMessageKind kind,
&gt; 	  String[] inserts) {
&gt; 		StringBuffer str = new StringBuffer(kind.getMessage());
&gt; 		int pos = -1;
&gt; 		while ((pos=new String(str).indexOf("%"))!=-1) {
&gt; 			int n = Character.getNumericValue(str.charAt(pos+1));
&gt; 			str.replace(pos,pos+2,inserts[n-1]);
&gt; 		}
&gt; 		return new WeaveMessage(str.toString(), null, null);
&gt; 	}
&gt; 	
&gt;     /**
&gt;      * Static helper method for constructing weaving messages.
&gt;      * @param kind what kind of message (e.g. declare parents)
&gt;      * @param inserts inserts for the message (inserts are marked %n in the message)
51c75,77
&lt; 	  String[] inserts) {
---
&gt; 	  String[] inserts,
&gt; 	  String affectedtypename,
&gt; 	  String aspectname) {
58c84
&lt; 		return new WeaveMessage(str.toString());
---
&gt; 		return new WeaveMessage(str.toString(), affectedtypename, aspectname);
60a87,92
&gt; 	/**
&gt; 	 * @return Returns the aspectname.
&gt; 	 */
&gt; 	public String getAspectname() {
&gt; 		return aspectname;
&gt; 	}
61a94,99
&gt; 	/**
&gt; 	 * @return Returns the affectedtypename.
&gt; 	 */
&gt; 	public String getAffectedtypename() {
&gt; 		return affectedtypename;
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.23" state="changed">113c113,114
&lt; 					tName,parentTM.getNewParent().getName(),fName}));
---
&gt; 					tName,parentTM.getNewParent().getName(),fName},
&gt; 					weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
122c123,124
&lt;         					 fName+":'"+munger.getSignature()+"'"}));
---
&gt;         					 fName+":'"+munger.getSignature()+"'"},
&gt; 							 weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
771a774
&gt; 		
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Advice.java" revision="1.15" state="changed">20d19
&lt; import org.aspectj.bridge.ISourceLocation;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Shadow.java" revision="1.25" state="changed">25c25,27
&lt; import org.aspectj.bridge.*;
---
&gt; import org.aspectj.bridge.IMessage;
&gt; import org.aspectj.bridge.ISourceLocation;
&gt; import org.aspectj.bridge.Message;
26a29
&gt; import org.aspectj.bridge.WeaveMessage;
419c422,424
&lt; 			    			 advisingType,beautifyLocation(munger.getSourceLocation())});
---
&gt; 			    			 advisingType,beautifyLocation(munger.getSourceLocation())},
&gt; 				advisedType,
&gt; 				advisingType);
423c428
&lt; 			  new String[]{ advisedType, beautifyLocation(getSourceLocation()),
---
&gt; 		    		new String[]{ advisedType, beautifyLocation(getSourceLocation()),
426c431,433
&lt; 				            (runtimeTest?" [with runtime test]":"")});
---
&gt; 				            (runtimeTest?" [with runtime test]":"")},
&gt; 					advisedType,
&gt; 					advisingType);
</file>
</fixedFiles>
</bug>
<bug id="82134" transactionid="68799">
<property name="files-churned" value="58"/>
<property name="java-files-churned" value="58"/>
<property name="classes-churned" value="58"/>
<property name="methods-churned" value="63"/>
<property name="hunks" value="181"/>
<property name="lines-added" value="118"/>
<property name="lines-deleted" value="51"/>
<property name="lines-modified" value="123"/>
<property name="lines-churned" value="292"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-else K-false K-for K-if K-import K-instanceof K-new K-null K-package K-return K-super K-this K-throw M O-&lt; O-&gt; O-&gt;= O-!= O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-throw Z-vardecl</fullfingerprint>
<bugreport>Hi Adrian,

thanks for the detailed explanation of the compatibility questions. That 
explains the problem I observed.

&gt; * An AspectJ program should always be run with the aspectjrt.jar runtime 
&gt; library that accompanies the distribution containing the compiler/weaver 
&gt; used to build it. 

Interesting point. Which one? The one that is used to compile it or the 
one that is used to weave it?

&gt; However, instead of some IOException, what you should see is a nice 
&gt; message saying that the aspect was produced by a more recent version of 
&gt; AspectJ and cannot be read. Likewise, if you load a pre-aspectj 5 aspect 
&gt; into the AspectJ 5 weaver right now, you'll also see an IOException 
&gt; (odds-on). In M2 we'll detect that and use the back-level loaders to read 
&gt; it in.

Okay. Is there a bug to track this? I really would like to update the 
weaver of my weaving runtime but only if it allows to load/weave 
asepects that are compiled with any of the AJDT versions that are out 
right now (AJDT 1.1.x and AJDT 1.2.0Mx).</bugreport>
<testsforfix ID="82134" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/MigrationTests.java">
      <test NAME="testMigrationFrom121_pointcutsAndAdvice"/>
      <test NAME="testMigrationFrom120_pointcutsAndAdvice"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="132" file="output/82134/pre-fix/testresults.xml" passing="1404" size="1536"/>
<post-fix-testcases failing="112" file="output/82134/post-fix/testresults.xml" passing="1424" size="1536"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PerClause.java" revision="1.6" state="changed">16d15
&lt; import java.io.DataInputStream;
25c24
&lt; 	public static PerClause readPerClause(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static PerClause readPerClause(VersionedDataInputStream s, ISourceContext context) throws IOException {
46c45
&lt;         public static Kind read(DataInputStream s) throws IOException {
---
&gt;         public static Kind read(VersionedDataInputStream s) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/TypePattern.java" revision="1.15" state="changed">16d15
&lt; import java.io.DataInputStream;
27a27
&gt; import org.aspectj.weaver.VersionedDataInputStream;
270c270
&lt; 	public static TypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static TypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java" revision="1.10" state="changed">12d11
&lt; import java.io.DataInputStream;
30a30
&gt; import org.aspectj.weaver.VersionedDataInputStream;
230c230
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java" revision="1.19" state="changed">16d15
&lt; import java.io.DataInputStream;
30a30
&gt; import org.aspectj.weaver.VersionedDataInputStream;
124c124
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java" revision="1.20" state="changed">16d15
&lt; import java.io.DataInputStream;
39a39
&gt; import org.aspectj.weaver.VersionedDataInputStream;
109c109
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/NamePattern.java" revision="1.4" state="changed">16d15
&lt; import java.io.DataInputStream;
19a19,20
&gt; import org.aspectj.weaver.VersionedDataInputStream;
&gt; 
138c139
&lt; 	public static NamePattern read(DataInputStream in) throws IOException {
---
&gt; 	public static NamePattern read(VersionedDataInputStream in) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java" revision="1.11" state="changed">16d15
&lt; import java.io.DataInputStream;
22a22
&gt; import org.aspectj.weaver.VersionedDataInputStream;
78c78
&lt; 	public static TypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static TypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java" revision="1.6" state="changed">12d11
&lt; import java.io.DataInputStream;
20a20
&gt; import org.aspectj.weaver.VersionedDataInputStream;
67c67
&lt; 	public static AnnotationTypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java" revision="1.7" state="changed">16d15
&lt; import java.io.DataInputStream;
23a23
&gt; import org.aspectj.weaver.VersionedDataInputStream;
63c63
&lt; 	public static Declare read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Declare read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java" revision="1.18" state="changed">16d15
&lt; import java.io.DataInputStream;
34a34
&gt; import org.aspectj.weaver.VersionedDataInputStream;
130c130
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelMethod.java" revision="1.14" state="changed">93c93
&lt; 		List as = BcelAttributes.readAjAttributes(method.getAttributes(), getSourceContext(world),world.getMessageHandler());
---
&gt; 		List as = BcelAttributes.readAjAttributes(getDeclaringType().getClassName(),method.getAttributes(), getSourceContext(world),world.getMessageHandler());
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java" revision="1.9" state="changed">16d15
&lt; import java.io.DataInputStream;
22a22
&gt; import org.aspectj.weaver.VersionedDataInputStream;
132c132
&lt; 	public static ThrowsPattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static ThrowsPattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java" revision="1.4" state="changed">12d11
&lt; import java.io.DataInputStream;
18a18
&gt; import org.aspectj.weaver.VersionedDataInputStream;
51c51
&lt; 	public static AnnotationTypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/Pointcut.java" revision="1.22" state="changed">16d15
&lt; import java.io.DataInputStream;
34a34
&gt; import org.aspectj.weaver.VersionedDataInputStream;
301c301
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PerSingleton.java" revision="1.8" state="changed">16d15
&lt; import java.io.DataInputStream;
25a25
&gt; import org.aspectj.weaver.VersionedDataInputStream;
74c74
&lt; 	public static PerClause readPerClause(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static PerClause readPerClause(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java" revision="1.5" state="changed">12d11
&lt; import java.io.DataInputStream;
18a18
&gt; import org.aspectj.weaver.VersionedDataInputStream;
57c57
&lt; 	public static AnnotationTypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/NotPointcut.java" revision="1.12" state="changed">16d15
&lt; import java.io.DataInputStream;
27a27
&gt; import org.aspectj.weaver.VersionedDataInputStream;
120c120
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java" revision="1.20" state="changed">16d15
&lt; import java.io.DataInputStream;
41a41
&gt; import org.aspectj.weaver.VersionedDataInputStream;
173c173
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PerObject.java" revision="1.8" state="changed">16d15
&lt; import java.io.DataInputStream;
30a30
&gt; import org.aspectj.weaver.VersionedDataInputStream;
118c118
&lt; 	public static PerClause readPerClause(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static PerClause readPerClause(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java" revision="1.22" state="changed">16d15
&lt; import java.io.DataInputStream;
32a32
&gt; import org.aspectj.weaver.VersionedDataInputStream;
110c110
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java" revision="1.5" state="changed">12d11
&lt; import java.io.DataInputStream;
20a20
&gt; import org.aspectj.weaver.VersionedDataInputStream;
158c158
&lt; 	public static AnnotationPatternList read(DataInputStream s, ISourceContext context) throws IOException  {
---
&gt; 	public static AnnotationPatternList read(VersionedDataInputStream s, ISourceContext context) throws IOException  {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java" revision="1.11" state="changed">16d15
&lt; import java.io.DataInputStream;
22a22
&gt; import org.aspectj.weaver.VersionedDataInputStream;
82c82
&lt; 	public static TypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static TypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AjAttribute.java" revision="1.11" state="changed">18d17
&lt; import java.io.DataInputStream;
85,86c84,85
&lt; 
&lt; 	public static AjAttribute read(String name, byte[] bytes, ISourceContext context,IMessageHandler msgHandler) {
---
&gt; 	
&gt; 	public static AjAttribute read(AjAttribute.WeaverVersionInfo v, String name, byte[] bytes, ISourceContext context,IMessageHandler msgHandler) {
89c88,89
&lt; 			DataInputStream s = new DataInputStream(new ByteArrayInputStream(bytes));
---
&gt; 			VersionedDataInputStream s = new VersionedDataInputStream(new ByteArrayInputStream(bytes));
&gt; 			s.setVersion(v);
198a199,203
&gt; 		// When we don't know ... (i.e. pre 1.2.1)
&gt; 		public static short WEAVER_VERSION_MAJOR_UNKNOWN = 0;
&gt; 		public static short WEAVER_VERSION_MINOR_UNKNOWN = 0;
&gt; 		
&gt; 		
200,201c205,210
&lt; 		private static short WEAVER_VERSION_MAJOR_AJ121 = 1;
&lt; 		private static short WEAVER_VERSION_MINOR_AJ121 = 0;
---
&gt; 		public static short WEAVER_VERSION_MAJOR_AJ121 = 1;
&gt; 		public static short WEAVER_VERSION_MINOR_AJ121 = 0;
&gt; 		
&gt; 		// These are the weaver major/minor numbers for AspectJ 1.5.0
&gt; 		public static short WEAVER_VERSION_MAJOR_AJ150 = 2;
&gt; 		public static short WEAVER_VERSION_MINOR_AJ150 = 0;
204,205c213,217
&lt; 		private static short CURRENT_VERSION_MAJOR      = WEAVER_VERSION_MAJOR_AJ121;
&lt; 		private static short CURRENT_VERSION_MINOR      = WEAVER_VERSION_MINOR_AJ121;
---
&gt; 		private static short CURRENT_VERSION_MAJOR      = WEAVER_VERSION_MAJOR_AJ150;
&gt; 		private static short CURRENT_VERSION_MINOR      = WEAVER_VERSION_MINOR_AJ150;
&gt; 		
&gt; 		public static final WeaverVersionInfo UNKNOWN = 
&gt; 			new WeaverVersionInfo(WEAVER_VERSION_MAJOR_UNKNOWN,WEAVER_VERSION_MINOR_UNKNOWN);
231c243
&lt; 		public static WeaverVersionInfo read(DataInputStream s) throws IOException {
---
&gt; 		public static WeaverVersionInfo read(VersionedDataInputStream s) throws IOException {
234c246,248
&lt; 			return new WeaverVersionInfo(major,minor);
---
&gt; 			WeaverVersionInfo wvi = new WeaverVersionInfo(major,minor);
&gt; //			s.setVersion(wvi);		
&gt; 			return wvi;
282c296
&lt; 		public static SourceContextAttribute read(DataInputStream s) throws IOException {
---
&gt; 		public static SourceContextAttribute read(VersionedDataInputStream s) throws IOException {
314c328
&lt; 		public static MethodDeclarationLineNumberAttribute read(DataInputStream s) throws IOException {
---
&gt; 		public static MethodDeclarationLineNumberAttribute read(VersionedDataInputStream s) throws IOException {
420c434
&lt; 		public static AdviceAttribute read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 		public static AdviceAttribute read(VersionedDataInputStream s, ISourceContext context) throws IOException {
547c561
&lt; 		public static PrivilegedAttribute read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 		public static PrivilegedAttribute read(VersionedDataInputStream s, ISourceContext context) throws IOException {
574c588
&lt; 		public static EffectiveSignatureAttribute read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 		public static EffectiveSignatureAttribute read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java" revision="1.5" state="changed">12d11
&lt; import java.io.DataInputStream;
18a18
&gt; import org.aspectj.weaver.VersionedDataInputStream;
62c62
&lt; 	public static AnnotationTypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java" revision="1.5" state="changed">13d12
&lt; import java.io.DataInputStream;
31a31
&gt; import org.aspectj.weaver.VersionedDataInputStream;
197c197
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java" revision="1.20" state="changed">16d15
&lt; import java.io.DataInputStream;
33a33
&gt; import org.aspectj.weaver.VersionedDataInputStream;
260c260
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java" revision="1.22" state="changed">38d37
&lt; import org.aspectj.weaver.AjAttribute.WeaverVersionInfo;
172c171
&lt; 		List l = BcelAttributes.readAjAttributes(javaClass.getAttributes(), getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler());
---
&gt; 		List l = BcelAttributes.readAjAttributes(javaClass.getClassName(),javaClass.getAttributes(), getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler());
193,200c192
&lt; 				wvInfo = (AjAttribute.WeaverVersionInfo)a;
&lt; 				if (wvInfo.getMajorVersion() &gt; WeaverVersionInfo.getCurrentWeaverMajorVersion()) {
&lt; 					// The class file containing this attribute was created by a version of AspectJ that
&lt; 					// added some behavior that 'this' version of AspectJ doesn't understand.  And the
&lt; 					// class file contains changes that mean 'this' version of AspectJ cannot continue.
&lt; 					throw new BCException("Unable to continue, this version of AspectJ supports classes built with weaver version "+
&lt; 							WeaverVersionInfo.toCurrentVersionString()+" but the class "+ javaClass.getClassName()+" is version "+wvInfo.toString());
&lt; 				}
---
&gt; 				wvInfo = (AjAttribute.WeaverVersionInfo)a; // Set the weaver version used to build this type
206a199,204
&gt; 		// Test isn't quite right, leaving this out for now...
&gt; //		if (isAspect() &amp;&amp; wvInfo.getMajorVersion() == WeaverVersionInfo.UNKNOWN.getMajorVersion()) {
&gt; //			throw new BCException("Unable to continue, this version of AspectJ cannot use aspects as input that were built "+
&gt; //					"with an AspectJ earlier than version 1.2.1.  Please rebuild class: "+javaClass.getClassName());
&gt; //		}
&gt; 		
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/TypePatternList.java" revision="1.9" state="changed">16d15
&lt; import java.io.DataInputStream;
27a27
&gt; import org.aspectj.weaver.VersionedDataInputStream;
474c474
&lt; 	public static TypePatternList read(DataInputStream s, ISourceContext context) throws IOException  {
---
&gt; 	public static TypePatternList read(VersionedDataInputStream s, ISourceContext context) throws IOException  {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.java" revision="1.4" state="changed">16d15
&lt; import java.io.DataInputStream;
22a22,23
&gt; import org.aspectj.weaver.VersionedDataInputStream;
&gt; 
61c62
&lt; 	public static ModifiersPattern read(DataInputStream s) throws IOException {
---
&gt; 	public static ModifiersPattern read(VersionedDataInputStream s) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclareParents.java" revision="1.12" state="changed">16d15
&lt; import java.io.DataInputStream;
26a26
&gt; import org.aspectj.weaver.VersionedDataInputStream;
89c89
&lt; 	public static Declare read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Declare read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java" revision="1.5" state="changed">12d11
&lt; import java.io.DataInputStream;
22a22
&gt; import org.aspectj.weaver.VersionedDataInputStream;
105c105
&lt; 	public static AnnotationTypePattern read(DataInputStream s,ISourceContext context) throws IOException {
---
&gt; 	public static AnnotationTypePattern read(VersionedDataInputStream s,ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java" revision="1.8" state="changed">16d15
&lt; import java.io.DataInputStream;
23a23
&gt; import org.aspectj.weaver.VersionedDataInputStream;
68c68
&lt; 	public static Declare read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Declare read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java" revision="1.11" state="changed">16d15
&lt; import java.io.DataInputStream;
22a22
&gt; import org.aspectj.weaver.VersionedDataInputStream;
79c79
&lt; 	public static TypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static TypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java" revision="1.12" state="changed">12d11
&lt; import java.io.DataInputStream;
23a23
&gt; import org.aspectj.weaver.VersionedDataInputStream;
154c154
&lt; 	public static AnnotationTypePattern read(DataInputStream s,ISourceContext context) throws IOException {
---
&gt; 	public static AnnotationTypePattern read(VersionedDataInputStream s,ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java" revision="1.8" state="changed">16d15
&lt; import java.io.DataInputStream;
55c54
&lt; 	public static ResolvedPointcutDefinition read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static ResolvedPointcutDefinition read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java" revision="1.6" state="changed">12d11
&lt; import java.io.DataInputStream;
29a29
&gt; import org.aspectj.weaver.VersionedDataInputStream;
165c165
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelField.java" revision="1.11" state="changed">55c55
&lt; 		List as = BcelAttributes.readAjAttributes(attrs, getSourceContext(world),world.getMessageHandler());
---
&gt; 		List as = BcelAttributes.readAjAttributes(getDeclaringType().getClassName(),attrs, getSourceContext(world),world.getMessageHandler());
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AndPointcut.java" revision="1.13" state="changed">16d15
&lt; import java.io.DataInputStream;
28a28
&gt; import org.aspectj.weaver.VersionedDataInputStream;
123c123
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PerCflow.java" revision="1.9" state="changed">16d15
&lt; import java.io.DataInputStream;
35a35
&gt; import org.aspectj.weaver.VersionedDataInputStream;
108c108
&lt; 	public static PerClause readPerClause(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static PerClause readPerClause(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java" revision="1.7" state="changed">16d15
&lt; import java.io.DataInputStream;
22a22
&gt; import org.aspectj.weaver.VersionedDataInputStream;
62c62
&lt; 	public static TypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static TypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeaverStateInfo.java" revision="1.5" state="changed">87c87
&lt; 	public static final WeaverStateInfo read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static final WeaverStateInfo read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java" revision="1.6" state="changed">12d11
&lt; import java.io.DataInputStream;
21a21
&gt; import org.aspectj.weaver.VersionedDataInputStream;
106c106
&lt; 	public static AnnotationTypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java" revision="1.4" state="changed">16d15
&lt; import java.io.DataInputStream;
20a20
&gt; import org.aspectj.weaver.VersionedDataInputStream;
70c70
&lt; 	public static Declare read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Declare read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java" revision="1.11" state="changed">16d15
&lt; import java.io.DataInputStream;
29a29
&gt; import org.aspectj.weaver.VersionedDataInputStream;
94c94
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java" revision="1.6" state="changed">23a24
&gt; import org.aspectj.weaver.BCException;
24a26
&gt; import org.aspectj.weaver.AjAttribute.WeaverVersionInfo;
31c33
&lt; 	public static List readAjAttributes(Attribute[] as, ISourceContext context,IMessageHandler msgHandler) {
---
&gt; 	public static List readAjAttributes(String classname,Attribute[] as, ISourceContext context,IMessageHandler msgHandler) {
32a35
&gt; 		AjAttribute.WeaverVersionInfo version = new WeaverVersionInfo();
39c42,52
&lt; 					AjAttribute attr = AjAttribute.read(name, u.getBytes(), context,msgHandler);
---
&gt; 					AjAttribute attr = AjAttribute.read(version,name,u.getBytes(),context,msgHandler); 
&gt; 					if (attr!=null &amp;&amp; attr instanceof AjAttribute.WeaverVersionInfo) {
&gt; 						version = (AjAttribute.WeaverVersionInfo)attr;
&gt; 						
&gt; 						// Do a version check, this weaver can't process versions 
&gt; 						// from a future AspectJ (where the major number has changed)
&gt; 						if (version.getMajorVersion() &gt; WeaverVersionInfo.getCurrentWeaverMajorVersion()) {
&gt; 							throw new BCException("Unable to continue, this version of AspectJ supports classes built with weaver version "+
&gt; 									WeaverVersionInfo.toCurrentVersionString()+" but the class "+classname+" is version "+version.toString());
&gt; 						}
&gt; 					}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java" revision="1.8" state="changed">16d15
&lt; import java.io.DataInputStream;
25a25
&gt; import org.aspectj.weaver.VersionedDataInputStream;
91c91
&lt; 	public static PerClause readPerClause(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static PerClause readPerClause(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java" revision="1.18" state="changed">22a23
&gt; import org.aspectj.weaver.AjAttribute;
26a28
&gt; import org.aspectj.weaver.VersionedDataInputStream;
200c202,210
&lt; 	public static TypePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static TypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
&gt; 		if (s.getMajorVersion()&gt;=AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150) {
&gt; 			return readTypePattern150(s,context);
&gt; 		} else {
&gt; 			return readTypePatternOldStyle(s,context);
&gt; 	    }
&gt;     }
&gt; 	
&gt; 	public static TypePattern readTypePattern150(VersionedDataInputStream s, ISourceContext context) throws IOException {
209c219,225
&lt;     public String toString() {
---
&gt; 	public static TypePattern readTypePatternOldStyle(DataInputStream s, ISourceContext context) throws IOException {
&gt; 		TypePattern ret = new ExactTypePattern(TypeX.read(s), s.readBoolean(),false);
&gt; 		ret.readLocation(context, s);
&gt; 		return ret;
&gt; 	}
&gt; 
&gt; 	public String toString() {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/IfPointcut.java" revision="1.20" state="changed">16d15
&lt; import java.io.DataInputStream;
35a35
&gt; import org.aspectj.weaver.VersionedDataInputStream;
103c103
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java" revision="1.6" state="changed">12d11
&lt; import java.io.DataInputStream;
28a28
&gt; import org.aspectj.weaver.VersionedDataInputStream;
185c185
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java" revision="1.8" state="changed">12d11
&lt; import java.io.DataInputStream;
31a31
&gt; import org.aspectj.weaver.VersionedDataInputStream;
179c179
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java" revision="1.25" state="changed">16d15
&lt; import java.io.DataInputStream;
26a26
&gt; import org.aspectj.weaver.AjAttribute;
30a31
&gt; import org.aspectj.weaver.VersionedDataInputStream;
610,614c611,640
&lt; 	public static TypePattern read(DataInputStream s, ISourceContext context) throws IOException {
&lt; 		byte version = s.readByte();
&lt; 		if (version &gt; VERSION) {
&lt; 			throw new BCException("WildTypePattern was written by a more recent version of AspectJ, cannot read");
&lt; 		}
---
&gt; 	public static TypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
&gt; 		if (s.getMajorVersion()&gt;=AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150) {
&gt; 			return readTypePattern150(s,context);
&gt; 		} else {
&gt; 			return readTypePatternOldStyle(s,context);
&gt; 	    }
&gt;     }
&gt; 
&gt;     public static TypePattern readTypePattern150(VersionedDataInputStream s, ISourceContext context) throws IOException {
&gt; 	  byte version = s.readByte();
&gt; 	  if (version &gt; VERSION) {
&gt; 		throw new BCException("WildTypePattern was written by a more recent version of AspectJ, cannot read");
&gt; 	  }
&gt; 	  int len = s.readShort();
&gt; 	  NamePattern[] namePatterns = new NamePattern[len];
&gt; 	  for (int i=0; i &lt; len; i++) {
&gt; 		namePatterns[i] = NamePattern.read(s);
&gt; 	  }
&gt; 	  boolean includeSubtypes = s.readBoolean();
&gt; 	  int dim = s.readInt();
&gt; 	  boolean varArg = s.readBoolean();
&gt; 	  WildTypePattern ret = new WildTypePattern(namePatterns, includeSubtypes, dim, varArg);
&gt; 	  ret.knownMatches = FileUtil.readStringArray(s);
&gt; 	  ret.importedPrefixes = FileUtil.readStringArray(s);
&gt; 	  ret.readLocation(context, s);
&gt; 	  ret.setAnnotationTypePattern(AnnotationTypePattern.read(s,context));
&gt; 	  return ret;
&gt; 	}
&gt;     
&gt; 	public static TypePattern readTypePatternOldStyle(VersionedDataInputStream s, ISourceContext context) throws IOException {
622,623c648
&lt; 		boolean varArg = s.readBoolean();
&lt; 		WildTypePattern ret = new WildTypePattern(namePatterns, includeSubtypes, dim,varArg);
---
&gt; 		WildTypePattern ret = new WildTypePattern(namePatterns, includeSubtypes, dim, false);
627d651
&lt; 		ret.setAnnotationTypePattern(AnnotationTypePattern.read(s,context));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java" revision="1.12" state="changed">16d15
&lt; import java.io.DataInputStream;
28a28
&gt; import org.aspectj.weaver.VersionedDataInputStream;
131c131
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java" revision="1.33" state="changed">444c444
&lt; 		List as = BcelAttributes.readAjAttributes(attributes, context,null);
---
&gt; 		List as = BcelAttributes.readAjAttributes(getClassName(),attributes, context,null);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java" revision="1.24" state="changed">16d15
&lt; import java.io.DataInputStream;
32a32
&gt; import org.aspectj.weaver.AjAttribute;
39a40
&gt; import org.aspectj.weaver.VersionedDataInputStream;
519c520
&lt; 	public static SignaturePattern read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static SignaturePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
527c528,534
&lt; 		AnnotationTypePattern annotationPattern = AnnotationTypePattern.read(s,context);
---
&gt; 		
&gt; 		AnnotationTypePattern annotationPattern = AnnotationTypePattern.ANY;
&gt; 		
&gt; 		if (s.getMajorVersion()&gt;=AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150) {
&gt; 		  annotationPattern = AnnotationTypePattern.read(s,context);
&gt; 		}
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AdviceKind.java" revision="1.4" state="changed">16d15
&lt; import java.io.DataInputStream;
38c37
&lt;     public static AdviceKind read(DataInputStream s) throws IOException {
---
&gt;     public static AdviceKind read(VersionedDataInputStream s) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/Declare.java" revision="1.5" state="changed">16d15
&lt; import java.io.DataInputStream;
19a19
&gt; import org.aspectj.weaver.VersionedDataInputStream;
27c27
&lt; 	public static Declare read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Declare read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/OrPointcut.java" revision="1.15" state="changed">16d15
&lt; import java.io.DataInputStream;
28a28
&gt; import org.aspectj.weaver.VersionedDataInputStream;
126c126
&lt; 	public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
---
&gt; 	public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java" revision="1.7" state="changed">297c297
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java" revision="1.5" state="changed">145c145
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java" revision="1.5" state="changed">120c120
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/NamePatternTestCase.java" revision="1.4" state="changed">18d17
&lt; import java.io.DataInputStream;
21a21,22
&gt; import org.aspectj.weaver.VersionedDataInputStream;
&gt; 
114c115
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java" revision="1.8" state="changed">26a27
&gt; 		suite.addTestSuite(MigrationTests.class);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/DeclareErrorOrWarningTestCase.java" revision="1.3" state="changed">17a18,19
&gt; import org.aspectj.weaver.VersionedDataInputStream;
&gt; 
56c58
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java" revision="1.4" state="changed">229c229
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/SignaturePatternTestCase.java" revision="1.3" state="changed">169c169
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/bcel/PatternWeaveTestCase.java" revision="1.5" state="changed">111c111
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/MigrationTests.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2004 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
package org.aspectj.systemtest.ajc150;

import java.io.File;

import org.aspectj.tools.ajc.CompilationResult;


/**
 * Checks if we are obeying migration rules. 
 */
public class MigrationTests extends TestUtils {
	
  protected void setUp() throws Exception {
	super.setUp();
	baseDir = new File("../tests/migration");
  }

  /**
   * Compile a simple java class with an aspect library built with aspectj 1.2.1 - this
   * checks that we can load in attributes (especially pointcuts) that were written out
   * in the 'old way'
   *
   */
  public void testMigrationFrom121_pointcutsAndAdvice() {
  	CompilationResult cR = ajc(baseDir,new String[]{"-aspectpath","aspects121.jar","Program.java"});
  	System.err.println(cR.getStandardError());
  	assertTrue("Should not coredump: "+cR.getStandardError(),cR.getStandardError().indexOf("Dumping to ajcore")==-1);
    assertTrue("Should be no error messages: \n"+cR.getErrorMessages(),cR.getErrorMessages().size()==0);
    File f = new File(ajc.getSandboxDirectory()+File.separator+"Program.class");
    assertTrue("Missing class file",f.exists());
  	run("Program");
  }
  
//  /**
//   * We cannot support all aspects built prior to AspectJ 1.2.1 - so we don't support any.
//   * There are probably many reasons but the first one I've hit is:
//   * - Changes for cflow optimizations (counters instead of stacks where we can) mean that an aspect
//   *   compiled at AspectJ1.2.0 will contain stack cases but AspectJ1.5.0 will look for counter
//   *   fields in some cases.
//   * 
//   * This means we should get a reasonable failure message in this case.
//   */
//  public void testMigrationFrom120_pointcutsAndAdvice() {
//  	CompilationResult cR = ajc(baseDir,new String[]{"-aspectpath","aspects120.jar","Program.java"});
//  	assertTrue("Should have failed",cR.getFailMessages().size()&gt;0);
//  	assertTrue("Should have produced nice message",cR.getFailMessages().get(0).toString().indexOf("Unable to continue")!=-1);
//  }
 
}</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/TypePatternListTestCase.java" revision="1.4" state="changed">184c184
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/ModifiersPatternTestCase.java" revision="1.4" state="changed">133c133
&lt; 		DataInputStream in = new DataInputStream(bi);
---
&gt; 		VersionedDataInputStream in = new VersionedDataInputStream(bi);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/VersionedDataInputStream.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2005 IBM
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Andy Clement           initial implementation
 * ******************************************************************/

package org.aspectj.weaver;	

import java.io.DataInputStream;
import java.io.InputStream;

import org.aspectj.weaver.AjAttribute.WeaverVersionInfo;

/**
 * Lightweight subclass of DataInputStream that knows what version of the weaver was used to construct the data in it.
 */
public class VersionedDataInputStream extends DataInputStream {
	private WeaverVersionInfo version = new WeaverVersionInfo();// assume we are the latest unless something tells us otherwise...
	public VersionedDataInputStream(InputStream is) { super(is); }
	
	public int getMajorVersion() { return version.getMajorVersion(); }
	public int getMinorVersion() { return version.getMinorVersion(); }
	
	public void setVersion(WeaverVersionInfo version) { this.version = version; }
}</file>
</fixedFiles>
</bug>
<bug id="82171" transactionid="74214">
<property name="files-churned" value="9"/>
<property name="java-files-churned" value="9"/>
<property name="classes-churned" value="9"/>
<property name="methods-churned" value="9"/>
<property name="hunks" value="32"/>
<property name="lines-added" value="139"/>
<property name="lines-deleted" value="29"/>
<property name="lines-modified" value="24"/>
<property name="lines-churned" value="192"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-class K-import K-interface K-new K-package K-return K-this M T V Y</fullfingerprint>
<bugreport>Proposal pasted from the following email discussion:
http://dev.eclipse.org/mhonarc/lists/ajdt-dev/msg00379.html

We finally seem to be both have more support for working directly with the
Java Model, and more need to do so.  Here's an idea for a light-weight
update to our architecture that will give us transparent access for working
with the relationship map using either the IJavaElements or
IProgramElements.

The idea is that we change the handle identifiers, used for storing entries
in the map, to be the same those used by the JavaModel, i.e.
IJavaElement.getHandleIdentifier().  That will allow us to ask for
relationships for IJavaElements, and get back a list of handles that an
adapter can turn into IJavaElements.  

Currently our identifiers are a source location including path, line, and
column number.  The Java model uses the handles that look like the
following, "=Project-l/src&lt;pkg1{Foo.java[Foo~m1", which uniquely identify
members, are stable across builds and Eclipse invocations, but don't go
below the member signature.  So our adapter will have to extend these by
appending either line/column or offset information to reach at "code"
elements (e.g. calls, handlers).  That's doable, and these handles should
just get ignored by JavaCore as desired.  But I'm wondering what they should
correspond to in our extended Java Model, perhaps a subtype of
SourceRefElement called ICodeElement?  We should get JDT Core to add
something like that anyway, but they'll probably want to call it
IUnknownElement or IGenericRefElement to provide other projects with the
same sort of extensibility.  Another challenge will be generating the
project part of the handle because our compiler doesn't know about
workspaces.  I hope that info can be extracted from the full path and source
path information.  Then for other IDEs we can simply use the same relative
path convention.</bugreport>
<testsforfix ID="82171" type="changed">
    <file LOCATION="org.aspectj/modules/docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java">
      <test NAME="testDeclares"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="111" file="output/82171/pre-fix/testresults.xml" passing="1430" size="1541"/>
<post-fix-testcases failing="111" file="output/82171/post-fix/testresults.xml" passing="1430" size="1541"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java" revision="1.17" state="changed">58c58
&lt; 		String sourceHandle = ProgramElement.createHandleIdentifier(
---
&gt; 		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
64c64
&lt; 		String targetHandle = ProgramElement.createHandleIdentifier(
---
&gt; 		String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
93c93
&lt; 			sourceHandle = ProgramElement.createHandleIdentifier(
---
&gt; 			sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
99c99
&lt; 			sourceHandle = ProgramElement.createHandleIdentifier(
---
&gt; 			sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
107c107
&lt; 			String targetHandle = ProgramElement.createHandleIdentifier(
---
&gt; 			String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
129c129
&lt; 		String sourceHandle = ProgramElement.createHandleIdentifier(decp.getSourceFile(),decp.getLine(),decp.getColumn(),decp.getOffset());
---
&gt; 		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(decp.getSourceFile(),decp.getLine(),decp.getColumn(),decp.getOffset());
134c134
&lt; 		String targetHandle = ProgramElement.createHandleIdentifier(
---
&gt; 		String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
157c157
&lt; 		String sourceHandle = ProgramElement.createHandleIdentifier(declareAnnotationLocation.getSourceFile(),declareAnnotationLocation.getLine(),
---
&gt; 		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(declareAnnotationLocation.getSourceFile(),declareAnnotationLocation.getLine(),
161c161
&lt; 		String targetHandle = ProgramElement.createHandleIdentifier(
---
&gt; 		String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
387c387
&lt; 	      ProgramElement.createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
---
&gt;             AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
428c428
&lt; 		  ProgramElement.createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
---
&gt;             AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
</file>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/AsmManager.java" revision="1.15" state="changed">36a37
&gt;     private IElementHandleProvider handleProvider;
47,48d47
&lt; 	
&lt; 
65a65
&gt;         handleProvider = new FullPathHandleProvider(); 
161a162,169
&gt;     public IElementHandleProvider getHandleProvider() {
&gt;         return handleProvider;
&gt;     }
&gt;     
&gt;     public void setHandleProvider(IElementHandleProvider handleProvider) {
&gt;         this.handleProvider = handleProvider;
&gt;     }
&gt;     
791a800
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ShadowMunger.java" revision="1.9" state="changed">17a18
&gt; import org.aspectj.asm.AsmManager;
90c91
&lt; 				handle = ProgramElement.createHandleIdentifier(
---
&gt; 				handle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
</file>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/internal/ProgramElement.java" revision="1.22" state="changed">34,35d33
&lt; 	static final String ID_DELIM = "|";
&lt; 		
450,461d447
&lt; 	public static String createHandleIdentifier(File sourceFile, int line,int column,int offset) {
&lt; 			StringBuffer sb = new StringBuffer();
&lt; 			sb.append(AsmManager.getDefault().getCanonicalFilePath(sourceFile));
&lt; 			sb.append(ID_DELIM);
&lt; 			sb.append(line);
&lt; 			sb.append(ID_DELIM);
&lt; 			sb.append(column);
&lt; 			sb.append(ID_DELIM);
&lt; 			sb.append(offset);
&lt; 			return sb.toString();		
&lt; 	}
&lt; 
466,467c452,454
&lt; 			    return genHandleIdentifier(sourceLocation);
&lt; 			}
---
&gt;                 return AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation);
&gt; //			    return genHandleIdentifier(sourceLocation);
&gt; 			} 
471,483d457
&lt; 
&lt; 	public static String genHandleIdentifier(ISourceLocation sourceLocation) {
&lt; 		StringBuffer sb = new StringBuffer();
&lt; 		sb.append(AsmManager.getDefault()
&lt; 							.getCanonicalFilePath(sourceLocation.getSourceFile()));
&lt; 		sb.append(ID_DELIM);
&lt; 		sb.append(sourceLocation.getLine());
&lt; 		sb.append(ID_DELIM);
&lt; 		sb.append(sourceLocation.getColumn());
&lt; 		sb.append(ID_DELIM);
&lt; 		sb.append(sourceLocation.getOffset());
&lt; 		return sb.toString();
&lt; 	}
</file>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java" revision="1.14" state="changed">39,43c39,45
&lt; 		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
&lt; 		String file = st.nextToken();
&lt; 		int line = new Integer(st.nextToken()).intValue();
&lt; 		// int col = new Integer(st.nextToken()).intValue(); TODO: use column number when available
&lt; 		String canonicalSFP = AsmManager.getDefault().getCanonicalFilePath(new File(file));
---
&gt; //		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
&gt; //        int line = new Integer(st.nextToken()).intValue();
&gt;         // int col = new Integer(st.nextToken()).intValue(); TODO: use column number when available
&gt;         String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
&gt;         int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
&gt;         
&gt;         String canonicalSFP = AsmManager.getDefault().getCanonicalFilePath(new File(file));
321,323c323,325
&lt; 		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
&lt; 		String file = st.nextToken();
&lt; 		int line = new Integer(st.nextToken()).intValue();
---
&gt; //		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
&gt; //		String file = st.nextToken();
&gt; //		int line = new Integer(st.nextToken()).intValue();
325a328,330
&gt;         String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
&gt;         int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
&gt;         
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AsmInterTypeRelationshipProvider.java" revision="1.8" state="changed">50c50
&lt; 			String sourceHandle = ProgramElement.createHandleIdentifier(
---
&gt; 			String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
56c56
&lt; 			String targetHandle = ProgramElement.createHandleIdentifier(
---
&gt; 			String targetHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java" revision="1.30" state="changed">372c372
&lt;                 foreward.addTarget(ProgramElement.genHandleIdentifier(member.getSourceLocation()));            
---
&gt;                 foreward.addTarget(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(member.getSourceLocation()));            
374c374
&lt;                 IRelationship back = AsmManager.getDefault().getRelationshipMap().get(ProgramElement.genHandleIdentifier(member.getSourceLocation()), IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
---
&gt;                 IRelationship back = AsmManager.getDefault().getRelationshipMap().get(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(member.getSourceLocation()), IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
</file>
<file name="org.aspectj/modules/docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java" revision="1.3" state="changed">62c62
&lt;     		String sourceHandle = ProgramElement.createHandleIdentifier(
---
&gt;     		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
66c66
&lt;     		String superHandle = ProgramElement.createHandleIdentifier(
---
&gt;     		String superHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
</file>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/internal/FullPathHandleProvider.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/

package org.aspectj.asm.internal;

import java.io.File;
import java.util.StringTokenizer;

import org.aspectj.asm.AsmManager;
import org.aspectj.asm.IElementHandleProvider;
import org.aspectj.bridge.ISourceLocation;

/**
 * @author Mik Kersten
 */
public class FullPathHandleProvider implements IElementHandleProvider {

    static final String ID_DELIM = "|";
    
    public String createHandleIdentifier(ISourceLocation location) {
        StringBuffer sb = new StringBuffer();
        sb.append(AsmManager.getDefault()
                            .getCanonicalFilePath(location.getSourceFile()));
        sb.append(ID_DELIM);
        sb.append(location.getLine());
        sb.append(ID_DELIM);
        sb.append(location.getColumn());
        sb.append(ID_DELIM);
        sb.append(location.getOffset());
        return sb.toString();
    }
    
    public String createHandleIdentifier(File sourceFile, int line,int column,int offset) {
        StringBuffer sb = new StringBuffer();
        sb.append(AsmManager.getDefault().getCanonicalFilePath(sourceFile));
        sb.append(ID_DELIM);
        sb.append(line);
        sb.append(ID_DELIM);
        sb.append(column);
        sb.append(ID_DELIM);
        sb.append(offset);
        return sb.toString();       
    }

    public String getFileForHandle(String handle) {
        StringTokenizer st = new StringTokenizer(handle, ID_DELIM);
        String file = st.nextToken();
        return file;
    }

    public int getLineNumberForHandle(String handle) {
        StringTokenizer st = new StringTokenizer(handle, ID_DELIM);
        st.nextToken(); // skip over the file
        return new Integer(st.nextToken()).intValue();
    }
}
</file>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/IElementHandleProvider.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/

package org.aspectj.asm;

import java.io.File;

import org.aspectj.bridge.ISourceLocation;

/**
 * Adapter used to uniquely identify program element handles.  Can be
 * implemented and overridden in @see{AsmManager} in order to provide
 * IDE-specific mechanisms of identifying elements.  For example, AJDT
 * uses workspace-relative paths that are understood by its JavaCore 
 * class.  
 * 
 * @author Mik Kersten
 */
public interface IElementHandleProvider {

    /**
     * @return  a String uniquely identifying this element
     */
    public String createHandleIdentifier(ISourceLocation location);

    /**
     * @return  a String uniquely identifying this element
     */
    public String createHandleIdentifier(File sourceFile, int line,int column,int offset);

    /**
     * NOTE: this is necessary for the current implementation to look up nodes, 
     * but we may want to consider removing it.
     * 
     * @return a String corresponding to the  
     */
    public String getFileForHandle(String handle);
    
    /**
     * NOTE: this is necessary for the current implementation to look up nodes, 
     * but we may want to consider removing it.
     * 
     * @return the line number corresponding to this handel
     */
    public int getLineNumberForHandle(String handle);
    
}
</file>
</fixedFiles>
</bug>
<bug id="82218" transactionid="74238">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="20"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="28"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-else K-if K-package K-return M O-- O-!= O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>Using AJDT 1.2.0M2 {with Java 5 JRE on XP SP2}, install Spacewar example and
generate to Spacewar/docs.  
Result: output has no cross-references (and displays special AJDT tags), and
stderr lists this exception:

java.lang.StringIndexOutOfBoundsException: String index out of range: -1
	at java.lang.AbstractStringBuilder.insert(AbstractStringBuilder.java:980)
	at java.lang.StringBuffer.insert(StringBuffer.java:447)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.insertDeclarationsDetails(HtmlDecorator.java:350)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.addAspectDocumentation(HtmlDecorator.java:234)
	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:188)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:116)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54)
	at
org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43)
	at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</bugreport>
<testsforfix ID="82218" type="new">
    <file LOCATION="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/JDKVersionTest.java">
      <test NAME="testIsUsing1point4"/>
      <test NAME="testIsUsing1point5"/>
    </file>
    <file LOCATION="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java">
      <test NAME="testCoveragePublicMode"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="113" file="output/82218/pre-fix/testresults.xml" passing="1423" size="1536"/>
<post-fix-testcases failing="115" file="output/82218/post-fix/testresults.xml" passing="1421" size="1536"/>
<fixedFiles>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java" revision="1.13" state="changed">404c404
&lt;         if (index1 &lt; index2) {
---
&gt;         if (index1 &lt; index2 &amp;&amp; index1 != -1) {
406,407c406
&lt;         }
&lt;         else {
---
&gt;         } else if (index2 != -1){
408a408,409
&gt;         } else {
&gt;             return index;
419,420c420,421
&lt;         int index3 = fbs.indexOf(MARKER_3, index);
&lt;         if (index1 &lt; index2 &amp;&amp; index1 &lt; index3) {
---
&gt;         int index3 = fbs.indexOf(MARKER_3, index); 
&gt;         if (index1 != -1 &amp;&amp; index1 &lt; index2 &amp;&amp; index1 &lt; index3) {
422,423c423
&lt;         }
&lt;         else if (index2 &lt; index1 &amp;&amp; index2 &lt; index3) {
---
&gt;         } else if (index2 != -1 &amp;&amp; index2 &lt; index1 &amp;&amp; index2 &lt; index3) {
425,426c425
&lt;         }
&lt;         else {
---
&gt;         } else if (index3 != -1) {
427a427,428
&gt;         } else {
&gt;             return index;
</file>
<file name="org.aspectj/modules/ajdoc/testdata/coverage/foo/ModelCoverage.java" revision="1.2" state="changed">122c122
&lt;     declare parents: Point+ implements java.util.Observable;
---
&gt; //    declare parents: Point+ implements java.util.Observable;
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/JDKVersionTest.java" revision="1.1" state="new">/*
 * Created on Jan 12, 2005
  */
package org.aspectj.tools.ajdoc;

import junit.framework.TestCase;

/**
 * @author Mik Kersten
 */
public class JDKVersionTest extends TestCase {

//    public void testIsUsing1point4() {
//        String v = System.getProperty("java.class.version","44.0");
//        assertTrue(("49.0".compareTo(v) &gt; 0) &amp;&amp; ("48.0".compareTo(v) &lt;= 0));
//        assertFalse(Util.isExecutingOnJava5());
//    }

    public void testIsUsing1point5() {
        assertTrue(Util.isExecutingOnJava5());
    }
    
}
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java" revision="1.9" state="changed">36c36,37
&lt; 	 
---
&gt; 	File file10 = new File("testdata/coverage/foo/NoMembers.java");
&gt;     
56a58,71
&gt;     public void testCoveragePublicMode() {
&gt;         outdir.delete();
&gt;         String[] args = { 
&gt;             "-public",
&gt;             "-source", 
&gt;             "1.4",
&gt;             "-d", 
&gt;             outdir.getAbsolutePath(),
&gt;             file3.getAbsolutePath(),
&gt;             file9.getAbsolutePath() 
&gt;         };
&gt;         org.aspectj.tools.ajdoc.Main.main(args);
&gt;     }
&gt;     
76,90c91,92
&lt; 			file9.getAbsolutePath()
&lt; 		};
&lt; 		org.aspectj.tools.ajdoc.Main.main(args);
&lt; 	}
&lt; 	
&lt; 	public void testCoveragePublicMode() {
&lt; 		outdir.delete();
&lt; 		String[] args = { 
&lt; 			"-public",
&lt; 			"-source", 
&lt; 			"1.4",
&lt; 			"-d", 
&lt; 			outdir.getAbsolutePath(),
&lt; 			file3.getAbsolutePath(),
&lt; 			file9.getAbsolutePath() 
---
&gt; 			file9.getAbsolutePath(),
&gt;             file10.getAbsolutePath()
</file>
<file name="org.aspectj/modules/ajdoc/testdata/coverage/foo/NoMembers.java" revision="1.1" state="new">/*
 * Created on Jan 12, 2005
 */

/**
 * @author Mik Kersten
 */
public class NoMembers {

}
</file>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/Util.java" revision="1.1" state="new">/*
 * Created on Jan 12, 2005
  */
package org.aspectj.tools.ajdoc;

/**
 * @author Mik Kersten
 */
public class Util {

    public static boolean isExecutingOnJava5() {
        String version = System.getProperty("java.class.version","44.0");
        return version.equals("49.0");
    }
    
}
</file>
</fixedFiles>
</bug>
<bug id="82570" transactionid="68507">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P2"/>
<property name="severity" value="blocker"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if M O-== T V Y Z-if</fullfingerprint>
<bugreport>I am attempting to use AspectJ and output all classes in debug mode (required by
our code coverage instrumentor). However any code introduced by our aspects to
production classes does not include debug line information.

Our ant script uses the iajc task as follows:

 &lt;iajc ... debug="true" .. /&gt;

We have an aspect that introduces a public, no-arguments constructor into
various classes. If I enable this aspect, then do a clean build, I get the
following error from our code coverage tool:

 [jblanket] java.lang.UnsupportedOperationException: No line numbers detected in
 com.abmuk.oms.core.model.core.XMLObject.&lt;init&gt;. Either remove the 'oneLineFile'
 tag or turn debug on when compiling.

If I remove that aspect, we get no errors about debug line information.

I've tried debug="true" or debugLevel="lines,vars,source", with no success.

This issue is preventing our Unit Test suite from executing.

If you require any further information, please don't hesitate to email me.

Cheers,

  Chris Nappin.</bugreport>
<testsforfix ID="82570" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java">
      <test NAME="testMissingDebugInfoForGeneratedMethods_pr82570"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="111" file="output/82570/pre-fix/testresults.xml" passing="1425" size="1536"/>
<post-fix-testcases failing="112" file="output/82570/post-fix/testresults.xml" passing="1424" size="1536"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java" revision="1.35" state="changed">973c973,980
&lt; 
---
&gt;         
&gt;         // JAVAC adds line number tables (with just one entry) to generated accessor methods - this
&gt;         // keeps some tools that rely on finding at least some form of linenumbertable happy.
&gt;         // Let's check if we have one - if we don't then let's add one.
&gt;         // TODO Could be made conditional on whether line debug info is being produced
&gt;         if (gen.getLineNumbers().length==0) { 
&gt;         	gen.addLineNumber(gen.getInstructionList().getStart(),1);
&gt;         }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java" revision="1.2" state="changed">14a15,18
&gt; import org.aspectj.apache.bcel.classfile.JavaClass;
&gt; import org.aspectj.apache.bcel.classfile.Method;
&gt; import org.aspectj.apache.bcel.util.ClassPath;
&gt; import org.aspectj.apache.bcel.util.SyntheticRepository;
33a38
&gt;   
39a45,93
&gt;   
&gt;   
&gt;   public void testMissingDebugInfoForGeneratedMethods_pr82570() throws ClassNotFoundException {
&gt;   	boolean f = false;
&gt;     CompilationResult cR = ajc(baseDir,new String[]{"PR82570_1.java"});
&gt;     System.err.println(cR.getStandardError());
&gt;     assertTrue("Expected no compile problem:"+cR,!cR.hasErrorMessages());
&gt;     JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"PR82570_1");
&gt;     Method[] meths = jc.getMethods();
&gt;     for (int i = 0; i &lt; meths.length; i++) {
&gt; 		Method method = meths[i];
&gt; 		if (f) System.err.println("Line number table for "+method.getName()+method.getSignature()+" = "+method.getLineNumberTable());
&gt; 		assertTrue("Didn't find a line number table for method "+method.getName()+method.getSignature(),
&gt; 				method.getLineNumberTable()!=null);
&gt; 	}
&gt; 
&gt;     // This test would determine the info isn't there if you pass -g:none ...
&gt; //    cR = ajc(baseDir,new String[]{"PR82570_1.java","-g:none"});
&gt; //    assertTrue("Expected no compile problem:"+cR,!cR.hasErrorMessages());
&gt; //    System.err.println(cR.getStandardError());
&gt; //    jc = getClassFrom(ajc.getSandboxDirectory(),"PR82570_1");
&gt; //    meths = jc.getMethods();
&gt; //    for (int i = 0; i &lt; meths.length; i++) {
&gt; //		Method method = meths[i];
&gt; //		assertTrue("Found a line number table for method "+method.getName(),
&gt; //				method.getLineNumberTable()==null);
&gt; //	}
&gt;   }
&gt;   
&gt;   
&gt;   
&gt;   
&gt;   
&gt;   
&gt;   
&gt;   
&gt;   ///////////////////////////////////////// TESTCASE HELPER METHODS BELOW HERE //////////////////////////
&gt;   
&gt;   // Some util methods for accessing .class contents as BCEL objects
&gt;   
&gt;   public SyntheticRepository createRepos(File cpentry) {
&gt; 	ClassPath cp = new ClassPath(cpentry+File.pathSeparator+System.getProperty("java.class.path"));
&gt; 	return SyntheticRepository.getInstance(cp);
&gt;   }
&gt;   
&gt;   private JavaClass getClassFrom(File where,String clazzname) throws ClassNotFoundException {
&gt; 	SyntheticRepository repos = createRepos(where);
&gt; 	return repos.loadClass(clazzname);
&gt;   }
</file>
<file name="org.aspectj/modules/tests/.classpath" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/tests/bugs150/PR82570_1.java" revision="1.1" state="new">
public class PR82570_1 {
  public static void main(String[] args) {
	new PR82570_1().m();
  }
  
  public void m() {
  	
  }
}

aspect X {
	
	
	public PR82570_1.new(String p) {}
	
	public int PR82570_1.itdField;
	
	public void PR82570_1.itdMethod(String s) {
		
	}
	
	before(): call(* m(..)) {
		System.err.println("m");
	}
	
	void around(): call(* m(..)) {
		
	}
	
}

</file>
</fixedFiles>
</bug>
<bug id="82752" transactionid="74239">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="10"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="P4"/>
<property name="severity" value="normal"/>
<concisefingerprint/>
<fullfingerprint/>
<bugreport>This bug affects ajdoc, and could affect other tools relying on the ASM.</bugreport>
<testsforfix ID="82752" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java">
      <test NAME="testAspectAccessibility"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="176" file="output/82752/pre-fix/testresults.xml" passing="1537" size="1713"/>
<post-fix-testcases failing="180" file="output/82752/post-fix/testresults.xml" passing="1534" size="1714"/>
<fixedFiles>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/internal/ProgramElement.java" revision="1.24" state="changed">14d13
&lt; 
79d77
&lt; //		System.err.println("&gt; created: " + name + ", children: " + children);
344,351d341
&lt; //	private void setParents() {
&lt; ////		System.err.println("&gt;&gt; setting parents on: " + name);
&lt; //		if (children == null) return;
&lt; //		for (Iterator it = children.iterator(); it.hasNext(); ) {
&lt; //			((IProgramElement)it.next()).setParent(this);	
&lt; //		}	
&lt; //	}
&lt; 
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java" revision="1.13" state="changed">13,15d12
&lt; //import java.util.Iterator;
&lt; 
&lt; //import org.aspectj.ajdt.internal.core.builder.AsmElementFormatter;
17,18d13
&lt; //import org.aspectj.asm.IProgramElement.Kind;
&lt; 
20c15,17
&lt; // TODO: add tests for java kinds, expand coverage
---
&gt; /**
&gt;  * @author Mik Kersten
&gt;  */ 
26d22
&lt; //	private static final int DEC_MESSAGE_LENGTH = AsmElementFormatter.MAX_MESSAGE_LENGTH;
37a34,39
&gt; 	public void testAspectAccessibility() {
&gt; 		IProgramElement packageAspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "AdviceNamingCoverage");
&gt; 		assertNotNull(packageAspect);
&gt; 		assertEquals(IProgramElement.Accessibility.PACKAGE, packageAspect.getAccessibility());
&gt; 	}
&gt; 	
122c124
&lt; 
---
&gt; 	
139,140d140
&lt; 
&lt; 
</file>
</fixedFiles>
</bug>
<bug id="83081" transactionid="72878">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-false K-true</fullfingerprint>
<bugreport>The time has come... now that all known limitations with incremental compilation
are resolved, the option should be enabled by default (and the message text
updated accordingly).</bugreport>
<pre-fix-testcases failing="112" file="output/83081/pre-fix/testresults.xml" passing="1424" size="1536"/>
<post-fix-testcases failing="68" file="output/83081/post-fix/testresults.xml" passing="671" size="739"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/preferences/AJCompilerPreferencePage.java" revision="1.4" state="changed">183c183
&lt; 		store.setDefault(PREF_ENABLE_INCREMENTAL, false);
---
&gt; 		store.setDefault(PREF_ENABLE_INCREMENTAL, true);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/CompilerPropertyPage.java" revision="1.8" state="changed">211c211
&lt; 		store.setDefault(thisProject + PREF_ENABLE_INCREMENTAL, false);
---
&gt; 		store.setDefault(thisProject + PREF_ENABLE_INCREMENTAL, true);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/resources/AspectJPluginResources.properties" revision="1.16" state="changed"/>
</fixedFiles>
</bug>
<bug id="83303" transactionid="70163">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="32"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="32"/>
<property name="priority" value="P3"/>
<property name="severity" value="blocker"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-for K-if K-null K-return K-super M O-! O-cast T V Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>Given this scenario:
- class A define method m1 (with proteceted visibility)
- class B extends class A and implements interface I and override method m1 (but
with public visibility)
- interface I define method m1 (with public  visibility)

The code is correct and compile using java 1.4

Let's modify the scenario:
move the method B.m1 into a method introduction on aspect C, such that
- class B extends class A
- apsect C intosuces method m1 into B (with public visibility) and makes B
implemts I (declare parents)
- A and I as before

The compiler reports this error:
B.java:1 [error] The inherited method A.m1() cannot hide the public abstract
method in I
class B extends A {</bugreport>
<testsforfix ID="83303" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java">
      <test NAME="testCanOverrideProtectedMethodsViaITDandDecp_pr83303"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="113" file="output/83303/pre-fix/testresults.xml" passing="1423" size="1536"/>
<post-fix-testcases failing="111" file="output/83303/post-fix/testresults.xml" passing="1425" size="1536"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java" revision="1.24" state="changed">138a139,170
&gt; 	public void inheritedMethodReducesVisibility(SourceTypeBinding type, MethodBinding concreteMethod, MethodBinding[] abstractMethods) {
&gt; 		// if we implemented this method by a public inter-type declaration, then there is no error
&gt; 		
&gt; 		ResolvedTypeX onTypeX = null;		
&gt; 		// If the type is anonymous, look at its supertype
&gt; 		if (!type.isAnonymousType()) {
&gt; 			onTypeX = factory.fromEclipse(type);
&gt; 		} else {
&gt; 			// Hmmm. If the ITD is on an interface that is being 'instantiated' using an anonymous type,
&gt; 			// we sort it out elsewhere and don't come into this method - 
&gt; 			// so we don't have to worry about interfaces, just the superclass.
&gt; 		    onTypeX = factory.fromEclipse(type.superclass()); //abstractMethod.declaringClass);
&gt; 		}
&gt; 		for (Iterator i = onTypeX.getInterTypeMungersIncludingSupers().iterator(); i.hasNext(); ) {
&gt; 			ConcreteTypeMunger m = (ConcreteTypeMunger)i.next();
&gt; 			ResolvedMember sig = m.getSignature();
&gt;             if (!Modifier.isAbstract(sig.getModifiers())) {
&gt; 				if (ResolvedTypeX
&gt; 					.matches(
&gt; 						AjcMemberMaker.interMethod(
&gt; 							sig,
&gt; 							m.getAspectType(),
&gt; 							sig.getDeclaringType().isInterface(
&gt; 								factory.getWorld())),
&gt; 						EclipseFactory.makeResolvedMember(concreteMethod))) {
&gt; 					return;
&gt; 				}
&gt; 			}
&gt; 		}
&gt; 
&gt; 		super.inheritedMethodReducesVisibility(type,concreteMethod,abstractMethods);
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java" revision="1.4" state="changed">75a76,80
&gt;   public void testCanOverrideProtectedMethodsViaITDandDecp_pr83303() {
&gt;   	CompilationResult cR = ajc(baseDir,new String[]{"PR83303.java"});
&gt;   	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/bugs150/PR83303.java" revision="1.1" state="new">

// Protected method in A
class A {
  protected void m1 (){System.err.println("A.m1()");}
}


// Simple subclass
public class PR83303 extends A {
  public static void main(String []argv) {
    System.err.println("Hi");
    new PR83303().m1();
  }
}


aspect C {
  declare parents: PR83303 implements I;
  public void PR83303.m1(){System.err.println("ITD version of m1");}
}


interface I {
  public void m1();
}
</file>
</fixedFiles>
</bug>
<bug id="83563" transactionid="69263">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="21"/>
<property name="lines-churned" value="25"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new K-null K-return K-while M O-!= T V Z-if Z-while</fullfingerprint>
<bugreport>It seems that pertypewithin() aspect association does not handle nested classes
correctly. Here is a test class that exhibits the problem:

package test;

public class Test {
    public static void main(String[] args) {
        new NestedTest().run();
    }
	
    static class NestedTest implements Runnable {
        public void run() {
            System.out.println("Running...");
        }
    }
}
 
aspect PertypewithinTest pertypewithin(Test) {
    before() : execution(* *.*(..)) {
        System.out.println(thisJoinPointStaticPart);
    }	
}

&gt; ajc -version
AspectJ Compiler DEVELOPMENT built on Monday Jan 24, 2005 at 17:07:00 GMT

&gt; ajc test\Test.java

&gt; java test.Test
execution(void test.Test.main(String[]))
execution(void test.Test.bar())
Exception in thread "main" java.lang.NoSuchMethodError: test.Test$1.ajc$test_Per
typewithinTest$localAspectOf()Ltest/PertypewithinTest;
        at test.Test$1.run(Test.java)
        at test.Test.bar(Test.java:9)
        at test.Test.main(Test.java:13)

The same problem is seen for anonymous inner classes, as well:
package test;

public class Test {
    public void bar() {
        new Runnable() {
            public void run() {
                System.out.println("Running...");
            }
        }.run();
    }
        
    public static void main(String[] args) {
        new Test().bar();
    }
}
 
aspect PertypewithinTest pertypewithin(Test) {
    before() : execution(* *.*(..)) {
        System.out.println(thisJoinPoint);
    }    
}

&gt; ajc test\Test.java
&gt; java test.Test
execution(void test.Test.main(String[]))
execution(void test.Test.bar())
Exception in thread "main" java.lang.NoSuchMethodError: test.Test$1.ajc$test_Per
typewithinTest$localAspectOf()Ltest/PertypewithinTest;
        at test.Test$1.run(Test.java)
        at test.Test.bar(Test.java:9)
        at test.Test.main(Test.java:13)</bugreport>
<testsforfix ID="83563" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java">
      <test NAME="testPerTypeWithinMissesNamedInnerTypes"/>
      <test NAME="testPerTypeWithinMissesAnonymousInnerTypes"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/83563/pre-fix/testresults.xml" passing="1424" size="1536"/>
<post-fix-testcases failing="112" file="output/83563/post-fix/testresults.xml" passing="1424" size="1536"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java" revision="1.2" state="changed">129c129
&lt; 				typePattern,
---
&gt; 				TypePattern.ANY,//typePattern,
135,136c135,142
&lt; 		Pointcut testPc = new KindedPointcut(Shadow.StaticInitialization,sigpat);
&lt; 		Pointcut testPc2= new WithinPointcut(typePattern);
---
&gt; 		
&gt; 		Pointcut staticInitStar = new KindedPointcut(Shadow.StaticInitialization,sigpat);
&gt; 		Pointcut withinTp= new WithinPointcut(typePattern);
&gt; 		Pointcut andPcut = new AndPointcut(staticInitStar,withinTp);
&gt; 		// We want the pointcut to be 'staticinitialization(*) &amp;&amp; within(&lt;typepattern&gt;' -
&gt; 		// we *cannot* shortcut this to staticinitialization(&lt;typepattern&gt;) because it
&gt; 		// doesnt mean the same thing.
&gt; 
138c144
&lt; 		inAspect.crosscuttingMembers.addConcreteShadowMunger(Advice.makePerTypeWithinEntry(world, testPc, inAspect));
---
&gt; 		inAspect.crosscuttingMembers.addConcreteShadowMunger(Advice.makePerTypeWithinEntry(world, andPcut, inAspect));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java" revision="1.2" state="changed">17a18
&gt; import org.aspectj.util.FuzzyBoolean;
20d20
&lt; import org.aspectj.weaver.patterns.TypePattern;
47a48,49
&gt; 	// This is a lexical within() so if you say PerTypeWithin(Test) and matchType is an
&gt; 	// inner type (e.g. Test$NestedType) then it should match successfully
49c51,61
&lt; 		return testPointcut.getTypePattern().matches(matchType,TypePattern.STATIC).alwaysTrue();
---
&gt; 		return isWithinType(matchType).alwaysTrue();
&gt; 	}
&gt; 	
&gt; 	private FuzzyBoolean isWithinType(ResolvedTypeX type) {
&gt; 		while (type != null) {
&gt; 			if (testPointcut.getTypePattern().matchesStatically(type)) {
&gt; 				return FuzzyBoolean.YES;
&gt; 			}
&gt; 			type = type.getDeclaringType();
&gt; 		}
&gt; 		return FuzzyBoolean.NO;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java" revision="1.6" state="changed">77a78,89
&gt;   
&gt;   public void testPerTypeWithinMissesNamedInnerTypes() {
&gt;   	CompilationResult cR = ajc(baseDir,new String[]{"PR83563_1.java"});
&gt;   	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
&gt;   	RunResult rR = run("PR83563_1");
&gt;   }
&gt;   
&gt;   public void testPerTypeWithinMissesAnonymousInnerTypes() {
&gt;   	CompilationResult cR = ajc(baseDir,new String[]{"PR83563_2.java"});
&gt;   	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
&gt;   	RunResult rR = run("PR83563_2");
&gt;   }
</file>
<file name="org.aspectj/modules/tests/bugs150/PR83563_2.java" revision="1.1" state="new">public class PR83563_2 {
    public void bar() {
        new Runnable() {
            public void run() {
                System.out.println("Running...");
            }
        }.run();
    }
        
    public static void main(String[] args) {
        new PR83563_2().bar();
        int c = PertypewithinTest.aspectOf(PR83563_2.class).cnt;
        if (c!=3)
          throw new RuntimeException("Expected 3 advice executions but got:"+c);
    }
}
 
aspect PertypewithinTest pertypewithin(PR83563_2) {
    public static int cnt = 0;

    before() : execution(* *.*(..)) {
        cnt++;
        System.out.println(thisJoinPoint);
    }    
}
</file>
<file name="org.aspectj/modules/tests/bugs150/PR83563_1.java" revision="1.1" state="new">public class PR83563_1 {
    public static void main(String[] args) {
        new NestedTest().run();
        int c = PertypewithinTest.aspectOf(PR83563_1.class).cnt;
        if (c!=2)
          throw new RuntimeException("Expected 2 advice executions: "+c);
    }
	
    static class NestedTest implements Runnable {
        public void run() {
            System.out.println("Running...");
        }
    }
}
 
aspect PertypewithinTest pertypewithin(PR83563_1) {
    public static int cnt = 0;

    before() : execution(* *.*(..)) {
        cnt++;
        System.out.println(thisJoinPointStaticPart);
    }	
}
</file>
</fixedFiles>
</bug>
<bug id="83565" transactionid="74097">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="37"/>
<property name="lines-churned" value="41"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HK</concisefingerprint>
<fullfingerprint>H K-catch K-import T V Y</fullfingerprint>
<tag>exception</tag>
<bugreport>I just downloaded AJDT version 1.2.0.20050124144759 and I am running Eclipse
3.1M4.  I tried to use aspectJ on an existing Java 5 project.  There are no
aspects in it yet, just straight Java 5.  The project runs just fine as a
standard Java project. 

When add the AspectJ nature and I try to compile the project, no class files are
generated and I get this error generated on a type that is parameterized:

Internal compiler error
org.aspectj.weaver.BCException: Bad type name: 

	at org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:634)

	at org.aspectj.weaver.TypeX.forName(TypeX.java:87)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)

	at
org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:675)

	at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:447)

	at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1133)

	at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:314)

	at
org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:171)

	at
org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:111)

	at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:354)

	at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:138)

	at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373)

	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)

	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)

	at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)

	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)

	at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165)


The source code of the file that generates this error is:

package mj.compiler.ast;

import java.util.Vector;

import mj.compiler.Driver;
import mj.compiler.Visitor;

public class Sequence&lt;T extends AST&gt; extends AST {
	
	private Vector&lt;T&gt; elements = new Vector&lt;T&gt;();
	
	public Sequence() {
		super(0, 0);
    }
	
	public Sequence(T element) {
		super(element);
		elements.add(element);
    }
    
	public int length()       { return elements.size(); }
	public T elementAt(int i) { return elements.elementAt(i); }

    public Sequence add(T element) {
    	elements.add(element);
		return this;
    }
    
    public Sequence add(int pos, T element) {
    	elements.add(pos, element);
    	return this;
    }
    
    public Sequence addAll(Sequence&lt;T&gt; others) {		
		if(  others == null ) return this;
		elements.addAll(others.elements);
		return this;
    }
    
    public void visitChildren(Visitor v) {
    	for( AST element : elements ) {
    		element.visit(v);
        }
    }
    
    public void replaceChild(AST old, AST gnu) {
    	T NEW = (T)gnu;
    	for(int i = 0; i &lt; elements.size(); i++ ) {
    		if( elements.get(i) == old ) {
    			elements.set(i, NEW);
    			return;
    		}
    	}
    	throw new Driver.CompileError("Can't find child in replaceChild.");
    }

	/*** START GENERATED VISITOR PROTOCOL ***///TODO
    public void visit(mj.compiler.Visitor v) {
        v.visitSequence(this);
    }
	/*** END GENERATED VISITOR PROTOCOL ***/
}


Hope this helps something.

ps- I am able to create and run a very simple AspectJ project with an aspect,
advice, and some Java 5 syntax.</bugreport>
<testsforfix ID="83565" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/GenericsTest.java">
      <test NAME="testBuild"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="112" file="output/83565/pre-fix/testresults.xml" passing="1424" size="1536"/>
<post-fix-testcases failing="112" file="output/83565/post-fix/testresults.xml" passing="1423" size="1535"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java" revision="1.27" state="changed">19,28c19,21
&lt; import java.util.ArrayList;
&lt; import java.util.Iterator;
&lt; import java.util.List;
&lt; import java.util.ListIterator;
&lt; import java.util.Stack;
&lt; 
&lt; import org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration;
&lt; import org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration;
&lt; import org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration;
&lt; import org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration;
---
&gt; import java.util.*;
&gt; 
&gt; import org.aspectj.ajdt.internal.compiler.ast.*;
31,34c24
&lt; import org.aspectj.asm.AsmManager;
&lt; import org.aspectj.asm.IHierarchy;
&lt; import org.aspectj.asm.IProgramElement;
&lt; import org.aspectj.asm.IRelationship;
---
&gt; import org.aspectj.asm.*;
40,51c30
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ExtendedStringLiteral;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ImportReference;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Initializer;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
---
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.*;
53,56c32
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BlockScope;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodScope;
---
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.*;
59,66c35,36
&lt; import org.aspectj.weaver.Member;
&lt; import org.aspectj.weaver.ResolvedMember;
&lt; import org.aspectj.weaver.TypeX;
&lt; import org.aspectj.weaver.World;
&lt; import org.aspectj.weaver.patterns.AndPointcut;
&lt; import org.aspectj.weaver.patterns.OrPointcut;
&lt; import org.aspectj.weaver.patterns.Pointcut;
&lt; import org.aspectj.weaver.patterns.ReferencePointcut;
---
&gt; import org.aspectj.weaver.*;
&gt; import org.aspectj.weaver.patterns.*;
489c459
&lt; 			try {
---
&gt; 			try { 
492a463,464
&gt; 			} catch (BCException bce) {  // bad type name 
&gt; 				memberName = "&lt;undefined&gt;";
677a650,651
&gt; 			} catch (BCException bce) {  // bad type name 
&gt; 				memberName = "&lt;undefined&gt;";
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AjdeTests.java" revision="1.20" state="changed">42a43
&gt; 		suite.addTestSuite(GenericsTest.class); 
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/GenericsTest.java" revision="1.1" state="new">/*
 * Created on Jan 27, 2005
  */
package org.aspectj.ajde;

import org.aspectj.asm.AsmManager;

/**
 * @author Mik Kersten
 */
public class GenericsTest extends AjdeTestCase {
    
    private AsmManager manager = null;
	private static final String CONFIG_FILE_PATH = "../bug-83565/build.lst";
 
	public void testBuild() {	
//	    assertTrue("build success", doSynchronousBuild(CONFIG_FILE_PATH));	
	}
	
	protected void setUp() throws Exception {
		super.setUp("examples");
		manager = AsmManager.getDefault();
	}
    
}
</file>
<file name="org.aspectj/modules/ajde/testdata/bug-83565/build.lst" revision="1.1" state="new">-1.5&#13;
Bug.java &#13;
&#13;
</file>
<file name="org.aspectj/modules/ajde/testdata/bug-83565/Bug.java" revision="1.1" state="new">
package mj.compiler.ast;

import java.util.Vector;

class Sequence&lt;T extends AST&gt; extends AST {
	
	private Vector&lt;T&gt; elements = new Vector&lt;T&gt;();
	
	public Sequence(T element) {
//		super(element);
		elements.add(element);
    }
    
	public int length()       { return elements.size(); }
	public T elementAt(int i) { return elements.elementAt(i); }
}

class AST&lt;T&gt; {
    public AST() { } 
    
    public AST(T element) {  }
}</file>
</fixedFiles>
</bug>
<bug id="84310" transactionid="73525">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="29"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="31"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-if K-import K-null K-return M O-&lt; O-== O-|| O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>If you check out a project from CVS which has multiple build configurations, one
of these becomes the active build configuration. However, that choice is random,
and it's usually the wrong one :)</bugreport>
<pre-fix-testcases failing="114" file="output/84310/pre-fix/testresults.xml" passing="1422" size="1536"/>
<post-fix-testcases failing="112" file="output/84310/post-fix/testresults.xml" passing="1424" size="1536"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/buildconfigurator/ProjectBuildConfigurator.java" revision="1.6" state="changed">13a14
&gt; import java.util.Iterator;
207,208c208,209
&lt; 			setActiveBuildConfiguration((BuildConfiguration) (buildconfigs
&lt; 					.values().iterator().next()));
---
&gt; 			// choose the active configuration
&gt; 			setActiveBuildConfiguration(getDefaultBuildConfiguration());
210a212,239
&gt; 	
&gt; 	/**
&gt; 	 * If there is no preference setting defining which build config should be
&gt; 	 * active, we need to pick on from the ones available. Choosing one at
&gt; 	 * random wouldn't be helpful, so for consistency we define the rule to be:
&gt; 	 * choose build.ajproperties if there is one with that name, otherwise
&gt; 	 * choose the first one alphabetically (bug 84310)
&gt; 	 * 
&gt; 	 * @return the chosen build configuration
&gt; 	 */
&gt; 	private BuildConfiguration getDefaultBuildConfiguration() {
&gt; 		if (buildconfigs.size()==1) {
&gt; 			// hobsons choice
&gt; 			return (BuildConfiguration)buildconfigs.values().iterator().next();
&gt; 		}
&gt; 		IFile first = null;
&gt; 		for (Iterator iter = buildconfigs.keySet().iterator(); iter.hasNext();) {
&gt; 			IFile file = (IFile) iter.next();
&gt; 			if (file.getName().equals(BuildConfiguration.STANDARD_BUILD_CONFIGURATION_FILE)) {
&gt; 				return (BuildConfiguration)buildconfigs.get(file);
&gt; 			}
&gt; 			if (first==null || (file.getName().compareTo(first.getName()) &lt; 0)) {
&gt; 				first = file;
&gt; 			}
&gt; 		}
&gt; 		return (BuildConfiguration)buildconfigs.get(first);
&gt; 	}
&gt; 	
</file>
</fixedFiles>
</bug>
<bug id="84318" transactionid="73063">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-null M Y</fullfingerprint>
<bugreport>When ajc supports directories on the aspect path, we should allow the option to
be used from the AspectPath project property page</bugreport>
<pre-fix-testcases failing="112" file="output/84318/pre-fix/testresults.xml" passing="1429" size="1541"/>
<post-fix-testcases failing="115" file="output/84318/post-fix/testresults.xml" passing="1426" size="1541"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/resources/AspectJPluginResources.properties" revision="1.29" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/AspectPathLibrariesWorkbookPage.java" revision="1.4" state="changed">91c91
&lt;             /* IDX_ADDFOL */ null, //AspectJUIPlugin.getResourceString("AspectPathLibrariesWorkbookPage.libraries.addclassfolder.button"), //$NON-NLS-1$
---
&gt;             /* IDX_ADDFOL */ AspectJUIPlugin.getResourceString("AspectPathLibrariesWorkbookPage.libraries.addclassfolder.button"), //$NON-NLS-1$
</file>
</fixedFiles>
</bug>
<bug id="86789" transactionid="70292">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="5"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-return M O-== O-() O-&amp;&amp; T V Z-if</fullfingerprint>
<bugreport>The following example

    declare precedence : (@PremiumPartner *), *;

results in the error message

    circularity in declare precedence, ''*'' occurs more than once   

It is the same example (apart form the name) as in the developers notebook.
(see also http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01326.html)</bugreport>
<pre-fix-testcases failing="112" file="output/86789/pre-fix/testresults.xml" passing="1426" size="1538"/>
<post-fix-testcases failing="113" file="output/86789/post-fix/testresults.xml" passing="1425" size="1538"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java" revision="1.28" state="changed">142c142
&lt; 		if (isStar()) {
---
&gt; 		if (isNamePatternStar()) {
370c370
&lt;     	if (isStar()) {
---
&gt;     	if (isNamePatternStar()) {
518a519,523
&gt; 		boolean annPatternStar = annotationPattern == AnnotationTypePattern.ANY;
&gt; 		return (isNamePatternStar() &amp;&amp; annPatternStar);
&gt; 	}
&gt; 	
&gt; 	private boolean isNamePatternStar() {
</file>
</fixedFiles>
</bug>
<bug id="87376" transactionid="71261">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-else K-if K-null K-return O-!= T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>see attached mini-project to reproduce</bugreport>
<testsforfix ID="87376" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="structure model npe on type not found"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="111" file="output/87376/pre-fix/testresults.xml" passing="1427" size="1538"/>
<post-fix-testcases failing="111" file="output/87376/post-fix/testresults.xml" passing="1427" size="1538"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java" revision="1.28" state="changed">384,385c384,389
&lt; 		    Member member = EclipseFactory.makeResolvedMember(declaration.binding);
&lt; 			onType = member.getDeclaringType();
---
&gt; 			if (declaration.binding != null) {
&gt; 			    Member member = EclipseFactory.makeResolvedMember(declaration.binding);
&gt; 				onType = member.getDeclaringType();
&gt; 			} else {
&gt; 				return null;
&gt; 			}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.8" state="changed">127a128,131
&gt;   public void npeOnTypeNotFound() {
&gt; 	  runTest("structure model npe on type not found");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.12" state="changed">42a43,49
&gt;     &lt;ajc-test dir="bugs150/pr87376" title="structure model npe on type not found"&gt;
&gt;         &lt;compile files="I.java,NPE.aj" options="-emacssym"&gt;
&gt;             &lt;message kind="error" line="8" text="I cannot be resolved to a type"/&gt;
&gt;             &lt;message kind="error" line="10" text="I cannot be resolved to a type"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs150/pr87376/I.java" revision="1.1" state="new">package a.b.c;

public interface I {

}</file>
<file name="org.aspectj/modules/tests/bugs150/pr87376/NPE.aj" revision="1.1" state="new">package a.b.d;
//import a.b.c.I;



public aspect NPE {
  
  pointcut ii(I i) : execution(* I.*(..)) &amp;&amp; this(i);

  after(I i) returning : ii(i) {
      System.out.println(i);
  }
  
}
</file>
</fixedFiles>
</bug>
<bug id="87954" transactionid="74531">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="19"/>
<property name="lines-added" value="102"/>
<property name="lines-deleted" value="20"/>
<property name="lines-modified" value="18"/>
<property name="lines-churned" value="140"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-import K-return K-true M O-== O-&gt;= O-|| O-() O-&amp;&amp; O-+ T V Y Z-if</fullfingerprint>
<bugreport>When I remove the AspectJ nature from a project the org.aspectj.runtime
dependency is not removed.  Readding the AspectJ nature later adds a duplicate
org.aspectj.runtime dependency back to the plugin.xml of the project.</bugreport>
<pre-fix-testcases failing="112" file="output/87954/pre-fix/testresults.xml" passing="1426" size="1538"/>
<post-fix-testcases failing="112" file="output/87954/post-fix/testresults.xml" passing="1426" size="1538"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/core/AJDTUtils.java" revision="1.20" state="changed">52d51
&lt; import org.eclipse.jface.preference.IPreferenceStore;
193,196d191
&lt; 		IPreferenceStore store = AspectJUIPlugin.getDefault()
&lt; 				.getPreferenceStore();
&lt; 		store.setDefault(project.getName()
&lt; 				+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
212,213d206
&lt; 				store.setValue(project.getName()
&lt; 						+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, true);
219,220d211
&lt; 			store.setValue(project.getName()
&lt; 					+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
256c247
&lt; 			if (project.hasNature("com.genuitec.eclipse.j2eedt.core.webnature") //$NON-NLS-1$
---
&gt; 			if (project.hasNature("com.genuitec.eclipse.j2eedt.core.webnature") // $NON-NLS-1$
606c597
&lt; 		if ((AspectJPreferences.askPDEAutoImport() &amp;&amp; confirmPDEAutoImport(window))
---
&gt; 		if ((AspectJPreferences.askPDEAutoImport() &amp;&amp; confirmPDEAutoAddImport(window))
824,835c815,818
&lt; 			// Bugzilla 72007
&lt; 			// Checks if it was ajdt that added the ajde dependancy and removes
&lt; 			// it if it was
&lt; 			IPreferenceStore store = AspectJUIPlugin.getDefault()
&lt; 					.getPreferenceStore();
&lt; 			store.setDefault(project.getName()
&lt; 					+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY, false);
&lt; 			boolean AJPluginDependancySetByAddAJNature = store
&lt; 					.getBoolean(project.getName()
&lt; 							+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY);
&lt; 			if (hasAJPluginDependency(project)
&lt; 					&amp;&amp; AJPluginDependancySetByAddAJNature) {
---
&gt; //			// Bugzilla 72007
&gt; //			// Checks if it was ajdt that added the ajde dependancy and removes
&gt; //			// it if it was
&gt; 			if (hasAJPluginDependency(project)) {
838,842d820
&lt; 				store
&lt; 						.setValue(
&lt; 								project.getName()
&lt; 										+ AspectJPreferences.HAS_SET_AJPLUGIN_DEPENDENCY,
&lt; 								false);
864,865c842,843
&lt; 	// This method checks wether the project already requires
&lt; 	// org.aspectj.ajde to be imported. Returns true if it does.
---
&gt; 	// This method checks whether the project already has
&gt; 	// org.aspectj.runtime imported. Returns true if it does.
882c860
&lt; 							AspectJPreferences.AJDE_JAR))
---
&gt; 							"aspectjrt.jar")) // $NON-NLS-1$
903,917c881,912
&lt; 		// Attempt to get hold of the open manifest editor
&lt; 		// for the current project.
&lt; 		ManifestEditor manEd = getPDEManifestEditor(project);
&lt; 
&lt; 		if (manEd != null) {
&lt; 			IPluginModel model = (IPluginModel) manEd.getAggregateModel();
&lt; 			try {
&lt; 				removeImportFromPDEModel(model,
&lt; 						AspectJPlugin.RUNTIME_PLUGIN_ID);
&lt; 				manEd.doSave(new NullProgressMonitor());
&lt; 			} catch (CoreException e) {
&lt; 				AspectJUIPlugin
&lt; 						.getDefault()
&lt; 						.getErrorHandler()
&lt; 						.handleError(
---
&gt; 		IWorkbenchWindow window = AspectJUIPlugin.getDefault().getWorkbench()
&gt; 		.getActiveWorkbenchWindow();
&gt; 		if ((AspectJPreferences.askPDEAutoRemoveImport() &amp;&amp; confirmPDEAutoRemoveImport(window))
&gt; 				|| (AspectJPreferences.doPDEAutoRemoveImport())) {
&gt; 
&gt; 			// Attempt to get hold of the open manifest editor
&gt; 			// for the current project.
&gt; 			ManifestEditor manEd = getPDEManifestEditor(project);
&gt; 	
&gt; 			if (manEd != null) {
&gt; 				IPluginModel model = (IPluginModel) manEd.getAggregateModel();
&gt; 				try {
&gt; 					removeImportFromPDEModel(model,
&gt; 							AspectJPlugin.RUNTIME_PLUGIN_ID);
&gt; 					manEd.doSave(new NullProgressMonitor());
&gt; 				} catch (CoreException e) {
&gt; 					AspectJUIPlugin
&gt; 							.getDefault()
&gt; 							.getErrorHandler()
&gt; 							.handleError(
&gt; 									AspectJUIPlugin
&gt; 											.getResourceString("AutoPluginRemoveErrorDialog.title"),
&gt; 									AspectJUIPlugin
&gt; 											.getResourceString("AutoPluginRemoveErrorDialog.message"),
&gt; 									e);
&gt; 				}
&gt; 			}// end if we got a reference to the manifest editor
&gt; 			else {
&gt; 				MessageDialog
&gt; 						.openError(
&gt; 								AspectJUIPlugin.getDefault().getWorkbench()
&gt; 										.getActiveWorkbenchWindow().getShell(),
919c914
&lt; 										.getResourceString("AutoPluginRemoveErrorDialog.title"),
---
&gt; 										.getResourceString("AutoPluginRemoveDialog.noEditor.title"),
921,922c916
&lt; 										.getResourceString("AutoPluginRemoveErrorDialog.message"),
&lt; 								e);
---
&gt; 										.getResourceString("AutoPluginRemoveDialog.noEditor.message"));
924,933d917
&lt; 		}// end if we got a reference to the manifest editor
&lt; 		else {
&lt; 			MessageDialog
&lt; 					.openError(
&lt; 							AspectJUIPlugin.getDefault().getWorkbench()
&lt; 									.getActiveWorkbenchWindow().getShell(),
&lt; 							AspectJUIPlugin
&lt; 									.getResourceString("AutoPluginRemoveDialog.noEditor.title"),
&lt; 							AspectJUIPlugin
&lt; 									.getResourceString("AutoPluginRemoveDialog.noEditor.message"));
1053c1037
&lt; 	private static boolean confirmPDEAutoImport(IWorkbenchWindow window) {
---
&gt; 	private static boolean confirmPDEAutoAddImport(IWorkbenchWindow window) {
1082a1067,1102
&gt; 	 * Prompts the user for whether to automatically remove the AspectJ runtime plug-in 
&gt; 	 * dependency when removing AspectJ nature from a PDE project.
&gt; 	 * 
&gt; 	 * @return &lt;code&gt;true&lt;/code&gt; if it's OK to import, &lt;code&gt;false&lt;/code&gt;
&gt; 	 *         otherwise
&gt; 	 */
&gt; 	private static boolean confirmPDEAutoRemoveImport(IWorkbenchWindow window) {
&gt; 
&gt; 		MessageDialogWithToggle dialog = MessageDialogWithToggle
&gt; 				.openQuestion(
&gt; 						window.getShell(),
&gt; 						AspectJUIPlugin
&gt; 								.getResourceString("PluginImportDialog.removeImportConfirmTitle"),
&gt; 						AspectJUIPlugin
&gt; 								.getResourceString("PluginImportDialog.removeImportConfirmMsg"),
&gt; 						AspectJUIPlugin
&gt; 								.getResourceString("PluginImportDialog.removeImportConfirmToggleMsg"),
&gt; 						false); // toggle is initially unchecked
&gt; 
&gt; 		int result = dialog.getReturnCode();
&gt; 
&gt; 		if (result &gt;= 0 &amp;&amp; dialog.getToggleState()) {
&gt; 			if (result == 0) {
&gt; 				// User chose Yes/Don't ask again, so always switch
&gt; 				AspectJPreferences.setDoPDEAutoRemoveImport(true);
&gt; 				AspectJPreferences.setAskPDEAutoRemoveImport(false);
&gt; 			} else {
&gt; 				// User chose No/Don't ask again, so never switch
&gt; 				AspectJPreferences.setDoPDEAutoRemoveImport(false);
&gt; 				AspectJPreferences.setAskPDEAutoRemoveImport(false);
&gt; 			}
&gt; 		}// end if
&gt; 		return result == 0;
&gt; 	}
&gt; 	
&gt; 	/**
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/preferences/AspectJPreferencePage.java" revision="1.7" state="changed">55a56,58
&gt;         store.setDefault(AspectJPreferences.PDE_AUTO_REMOVE_IMPORT_CONFIG_DONE, false);
&gt;         store.setDefault(AspectJPreferences.ASK_PDE_AUTO_REMOVE_IMPORT, true);
&gt;         store.setDefault(AspectJPreferences.DO_PDE_AUTO_REMOVE_IMPORT, false);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/preferences/AspectJPreferences.java" revision="1.17" state="changed">53,58d52
&lt; 	/**
&lt; 	 * Identifier for whether it was the addAspectJNature() that added the ajde
&lt; 	 * dependency
&lt; 	 */
&lt; 	public static final String HAS_SET_AJPLUGIN_DEPENDENCY = "Has_Set_AJPlugin_Dependency"; //$NON-NLS-1$
&lt; 
98a93,94
&gt; 	public static final String PDE_AUTO_REMOVE_IMPORT_CONFIG_DONE = "org.eclipse.ajdt.ui.preferences.pdeAutoRemoveImportConfigDone"; //$NON-NLS-1$
&gt; 
102a99,102
&gt; 	public static final String ASK_PDE_AUTO_REMOVE_IMPORT = "org.eclipse.ajdt.ui.preferences.askPdeAutoRemoveImport"; //$NON-NLS-1$
&gt; 
&gt; 	public static final String DO_PDE_AUTO_REMOVE_IMPORT = "org.eclipse.ajdt.ui.preferences.doPdeAutoRemoveImport"; //$NON-NLS-1$
&gt; 
432a433,483
&gt; 	/**
&gt; 	 * Helper set method
&gt; 	 * 
&gt; 	 * @param ask
&gt; 	 *            true if the user wants to be asked again about having auto
&gt; 	 *            removal of aspectj runtime library import upon removing aspectj nature
&gt; 	 *            from PDE projects.
&gt; 	 */
&gt; 	static public void setAskPDEAutoRemoveImport(boolean ask) {
&gt; 		IPreferenceStore store = AspectJUIPlugin.getDefault()
&gt; 				.getPreferenceStore();
&gt; 		store.setValue(ASK_PDE_AUTO_REMOVE_IMPORT, ask);
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Helper get method used to determine whether to ask the user if they want
&gt; 	 * to automatically remove the the aspectj runtime library import from the 
&gt; 	 * appropriate plugin.
&gt; 	 * 
&gt; 	 * @return boolean true if user is to be asked
&gt; 	 */
&gt; 	static public boolean askPDEAutoRemoveImport() {
&gt; 		IPreferenceStore store = AspectJUIPlugin.getDefault()
&gt; 				.getPreferenceStore();
&gt; 		return store.getBoolean(ASK_PDE_AUTO_REMOVE_IMPORT);
&gt; 	}
&gt; 
&gt; 	static public void setPDEAutoRemoveImportConfigDone(boolean done) {
&gt; 		IPreferenceStore store = AspectJUIPlugin.getDefault()
&gt; 				.getPreferenceStore();
&gt; 		store.setValue(PDE_AUTO_REMOVE_IMPORT_CONFIG_DONE, done);
&gt; 	}
&gt; 
&gt; 	public static boolean isPDEAutoRemoveImportConfigDone() {
&gt; 		IPreferenceStore store = AspectJUIPlugin.getDefault()
&gt; 				.getPreferenceStore();
&gt; 		return store.getBoolean(PDE_AUTO_REMOVE_IMPORT_CONFIG_DONE);
&gt; 	}
&gt; 
&gt; 	static public void setDoPDEAutoRemoveImport(boolean doImport) {
&gt; 		IPreferenceStore store = AspectJUIPlugin.getDefault()
&gt; 				.getPreferenceStore();
&gt; 		store.setValue(DO_PDE_AUTO_REMOVE_IMPORT, doImport);
&gt; 	}
&gt; 
&gt; 	static public boolean doPDEAutoRemoveImport() {
&gt; 		IPreferenceStore store = AspectJUIPlugin.getDefault()
&gt; 				.getPreferenceStore();
&gt; 		return store.getBoolean(DO_PDE_AUTO_REMOVE_IMPORT);
&gt; 	}
&gt; 	
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/resources/AspectJPluginResources.properties" revision="1.26" state="changed"/>
</fixedFiles>
</bug>
<bug id="88652" transactionid="71437">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="8"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="12"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="16"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-return M O-&gt; T V Y Z-if</fullfingerprint>
<bugreport>I get this warning in my code, though I actually do not specify an array type.

The signature I want to match is the following constructor signature:

public Touple(Object formulaHandle, Object... propositions) {...}

Touple implements IRelation

The pointcut I use is the following:

pointcut p(): call(Touple.new(..));

This should actually match the signature, shouldn't it?
AspectJ however complains with this warning:

an array type as the last parameter in a signature does not match on the varargs 
declared method: void ltlrv.Touple.&lt;init&gt;(java.lang.Object, java.lang.Object[]) 
[Xlint:cantMatchArrayTypeOnVarargs]

Also, even if I *had* stated an array type, it should match even then IMHO, 
since arrays and varargs are actually the same in the Java implementation.</bugreport>
<testsforfix ID="88652" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testVarargsInConsBug"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="varargs in constructor sig"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="113" file="output/88652/pre-fix/testresults.xml" passing="1425" size="1538"/>
<post-fix-testcases failing="114" file="output/88652/post-fix/testresults.xml" passing="1424" size="1538"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java" revision="1.27" state="changed">576,578c576,579
&lt; 		if (params.size()&gt;0 &amp;&amp; (modifiers &amp; Constants.ACC_VARARGS)!=0 &amp;&amp;  // XXX Promote this to an isVarargs() on MethodSignature?
&lt; 			!params.get(params.size()-1).isVarArgs) {
&lt; 			return true;
---
&gt; 		if (params.size()&gt;0 &amp;&amp; (modifiers &amp; Constants.ACC_VARARGS)!=0) {
&gt; 			// we have at least one parameter in the pattern list, and the method has a varargs signature
&gt; 			TypePattern lastPattern = params.get(params.size()-1);
&gt; 			if (lastPattern.isArray() &amp;&amp; !lastPattern.isVarArgs) return true;
580c581
&lt; 		return false;
---
&gt; 	    return false;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/TypePattern.java" revision="1.20" state="changed">66a67,70
&gt; 	public boolean isArray() {
&gt; 		return false;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java" revision="1.21" state="changed">72a73,76
&gt; 	public boolean isArray() { 
&gt; 		return type.isArray();
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java" revision="1.31" state="changed">142a143,146
&gt; 	public boolean isArray() {
&gt; 		return dim &gt; 1;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.11" state="changed">143a144,147
&gt;   public void testVarargsInConsBug() {
&gt; 	  runTest("varargs in constructor sig");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.18" state="changed">128a129,135
&gt;     &lt;ajc-test dir="java5/varargs" title="varargs in constructor sig" vm="1.5"&gt;
&gt;         &lt;compile files="Pr88652.aj" options="-1.5"&gt;
&gt;             &lt;message kind="warning" line="8" text="should match"/&gt;
&gt;             &lt;message kind="warning" line="9" text="should match"/&gt;        
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/java5/varargs/Pr88652.aj" revision="1.1" state="new">public aspect Pr88652 {
	
	pointcut p(): call(Touple.new(..));
	
	declare warning: p() : "should match";
	
	public static void main(String[] args) {
		Touple t = new Touple(new Object());
		Touple t2 = new Touple(new Object(),new Object());
	}
}


class Touple {
	
	public Touple(Object formulaHandle, Object... propositions) {
		; // empty
	}
	
}</file>
</fixedFiles>
</bug>
<bug id="89152" transactionid="73009">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="6"/>
<property name="lines-deleted" value="51"/>
<property name="lines-modified" value="16"/>
<property name="lines-churned" value="73"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-else K-if K-import K-null K-return K-try M O-== T V Y Z-if</fullfingerprint>
<bugreport>I am using the headless ANT feature provided in Rational Application Developer 
(RAD) v6.0 to build a web project. If the web project is not an ASPECTJ 
project, then all .class files end up in the WebContent\WEB-INF\classes folder, 
as expected. However, if I make the web project an ASPECTJ project, then 
all .class files end up in the JavaSource (the same folder where the source 
files are located). This does not happen when I build the web ASPECTJ project 
using the user interface; it only happens when running RAD in headless mode.

I will upload a zip file (files.zip) that contains the files to re-create the 
problem.  I have applied fixpak 2 to RAD (RAD Version: 6.0.0 Build id: 
20041117_2230). I am running Windows 2000. I am running the latest AJDT 
development build: ajdt_1.2.0.20050325175227_archive.zip

In the following folder you should find a runAnt.bat file:

&lt;RAD installation folder&gt;\rwd\eclipse\plugins\com.ibm.etools.j2ee.ant_6.0.0.002

(in my case the RAD installation folder is: C:\Program 
Files\IBM\Rational\SDP\6.0)

In the runAnt.bat file, make sure you set the WORKSPACE variable to a folder 
that is empty. In my case, I set it to:

set WORKSPACE=C:\build_workspace

Also, copy to this folder (&lt;RAD installation 
folder&gt;\rwd\eclipse\plugins\com.ibm.etools.j2ee.ant_6.0.0.002) the following 
files that I have included in the zip file:
1) build.xml
2) ProjectBuild.xml
3) build.properties

Done this, copy to the empty workspace folder (in my case this is 
C:\build_workspace) the two folder projects I also included in the zip file:
1) BuildEAR
2) BuildWEB

So, in the worskpace folder you should have now these two folders.
The next step is to go back to the folder where the runAnt.bat is (&lt;RAD 
installation folder&gt;\rwd\eclipse\plugins\com.ibm.etools.j2ee.ant_6.0.0.002). 
Using the command line environment, execute the runAnt.bat file (remember, the 
WORKSPACE variable should be set correctly before running this script). The 
runAnt.bat file will use the build.xml and the ProjectBuild.xml files. This 
will import those two projects into a clean workspace and then it will try to 
build both projects. After you have built the web ASPECTJ project, you should 
find the .class files in the source folder and not in the WebContent\WEB-
INF\classes folder.</bugreport>
<pre-fix-testcases failing="112" file="output/89152/pre-fix/testresults.xml" passing="1429" size="1541"/>
<post-fix-testcases failing="112" file="output/89152/post-fix/testresults.xml" passing="1429" size="1541"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/ajde/ProjectProperties.java" revision="1.15" state="changed">67,117d66
&lt; 	 * Called to determine where the resultant class files should go when AJC is
&lt; 	 * compiling code. We grab the location from the current project and convert
&lt; 	 * it to a string.
&lt; 	 */
&lt; 	public String getOutputPath() {
&lt; 		try {
&lt; 			IProject currProject = AspectJPlugin.getDefault()
&lt; 					.getCurrentProject();
&lt; 			IJavaProject jProject = JavaCore.create(currProject);
&lt; 			IPath workspaceRelativeOutputPath = jProject.getOutputLocation();
&lt; 
&lt; 			if (workspaceRelativeOutputPath.segmentCount() == 1) { // project
&lt; 				// root
&lt; 				return jProject.getResource().getLocation().toOSString();
&lt; 			} else {
&lt; 				IFolder out = ResourcesPlugin.getWorkspace().getRoot()
&lt; 						.getFolder(workspaceRelativeOutputPath);
&lt; 				return out.getLocation().toOSString();
&lt; 			}
&lt; 
&lt; 			// Bug 37033 - get the path right, stupid!
&lt; 			// // Bug21998: Use the project location rather than the workspace
&lt; 			// location.
&lt; 			// String workspaceLoc =
&lt; 			// currProject.getLocation().removeLastSegments(1).toOSString();
&lt; 			//
&lt; 			// IJavaProject jProject = JavaCore.create(currProject);
&lt; 			// String relativePath = jProject.getOutputLocation().toOSString();
&lt; 			// return workspaceLoc + relativePath;
&lt; 
&lt; 			// find the resource that corresponds with this path (if its a
&lt; 			// linked folder this will enable us to dereference it).
&lt; 
&lt; 			// IResource r =
&lt; 			// currProject.findMember(workspaceRelativeOutputPath.removeFirstSegments(1));
&lt; 			// String ret = "";
&lt; 			// if ( r != null ) ret = r.getLocation().toOSString();
&lt; 			// AJDTEventTrace.generalEvent("Output path =" + ret);
&lt; 			//			
&lt; 			// System.err.println("&gt;&gt;&gt;&gt; ret: " + ret + ", r: " + r);
&lt; 			//			
&lt; 			// return ret;
&lt; 		} catch (CoreException ce) {
&lt; 			Ajde.getDefault().getErrorHandler().handleError(
&lt; 					AspectJUIPlugin.getResourceString("noOutputDir"), ce);
&lt; 		}
&lt; 		return null;
&lt; 	}
&lt; 
&lt; 
&lt; 	/**
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/builder/CoreProjectProperties.java" revision="1.2" state="changed">28a29
&gt; import org.eclipse.core.resources.ResourcesPlugin;
167a169,173
&gt; 	/**
&gt; 	 * Called to determine where the resultant class files should go when AJC is
&gt; 	 * compiling code. We grab the location from the current project and convert
&gt; 	 * it to a string.
&gt; 	 */
169c175,190
&lt; 		return "";
---
&gt; 		IProject currProject = AspectJPlugin.getDefault().getCurrentProject();
&gt; 		IJavaProject jProject = JavaCore.create(currProject);
&gt; 		IPath workspaceRelativeOutputPath;
&gt; 		try {
&gt; 			workspaceRelativeOutputPath = jProject.getOutputLocation();
&gt; 		} catch (JavaModelException e) {
&gt; 			return currProject.getLocation().toOSString();
&gt; 		}
&gt; 		if (workspaceRelativeOutputPath.segmentCount() == 1) { // project
&gt; 			// root
&gt; 			return jProject.getResource().getLocation().toOSString();
&gt; 		} else {
&gt; 			IFolder out = ResourcesPlugin.getWorkspace().getRoot().getFolder(
&gt; 					workspaceRelativeOutputPath);
&gt; 			return out.getLocation().toOSString();
&gt; 		}
</file>
</fixedFiles>
</bug>
<bug id="92880" transactionid="71660">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint/>
<fullfingerprint/>
<bugreport>implement PTW for @AJ aspects
so far delayed to make sure PTW in code style was not evolving</bugreport>
<testsforfix ID="92880" type="changed">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/syntax.xml">
      <test NAME="IfPointcutTest"/>
      <test NAME="IfPointcut2Test"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="177" file="output/92880/pre-fix/testresults.xml" passing="1531" size="1708"/>
<post-fix-testcases failing="178" file="output/92880/post-fix/testresults.xml" passing="1530" size="1708"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java" revision="1.10" state="changed">497,498c497,498
&lt;         il.append(InstructionConstants.ALOAD_1);
&lt;         il.append(InstructionConstants.ATHROW);
---
&gt;         il.append(InstructionConstants.ACONST_NULL);
&gt;         il.append(InstructionConstants.ARETURN);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/syntax.xml" revision="1.18" state="changed">75,76c75,76
&lt; &lt;!--        &lt;compile files="ataspectj/IfPointcutTest.java,ataspectj/TestHelper.java" options="-1.5"/&gt;--&gt;
&lt; &lt;!--        &lt;run class="ataspectj.IfPointcutTest"/&gt;--&gt;
---
&gt;         &lt;!--&lt;compile files="ataspectj/IfPointcutTest.java,ataspectj/TestHelper.java" options="-1.5"/&gt;--&gt;
&gt;         &lt;!--&lt;run class="ataspectj.IfPointcutTest"/&gt;--&gt;
83,84c83,84
&lt; &lt;!--        &lt;compile files="ataspectj/IfPointcut2Test.java,ataspectj/TestHelper.java" options="-1.5"/&gt;--&gt;
&lt; &lt;!--        &lt;run class="ataspectj.IfPointcut2Test"/&gt;--&gt;
---
&gt;         &lt;!--&lt;compile files="ataspectj/IfPointcut2Test.java,ataspectj/TestHelper.java" options="-1.5"/&gt;--&gt;
&gt;         &lt;!--&lt;run class="ataspectj.IfPointcut2Test"/&gt;--&gt;
</file>
</fixedFiles>
</bug>
<bug id="93532" transactionid="72147">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-null M O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I converted a project to an AspectJ project and saw an NPE as below. This
project DID NOT HAVE a plugin.xml file.

java.lang.NullPointerException
	at
org.eclipse.ajdt.internal.core.AJDTUtils.getPDEManifestEditor(AJDTUtils.java:682)
	at
org.eclipse.ajdt.internal.core.AJDTUtils.hasAJPluginDependency(AJDTUtils.java:846)
	at org.eclipse.ajdt.internal.core.AJDTUtils.addAspectJNature(AJDTUtils.java:204)
	at
org.eclipse.ajdt.internal.ui.actions.AddAJNatureAction.run(AddAJNatureAction.java:50)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:246)
	at
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:538)
	at
org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
	at
org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2894)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2527)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1570)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1534)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:306)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
	at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:228)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:156)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:315)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:268)
	at org.eclipse.core.launcher.Main.run(Main.java:942)
	at org.eclipse.core.launcher.Main.main(Main.java:926)</bugreport>
<testsforfix ID="93532" type="new">
    <file LOCATION="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/internal/core/AJDTUtilsTest.java">
      <test NAME="testBug93532"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="69" file="output/93532/pre-fix/testresults.xml" passing="873" size="942"/>
<post-fix-testcases failing="69" file="output/93532/post-fix/testresults.xml" passing="873" size="942"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/core/AJDTUtils.java" revision="1.33" state="changed">200c200,203
&lt; 		if (project.hasNature(PDE.PLUGIN_NATURE)) {
---
&gt; 		// Bugzilla 93532 - just add plugin dependency if there is a plugin.xml file
&gt; 		if (project.hasNature(PDE.PLUGIN_NATURE) 
&gt; 		        &amp;&amp; PDECore.getDefault().getWorkspaceModelManager()
&gt; 		        	.getWorkspacePluginModel(project) != null) {
833c836,839
&lt; 		if (project.hasNature(PDE.PLUGIN_NATURE)) {
---
&gt; 		// Bugzilla 93532 - just remove plugin dependency if there is a plugin.xml file
&gt; 		if (project.hasNature(PDE.PLUGIN_NATURE) 
&gt; 		        &amp;&amp; PDECore.getDefault().getWorkspaceModelManager()
&gt; 		        	.getWorkspacePluginModel(project) != null) {
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/internal/core/AJDTUtilsTest.java" revision="1.15" state="changed">101a102,129
&gt; 	
&gt; 	/**
&gt; 	 * Test for bug 93532 - NPE when add aspectj nature to a plugin project
&gt; 	 * which doesn't have a plugin.xml file.
&gt; 	 * 
&gt; 	 * @throws Exception
&gt; 	 */
&gt; 	public void testBug93532() throws Exception {
&gt; 		IProject testProject = Utils.createPredefinedProject("bug93532");
&gt; 		IJavaProject jY = JavaCore.create(testProject);
&gt; 		Utils.waitForJobsToComplete();
&gt; 		
&gt; 		assertFalse("Java project should not have AspectJ Nature",
&gt; 				AspectJPlugin.isAJProject(testProject.getProject()));
&gt; 		assertFalse("Build path shouldn't contain aspectjrt.jar",
&gt; 				hasAjrtOnBuildPath(jY));
&gt; 		AJDTUtils.addAspectJNature(testProject.getProject());
&gt; 		assertTrue("Java project should now have AspectJ Nature", AspectJPlugin
&gt; 				.isAJProject(testProject.getProject()));
&gt; 		assertTrue("Build path should now contain aspectjrt.jar",
&gt; 				hasAjrtOnBuildPath(jY));
&gt; 		AJDTUtils.removeAspectJNature(testProject.getProject());
&gt; 		assertFalse("Java project should not have AspectJ Nature",
&gt; 				AspectJPlugin.isAJProject(testProject.getProject()));
&gt; 		assertFalse("Build path shouldn't contain aspectjrt.jar",hasAjrtOnBuildPath(jY));
&gt; 		Utils.deleteProject(testProject);
&gt; 		Utils.waitForJobsToComplete();	    
&gt; 	}
</file>
</fixedFiles>
</bug>
<bug id="95370" transactionid="73279">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="31"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="34"/>
<property name="lines-churned" value="65"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-break K-case K-catch K-class K-continue K-default K-false K-if K-import K-new K-null K-super K-switch K-try K-while M O-== T V Y Z-if Z-switch Z-while</fullfingerprint>
<bugreport>Possibly the fault of the AspectJ parsers ...

I'm working on a module of AspectJ, when I convert it to an .aj project and ask
it to convert file extensions, it renames a couple of files it shouldnt.
I'm attaching the offending files:</bugreport>
<testsforfix ID="95370" type="new">
    <file LOCATION="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/codeconversion/CodeCheckerTest.java">
      <test NAME="testContainsAspectJConstructs2"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="69" file="output/95370/pre-fix/testresults.xml" passing="873" size="942"/>
<post-fix-testcases failing="69" file="output/95370/post-fix/testresults.xml" passing="873" size="942"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/internal/codeconversion/CodeChecker.java" revision="1.2" state="changed">19,21c19,24
&lt; import org.aspectj.org.eclipse.jdt.core.compiler.InvalidInputException;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.parser.Scanner;
&lt; import org.aspectj.org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
---
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.batch.CompilationUnit;
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser;
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
52,53c55,56
&lt; 			char[] data = new char[size];
&lt; 			fr.read(data, 0, size);
---
&gt; 			char[] source = new char[size];
&gt; 			fr.read(source, 0, size);
56,77c59,82
&lt; 			Scanner scanner = new Scanner();
&lt; 			scanner.setSource(data);
&lt; 
&lt; 			int tok;
&lt; 			while (true) {
&lt; 				try {
&lt; 					tok = scanner.getNextToken();
&lt; 				} catch (InvalidInputException e) {
&lt; 					continue;
&lt; 				}
&lt; 				if (tok == TerminalTokens.TokenNameEOF)
&lt; 					break;
&lt; 
&lt; 				switch (tok) {
&lt; 				case TerminalTokens.TokenNameaspect:
&lt; 					return true;
&lt; 				case TerminalTokens.TokenNamepointcut:
&lt; 					return true;
&lt; 				default:
&lt; 					break;
&lt; 				}
&lt; 			}
---
&gt; 			/*
&gt; 			 * bug 95370: we previously used a simple scanner here, looking for
&gt; 			 * aspect or pointcut tokens. But there might be identifiers with
&gt; 			 * the same name, which is allowed. Therefore we need to do a parse
&gt; 			 * instead, so that the context is taken into account, allowing us
&gt; 			 * to determine only when "aspect" or "pointcut" are used as
&gt; 			 * keywords.
&gt; 			 */
&gt; 
&gt; 			// create a compilation unit with the source code for input to the
&gt; 			// parser
&gt; 			CompilerOptions options = new CompilerOptions();
&gt; 			ProblemReporter probrep = new ProblemReporter(null, options, null);
&gt; 			ICompilationUnit sourceUnit = new CompilationUnit(source, "", //$NON-NLS-1$
&gt; 					options.defaultEncoding);
&gt; 			CompilationResult result = new CompilationResult(sourceUnit, 0, 0,
&gt; 					options.maxProblemsPerUnit);
&gt; 
&gt; 			// drive our parser extension which records aspect and pointcut
&gt; 			// declarations
&gt; 			AspectDetectingParser parser = new AspectDetectingParser(probrep,
&gt; 					false);
&gt; 			parser.parse(sourceUnit, result);
&gt; 			return parser.containsAspectJSyntax();
83a89
&gt; 
84a91,120
&gt; 
&gt; /**
&gt;  * Extends the AspectJ parser, and records whether any AspectJ-specific syntax
&gt;  * (aspects or pointcut declarations) is encountered.
&gt;  */
&gt; class AspectDetectingParser extends Parser {
&gt; 
&gt; 	private boolean foundAspectJSyntax = false;
&gt; 
&gt; 	public AspectDetectingParser(ProblemReporter problemReporter,
&gt; 			boolean optimizeStringLiterals) {
&gt; 		super(problemReporter, optimizeStringLiterals);
&gt; 		diet = true;
&gt; 	}
&gt; 
&gt; 	protected void consumeAspectDeclaration() {
&gt; 		foundAspectJSyntax = true;
&gt; 		super.consumeAspectDeclaration();
&gt; 	}
&gt; 
&gt; 	protected void consumePointcutDeclaration() {
&gt; 		foundAspectJSyntax = true;
&gt; 		super.consumePointcutDeclaration();
&gt; 	}
&gt; 
&gt; 	public boolean containsAspectJSyntax() {
&gt; 		return foundAspectJSyntax;
&gt; 	}
&gt; 
&gt; }
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/codeconversion/CodeCheckerTest.java" revision="1.2" state="changed">51c51
&lt; 		
---
&gt; 
84a85,114
&gt; 
&gt; 	/**
&gt; 	 * Check that CodeChecker.containsAspectJConstructs() returns false for all
&gt; 	 * the given source files, despite them containing "pointcut" and "aspect"
&gt; 	 * used as identifiers (instead of keywords)
&gt; 	 * 
&gt; 	 * @throws Exception
&gt; 	 */
&gt; 	public void testContainsAspectJConstructs2() throws Exception {
&gt; 		IProject project = createPredefinedProject("bug95370");
&gt; 		try {
&gt; 			project.accept(new IResourceVisitor() {
&gt; 				public boolean visit(IResource resource) throws CoreException {
&gt; 					if (resource.getType() == IResource.FILE) {
&gt; 						String name = resource.getName();
&gt; 						if (CoreUtils.ASPECTJ_SOURCE_FILTER.accept(name)) {
&gt; 							boolean ret = CodeChecker
&gt; 									.containsAspectJConstructs((IFile) resource);
&gt; 							assertFalse(
&gt; 									"Returned true from CodeChecker.containsAspectJConstructs for "
&gt; 											+ name + ", expected false", ret);
&gt; 						}
&gt; 					}
&gt; 					return true;
&gt; 				}
&gt; 			});
&gt; 		} finally {
&gt; 			deleteProject(project);
&gt; 		}
&gt; 	}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug95370/src/DeclarationFactory.java" revision="1.1" state="new">/*******************************************************************************&#13;
 * Copyright (c) 2002,2003 Palo Alto Research Center, Incorporated (PARC).&#13;
 * Copyright (c) 2004 IBM Corporation and others.&#13;
 * All rights reserved. This program and the accompanying materials &#13;
 * are made available under the terms of the Common Public License v1.0&#13;
 * which accompanies this distribution, and is available at&#13;
 * http://www.eclipse.org/legal/cpl-v10.html&#13;
 * &#13;
 * Contributors:&#13;
 *     PARC initial implementation &#13;
 *     IBM Corporation &#13;
 *******************************************************************************/&#13;
package org.aspectj.ajdt.internal.compiler.parser;&#13;
&#13;
import org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.AjConstructorDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.AjMethodDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.DeclareAnnotationDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.DeclareDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.IfPseudoToken;&#13;
import org.aspectj.ajdt.internal.compiler.ast.InterTypeConstructorDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.PointcutDeclaration;&#13;
import org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator;&#13;
import org.aspectj.ajdt.internal.compiler.ast.Proceed;&#13;
import org.aspectj.ajdt.internal.compiler.ast.PseudoToken;&#13;
import org.aspectj.ajdt.internal.compiler.ast.PseudoTokens;&#13;
import org.aspectj.ajdt.internal.core.builder.EclipseSourceContext;&#13;
import org.aspectj.weaver.AdviceKind;&#13;
import org.aspectj.weaver.patterns.Declare;&#13;
import org.aspectj.weaver.patterns.DeclareAnnotation;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory;&#13;
&#13;
/**&#13;
 * @author colyer&#13;
 *&#13;
 * To change the template for this generated type comment go to&#13;
 * Window&amp;gt;Preferences&amp;gt;Java&amp;gt;Code Generation&amp;gt;Code and Comments&#13;
 */&#13;
public class DeclarationFactory implements IDeclarationFactory {&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createMethodDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public MethodDeclaration createMethodDeclaration(CompilationResult result) {&#13;
		return new AjMethodDeclaration(result);&#13;
	}&#13;
		&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createConstructorDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public ConstructorDeclaration createConstructorDeclaration(CompilationResult result) {&#13;
		return new AjConstructorDeclaration(result);&#13;
	}&#13;
		&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createProceed(org.eclipse.jdt.internal.compiler.ast.MessageSend)&#13;
	 */&#13;
	public MessageSend createProceed(MessageSend m) {&#13;
		return new Proceed(m);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createAspect(org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public TypeDeclaration createAspect(CompilationResult result) {&#13;
		return new AspectDeclaration(result);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setPrivileged(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration, boolean)&#13;
	 */&#13;
	public void setPrivileged(TypeDeclaration aspectDecl, boolean isPrivileged) {&#13;
		((AspectDeclaration)aspectDecl).isPrivileged = isPrivileged;		&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setPerClauseFrom(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration, org.eclipse.jdt.internal.compiler.ast.ASTNode)&#13;
	 */&#13;
	public void setPerClauseFrom(TypeDeclaration aspectDecl, ASTNode pseudoTokens, Parser parser) {&#13;
		AspectDeclaration aspect = (AspectDeclaration) aspectDecl;&#13;
		PseudoTokens tok = (PseudoTokens) pseudoTokens;&#13;
		aspect.perClause = tok.parsePerClause(parser);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setDominatesPatternFrom(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration, org.eclipse.jdt.internal.compiler.ast.ASTNode)&#13;
	 */&#13;
	public void setDominatesPatternFrom(TypeDeclaration aspectDecl, ASTNode pseudoTokens, Parser parser) {&#13;
		AspectDeclaration aspect = (AspectDeclaration) aspectDecl;&#13;
		PseudoTokens tok = (PseudoTokens) pseudoTokens;&#13;
		aspect.dominatesPattern = tok.maybeParseDominatesPattern(parser);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createPseudoTokensFrom(org.eclipse.jdt.internal.compiler.ast.ASTNode[], org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public ASTNode createPseudoTokensFrom(ASTNode[] tokens, CompilationResult result) {&#13;
		PseudoToken[] psts = new PseudoToken[tokens.length];&#13;
		for (int i = 0; i &lt; psts.length; i++) {&#13;
			psts[i] = (PseudoToken)tokens[i];&#13;
		}&#13;
		return new PseudoTokens(psts,new EclipseSourceContext(result));&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createPointcutDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public MethodDeclaration createPointcutDeclaration(CompilationResult result) {&#13;
		return new PointcutDeclaration(result);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createAroundAdviceDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public MethodDeclaration createAroundAdviceDeclaration(CompilationResult result) {&#13;
		return new AdviceDeclaration(result,AdviceKind.Around);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createAfterAdviceDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public MethodDeclaration createAfterAdviceDeclaration(CompilationResult result) {&#13;
		return new AdviceDeclaration(result,AdviceKind.After);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createBeforeAdviceDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public MethodDeclaration createBeforeAdviceDeclaration(CompilationResult result) {&#13;
		return new AdviceDeclaration(result,AdviceKind.Before);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createPointcutDesignator(org.eclipse.jdt.internal.compiler.parser.Parser, org.eclipse.jdt.internal.compiler.ast.ASTNode)&#13;
	 */&#13;
	public ASTNode createPointcutDesignator(Parser parser, ASTNode pseudoTokens) {&#13;
		return new PointcutDesignator(parser,(PseudoTokens)pseudoTokens);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setPointcutDesignator(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, org.eclipse.jdt.internal.compiler.ast.ASTNode)&#13;
	 */&#13;
	public void setPointcutDesignatorOnAdvice(MethodDeclaration adviceDecl, ASTNode des) {&#13;
		((AdviceDeclaration)adviceDecl).pointcutDesignator = (PointcutDesignator)des;&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setPointcutDesignator(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, org.eclipse.jdt.internal.compiler.ast.ASTNode)&#13;
	 */&#13;
	public void setPointcutDesignatorOnPointcut(MethodDeclaration pcutDecl, ASTNode des) {&#13;
		((PointcutDeclaration)pcutDecl).pointcutDesignator = (PointcutDesignator)des;&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setExtraArgument(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, org.eclipse.jdt.internal.compiler.ast.Argument)&#13;
	 */&#13;
	public void setExtraArgument(MethodDeclaration adviceDeclaration, Argument arg) {&#13;
		((AdviceDeclaration)adviceDeclaration).extraArgument = arg;&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#isAfterAdvice(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration)&#13;
	 */&#13;
	public boolean isAfterAdvice(MethodDeclaration adviceDecl) {		&#13;
		return ((AdviceDeclaration)adviceDecl).kind != AdviceKind.After;&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setAfterThrowingAdviceKind(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration)&#13;
	 */&#13;
	public void setAfterThrowingAdviceKind(MethodDeclaration adviceDecl) {&#13;
		((AdviceDeclaration)adviceDecl).kind = AdviceKind.AfterThrowing;&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setAfterReturningAdviceKind(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration)&#13;
	 */&#13;
	public void setAfterReturningAdviceKind(MethodDeclaration adviceDecl) {&#13;
		((AdviceDeclaration)adviceDecl).kind = AdviceKind.AfterReturning;&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createDeclareDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult, org.eclipse.jdt.internal.compiler.ast.ASTNode)&#13;
	 */&#13;
	public MethodDeclaration createDeclareDeclaration(CompilationResult result, ASTNode pseudoTokens, Parser parser) {&#13;
		Declare declare = ((PseudoTokens)pseudoTokens).parseDeclare(parser);&#13;
		return new DeclareDeclaration(result,declare); &#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createDeclareAnnotationDeclaration(org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult, org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode, org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation, org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser)&#13;
	 */&#13;
	public MethodDeclaration createDeclareAnnotationDeclaration(&#13;
			CompilationResult result, ASTNode pseudoTokens,&#13;
			Annotation annotation, Parser parser) {&#13;
		DeclareAnnotation declare = (DeclareAnnotation) ((PseudoTokens)pseudoTokens).parseAnnotationDeclare(parser);&#13;
		DeclareAnnotationDeclaration decl = new DeclareAnnotationDeclaration(result,declare,annotation);&#13;
		return decl;&#13;
	}&#13;
	&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createInterTypeFieldDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult, org.eclipse.jdt.internal.compiler.ast.TypeReference)&#13;
	 */&#13;
	public MethodDeclaration createInterTypeFieldDeclaration(CompilationResult result, TypeReference onType) {&#13;
		return new InterTypeFieldDeclaration(result,onType);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createInterTypeMethodDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public MethodDeclaration createInterTypeMethodDeclaration(CompilationResult result) {&#13;
		return new InterTypeMethodDeclaration(result,null);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createInterTypeConstructorDeclaration(org.eclipse.jdt.internal.compiler.CompilationResult)&#13;
	 */&#13;
	public MethodDeclaration createInterTypeConstructorDeclaration(CompilationResult result) {&#13;
		return new InterTypeConstructorDeclaration(result,null);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setSelector(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, char[])&#13;
	 */&#13;
	public void setSelector(MethodDeclaration interTypeDecl, char[] selector) {&#13;
		((InterTypeDeclaration)interTypeDecl).setSelector(selector);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setDeclaredModifiers(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, int)&#13;
	 */&#13;
	public void setDeclaredModifiers(MethodDeclaration interTypeDecl, int modifiers) {&#13;
		((InterTypeDeclaration)interTypeDecl).setDeclaredModifiers(modifiers);	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setInitialization(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, org.eclipse.jdt.internal.compiler.ast.Expression)&#13;
	 */&#13;
	public void setInitialization(MethodDeclaration itdFieldDecl, Expression initialization) {&#13;
		((InterTypeFieldDeclaration)itdFieldDecl).setInitialization(initialization);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setOnType(org.eclipse.jdt.internal.compiler.ast.MethodDeclaration, org.eclipse.jdt.internal.compiler.ast.TypeReference)&#13;
	 */&#13;
	public void setOnType(MethodDeclaration interTypeDecl, TypeReference onType) {&#13;
		((InterTypeDeclaration)interTypeDecl).onType = onType;	&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createPseudoToken(org.eclipse.jdt.internal.compiler.parser.Parser, java.lang.String, boolean)&#13;
	 */&#13;
	public ASTNode createPseudoToken(Parser parser, String value, boolean isIdentifier) {&#13;
		return new PseudoToken(parser,value,isIdentifier);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#createIfPseudoToken(org.eclipse.jdt.internal.compiler.parser.Parser, org.eclipse.jdt.internal.compiler.ast.Expression)&#13;
	 */&#13;
	public ASTNode createIfPseudoToken(Parser parser, Expression expr) {&#13;
		return new IfPseudoToken(parser,expr);&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#setLiteralKind(org.eclipse.jdt.internal.compiler.ast.ASTNode, java.lang.String)&#13;
	 */&#13;
	public void setLiteralKind(ASTNode pseudoToken, String string) {&#13;
		((PseudoToken)pseudoToken).literalKind = string;&#13;
	}&#13;
&#13;
	/* (non-Javadoc)&#13;
	 * @see org.eclipse.jdt.internal.compiler.parser.Parser.IDeclarationFactory#shouldTryToRecover(org.eclipse.jdt.internal.compiler.ast.ASTNode)&#13;
	 */&#13;
	public boolean shouldTryToRecover(ASTNode node) {&#13;
		return !(node instanceof AspectDeclaration || &#13;
			 	 node instanceof PointcutDeclaration || &#13;
				 node instanceof AdviceDeclaration) ;&#13;
	}&#13;
&#13;
}&#13;
&#13;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug95370/src/AtAspectJAnnotationFactory.java" revision="1.1" state="new">/* *******************************************************************&#13;
 * Copyright (c) 2005 Contributors.&#13;
 * All rights reserved. &#13;
 * This program and the accompanying materials are made available &#13;
 * under the terms of the Eclipse Public License v1.0 &#13;
 * which accompanies this distribution and is available at &#13;
 * http://eclipse.org/legal/epl-v10.html &#13;
 *  &#13;
 * Contributors: &#13;
 *   Adrian Colyer			Initial implementation&#13;
 * ******************************************************************/&#13;
package org.aspectj.ajdt.internal.compiler.ast;&#13;
&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MemberValuePair;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.StringLiteral;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TrueLiteral;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.FalseLiteral;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TagBits;&#13;
&#13;
/**&#13;
 * @author colyer&#13;
 * Creates @AspectJ annotations for use by AtAspectJVisitor&#13;
 */&#13;
public class AtAspectJAnnotationFactory {&#13;
	&#13;
	static final char[] org = "org".toCharArray();&#13;
	static final char[] aspectj = "aspectj".toCharArray();&#13;
	static final char[] lang = "lang".toCharArray();&#13;
	static final char[] internal = "internal".toCharArray();&#13;
	static final char[] annotation = "annotation".toCharArray();&#13;
	static final char[] value = "value".toCharArray();&#13;
	&#13;
	static final char[] aspect = "Aspect".toCharArray();&#13;
	static final char[] privileged = "ajcPrivileged".toCharArray();&#13;
	static final char[] before = "Before".toCharArray();&#13;
	static final char[] after = "After".toCharArray();&#13;
	static final char[] afterReturning = "AfterReturning".toCharArray();&#13;
	static final char[] afterThrowing = "AfterThrowing".toCharArray();&#13;
	static final char[] around = "Around".toCharArray();&#13;
    static final char[] pointcut = "Pointcut".toCharArray(); &#13;
	static final char[] declareErrorOrWarning = "ajcDeclareEoW".toCharArray();&#13;
&#13;
	/**&#13;
	 * Create an @Aspect annotation for a code style aspect declaration starting at&#13;
	 * the given position in the source file&#13;
	 */&#13;
	public static Annotation createAspectAnnotation(String perclause, int pos) {&#13;
		char[][] typeName = new char[][] {org,aspectj,lang,annotation,aspect};&#13;
		long[] positions = new long[] {pos,pos,pos,pos,pos};&#13;
		TypeReference orgAspectJLangAnnotationAspect = new QualifiedTypeReference(typeName,positions);&#13;
		NormalAnnotation atAspectAnnotation = new NormalAnnotation(orgAspectJLangAnnotationAspect,pos);&#13;
		if (!perclause.equals("")) {&#13;
			// we have to set the value&#13;
			Expression perclauseExpr = new StringLiteral(perclause.toCharArray(),pos,pos);&#13;
			MemberValuePair[] mvps = new MemberValuePair[1];&#13;
			mvps[0] = new MemberValuePair(value,pos,pos,perclauseExpr);&#13;
			atAspectAnnotation.memberValuePairs = mvps;&#13;
		}&#13;
		return atAspectAnnotation;&#13;
	}&#13;
	&#13;
	public static Annotation createPrivilegedAnnotation(int pos) {&#13;
		char[][] typeName = new char[][] {org,aspectj,internal,lang,annotation,privileged};&#13;
		long[] positions = new long[] {pos,pos,pos,pos,pos,pos};&#13;
		TypeReference annType = new QualifiedTypeReference(typeName,positions);&#13;
		NormalAnnotation ann = new NormalAnnotation(annType,pos);&#13;
		return ann;&#13;
	}&#13;
&#13;
	public static Annotation createBeforeAnnotation(String pointcutExpression, int pos) {&#13;
		char[][] typeName = new char[][] {org,aspectj,lang,annotation,before};&#13;
		return makeSingleStringMemberAnnotation(typeName, pos, pointcutExpression);&#13;
	}&#13;
&#13;
	public static Annotation createAfterAnnotation(String pointcutExpression, int pos) {&#13;
		char[][] typeName = new char[][] {org,aspectj,lang,annotation,after};&#13;
		return makeSingleStringMemberAnnotation(typeName, pos, pointcutExpression);&#13;
	}&#13;
&#13;
	public static Annotation createAfterReturningAnnotation(String pointcutExpression, String extraArgumentName, int pos) {&#13;
		char[][] typeName = new char[][] {org,aspectj,lang,annotation,afterReturning};&#13;
		long[] positions = new long[] {pos,pos,pos,pos,pos};&#13;
		TypeReference annType = new QualifiedTypeReference(typeName,positions);&#13;
		NormalAnnotation ann = new NormalAnnotation(annType,pos);&#13;
		Expression pcExpr = new StringLiteral(pointcutExpression.toCharArray(),pos,pos);&#13;
		MemberValuePair[] mvps = new MemberValuePair[2];&#13;
		mvps[0] = new MemberValuePair("pointcut".toCharArray(),pos,pos,pcExpr);&#13;
		Expression argExpr = new StringLiteral(extraArgumentName.toCharArray(),pos,pos);&#13;
		mvps[1] = new MemberValuePair("returning".toCharArray(),pos,pos,argExpr);&#13;
		ann.memberValuePairs = mvps;&#13;
		return ann;&#13;
	}&#13;
&#13;
	public static Annotation createAfterThrowingAnnotation(String pointcutExpression, String extraArgumentName, int pos) {&#13;
		char[][] typeName = new char[][] {org,aspectj,lang,annotation,afterThrowing};&#13;
		long[] positions = new long[] {pos,pos,pos,pos,pos};&#13;
		TypeReference annType = new QualifiedTypeReference(typeName,positions);&#13;
		NormalAnnotation ann = new NormalAnnotation(annType,pos);&#13;
		Expression pcExpr = new StringLiteral(pointcutExpression.toCharArray(),pos,pos);&#13;
		MemberValuePair[] mvps = new MemberValuePair[2];&#13;
		mvps[0] = new MemberValuePair("pointcut".toCharArray(),pos,pos,pcExpr);&#13;
		Expression argExpr = new StringLiteral(extraArgumentName.toCharArray(),pos,pos);&#13;
		mvps[1] = new MemberValuePair("throwing".toCharArray(),pos,pos,argExpr);&#13;
		ann.memberValuePairs = mvps;&#13;
		return ann;&#13;
	}&#13;
&#13;
	public static Annotation createAroundAnnotation(String pointcutExpression, int pos) {&#13;
		char[][] typeName = new char[][] {org,aspectj,lang,annotation,around};&#13;
		return makeSingleStringMemberAnnotation(typeName, pos, pointcutExpression);&#13;
	}&#13;
&#13;
	public static Annotation createPointcutAnnotation(String pointcutExpression, int pos) {&#13;
		char[][] typeName = new char[][] {org,aspectj,lang,annotation,pointcut};&#13;
		return makeSingleStringMemberAnnotation(typeName, pos, pointcutExpression);&#13;
	}&#13;
&#13;
	public static Annotation createDeclareErrorOrWarningAnnotation(String pointcutExpression, String message, boolean isError, int pos) {&#13;
		char[][] typeName = new char[][] {org,aspectj,internal,lang,annotation,declareErrorOrWarning};&#13;
		long[] positions = new long[typeName.length];&#13;
		for (int i = 0; i &lt; positions.length; i++) positions[i] = pos;&#13;
		TypeReference annType = new QualifiedTypeReference(typeName,positions);&#13;
		NormalAnnotation ann = new NormalAnnotation(annType,pos);&#13;
		Expression pcutExpr = new StringLiteral(pointcutExpression.toCharArray(),pos,pos);&#13;
		Expression msgExpr = new StringLiteral(message.toCharArray(),pos,pos);&#13;
		Expression isErrorExpr;&#13;
		if (isError) {&#13;
			isErrorExpr = new TrueLiteral(pos,pos);&#13;
		} else {&#13;
			isErrorExpr =  new FalseLiteral(pos,pos);&#13;
		}&#13;
		MemberValuePair[] mvps = new MemberValuePair[3];&#13;
		mvps[0] = new MemberValuePair("pointcut".toCharArray(),pos,pos,pcutExpr);&#13;
		mvps[1] = new MemberValuePair("message".toCharArray(),pos,pos,msgExpr);&#13;
		mvps[2] = new MemberValuePair("isError".toCharArray(),pos,pos,isErrorExpr);&#13;
		ann.memberValuePairs = mvps;&#13;
		return ann;&#13;
	}&#13;
	&#13;
	private static Annotation makeSingleStringMemberAnnotation(char[][] name, int pos, String annValue) {&#13;
		long[] positions = new long[name.length];&#13;
		for (int i = 0; i &lt; positions.length; i++) positions[i] = pos;&#13;
		TypeReference annType = new QualifiedTypeReference(name,positions);&#13;
		NormalAnnotation ann = new NormalAnnotation(annType,pos);&#13;
		Expression valueExpr = new StringLiteral(annValue.toCharArray(),pos,pos);&#13;
		MemberValuePair[] mvps = new MemberValuePair[1];&#13;
		mvps[0] = new MemberValuePair(value,pos,pos,valueExpr);&#13;
		ann.memberValuePairs = mvps;&#13;
		return ann;		&#13;
	}&#13;
&#13;
	public static void addAnnotation(AjMethodDeclaration decl, Annotation annotation) {&#13;
		if (decl.annotations == null) {&#13;
			decl.annotations = new Annotation[] { annotation };&#13;
		} else {&#13;
			Annotation[] old = decl.annotations;&#13;
			decl.annotations = new Annotation[old.length +1];&#13;
			System.arraycopy(old,0,decl.annotations,0,old.length);&#13;
			decl.annotations[old.length] = annotation;&#13;
		}&#13;
		if (decl.binding!= null) {&#13;
			decl.binding.tagBits -= TagBits.AnnotationResolved;&#13;
		}&#13;
	}&#13;
&#13;
}&#13;
&#13;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug95370/src/IfPseudoToken.java" revision="1.1" state="new">/* *******************************************************************&#13;
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).&#13;
 * All rights reserved. &#13;
 * This program and the accompanying materials are made available &#13;
 * under the terms of the Common Public License v1.0 &#13;
 * which accompanies this distribution and is available at &#13;
 * http://www.eclipse.org/legal/cpl-v10.html &#13;
 *  &#13;
 * Contributors: &#13;
 *     PARC     initial implementation &#13;
 * ******************************************************************/&#13;
&#13;
&#13;
/*package org.aspectj.ajdt.internal.compiler.ast;&#13;
&#13;
import java.lang.reflect.Modifier;&#13;
&#13;
import org.aspectj.weaver.Member;&#13;
import org.aspectj.weaver.ResolvedMember;&#13;
import org.aspectj.weaver.TypeX;&#13;
import org.aspectj.weaver.patterns.IfPointcut;&#13;
import org.aspectj.weaver.patterns.Pointcut;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.CompilationResult;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.FalseLiteral;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.ReturnStatement;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.Statement;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TrueLiteral;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.TypeBinding;&#13;
import org.aspectj.org.eclipse.jdt.internal.compiler.parser.Parser;&#13;
*/&#13;
&#13;
/**&#13;
 * (formals*): ... if(expr) ...&#13;
 * &#13;
 * generates the following:&#13;
 * public static final boolean ajc$if_N(formals*, [thisJoinPoints as needed]) {&#13;
 *     return expr;&#13;
 * }&#13;
 * &#13;
 * Here's the complicated bit, it deals with cflow:&#13;
 * 	(a): ... this(a) &amp;&amp; cflow(if (a == foo)) is an error.&#13;
 * The way we capture this is:&#13;
 *  We generate the ajc$if method with an (a) parameter, we let eclipse do the proper&#13;
 * name binding.  We then, as a post pass (that we need to do anyway) look for the&#13;
 * used parameters.  If a is used, we signal an error because a was not one of the &#13;
 * cflow variables. &#13;
 * XXX we'll do this part after we do cflow&#13;
 * &#13;
 * The IfPointcut pcd then generates itself always as a dynamic test, it has to&#13;
 * get the right parameters through any named pointcut references...&#13;
 */&#13;
public class IfPseudoToken extends PseudoToken {&#13;
    public Expression expr;&#13;
    public MethodDeclaration testMethod;&#13;
    private IfPointcut pointcut;&#13;
    &#13;
	public IfPseudoToken(&#13;
		Parser parser,&#13;
		Expression expr) {&#13;
		super(parser, "if", false);&#13;
		this.expr = expr;&#13;
	}&#13;
	&#13;
	public Pointcut maybeGetParsedPointcut() {&#13;
		if (expr instanceof FalseLiteral) {&#13;
			return IfPointcut.makeIfFalsePointcut(Pointcut.SYMBOLIC);&#13;
		} else if (expr instanceof TrueLiteral) {&#13;
			return IfPointcut.makeIfTruePointcut(Pointcut.SYMBOLIC);&#13;
		} else {&#13;
		  pointcut = new IfPointcut(new ResolvedMember(Member.METHOD, TypeX.OBJECT, 0, "if_", "()V"), 0);&#13;
		}&#13;
		return pointcut;&#13;
		&#13;
	}&#13;
&#13;
&#13;
	/**&#13;
	 * enclosingDec is either AdviceDeclaration or PointcutDeclaration&#13;
	 */&#13;
	public void postParse(TypeDeclaration typeDec, MethodDeclaration enclosingDec) {&#13;
//		typeDec.scope.problemReporter().signalError(sourceStart, sourceEnd,&#13;
//			"if pcd is not implemented in 1.1alpha1");&#13;
		//XXX need to implement correctly&#13;
		if (pointcut == null) return;&#13;
		testMethod = makeMethod(enclosingDec.compilationResult, enclosingDec);&#13;
		AstUtil.addMethodDeclaration(typeDec, testMethod);&#13;
	}&#13;
&#13;
&#13;
	//XXX static state bad&#13;
	private static int counter = 0;&#13;
&#13;
	//XXX todo: make sure that errors in Arguments only get displayed once&#13;
	private MethodDeclaration makeMethod(CompilationResult result, MethodDeclaration enclosingDec) {&#13;
		MethodDeclaration ret = new IfMethodDeclaration(result, pointcut);&#13;
		ret.modifiers = AccStatic | AccFinal | AccPublic;&#13;
		ret.returnType = AstUtil.makeTypeReference(TypeBinding.BooleanBinding);&#13;
		ret.selector = ("ajc$if_" + counter++).toCharArray();&#13;
		ret.arguments = makeArguments(enclosingDec);&#13;
		ret.statements = new Statement[] {&#13;
			new ReturnStatement(expr, expr.sourceStart, expr.sourceEnd)&#13;
		};&#13;
		return ret;&#13;
	}&#13;
&#13;
	private Argument[] makeArguments(MethodDeclaration enclosingDec) {&#13;
		Argument[] baseArguments = enclosingDec.arguments;&#13;
		int len = baseArguments.length;&#13;
		if (enclosingDec instanceof AdviceDeclaration) {&#13;
			len = ((AdviceDeclaration)enclosingDec).baseArgumentCount;&#13;
		}&#13;
		&#13;
		Argument[] ret = new Argument[len];&#13;
		for (int i=0; i &lt; len; i ++) {&#13;
			Argument a = baseArguments[i];&#13;
			ret[i] = new Argument(a.name, AstUtil.makeLongPos(a.sourceStart, a.sourceEnd),&#13;
								a.type, Modifier.FINAL);&#13;
		}&#13;
		ret = AdviceDeclaration.addTjpArguments(ret);&#13;
		&#13;
		return ret;&#13;
	}&#13;
&#13;
}&#13;
&#13;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug95370/.classpath" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug95370/.project" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug95370/build.ajproperties" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="95517" transactionid="69860">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="12"/>
<property name="lines-added" value="39"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="13"/>
<property name="lines-churned" value="52"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-class M T V Y</fullfingerprint>
<bugreport>docs says ajc provides LTW things, but that one does not at all go thru aop.xml
lookups and so on

Needs to be removed or made consistent in some way</bugreport>
<pre-fix-testcases failing="180" file="output/95517/pre-fix/testresults.xml" passing="1603" size="1783"/>
<post-fix-testcases failing="181" file="output/95517/post-fix/testresults.xml" passing="1602" size="1783"/>
<fixedFiles>
<file name="org.aspectj/modules/build/src/$installer$/org/aspectj/Main.java" revision="1.13" state="changed">708c708
&lt;         return !onMacintosh() &amp;&amp; !onWindows();
---
&gt;         return !onWindows();
1350c1350,1351
&lt;                     lsm.writeAJLaunchScript();
---
&gt;                     lsm.writeAJLaunchScript("aj",false);
&gt;                     lsm.writeAJLaunchScript("aj5",true);
1520,1521c1521
&lt; 	public void writeAJLaunchScript() throws IOException {
&lt; 		String name = "aj";
---
&gt; 	public void writeAJLaunchScript(String name, boolean isJava5) throws IOException {
1535c1535
&lt; 		writeAJLaunchScriptContent(ps);
---
&gt; 		writeAJLaunchScriptContent(ps,isJava5);
1546c1546
&lt; 	private void writeAJLaunchScriptContent(PrintStream ps) {
---
&gt; 	private void writeAJLaunchScriptContent(PrintStream ps, boolean isJava5) {
1549c1549,1550
&lt; 			writeAJUnixLaunchLine(ps);
---
&gt; 			if (isJava5) writeAJ5UnixLaunchLine(ps);
&gt; 			else writeAJUnixLaunchLine(ps);
1553c1554,1555
&lt; 			writeAJWindowsLaunchLine(ps);
---
&gt; 			if (isJava5) writeAJ5WindowsLaunchLine(ps);
&gt; 			else writeAJWindowsLaunchLine(ps);
1564c1566
&lt; 			" \"-Djava.system.class.loader=org.aspectj.weaver.WeavingURLClassLoader\"" +
---
&gt; 			" \"-Djava.system.class.loader=org.aspectj.weaver.loadtime.WeavingURLClassLoader\"" +
1572a1575,1585
&gt; 	private void writeAJ5WindowsLaunchLine(PrintStream ps) {
&gt; 		ps.println(
&gt; 			"\"%JAVA_HOME%\\bin\\java\" -classpath " +
&gt; 			"\"%ASPECTJ_HOME%\\lib\\aspectjweaver.jar;%CLASSPATH%\"" +
&gt; 			" \"-javaagent:%ASPECTJ_HOME%\\lib\\aspectjweaver.jar\"" +
&gt; 			" " + makeScriptArgs(false));
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * @param ps
&gt; 	 */
1577c1590
&lt; 		    " \"-Djava.system.class.loader=org.aspectj.weaver.WeavingURLClassLoader\"" +
---
&gt; 		    " \"-Djava.system.class.loader=org.aspectj.weaver.loadtime.WeavingURLClassLoader\"" +
1583a1597,1608
&gt; 	/**
&gt; 	 * @param ps
&gt; 	 */
&gt; 	private void writeAJ5UnixLaunchLine(PrintStream ps) {
&gt; 		ps.println(
&gt; 			"\"$JAVA_HOME/bin/java\" -classpath" +
&gt; 		    " \"$ASPECTJ_HOME/lib/aspectjweaver.jar:$CLASSPATH\"" +
&gt; 		    " \"-javaagent:$ASPECTJ_HOME/lib/aspectjweaver.jar\"" +
&gt; 		    " " +
&gt; 			makeScriptArgs(true));
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/docs/dist/doc/examples/ltw/README" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/docs/dist/doc/examples/ltw/Tracing.aj" revision="1.1" state="new">/*
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster    initial implementation
 */
public aspect Tracing {

	private pointcut mainMethod () :
		execution(public static void main(String[]));

	before () : mainMethod() {
		System.out.println("&gt; " + thisJoinPoint);
	}

	after () : mainMethod() {
		System.out.println("&lt; " + thisJoinPoint);
	}
}
</file>
<file name="org.aspectj/modules/docs/dist/doc/examples/ltw/HelloWorld.java" revision="1.1" state="new">/*
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster    initial implementation
 */
public class HelloWorld {
	
	public static void main (String[] args) {
		System.out.println("Hello World!");
	}
}
</file>
</fixedFiles>
</bug>
<bug id="95529" transactionid="71536">
<property name="files-churned" value="13"/>
<property name="java-files-churned" value="9"/>
<property name="classes-churned" value="9"/>
<property name="methods-churned" value="8"/>
<property name="hunks" value="32"/>
<property name="lines-added" value="375"/>
<property name="lines-deleted" value="4"/>
<property name="lines-modified" value="50"/>
<property name="lines-churned" value="429"/>
<property name="priority" value="P2"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-class K-else K-false K-for K-if K-import K-instanceof K-new K-null K-package K-return K-this K-throw K-true K-while M O-== O-&gt; O-|| O-! O-!= O-() O-&amp;&amp; O-+ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-throw Z-vardecl Z-while</fullfingerprint>
<bugreport>for M4

note: need to think some if we want to jit the concrete aspect, or if its not
that needed ie that the shadow munger API allow us to do what we need (perhaps
not easy to deal with perClause and uniqueness enforcement of concrete-aspect
name, but perhaps a burden as well to deal with jit since then no bytecode can
be grabbed from file system ie may confuse the bcel repository and resolvedTypeX
and alike)

Ideas Andy ? I am more in favor of bytecode gen the concrete aspect there.
(that further means the underlying infra needs to support define class callbacks
like "acceptClass" thing used for ajc$Closure and alike when running LTW. I am
ok with that)</bugreport>
<testsforfix ID="95529" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
      <test NAME="testConcreteAtAspect"/>
      <test NAME="testConcreteAspect"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.java">
      <test NAME="testConcrete"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml">
      <test NAME="Concrete@Aspect"/>
      <test NAME="ConcreteAspect"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/95529/pre-fix/testresults.xml" passing="1580" size="1760"/>
<post-fix-testcases failing="177" file="output/95529/post-fix/testresults.xml" passing="1583" size="1760"/>
<fixedFiles>
<file name="org.aspectj/modules/docs/adk15ProgGuideDB/ltw.xml" revision="1.12" state="changed">1a2,21
&gt; 
&gt;     &lt;!--
&gt; 
&gt; 
&gt; 
&gt;     DO NOT MODIFY THIS ONE
&gt;     Wes is in the process of polishing docs
&gt;     Do changes in the devGuideDB/ltw.xml instead
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt;     --&gt;
&gt; 
&gt; 
</file>
<file name="org.aspectj/modules/loadtime/.classpath" revision="1.5" state="changed"/>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java" revision="1.2" state="changed">45c45
&lt; //		System.err.println("? WeavingURLClassLoader.&lt;init&gt;(" + parent + ")");
---
&gt; //		System.err.println("? WeavingURLClassLoader.&lt;init&gt;(" + m_parent + ")");
58c58
&lt; 		/* If either we nor our parent is using an ASPECT_PATH use a new-style
---
&gt; 		/* If either we nor our m_parent is using an ASPECT_PATH use a new-style
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java" revision="1.70" state="changed">143a144
&gt;      * @return aspect
145c146
&lt;     public void addLibraryAspect(String aspectName) {
---
&gt;     public ResolvedType addLibraryAspect(String aspectName) {
170,171c171,173
&lt; 		} else {
&lt;             // FIXME : Alex: better warning upon no such aspect from aop.xml
---
&gt;             return type;
&gt;         } else {
&gt;             // FIXME AV - better warning upon no such aspect from aop.xml
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java" revision="1.7" state="changed">58a59
&gt;     private final static String PRECEDENCE_ATTRIBUTE = "precedence";
151a153
&gt;             String precedence = attributes.getValue(PRECEDENCE_ATTRIBUTE);
153c155,159
&lt;                 m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend);
---
&gt;                 if (isNull(precedence)) {
&gt;                     m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend);
&gt;                 } else {
&gt;                     m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend, precedence);
&gt;                 }
</file>
<file name="org.aspectj/modules/loadtime/src/aspectj_1_5_0.dtd" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.20" state="changed">74d73
&lt;                 //TODO av make dump configurable
81a81
&gt; 
115a116,132
&gt; //            // weave and flush what was registered so far
&gt; //            for (Iterator iterator = m_codeGens.iterator(); iterator.hasNext();) {
&gt; //                ConcreteAspectCodeGen concreteAspectCodeGen = (ConcreteAspectCodeGen) iterator.next();
&gt; //                byte[] partiallyWoven = concreteAspectCodeGen.getBytes(this);
&gt; //                this.generatedClassHandler.acceptClass(
&gt; //                        concreteAspectCodeGen.m_concreteAspect.name,
&gt; //                        partiallyWoven
&gt; //                );
&gt; //                ResolvedType aspect = weaver.addLibraryAspect(concreteAspectCodeGen.m_concreteAspect.name);
&gt; //                //generate key for SC
&gt; //                String aspectCode = readAspect(concreteAspectCodeGen.m_concreteAspect.name, loader);
&gt; //                if(namespace==null){
&gt; //                    namespace=new StringBuffer(aspectCode);
&gt; //                }else{
&gt; //                    namespace = namespace.append(";"+aspectCode);
&gt; //                }
&gt; //            }
260c277
&lt;         //it aspectClassNames
---
&gt;         //iterate aspectClassNames
267,269c284,291
&lt;                     weaver.addLibraryAspect(aspectClassName);
&lt;                 	
&lt;                 	//generate key for SC
---
&gt;                     ResolvedType aspect = weaver.addLibraryAspect(aspectClassName);
&gt;                     if (aspect.isAbstract()) {
&gt;                         // this is a warning
&gt;                         weaver.getWorld().getMessageHandler().handleMessage(
&gt;                                 new Message("Abstract aspect registered in aop.xml, use a &lt;concrete-aspect&gt; element instead", IMessage.WARNING, null, null)
&gt;                         );
&gt;                     }
&gt;                     //generate key for SC
280,282c302,330
&lt;         //it concreteAspects
&lt;         //exclude if in any of the exclude list
&lt;         //TODO
---
&gt;         //iterate concreteAspects
&gt;         //exclude if in any of the exclude list - note that the user defined name matters for that to happen
&gt;         for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
&gt;             Definition definition = (Definition) iterator.next();
&gt;             for (Iterator aspects = definition.getConcreteAspects().iterator(); aspects.hasNext();) {
&gt;                 Definition.ConcreteAspect concreteAspect = (Definition.ConcreteAspect) aspects.next();
&gt;                 if (acceptAspect(concreteAspect.name)) {
&gt;                     ConcreteAspectCodeGen gen = new ConcreteAspectCodeGen(concreteAspect, weaver.getWorld());
&gt;                     if (!gen.validate()) {
&gt;                         weaver.getWorld().getMessageHandler().handleMessage(
&gt;                                 new Message("Concrete-aspect '"+concreteAspect.name+"' could not be registered", IMessage.ERROR, null, null)
&gt;                         );
&gt;                         break;
&gt;                     }
&gt;                     this.generatedClassHandler.acceptClass(
&gt;                             concreteAspect.name,
&gt;                             gen.getBytes()
&gt;                     );
&gt;                     ResolvedType aspect = weaver.addLibraryAspect(concreteAspect.name);
&gt;                     //generate key for SC
&gt;                 	String aspectCode = readAspect(concreteAspect.name, loader);
&gt;                     if(namespace==null){
&gt;                     	namespace=new StringBuffer(aspectCode);
&gt;                     }else{
&gt;                     	namespace = namespace.append(";"+aspectCode);
&gt;                     }
&gt;                 }
&gt;             }
&gt;         }
</file>
<file name="org.aspectj/modules/aspectj5rt/java5-src/org/aspectj/lang/annotation/Pointcut.java" revision="1.6" state="changed">29a30
&gt;      * We allow "" as default for abstract pointcut
31c32
&lt;     String value();
---
&gt;     String value() default "";
</file>
<file name="org.aspectj/modules/docs/devGuideDB/ltw.xml" revision="1.3" state="changed">42,43c42,43
&lt;             &lt;para&gt;&lt;!-- FIXME AV --&gt;As per AspectJ 1.5.0 M3 aspects (code style or annotation style) are
&lt;             reweavable by default, and weaved classes may be as well in 1.5.0 final.&lt;/para&gt;
---
&gt;             &lt;para&gt;As per AspectJ 1.5.0 M3 aspects (code style or annotation style) are
&gt;             reweavable by default, and weaved classes are reweavable by default as well as per AspectJ 1.5.0 M4.&lt;/para&gt;
209,214c209
&lt;             &lt;/para&gt;
&lt; 
&lt;             &lt;para&gt;
&lt;                 &lt;emphasis&gt;
&lt;                 Note: concrete-aspect is not available in AspectJ 1.5 M3.
&lt;                 &lt;/emphasis&gt;
---
&gt;                 Refer to the next section for more details.
274a270,354
&gt;         &lt;sect2 id="concrete-aspect" xreflabel="concrete-aspect"&gt;
&gt;             &lt;title&gt;Using Concrete Aspects&lt;/title&gt;
&gt;             &lt;para&gt;
&gt;                 It is possible to concretize an abstract aspect by the mean of the &lt;literal&gt;META-INF/aop.xml&lt;/literal&gt;
&gt;                 file. This is usefull to define abstract pointcuts at deployment time.
&gt;                 Consider the following:
&gt;             &lt;/para&gt;
&gt;             &lt;programlisting&gt;&lt;![CDATA[
&gt;             package mypack;
&gt; 
&gt;             @Aspect
&gt;             public abstract class AbstractAspect {
&gt; 
&gt;                 // abstract pointcut: no expression is defined
&gt;                 @Pointcut
&gt;                 abstract void scope();
&gt; 
&gt;                 @Before("scope() &amp;&amp; execution(* *..doSome(..))")
&gt;                 public void before(JoinPoint jp) {
&gt;                    ....
&gt;                 }
&gt;             }
&gt;             ]]&gt;&lt;/programlisting&gt;
&gt;             &lt;para&gt;
&gt;                 This aspect is equivalent to the following in code style:
&gt;             &lt;/para&gt;
&gt;             &lt;programlisting&gt;&lt;![CDATA[
&gt;             package mypack;
&gt; 
&gt;             public abstract aspect AbstractAspect {
&gt; 
&gt;                 // abstract pointcut: no expression is defined
&gt;                 abstract pointcut scope();
&gt; 
&gt;                 before() : scope() &amp;&amp; execution(* *..doSome(..)) {
&gt;                    ....
&gt;                 }
&gt;             }
&gt;             ]]&gt;&lt;/programlisting&gt;
&gt;             &lt;para&gt;
&gt;                 This aspect (in either of its style) is a good candidate for concretization through &lt;literal&gt;META-INF/aop.xml&lt;/literal&gt;.
&gt;                 It defines the abstract pointcut &lt;literal&gt;within()&lt;/literal&gt;. It is important to remember that
&gt;                 concretization in this case must obey to the following rules:
&gt;                 &lt;itemizedlist&gt;
&gt;                     &lt;listitem&gt;&lt;para&gt;The parent aspect must be abstract. It can be an @AspectJ or a
&gt;                             regular code style aspect.&lt;/para&gt;&lt;/listitem&gt;
&gt;                     &lt;listitem&gt;&lt;para&gt;Only simple abstract pointcut can be concretized ie pointcut that don't expose
&gt;                             state (through &lt;literal&gt;args(), this(), target(), if()&lt;/literal&gt;). In @AspectJ syntax
&gt;                             as illustrated in this sample, this means the method that hosts the pointcut is abstract,
&gt;                             has no arguments, and returns void.&lt;/para&gt;&lt;/listitem&gt;
&gt;                     &lt;listitem&gt;&lt;para&gt;Concretization must defines all such abstract pointcuts ie it is not possible
&gt;                             to have &lt;literal&gt;concrete-aspect&lt;/literal&gt; inter dependancies.&lt;/para&gt;&lt;/listitem&gt;
&gt;                     &lt;listitem&gt;&lt;para&gt;Concretization can only concretize pointcuts ie there cannot be abstract method
&gt;                             left in the aspect.&lt;/para&gt;&lt;/listitem&gt;
&gt;                 &lt;/itemizedlist&gt;
&gt;                 If you have requirements for more complex aspect inheritance, you should consider regular aspect
&gt;                 inheritance instead of concretization through XML.
&gt;                 Given that the following XML is valid:
&gt;             &lt;/para&gt;
&gt;             &lt;programlisting&gt;&lt;![CDATA[
&gt;             &lt;aspectj&gt;
&gt;                 &lt;conrete-aspect name="mypack.__My__AbstractAspect" extends="mypack.AbstractAspect"&gt;
&gt;                     &lt;pointcut name="scope" expression="within(yourpackage..*)"/&gt;
&gt;                 &lt;/concrete-aspect&gt;
&gt;             &lt;/aspectj&gt;
&gt;             ]]&gt;&lt;/programlisting&gt;
&gt;             &lt;para&gt;
&gt;                 It is important to remember that the &lt;literal&gt;name&lt;/literal&gt; attribute in the XML directive
&gt;                 &lt;literal&gt;concrete-aspect&lt;/literal&gt; defines the fully qualified name that will be given to the
&gt;                 concrete aspect. It must then be a valid class name. This one will indeed be generated on the fly by the weaver internals. You must
&gt;                 then ensure that there won't be name collision. Also note that the concrete aspect will be
&gt;                 defined at the classloader level for which the aop.xml is visible. This implies that if you need
&gt;                 to use the &lt;literal&gt;aspectof&lt;/literal&gt; methods to access the aspect instance(s) (depending on the perclause
&gt;                 of the aspect it extends) you have to use the helper API &lt;literal&gt;org.aspectj.lang.Aspects.aspectOf(..)&lt;/literal&gt;
&gt;                 as in:
&gt;             &lt;/para&gt;
&gt;             &lt;programlisting&gt;&lt;![CDATA[
&gt;                 // exception handling omitted
&gt;                 Class myConcreteAspectClass = Class.forName("mypack.__My__AbstractAspect");
&gt; 
&gt;                 // here we are using a singleton aspect
&gt;                 AbstractAspect concreteInstance = Aspects.aspectOf(myConcreteAspectClass);
&gt;             ]]&gt;&lt;/programlisting&gt;
&gt;         &lt;/sect2&gt;
&gt; 
</file>
<file name="org.aspectj/modules/lib/test/aspectjrt.jar" revision="1.33" state="changed"/>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/definition/Definition.java" revision="1.5" state="changed">77,79c77,80
&lt;         String name;
&lt;         String extend;
&lt;         List pointcuts;
---
&gt;         public final String name;
&gt;         public final String extend;
&gt;         public final String precedence;
&gt;         public final List pointcuts;
81a83,86
&gt;             this(name, extend,  null);
&gt;         }
&gt; 
&gt;         public ConcreteAspect(String name, String extend, String precedence) {
83a89
&gt;             this.precedence = precedence;
89,90c95,96
&lt;         String name;
&lt;         String expression;
---
&gt;         public final String name;
&gt;         public final String expression;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java" revision="1.13" state="changed">87a88,91
&gt;         return forceMunge(gen);
&gt;     }
&gt; 
&gt;     public boolean forceMunge(LazyClassGen gen) {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java" revision="1.23" state="changed">1054d1053
&lt;             if (pointcutExpr != null) {
1056,1066c1055,1078
&lt;                 // semantic check: the method must return void, or be "public static boolean" for if() support
&lt;                 if (!(Type.VOID.equals(struct.method.getReturnType())
&lt;                       || (Type.BOOLEAN.equals(struct.method.getReturnType()) &amp;&amp; struct.method.isStatic() &amp;&amp; struct.method.isPublic()))) {
&lt;                     reportWarning("Found @Pointcut on a method not returning 'void' or not 'public static boolean'", struct);
&lt;                     ;//no need to stop
&lt;                 }
&lt;                 // semantic check: the method must not throw anything
&lt;                 if (struct.method.getExceptionTable() != null) {
&lt;                     reportWarning("Found @Pointcut on a method throwing exception", struct);
&lt;                     ;// no need to stop
&lt;                 }
---
&gt;             // semantic check: the method must return void, or be "public static boolean" for if() support
&gt;             if (!(Type.VOID.equals(struct.method.getReturnType())
&gt;                   || (Type.BOOLEAN.equals(struct.method.getReturnType()) &amp;&amp; struct.method.isStatic() &amp;&amp; struct.method.isPublic()))) {
&gt;                 reportWarning("Found @Pointcut on a method not returning 'void' or not 'public static boolean'", struct);
&gt;                 ;//no need to stop
&gt;             }
&gt; 
&gt;             // semantic check: the method must not throw anything
&gt;             if (struct.method.getExceptionTable() != null) {
&gt;                 reportWarning("Found @Pointcut on a method throwing exception", struct);
&gt;                 ;// no need to stop
&gt;             }
&gt; 
&gt;             // this/target/args binding
&gt;             final IScope binding;
&gt;             try {
&gt;                 binding = new BindingScope(
&gt;                         struct.enclosingType,
&gt;                         struct.context,
&gt;                         extractBindings(struct)
&gt;                 );
&gt;             } catch (UnreadableDebugInfoException e) {
&gt;                 return;
&gt;             }
1068,1078c1080,1083
&lt;                 // this/target/args binding
&lt;                 final IScope binding;
&lt;                 try {
&lt;                     binding = new BindingScope(
&lt;                             struct.enclosingType,
&lt;                             struct.context,
&lt;                             extractBindings(struct)
&lt;                     );
&lt;                 } catch (UnreadableDebugInfoException e) {
&lt;                     return;
&lt;                 }
---
&gt;             UnresolvedType[] argumentTypes = new UnresolvedType[struct.method.getArgumentTypes().length];
&gt;             for (int i = 0; i &lt; argumentTypes.length; i++) {
&gt;                 argumentTypes[i] = UnresolvedType.forSignature(struct.method.getArgumentTypes()[i].getSignature());
&gt;             }
1080,1082c1085,1104
&lt;                 UnresolvedType[] argumentTypes = new UnresolvedType[struct.method.getArgumentTypes().length];
&lt;                 for (int i = 0; i &lt; argumentTypes.length; i++) {
&lt;                     argumentTypes[i] = UnresolvedType.forSignature(struct.method.getArgumentTypes()[i].getSignature());
---
&gt;             Pointcut pc = null;
&gt;             if (struct.method.isAbstract()) {
&gt;                 if ((pointcutExpr != null &amp;&amp; isNullOrEmpty(pointcutExpr.getValue().stringifyValue()))
&gt;                     || pointcutExpr == null) {
&gt;                     // abstract pointcut
&gt;                     // leave pc = null
&gt;                 } else {
&gt;                     reportError("Found defined @Pointcut on an abstract method", struct);
&gt;                     return;//stop
&gt;                 }
&gt;             } else {
&gt;                 if (pointcutExpr != null) {
&gt;                     // use a LazyResolvedPointcutDefinition so that the pointcut is resolved lazily
&gt;                     // since for it to be resolved, we will need other pointcuts to be registered as well
&gt;                     pc = parsePointcut(pointcutExpr.getValue().stringifyValue(), struct, true);
&gt;                     if (pc == null) return;//parse error
&gt;                     pc.setLocation(struct.context, -1, -1);//FIXME AVASM !! bMethod is null here..
&gt;                 } else {
&gt;                     reportError("Found undefined @Pointcut on a non-abstract method", struct);
&gt;                     return;
1084,1103d1105
&lt; 
&lt;                 // use a LazyResolvedPointcutDefinition so that the pointcut is resolved lazily
&lt;                 // since for it to be resolved, we will need other pointcuts to be registered as well
&lt;                 Pointcut pc = parsePointcut(pointcutExpr.getValue().stringifyValue(), struct, true);
&lt;                 if (pc == null) return;//parse error
&lt;                 // do not resolve binding now but lazily
&lt;                 pc.setLocation(struct.context, -1, -1);//FIXME AVASM !! bMethod is null here..
&lt;                 struct.ajAttributes.add(
&lt;                         new AjAttribute.PointcutDeclarationAttribute(
&lt;                                 new LazyResolvedPointcutDefinition(
&lt;                                         struct.enclosingType,
&lt;                                         struct.method.getModifiers(),
&lt;                                         struct.method.getName(),
&lt;                                         argumentTypes,
&lt;                                         UnresolvedType.forSignature(struct.method.getReturnType().getSignature()),
&lt;                                         pc,
&lt;                                         binding
&lt;                                 )
&lt;                         )
&lt;                 );
1104a1107,1120
&gt;             // do not resolve binding now but lazily
&gt;             struct.ajAttributes.add(
&gt;                     new AjAttribute.PointcutDeclarationAttribute(
&gt;                             new LazyResolvedPointcutDefinition(
&gt;                                     struct.enclosingType,
&gt;                                     struct.method.getModifiers(),
&gt;                                     struct.method.getName(),
&gt;                                     argumentTypes,
&gt;                                     UnresolvedType.forSignature(struct.method.getReturnType().getSignature()),
&gt;                                     pc,//can be null for abstract pointcut
&gt;                                     binding
&gt;                             )
&gt;                     )
&gt;             );
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
package ataspectj;

import junit.framework.TestCase;
import junit.framework.Test;
import junit.framework.TestSuite;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

/**
 * @author &lt;a href="mailto:alex AT gnilux DOT com"&gt;Alexandre Vasseur&lt;/a&gt;
 */
public class ConcreteAtAspectTest extends TestCase {

    static int I;

    void target() {
        I++;
    }

    // abstract aspect
    // pc() is undefined hence always false, and advice not applied
    // this aspect is illegal as is in aop.xml
    // ones must use a concrete-aspect
    @Aspect
    abstract static class ConcreteAtAspect {

        @Pointcut()
        abstract void pc();
        // must be abstract
        // for concrete-aspect, must further be no-arg, void
        // but can be more complex for non-xml inheritance

        @Before("pc()")
        public void before() {
            I++;
        }
    }

    // legal abstract aspect resolved with inheritance
    @Aspect
    static class ConcreteAtAspectSub extends ConcreteAtAspect {
        @Pointcut("execution(* ataspectj.ConcreteAtAspectTest.target())")
        void pc() {}
    }

    public void testConcrete() {
        I = 0;
        target();
        assertEquals(3, I);
    }

    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }

    public static Test suite() {
        return new TestSuite(ConcreteAtAspectTest.class);
    }

}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml" revision="1.12" state="changed">133a134,149
&gt;     &lt;ajc-test dir="java5/ataspectj" title="Concrete@Aspect"&gt;
&gt;         &lt;compile
&gt;             files="ataspectj/ConcreteAtAspectTest.java,ataspectj/TestHelper.java"
&gt;             options="-1.5 -Xdev:NoAtAspectJProcessing -XnoWeave"
&gt;             /&gt;
&gt;         &lt;run class="ataspectj.ConcreteAtAspectTest" ltw="ataspectj/aop-concreteataspect.xml"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="java5/ataspectj" title="ConcreteAspect"&gt;
&gt;         &lt;compile
&gt;             files="ataspectj/ConcreteAspectTest.aj,ataspectj/TestHelper.java"
&gt;             options="-1.5 -Xdev:NoAtAspectJProcessing -XnoWeave"
&gt;             /&gt;
&gt;         &lt;run class="ataspectj.ConcreteAspectTest" ltw="ataspectj/aop-concreteaspect.xml"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java" revision="1.16" state="changed">96a97,103
&gt;     public void testConcreteAtAspect() {
&gt;         runTest("Concrete@Aspect");
&gt;     }
&gt; 
&gt;     public void testConcreteAspect() {
&gt;         runTest("ConcreteAspect");
&gt;     }
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/aop-concreteaspect.xml" revision="1.1" state="new">&lt;?xml version="1.0"?&gt;
&lt;aspectj&gt;
    &lt;weaver options="-XmessageHandlerClass:ataspectj.TestHelper -1.5"/&gt;
    &lt;aspects&gt;
        &lt;concrete-aspect name="ataspectj.Foo" extends="ataspectj.ConcreteAspectTest.ConcreteAspect"&gt;
            &lt;pointcut name="pc" expression="execution(* ataspectj.ConcreteAspectTest.target())"/&gt;
        &lt;/concrete-aspect&gt;
    &lt;/aspects&gt;
&lt;/aspectj&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ConcreteAspectTest.aj" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
package ataspectj;

import junit.framework.TestCase;
import junit.framework.Test;
import junit.framework.TestSuite;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

/**
 * @author &lt;a href="mailto:alex AT gnilux DOT com"&gt;Alexandre Vasseur&lt;/a&gt;
 */
public class ConcreteAspectTest extends TestCase {

    static int I;

    void target() {
        I++;
    }

    // abstract aspect
    // pc() is undefined hence always false, and advice not applied
    // this aspect is illegal as is in aop.xml
    // ones must use a concrete-aspect
    static abstract aspect ConcreteAspect {

        abstract pointcut pc();
        // must be abstract
        // for concrete-aspect, must further be no-arg, void
        // but can be more complex for non-xml inheritance

        before() : pc() {
            I++;
        }
    }

    public void testConcrete() {
        I = 0;
        target();
        assertEquals(2, I);
    }

    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }

    public static Test suite() {
        return new TestSuite(ConcreteAspectTest.class);
    }

}
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
package org.aspectj.weaver.loadtime;

import org.aspectj.apache.bcel.Constants;
import org.aspectj.apache.bcel.classfile.JavaClass;
import org.aspectj.apache.bcel.generic.InstructionConstants;
import org.aspectj.apache.bcel.generic.InstructionList;
import org.aspectj.apache.bcel.generic.ObjectType;
import org.aspectj.apache.bcel.generic.Type;
import org.aspectj.apache.bcel.generic.annotation.AnnotationGen;
import org.aspectj.apache.bcel.generic.annotation.ElementNameValuePairGen;
import org.aspectj.apache.bcel.generic.annotation.ElementValueGen;
import org.aspectj.apache.bcel.generic.annotation.SimpleElementValueGen;
import org.aspectj.bridge.IMessage;
import org.aspectj.bridge.Message;
import org.aspectj.weaver.AnnotationX;
import org.aspectj.weaver.ResolvedMember;
import org.aspectj.weaver.ResolvedType;
import org.aspectj.weaver.UnresolvedType;
import org.aspectj.weaver.World;
import org.aspectj.weaver.bcel.BcelPerClauseAspectAdder;
import org.aspectj.weaver.bcel.BcelWorld;
import org.aspectj.weaver.bcel.LazyClassGen;
import org.aspectj.weaver.bcel.LazyMethodGen;
import org.aspectj.weaver.loadtime.definition.Definition;
import org.aspectj.weaver.patterns.PerClause;

import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

/**
 * Generates bytecode for concrete-aspect
 * &lt;p/&gt;
 * The concrete aspect is @AspectJ code generated. As it is build during aop.xml definitions registration
 * we perform the type munging for perclause ie aspectOf artifact directly, instead of waiting for it
 * to go thru the weaver (that we are in the middle of configuring).
 *
 * @author &lt;a href="mailto:alex AT gnilux DOT com"&gt;Alexandre Vasseur&lt;/a&gt;
 */
public class ConcreteAspectCodeGen {

    private final static String[] EMPTY_STRINGS = new String[0];
    private final static Type[] EMPTY_TYPES = new Type[0];

    /**
     * Concrete aspect definition we build for
     */
    private final Definition.ConcreteAspect m_concreteAspect;

    /**
     * World for which we build for
     */
    private final World m_world;

    /**
     * Set to true when all is checks are verified
     */
    private boolean m_isValid = false;

    /**
     * The parent aspect, not concretized
     */
    private ResolvedType m_parent;

    /**
     * Aspect perClause, used for direct munging of aspectOf artifacts
     */
    private PerClause m_perClause;

    /**
     * Create a new compiler for a concrete aspect
     *
     * @param concreteAspect
     * @param world
     */
    ConcreteAspectCodeGen(Definition.ConcreteAspect concreteAspect, World world) {
        m_concreteAspect = concreteAspect;
        m_world = world;
    }

    /**
     * Checks that concrete aspect is valid
     *
     * @return true if ok, false otherwise
     */
    public boolean validate() {
        if (!(m_world instanceof BcelWorld)) {
            reportError("Internal error: world must be of type BcelWorld");
            return false;
        }

        m_parent = m_world.resolve(m_concreteAspect.extend, true);
        // handle inner classes
        if (m_parent.equals(ResolvedType.MISSING)) {
            // fallback on inner class lookup mechanism
            String fixedName = m_concreteAspect.extend;
            int hasDot = fixedName.lastIndexOf('.');
            while (hasDot &gt; 0) {
                char[] fixedNameChars = fixedName.toCharArray();
                fixedNameChars[hasDot] = '$';
                fixedName = new String(fixedNameChars);
                hasDot = fixedName.lastIndexOf('.');
                m_parent = m_world.resolve(UnresolvedType.forName(fixedName), true);
                if (!m_parent.equals(ResolvedType.MISSING)) {
                    break;
                }
            }
        }
        if (m_parent.isMissing()) {
            reportError("Cannot find m_parent aspect for: " + stringify());
            return false;
        }

        // extends must be abstract
        if (!m_parent.isAbstract()) {
            reportError("Attempt to concretize a non-abstract aspect: " + stringify());
            return false;
        }

        // m_parent must be aspect
        if (!m_parent.isAspect()) {
            reportError("Attempt to concretize a non aspect: " + stringify());
            return false;
        }

        // must be undefined so far
        ResolvedType current = m_world.resolve(m_concreteAspect.name, true);
        if (!current.isMissing()) {
            reportError("Attempt to concretize but choosen aspect name already defined:" + stringify());
            return false;
        }

        // must have all abstractions defined
        List elligibleAbstractions = new ArrayList();
        Iterator methods = m_parent.getMethods();
        while (methods.hasNext()) {
            ResolvedMember method = (ResolvedMember) methods.next();
            if (method.isAbstract()) {
                if ("()V".equals(method.getSignature())) {
                    elligibleAbstractions.add(method.getName());
                } else {
                    reportError("Abstract member '" + method.getName() + "' cannot be concretized as a pointcut (illegal signature): " + stringify());
                    return false;
                }
            }
        }
        List pointcutNames = new ArrayList();
        for (Iterator it = m_concreteAspect.pointcuts.iterator(); it.hasNext();) {
            Definition.Pointcut abstractPc = (Definition.Pointcut) it.next();
            pointcutNames.add(abstractPc.name);
        }
        for (Iterator it = elligibleAbstractions.iterator(); it.hasNext();) {
            String elligiblePc = (String) it.next();
            if (!pointcutNames.contains(elligiblePc)) {
                reportError("Abstract pointcut '" + elligiblePc + "' not configured: " + stringify());
                return false;
            }
        }

        m_perClause = m_parent.getPerClause();
        m_isValid = true;
        return m_isValid;
    }

    /**
     * Rebuild the XML snip that defines this concrete aspect, for log error purpose
     *
     * @return string repr.
     */
    private String stringify() {
        StringBuffer sb = new StringBuffer("&lt;concrete-aspect name='");
        sb.append(m_concreteAspect.name);
        sb.append("' extends='");
        sb.append(m_concreteAspect.extend);
        sb.append("'/&gt; in aop.xml");
        return sb.toString();
    }

    /**
     * Build the bytecode for the concrete aspect
     *
     * @return concrete aspect bytecode
     */
    public byte[] getBytes() {
        if (!m_isValid) {
            throw new RuntimeException("Must validate first");
        }

        //TODO AV - abstract away from BCEL...
        // @Aspect //inherit clause from m_parent
        // @DeclarePrecedence("....") // if any
        // public class xxxName extends xxxExtends {
        //    @Pointcut(xxxExpression-n)
        //    private void xxxName-n() {}
        // }

        // @Aspect public class ...
        LazyClassGen cg = new LazyClassGen(
                m_concreteAspect.name.replace('.', '/'),
                m_parent.getName(),
                null,//TODO AV - we could point to the aop.xml that defines it and use JSR-45
                Modifier.PUBLIC + Constants.ACC_SUPER,
                EMPTY_STRINGS,
                m_world
        );
        AnnotationGen ag = new AnnotationGen(
                new ObjectType("org/aspectj/lang/annotation/Aspect"),
                Collections.EMPTY_LIST,
                true,
                cg.getConstantPoolGen()
        );
        cg.addAnnotation(ag.getAnnotation());
        if (m_concreteAspect.precedence != null) {
            SimpleElementValueGen svg = new SimpleElementValueGen(
                    ElementValueGen.STRING,
                    cg.getConstantPoolGen(),
                    m_concreteAspect.precedence
            );
            List elems = new ArrayList();
            elems.add(new ElementNameValuePairGen("value", svg, cg.getConstantPoolGen()));
            AnnotationGen agprec = new AnnotationGen(
                    new ObjectType("org/aspectj/lang/annotation/DeclarePrecedence"),
                    elems,
                    true,
                    cg.getConstantPoolGen()
            );
            cg.addAnnotation(agprec.getAnnotation());
        }

        // default constructor
        LazyMethodGen init = new LazyMethodGen(
                Modifier.PUBLIC,
                Type.VOID,
                "&lt;init&gt;",
                EMPTY_TYPES,
                EMPTY_STRINGS,
                cg
        );
        InstructionList cbody = init.getBody();
        cbody.append(InstructionConstants.ALOAD_0);
        cbody.append(cg.getFactory().createInvoke(
                m_parent.getName().replace('.', '/'),
                "&lt;init&gt;",
                Type.VOID,
                EMPTY_TYPES,
                Constants.INVOKESPECIAL
        ));
        cbody.append(InstructionConstants.RETURN);
        cg.addMethodGen(init);

        for (Iterator it = m_concreteAspect.pointcuts.iterator(); it.hasNext();) {
            Definition.Pointcut abstractPc = (Definition.Pointcut) it.next();

            LazyMethodGen mg = new LazyMethodGen(
                    Modifier.PUBLIC,
                    Type.VOID,
                    abstractPc.name,
                    EMPTY_TYPES,
                    EMPTY_STRINGS,
                    cg
            );
            SimpleElementValueGen svg = new SimpleElementValueGen(
                    ElementValueGen.STRING,
                    cg.getConstantPoolGen(),
                    abstractPc.expression
            );
            List elems = new ArrayList();
            elems.add(new ElementNameValuePairGen("value", svg, cg.getConstantPoolGen()));
            AnnotationGen mag = new AnnotationGen(
                    new ObjectType("org/aspectj/lang/annotation/Pointcut"),
                    elems,
                    true,
                    cg.getConstantPoolGen()
            );
            AnnotationX max = new AnnotationX(mag.getAnnotation(), m_world);
            mg.addAnnotation(max);

            InstructionList body = mg.getBody();
            body.append(InstructionConstants.RETURN);

            cg.addMethodGen(mg);
        }

        // handle the perClause
        BcelPerClauseAspectAdder perClauseMunger = new BcelPerClauseAspectAdder(
                ResolvedType.forName(m_concreteAspect.name).resolve(m_world),
                m_perClause.getKind()
        );
        perClauseMunger.forceMunge(cg);

        //TODO AV - unsafe cast
        // register the fresh new class into the world repository as it does not exist on the classpath anywhere
        JavaClass jc = cg.getJavaClass((BcelWorld) m_world);
        ((BcelWorld) m_world).addSourceObjectType(jc);

        return jc.getBytes();
    }

    /**
     * Error reporting
     *
     * @param message
     */
    private void reportError(String message) {
        m_world.getMessageHandler().handleMessage(new Message(message, IMessage.ERROR, null, null));
    }
}
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/aop-concreteataspect.xml" revision="1.1" state="new">&lt;?xml version="1.0"?&gt;
&lt;aspectj&gt;
    &lt;weaver options="-XmessageHandlerClass:ataspectj.TestHelper -1.5"/&gt;
    &lt;aspects&gt;
        &lt;concrete-aspect name="ataspectj.Foo" extends="ataspectj.ConcreteAtAspectTest.ConcreteAtAspect"&gt;
            &lt;pointcut name="pc" expression="execution(* ataspectj.ConcreteAtAspectTest.target())"/&gt;
        &lt;/concrete-aspect&gt;
        &lt;aspect name="ataspectj.ConcreteAtAspectTest.ConcreteAtAspectSub"/&gt;
    &lt;/aspects&gt;
&lt;/aspectj&gt;
</file>
</fixedFiles>
</bug>
<bug id="95726" transactionid="71853">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="14"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="16"/>
<property name="priority" value="P3"/>
<property name="severity" value="minor"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-import T V</fullfingerprint>
<bugreport>For consistency with the Outline view, the entry on the Navigate menu should be
"Quick Cross References" instead of "Open Cross References", and it should be in
the section with the other "Quick.." entries.

Also, I see there is a "Show In &gt; " menu with sub-menu entries for things like
the Outline view. I don't know whether this is extensible, but if so, it would
be great to have a "Show In &gt; Cross References" entry added here.</bugreport>
<pre-fix-testcases failing="69" file="output/95726/pre-fix/testresults.xml" passing="873" size="942"/>
<post-fix-testcases failing="70" file="output/95726/post-fix/testresults.xml" passing="872" size="942"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/plugin.properties" revision="1.4" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/plugin.xml" revision="1.8" state="changed">34c34
&lt;             name="Cross References"
---
&gt;             name="%XRefView.label"
67c67
&lt;    &lt;!-- Adding action set for inplace XReferenceView --&gt;   
---
&gt;    &lt;!-- Actions contributed by the XReference plugin to the Java perspective --&gt;
77c77
&lt;                label="Open Cross References"
---
&gt;                label="%QuickXRef.label"
79,80c79,80
&lt;                menubarPath="navigate/open.ext2"
&lt;                id="openXRef"&gt;
---
&gt;                menubarPath="navigate/showIn"
&gt;                id="openInplaceXRef"&gt;
81a82,89
&gt;          &lt;action
&gt;                definitionId="org.eclipse.contribution.xref.show.xref.view"
&gt;                label="%XRefView.label"
&gt;                icon="icons/XRefIcon.gif"
&gt;                class="org.eclipse.contribution.xref.ui.views.OpenXReferenceViewAction"
&gt;                menubarPath="navigate/showIn/"
&gt;                id="openXRefView"&gt;
&gt;          &lt;/action&gt;       
85c93,94
&lt;    &lt;!-- Adding key binding for inplace XReferenceView --&gt;             
---
&gt;    &lt;!-- Adding key binding for inplace XReferenceView 
&gt;         and commands for showing the inplace and regular view --&gt;             
89c98
&lt;             name="%ShowXRef.label"
---
&gt;             name="%QuickXRef.label"
99a109,114
&gt;       &lt;command
&gt;             name="%XRefView.label"
&gt;             description="%ShowXRef.description"
&gt;             category="org.eclipse.ui.category.navigate"
&gt;             id="org.eclipse.contribution.xref.show.xref.view"&gt;
&gt;       &lt;/command&gt;
102c117,118
&lt; 
---
&gt;    &lt;!-- Adding "Open Cross References" to outline views 
&gt;         context menu --&gt;             
109c125
&lt;             label="Open Cross References"
---
&gt;             label="%OpenXRef.label"
115c131
&lt;             &lt;objectContribution
---
&gt;          &lt;objectContribution
119c135
&lt;             label="Open Cross References"
---
&gt;             label="%OpenXRef.label"
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/ui/views/OpenXReferenceViewAction.java" revision="1.3" state="changed">18a19,20
&gt; import org.eclipse.ui.IWorkbenchWindow;
&gt; import org.eclipse.ui.IWorkbenchWindowActionDelegate;
23c25
&lt;  * in the outline view.
---
&gt;  * in the outline view and the Navigate/Show In workbench menu
25c27
&lt; public class OpenXReferenceViewAction implements IObjectActionDelegate {
---
&gt; public class OpenXReferenceViewAction implements IObjectActionDelegate, IWorkbenchWindowActionDelegate {
52a55,66
&gt; 
&gt;     /* (non-Javadoc)
&gt;      * @see org.eclipse.ui.IWorkbenchWindowActionDelegate#dispose()
&gt;      */
&gt;     public void dispose() {        
&gt;     }
&gt; 
&gt;     /* (non-Javadoc)
&gt;      * @see org.eclipse.ui.IWorkbenchWindowActionDelegate#init(org.eclipse.ui.IWorkbenchWindow)
&gt;      */
&gt;     public void init(IWorkbenchWindow window) {      
&gt;     }
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/xref/xref inplace view tests.txt" revision="1.2" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/xref/xref view tests.txt" revision="1.2" state="changed"/>
</fixedFiles>
</bug>
<bug id="96276" transactionid="72955">
<property name="files-churned" value="9"/>
<property name="java-files-churned" value="9"/>
<property name="classes-churned" value="9"/>
<property name="methods-churned" value="9"/>
<property name="hunks" value="26"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="28"/>
<property name="lines-churned" value="28"/>
<property name="priority" value="P3"/>
<property name="severity" value="minor"/>
<concisefingerprint/>
<fullfingerprint/>
<bugreport>After adding NLS support for 3.1M7 there remained still various (now obsolete)
//$NON-NLS-x$ tags in the source code.

The attached patch removes them.</bugreport>
<pre-fix-testcases failing="69" file="output/96276/pre-fix/testresults.xml" passing="873" size="942"/>
<post-fix-testcases failing="69" file="output/96276/post-fix/testresults.xml" passing="873" size="942"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src31/org/eclipse/ajdt/internal/ui/wizards/AspectJProjectWizardSecondPage.java" revision="1.3" state="changed">101,102c101,102
&lt; 			final String title= NewWizardMessages.JavaProjectWizardSecondPage_error_title; //$NON-NLS-1$
&lt; 			final String message= NewWizardMessages.JavaProjectWizardSecondPage_error_message; //$NON-NLS-1$
---
&gt; 			final String title= NewWizardMessages.JavaProjectWizardSecondPage_error_title;
&gt; 			final String message= NewWizardMessages.JavaProjectWizardSecondPage_error_message;
120c120
&lt; 			monitor.beginTask(NewWizardMessages.JavaProjectWizardSecondPage_operation_initialize, 2); //$NON-NLS-1$
---
&gt; 			monitor.beginTask(NewWizardMessages.JavaProjectWizardSecondPage_operation_initialize, 2);
188c188
&lt; 			monitor.beginTask(NewWizardMessages.JavaProjectWizardSecondPage_operation_create, 3); //$NON-NLS-1$
---
&gt; 			monitor.beginTask(NewWizardMessages.JavaProjectWizardSecondPage_operation_create, 3);
213c213
&lt; 				monitor.beginTask(NewWizardMessages.JavaProjectWizardSecondPage_operation_remove, 3); //$NON-NLS-1$
---
&gt; 				monitor.beginTask(NewWizardMessages.JavaProjectWizardSecondPage_operation_remove, 3);
231,232c231,232
&lt; 			final String title= NewWizardMessages.JavaProjectWizardSecondPage_error_remove_title; //$NON-NLS-1$
&lt; 			final String message= NewWizardMessages.JavaProjectWizardSecondPage_error_remove_message; //$NON-NLS-1$
---
&gt; 			final String title= NewWizardMessages.JavaProjectWizardSecondPage_error_remove_title;
&gt; 			final String message= NewWizardMessages.JavaProjectWizardSecondPage_error_remove_message;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src31/org/eclipse/ajdt/internal/ui/preferences/AspectPathPropertyPage.java" revision="1.6" state="changed">107c107
&lt;         label.setText(PreferencesMessages.BuildPathsPropertyPage_no_java_project_message); //$NON-NLS-1$
---
&gt;         label.setText(PreferencesMessages.BuildPathsPropertyPage_no_java_project_message);
128c128
&lt;         label.setText(PreferencesMessages.BuildPathsPropertyPage_closed_project_message); //$NON-NLS-1$
---
&gt;         label.setText(PreferencesMessages.BuildPathsPropertyPage_closed_project_message);
247c247
&lt;                 String message= PreferencesMessages.BuildPathsPropertyPage_error_message; //$NON-NLS-1$
---
&gt;                 String message= PreferencesMessages.BuildPathsPropertyPage_error_message;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src31/org/eclipse/ajdt/internal/debug/ui/actions/ToggleBreakpointAdapter.java" revision="1.2" state="changed">147c147
&lt;                 ExceptionHandler.handle(e, ActionMessages.ManageBreakpointActionDelegate_error_title1, ActionMessages.ManageBreakpointActionDelegate_error_message1); //$NON-NLS-1$ //$NON-NLS-2$
---
&gt;                 ExceptionHandler.handle(e, ActionMessages.ManageBreakpointActionDelegate_error_title1, ActionMessages.ManageBreakpointActionDelegate_error_message1);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src31/org/eclipse/ajdt/internal/launching/AJMainMethodSearchEngine.java" revision="1.2" state="changed">60c60
&lt; 		pm.beginTask(LauncherMessages.MainMethodSearchEngine_1, 100); //$NON-NLS-1$
---
&gt; 		pm.beginTask(LauncherMessages.MainMethodSearchEngine_1, 100);
69c69
&lt; 		ajSearchMonitor.beginTask(LauncherMessages.MainMethodSearchEngine_1, 100); //$NON-NLS-1$
---
&gt; 		ajSearchMonitor.beginTask(LauncherMessages.MainMethodSearchEngine_1, 100);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src31/org/eclipse/ajdt/internal/launching/AJClasspathModel.java" revision="1.4" state="changed">157c157
&lt; 			String name = ClasspathMessages.ClasspathModel_0; //$NON-NLS-1$
---
&gt; 			String name = ClasspathMessages.ClasspathModel_0;
166c166
&lt; 			String name = ClasspathMessages.ClasspathModel_1; //$NON-NLS-1$
---
&gt; 			String name = ClasspathMessages.ClasspathModel_1;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src31/org/eclipse/ajdt/internal/launching/AJMainTypeSelectionDialog.java" revision="1.2" state="changed">98c98
&lt; 				.MainTypeSelectionDialog_Choose_a_type); //$NON-NLS-1$		
---
&gt; 				.MainTypeSelectionDialog_Choose_a_type);
100c100
&lt; 				.MainTypeSelectionDialog_Matching_types); //$NON-NLS-1$
---
&gt; 				.MainTypeSelectionDialog_Matching_types);
102c102
&lt; 				.MainTypeSelectionDialog_Qualifier); //$NON-NLS-1$
---
&gt; 				.MainTypeSelectionDialog_Qualifier);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src31/org/eclipse/ajdt/ajdocexport/AJdocSpecificsWizardPage.java" revision="1.2" state="changed">126c126
&lt; 		fJDK14Button= createButton(composite, SWT.CHECK, JavadocExportMessages.JavadocSpecificsWizardPage_jdk14mode_label, createGridData(3)); //$NON-NLS-1$
---
&gt; 		fJDK14Button= createButton(composite, SWT.CHECK, JavadocExportMessages.JavadocSpecificsWizardPage_jdk14mode_label, createGridData(3));
173c173
&lt; 		fCheckbrowser= createButton(c, SWT.CHECK, JavadocExportMessages.JavadocSpecificsWizardPage_openbrowserbutton_label, createGridData(3)); //$NON-NLS-1$
---
&gt; 		fCheckbrowser= createButton(c, SWT.CHECK, JavadocExportMessages.JavadocSpecificsWizardPage_openbrowserbutton_label, createGridData(3));
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src31/org/eclipse/ajdt/internal/launching/AspectJApplicationLaunchShortcut.java" revision="1.2" state="changed">107c107
&lt; 					message = LauncherMessages.JavaApplicationLaunchShortcut_The_active_editor_does_not_contain_a_main_type__1; //$NON-NLS-1$
---
&gt; 					message = LauncherMessages.JavaApplicationLaunchShortcut_The_active_editor_does_not_contain_a_main_type__1;
109c109
&lt; 					message = LauncherMessages.JavaApplicationLaunchShortcut_The_selection_does_not_contain_a_main_type__2; //$NON-NLS-1$
---
&gt; 					message = LauncherMessages.JavaApplicationLaunchShortcut_The_selection_does_not_contain_a_main_type__2;
111c111
&lt; 				MessageDialog.openError(getShell(), LauncherMessages.JavaApplicationAction_Launch_failed_7, message); //$NON-NLS-1$
---
&gt; 				MessageDialog.openError(getShell(), LauncherMessages.JavaApplicationAction_Launch_failed_7, message);
282c282
&lt; 			dialog.setTitle(LauncherMessages.JavaApplicationAction_Type_Selection_Debug); //$NON-NLS-1$
---
&gt; 			dialog.setTitle(LauncherMessages.JavaApplicationAction_Type_Selection_Debug);
284c284
&lt; 			dialog.setTitle(LauncherMessages.JavaApplicationAction_Type_Selection_Run); //$NON-NLS-1$
---
&gt; 			dialog.setTitle(LauncherMessages.JavaApplicationAction_Type_Selection_Run);
311c311
&lt; 			MessageDialog.openError(getShell(), LauncherMessages.JavaApplicationAction_Launch_failed_7, LauncherMessages.JavaApplicationLaunchShortcut_The_active_editor_does_not_contain_a_main_type__1); //$NON-NLS-1$ //$NON-NLS-2$
---
&gt; 			MessageDialog.openError(getShell(), LauncherMessages.JavaApplicationAction_Launch_failed_7, LauncherMessages.JavaApplicationLaunchShortcut_The_active_editor_does_not_contain_a_main_type__1);
361c361
&lt; 			MessageDialog.openError(getShell(), LauncherMessages.JavaApplicationAction_Launch_failed_7, LauncherMessages.JavaApplicationLaunchShortcut_The_selection_does_not_contain_a_main_type__2); //$NON-NLS-1$ //$NON-NLS-2$
---
&gt; 			MessageDialog.openError(getShell(), LauncherMessages.JavaApplicationAction_Launch_failed_7, LauncherMessages.JavaApplicationLaunchShortcut_The_selection_does_not_contain_a_main_type__2);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src31/org/eclipse/ajdt/internal/launching/AJClasspathTab.java" revision="1.2" state="changed">68c68
&lt; 		label.setText(LauncherMessages.JavaClasspathTab_0); //$NON-NLS-1$
---
&gt; 		label.setText(LauncherMessages.JavaClasspathTab_0);
</file>
</fixedFiles>
</bug>
<bug id="96371" transactionid="71700">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="3"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-import T V Y</fullfingerprint>
<bugreport>AspectJ 5 load-time weaving in CVS HEAD isn't loading aop.xml files properly 
from a jar file without specifying the global -D flag. The following patch 
fixes the problem for me so I can load aop.xml files from jars on the 
classpath without a global flag:

ClassLoaderWeavingAdaptor.java:109:
-             Enumeration xmls = loader.getResources("/META-INF/aop.xml");
+            Enumeration xmls = loader.getResources("META-INF/aop.xml");


I.e., getResources doesn't work with a leading separator, at least not on the 
Sun VM or JRockIt on Windows. Writing a unit test for this would require 
significant changes to the loadtime module, so I wrote a standalone test of 
the API:

public class TestApi extends TestCase {
    public void testLoadResource() throws Exception {
        URL urlList[] = { new URL
("file:testsrc/org/aspectj/weaver/loadtime/test/sample.jar") };
        ClassLoader loader = new URLClassLoader(urlList);	
          
        Enumeration xmls = loader.getResources("META-INF/aop.xml");
        //this version fails:
        //Enumeration xmls = loader.getResources("/META-INF/aop.xml");

        assertTrue(xmls.hasMoreElements());
    }
}</bugreport>
<pre-fix-testcases failing="70" file="output/96371/pre-fix/testresults.xml" passing="872" size="942"/>
<post-fix-testcases failing="69" file="output/96371/post-fix/testresults.xml" passing="873" size="942"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.5" state="changed">42a43,44
&gt;     private final static String AOP_XML = "META-INF/aop.xml";
&gt; 
109c111
&lt;             Enumeration xmls = loader.getResources("/META-INF/aop.xml");
---
&gt;             Enumeration xmls = loader.getResources(AOP_XML);
</file>
<file name="org.aspectj/modules/loadtime5/java5-src/org/aspectj/weaver/loadtime/ClassPreProcessorAgentAdapter.java" revision="1.2" state="changed">14,16d13
&lt; import org.aspectj.weaver.loadtime.Aj;
&lt; import org.aspectj.weaver.loadtime.ClassPreProcessor;
&lt; 
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java" revision="1.4" state="changed">18,22d17
&lt; import org.aspectj.lang.annotation.DeclarePrecedence;
&lt; import org.aspectj.lang.annotation.After;
&lt; import org.aspectj.lang.annotation.Around;
&lt; import org.aspectj.lang.annotation.Before;
&lt; import org.aspectj.lang.annotation.Before;
25,26d19
&lt; import org.aspectj.lang.ProceedingJoinPoint;
&lt; import org.aspectj.runtime.internal.AroundClosure;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/aop.xml" revision="1.4" state="deleted"/>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/pathentry/META-INF/aop.xml" revision="1.1" state="new">&lt;?xml version="1.0"?&gt;
&lt;aspectj&gt;
    &lt;weaver options="-XmessageHolderClass:ataspectj.TestHelper"/&gt;
    &lt;aspects&gt;
        &lt;!-- see here nested class with ".", "$" is accepted as well --&gt;
        &lt;aspect name="ataspectj.SingletonAspectBindingsTest.TestAspect"/&gt;
        &lt;aspect name="ataspectj.CflowTest.TestAspect"/&gt;
        &lt;aspect name="ataspectj.PointcutReferenceTest.TestAspect"/&gt;
        &lt;aspect name="ataspectj.AfterXTest.TestAspect"/&gt;
&lt;!--        &lt;aspect name="ataspectj.IfPointcutTest.TestAspect"/&gt;--&gt;
        &lt;aspect name="ataspectj.XXJoinPointTest.TestAspect"/&gt;
        &lt;aspect name="ataspectj.PrecedenceTest.TestAspect_2"/&gt;
        &lt;aspect name="ataspectj.PrecedenceTest.TestAspect_1"/&gt;
        &lt;aspect name="ataspectj.PrecedenceTest.TestAspect_3"/&gt;
        &lt;aspect name="ataspectj.PrecedenceTest.TestAspect_Order"/&gt;

        &lt;aspect name="ataspectj.BindingTest.TestAspect_1"/&gt;

        &lt;aspect name="ataspectj.PerClauseTestAspects.TestAspectPerSingleton"/&gt;
        &lt;aspect name="ataspectj.PerClauseTestAspects.TestAspectPerTarget"/&gt;
        &lt;aspect name="ataspectj.PerClauseTestAspects.TestAspectPerCflow"/&gt;
        &lt;aspect name="ataspectj.PerClauseTestAspects.TestAspectPTW"/&gt;

        &lt;aspect name="ataspectj.AroundInlineMungerTestAspects.Open"/&gt;
    &lt;/aspects&gt;
&lt;/aspectj&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ajc-ant.xml" revision="1.7" state="changed">2c2
&lt; &lt;project name="foo" default="javac.ltw"&gt;
---
&gt; &lt;project name="ltw" default="javac.ltw"&gt;
20a21,22
&gt;             &lt;!-- use META-INF/aop.xml style --&gt;
&gt;             &lt;classpath path="ataspectj/pathentry"/&gt;
22d23
&lt;             &lt;jvmarg value="-Daj5.def=ataspectj/aop.xml"/&gt;
</file>
</fixedFiles>
</bug>
<bug id="96450" transactionid="73724">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="21"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="9"/>
<property name="lines-churned" value="30"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-import K-new K-return M O-+ T V Y</fullfingerprint>
<bugreport>Elements that are advised by aspects from the aspect path are labelled as being
advised by "injar" aspects, which is not even a proper word :)  Previously the
aspect path only supported JAR files, but now that it supports directories,
describing the aspect as "binary" would sound better, and be more accurate.</bugreport>
<pre-fix-testcases failing="70" file="output/96450/pre-fix/testresults.xml" passing="872" size="942"/>
<post-fix-testcases failing="69" file="output/96450/post-fix/testresults.xml" passing="873" size="942"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/AspectJPlugin.java" revision="1.15" state="changed">13a14
&gt; import java.text.MessageFormat;
168a170,189
&gt; 	 * @param key
&gt; 	 * @param arg
&gt; 	 * @return string from plugin's resource bundle that includes the inserted
&gt; 	 *         argument.
&gt; 	 */
&gt; 	public static String getFormattedResourceString(String key, String arg) {
&gt; 		return getFormattedResourceString(key, new String[] { arg });
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * @param key
&gt; 	 * @param arg
&gt; 	 * @return string from plugin's resource bundle that includes all of the
&gt; 	 *         inserted arguments.
&gt; 	 */
&gt; 	public static String getFormattedResourceString(String key, String[] args) {
&gt; 		return MessageFormat.format(getResourceString(key), args);
&gt; 	}
&gt; 	
&gt; 	/**
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/model/AJModelTest2.java" revision="1.3" state="changed">54c54
&lt; 					if (target.getElementName().indexOf("injar aspect") != -1) {
---
&gt; 					if (target.getElementName().indexOf("binary aspect") != -1) {
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/resources/AspectJPluginResources.properties" revision="1.4" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/model/AJProjectModel.java" revision="1.20" state="changed">304,308c304,312
&lt; 								// if the problem element has no parent, then we have a binary/injar
&lt; 								// aspect, otherwise we don't know what it is, so we skip it
&lt; 								String name = "injar aspect: " + link.getName();
&lt; 								targetEl = new AJInjarElement("injar aspect: "+link.getName());
&lt; 								
---
&gt; 								// if the problem element has no parent, then we
&gt; 								// have a binary/injar aspect, otherwise we
&gt; 								// don't know what it is, so we skip it
&gt; 								String name = AspectJPlugin
&gt; 										.getFormattedResourceString(
&gt; 												"injarElementLabel", link //$NON-NLS-1$
&gt; 														.getName());
&gt; 								targetEl = new AJInjarElement(name);
&gt; 
375c379
&lt; 			if (file.getName().endsWith(".java")) {
---
&gt; 			if (file.getName().endsWith(".java")) { //$NON-NLS-1$
</file>
</fixedFiles>
</bug>
<bug id="98320" transactionid="70027">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T</fullfingerprint>
<bugreport>import java.util.*;

class C {
  Set&lt;String&gt; simple_local;
  Set&lt;Set&lt;String&gt;&gt; nested_local;
}

aspect Inter_Type_Injector {
  Set&lt;String&gt; C.simple_intertype;
  Set&lt;Set&lt;String&gt;&gt; C.nested_intertype;

  public void test() {
    Set&lt;String&gt; simple_local = new C().simple_local; // works
    Set&lt;String&gt; simple_intertype = new C().simple_intertype; // works
    Set&lt;Set&lt;String&gt;&gt; nested_local = new C().nested_local; // works
    Set&lt;Set&lt;String&gt;&gt; nested_intertype = new C().nested_intertype; // fails
  }
}


zipfile classpath entry does not exist: /opt/sun-jdk-1.5.0/jre/lib/i18n.jar
        
zipfile classpath entry does not exist: /opt/sun-jdk-1.5.0/jre/lib/sunrsasign.jar
        
directory classpath entry does not exist: /opt/sun-jdk-1.5.0/jre/classes
        
compiling /home/user/sgelin3/shared/dev/java/ajc/Bug.java
        
/home/user/sgelin3/shared/dev/java/ajc/Bug.java:16 [error] Type mismatch: cannot
convert from Set&lt;Set&lt;E&gt;&gt; to Set&lt;Set&lt;String&gt;&gt;
Set&lt;Set&lt;String&gt;&gt; nested_intertype = new C().nested_intertype; // fails
                 ^^^^^^^^^^^

1 error</bugreport>
<pre-fix-testcases failing="70" file="output/98320/pre-fix/testresults.xml" passing="872" size="942"/>
<post-fix-testcases failing="70" file="output/98320/post-fix/testresults.xml" passing="870" size="940"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java" revision="1.25" state="changed">208c208
&lt; 					arguments[i] = getName(ptb.arguments[i]);
---
&gt; 					arguments[i] = fromBinding(ptb.arguments[i]).getName();
364c364
&lt; 				ReferenceBinding[] argumentBindings = new ReferenceBinding[typeParameters.length];
---
&gt; 				TypeBinding[] argumentBindings = new TypeBinding[typeParameters.length];
366c366
&lt; 					argumentBindings[i] = lookupBinding(typeParameters[i].getName());
---
&gt; 					argumentBindings[i] = makeTypeBinding(typeParameters[i]);
</file>
</fixedFiles>
</bug>
<bug id="99168" transactionid="69642">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-instanceof K-new K-return K-throw M O-() O-+ O-cast O-instanceof T V Y Z-cast Z-if Z-throw</fullfingerprint>
<bugreport>inter-type declaration on a generic inner class crashes the compiler:

class Outer {
  class Inner {}
  class Generic_Inner&lt;T&gt; {}
}

class Generic_Outer&lt;T&gt; {
}

aspect Injector {
  int Outer.outer; // works
  int Outer.Inner.inner; // works
  int Generic_Outer.outer; // works
  int Outer.Generic_Inner.inner; // crashes
}


/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error
java.lang.RuntimeException: can't handle: class Generic_Inner#RAW
        extends NULL TYPENULL SUPERINTERFACES
        enclosing type : OuterNULL FIELDSNULL METHODS


        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.makeSourceTypeBinding(InterTypeScope.java:35)
        at
org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.&lt;init&gt;(InterTypeScope.java:28)
        at
org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration.resolve(InterTypeDeclaration.java:101)
        at
org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.resolve(InterTypeFieldDeclaration.java:141)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1076)
        at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:110)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1125)
...</bugreport>
<pre-fix-testcases failing="71" file="output/99168/pre-fix/testresults.xml" passing="871" size="942"/>
<post-fix-testcases failing="70" file="output/99168/post-fix/testresults.xml" passing="872" size="942"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java" revision="1.7" state="changed">17a18
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
20a22
&gt; import org.aspectj.weaver.BCException;
35c37,42
&lt; 		else throw new RuntimeException("can't handle: " + onType);
---
&gt; 		else if (onType instanceof ParameterizedTypeBinding) {
&gt; 			ReferenceBinding rb = ((ParameterizedTypeBinding)onType).type;
&gt; 			if (rb instanceof SourceTypeBinding) return (SourceTypeBinding)rb;
&gt; 			else throw new BCException("In parameterized type "+onType+", can't handle reference binding "+rb);
&gt; 		}
&gt; 		throw new BCException("can't handle: " + onType);
</file>
</fixedFiles>
</bug>
<bug id="100195" transactionid="70551">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="27"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="28"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-for K-if K-instanceof K-null K-return K-this K-true M O-&gt;= O-- O--- O-! O-!= O-&amp;&amp; O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>AspectJ version: 1.2.1  (also observed in aspectj-DEVELOPMENT)
java version "1.4.2_07"

When debugging java code woven with an "around" advice with proceed, it looks 
like the LocalVariableTable information gets lost during the weaving. Example 
code:

// Foo.java
public class Foo {
    private String myString = "A String";
    public static void main(String[] args) {
        new Foo().foo();
    }
    private void foo() {
      String myLocal = myString;
      System.out.println(myLocal);   // breakpoint here
    }
}
// Test.aj
aspect Test {
  void around() : ( execution(* Foo.foo(..) ) ) {
      System.out.println("before");
      proceed();
      System.out.println("after");
  }
}

We compiled with ajc 1.2.1:
  ajc -g -preserveAllLocals -sourceroots .

When running Foo in the Eclipse 3.1.0 debugger and setting a breakpoint at
the "System.out.println(myLocal);" line, the debugger "Variables" window is
empty. Also, disassembling with javap shows that the LocalVariableTable is
empty in the generated foo_aroundBody0 method :

&gt; javap -c -l -s -private Foo

 private static final void foo_aroundBody0(Foo);
  Signature: (LFoo;)V
  Code:
   0:   aload_0
   1:   getfield        #15; //Field myString:Ljava/lang/String;
   4:   astore_1
   5:   aload_1
   6:   ldc     #30; //String X
   8:   invokevirtual   #36; //Method java/lang/String.endsWith:
(Ljava/lang/String;)Z
   11:  ifeq    27
   14:  ldc     #38; //String local1
   16:  astore_3
   17:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   20:  aload_3
   21:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   24:  goto    37
   27:  ldc     #52; //String local2
   29:  astore_3
   30:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   33:  aload_3
   34:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   37:  return

  LineNumberTable: 
   line 7: 0
   line 8: 5
   line 9: 14
   line 10: 17
   line 12: 27
   line 13: 30
   line 15: 37</bugreport>
<pre-fix-testcases failing="108" file="output/100195/pre-fix/testresults.xml" passing="965" size="1073"/>
<post-fix-testcases failing="108" file="output/100195/post-fix/testresults.xml" passing="708" size="816"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/testdata/AroundAllFancyHelloWorld.txt" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/AroundAllAndOthersFancyHelloWorld.txt" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/ShadowRange.java" revision="1.8" state="changed">177a178,196
&gt;         
&gt;         // now go through again and update variable slots that have been altered as a result
&gt;         // of remapping...
&gt;         for (InstructionHandle newIh = freshBody.getStart(); newIh != freshBody.getEnd(); newIh = newIh.getNext()) {
&gt;             InstructionTargeter[] sources = newIh.getTargeters();
&gt;             if (sources != null) {
&gt;                 for (int i = sources.length - 1; i &gt;= 0; i--) {
&gt;                     if (sources[i] instanceof LocalVariableTag) {
&gt;                     	LocalVariableTag lvt = (LocalVariableTag) sources[i];
&gt;                     	if (!lvt.isRemapped() &amp;&amp; remap.hasKey(lvt.getSlot())) {
&gt;                     		lvt.updateSlot(remap.get(lvt.getSlot()));                    		
&gt;                     	}
&gt;                     }
&gt;                 }
&gt;             }
&gt;         }
&gt;        
&gt;         
&gt;         
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java" revision="1.5" state="changed">21c21
&lt;     private final int slot;
---
&gt;     private int slot;
22a23
&gt;     boolean remapped = false;
42a44,50
&gt;     public void updateSlot(int newSlot) {
&gt;     	this.slot = newSlot;
&gt;     	this.remapped = true;
&gt;     }
&gt;     
&gt;     public boolean isRemapped() { return this.remapped; }
&gt;     
</file>
</fixedFiles>
</bug>
<bug id="100227" transactionid="70264">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="16"/>
<property name="lines-added" value="18"/>
<property name="lines-deleted" value="5"/>
<property name="lines-modified" value="10"/>
<property name="lines-churned" value="33"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-null K-return K-true M O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<bugreport>ajc crashes with a NullPointerException when an intertype declaration tries to
modify an inner class, if the enclosing (outer) class is generic:

class Outer {
  class Inner {}
}

class Generic_Outer&lt;T&gt; {
  class Inner {}
}

aspect Injector {
  int Outer.outer; // works
  int Outer.Inner.inner; // works
  int Generic_Outer.outer; // works
  int Generic_Outer.Inner.inner; // crashes
}


/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error
java.lang.NullPointerException
        at
org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:202)
        at
org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.build(InterTypeFieldDeclaration.java:173)
        at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1020)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:306)
        at
org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:122)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:302)
        at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:316)
...</bugreport>
<testsforfix ID="100227" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testItdGenerics_pr99228"/>
      <test NAME="testItdGenerics_pr98320"/>
      <test NAME="testItdGenerics_pr100227"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="inner class with generic enclosing class"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="71" file="output/100227/pre-fix/testresults.xml" passing="871" size="942"/>
<post-fix-testcases failing="70" file="output/100227/post-fix/testresults.xml" passing="872" size="942"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/TypeX.java" revision="1.27" state="changed">23a24
&gt; 
37,39c38,40
&lt; 	/**
&lt; 	 * If this is a parameterized type, these are its parameters
&lt; 	 */
---
&gt; 	// It is not sufficient to say that a parameterized type with no type parameters in fact
&gt; 	// represents a raw type - a parameterized type with no type parameters can represent
&gt; 	// an inner type of a parameterized type that specifies no type parameters of its own.
41a43,44
&gt; 	private boolean isRawtype = false;
&gt; 	
197,199c200,205
&lt; 		ret.typeParameters = new TypeX[paramTypeNames.length];
&lt; 		for (int i = 0; i &lt; paramTypeNames.length; i++) {
&lt; 			ret.typeParameters[i] = TypeX.forName(paramTypeNames[i]);
---
&gt; 		ret.typeParameters = null;
&gt; 		if (paramTypeNames!=null) {
&gt; 			ret.typeParameters = new TypeX[paramTypeNames.length];
&gt; 			for (int i = 0; i &lt; paramTypeNames.length; i++) {
&gt; 				ret.typeParameters[i] = TypeX.forName(paramTypeNames[i]);
&gt; 			}
203,210c209,218
&lt; 		StringBuffer sigAddition = new StringBuffer();
&lt; 		sigAddition.append("&lt;");
&lt; 		for (int i = 0; i &lt; ret.typeParameters.length; i++) {
&lt; 			sigAddition.append(ret.typeParameters[i].signature);			
&lt; 		}
&lt; 		sigAddition.append("&gt;");
&lt; 		sigAddition.append(";");
&lt; 		ret.signature = ret.signature.substring(0,ret.signature.length()-1) + sigAddition.toString();
---
&gt; 		if (ret.typeParameters!=null) {
&gt; 			StringBuffer sigAddition = new StringBuffer();
&gt; 			sigAddition.append("&lt;");
&gt; 			for (int i = 0; i &lt; ret.typeParameters.length; i++) {
&gt; 				sigAddition.append(ret.typeParameters[i].signature);			
&gt; 			}
&gt; 			sigAddition.append("&gt;");
&gt; 			sigAddition.append(";");
&gt; 			ret.signature = ret.signature.substring(0,ret.signature.length()-1) + sigAddition.toString();
&gt; 		}
216a225
&gt; 		ret.setRawtype(true);
327c336,339
&lt; 			else             return name.substring(0,name.indexOf("&lt;"));
---
&gt; 			else {
&gt; 				if (typeParameters==null) return name;
&gt; 				else                      return name.substring(0,name.indexOf("&lt;"));
&gt; 			}
390,392d401
&lt; 	/**
&lt; 	 * Determines if this represents a parameterized type.
&lt; 	 */
395,396d403
&lt; //		return signature.indexOf("&lt;") != -1; 
&lt; //		//(typeParameters != null) &amp;&amp; (typeParameters.length &gt; 0);
400c407,408
&lt; 	    return isParameterized &amp;&amp; typeParameters==null;
---
&gt; 		return isRawtype;
&gt; //	    return isParameterized &amp;&amp; typeParameters==null;
406a415,419
&gt;     private final void setRawtype(boolean b) {
&gt; 		isRawtype=b;
&gt;     }
&gt; 	
&gt; 	
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java" revision="1.26" state="changed">202,208c202,213
&lt; 			String[] arguments = new String[ptb.arguments.length];
&lt; 			for (int i = 0; i &lt; arguments.length; i++) {
&lt; 				if (ptb.arguments[i] instanceof WildcardBinding) {
&lt; 					WildcardBinding wcb = (WildcardBinding) ptb.arguments[i];
&lt; 					arguments[i] = getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
&lt; 				}  else {
&lt; 					arguments[i] = fromBinding(ptb.arguments[i]).getName();
---
&gt; 			
&gt; 			String[] arguments = null;
&gt; 			
&gt; 			if (ptb.arguments!=null) { // null can mean this is an inner type of a Parameterized Type with no bounds of its own (pr100227)
&gt; 				arguments = new String[ptb.arguments.length];
&gt; 				for (int i = 0; i &lt; arguments.length; i++) {
&gt; 					if (ptb.arguments[i] instanceof WildcardBinding) {
&gt; 						WildcardBinding wcb = (WildcardBinding) ptb.arguments[i];
&gt; 						arguments[i] = getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
&gt; 					}  else {
&gt; 						arguments[i] = fromBinding(ptb.arguments[i]).getName();
&gt; 					}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.43" state="changed">2277a2278,2289
&gt;    &lt;ajc-test dir="bugs150" pr="100227" title="inner class with generic enclosing class"&gt;
&gt;      &lt;compile files="pr100227.aj" options="-1.5"/&gt;
&gt;      &lt;run class="pr100227"&gt;
&gt; 	     &lt;stderr&gt;
&gt; 	    	 &lt;line text="Outer.Inner.inner=2"/&gt;
&gt; 	    	 &lt;line text="Outer.Inner.p() executing"/&gt;
&gt; 	    	 &lt;line text="Generic_Outer.Inner.inner=4"/&gt;
&gt; 	    	 &lt;line text="Generic_Outer.Inner.p() executing"/&gt;
&gt; 	     &lt;/stderr&gt;
&gt;      &lt;/run&gt;
&gt;    &lt;/ajc-test&gt;
&gt;    
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.25" state="changed">183,185c183,186
&lt;   public void testItdGenerics_pr99228() {runTest("ITD of a field into a generic class");}
&lt;   public void testItdGenerics_pr98320() {runTest("intertype with nested generic type");}
&lt;   
---
&gt;   public void testItdGenerics_pr99228()  {runTest("ITD of a field into a generic class");}
&gt;   public void testItdGenerics_pr98320()  {runTest("intertype with nested generic type");}
&gt;   public void testItdGenerics_pr100227() {runTest("inner class with generic enclosing class");}
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs150/pr100227.aj" revision="1.1" state="new">class Outer {
  class Inner {public void p() {System.err.println("Outer.Inner.p() executing");} }
  public void m() { new Inner().p(); }
}

class Generic_Outer&lt;T&gt; {
  class Inner {public void p() {System.err.println("Generic_Outer.Inner.p() executing");} }

  public void m() { new Inner().p(); }
}

aspect Injector {
  int Outer.outer = 1;
  int Outer.Inner.inner = 2;
  int Generic_Outer.outer = 3; 
  int Generic_Outer.Inner.inner = 4;

  before(Object o): execution(* p()) &amp;&amp; this(o) {
    if (o instanceof Outer.Inner) {
      System.err.println("Outer.Inner.inner="+((Outer.Inner)o).inner);
    }
    if (o instanceof Generic_Outer.Inner) {
      System.err.println("Generic_Outer.Inner.inner="+((Generic_Outer.Inner)o).inner);
    }
  }
}

public class pr100227 {
  public static void main(String []argv) {
    new Outer().m();
    new Generic_Outer&lt;String&gt;().m();
  }
}
</file>
</fixedFiles>
</bug>
<bug id="100400" transactionid="73902">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="9"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-else K-if K-null K-return K-true O-== T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I'm using Eclipse RC2 w/ the latest AJDT development drop, 
1.2.1.20050615132409.  Now, whenever I launch any of the applications in my
workspace, the launch fails with the following stacktrace:

java.lang.NullPointerException
	at
org.eclipse.ajdt.internal.ui.actions.UICoreOperations.sourceFilesChanged(UICoreOperations.java:58)
	at org.eclipse.ajdt.core.builder.AJBuilder.build(AJBuilder.java:168)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:593)
	at
org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1038)
	at org.eclipse.core.runtime.Platform.run(Platform.java:775)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:168)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:202)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:231)
	at
org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1038)
	at org.eclipse.core.runtime.Platform.run(Platform.java:775)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:234)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:303)
	at org.eclipse.core.internal.resources.Project.build(Project.java:106)
	at
org.eclipse.debug.core.model.LaunchConfigurationDelegate.buildProjects(LaunchConfigurationDelegate.java:335)
	at
org.eclipse.debug.core.model.LaunchConfigurationDelegate.buildForLaunch(LaunchConfigurationDelegate.java:94)
	at
org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:569)
	at
org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:515)
	at
org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:733)
	at org.eclipse.debug.internal.ui.DebugUIPlugin$6.run(DebugUIPlugin.java:931)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:76)</bugreport>
<pre-fix-testcases failing="177" file="output/100400/pre-fix/testresults.xml" passing="1505" size="1682"/>
<post-fix-testcases failing="176" file="output/100400/post-fix/testresults.xml" passing="1506" size="1682"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/actions/UICoreOperations.java" revision="1.4" state="changed">57a58,61
&gt; 			if (pbc == null) {
&gt; 				// may not be an AJ project, better assume there might be changes
&gt; 				return true;
&gt; 			}
60,61c64,68
&lt; 			IJavaProject ijp = JavaCore.create(project);
&lt; 		
---
&gt; 			IJavaProject ijp = JavaCore.create(project);		
&gt; 			if (ijp == null) {
&gt; 				return true;
&gt; 			}
&gt; 			
66a74,75
&gt; 				} else {
&gt; 					return false;
70c79
&lt; 		return false;
---
&gt; 		return true;
</file>
</fixedFiles>
</bug>
<bug id="101047" transactionid="71175">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null M O-!= T V Z-if</fullfingerprint>
<bugreport>AspectJ version: DEVELOPMENT (also observed in 1.2.1)
When weaving with a before or after advice, the generated local variable table 
will, on branch instructions, offset the "length" field of a local variable 
wrongly by one instruction. Also, the weaver will mix up local variables with 
the same name, thus violating the java VM specification:

// Test.aj
aspect Test {
	before() : ( execution(* Foo.foo(..) ) ) {
		System.out.println("before");
		
	}
// Foo.java
public class Foo {
    private String myString = "A String";
    public static void main(String[] args) {
        new Foo().foo();  
    }
    private void foo() { 
        String myLocal = myString;
        if (myLocal.endsWith("X")) {
      	   String local1 = "local1";
             System.out.println(local1);
        } else if (myLocal.endsWith("Y")) {
             String local2 = "local2";
             System.out.println(local2);
        } else {
      	  String local1 = "local3";
            System.out.println(local1);
        }
      }
}
---
We compilw with ajc -sourceroots . and dumps Foo with javap:
javap -c -l -s -private Foo
....
....
private void foo();
  Signature: ()V
  Code:
   0:   invokestatic    #65; //Method Test.aspectOf:()LTest;
   3:   invokevirtual   #68; //Method Test.ajc$before$Test$1$f0485e90:()V
   6:   aload_0
   7:   getfield        #15; //Field myString:Ljava/lang/String;
   10:  astore_1
   11:  aload_1
   12:  ldc     #30; //String X
   14:  invokevirtual   #36; //Method java/lang/String.endsWith:
(Ljava/lang/String;)Z
   17:  ifeq    33
   20:  ldc     #38; //String local1
   22:  astore_2
   23:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   26:  aload_2
   27:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   30:  goto    65
   33:  aload_1
   34:  ldc     #52; //String Y
   36:  invokevirtual   #36; //Method java/lang/String.endsWith:
(Ljava/lang/String;)Z
   39:  ifeq    55
   42:  ldc     #54; //String local2
   44:  astore_2
   45:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   48:  aload_2
   49:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   52:  goto    65
   55:  ldc     #56; //String local3
   57:  astore_2
   58:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;
   61:  aload_2
   62:  invokevirtual   #50; //Method java/io/PrintStream.println:
(Ljava/lang/String;)V
   65:  return

  LineNumberTable: 
   line 7: 6
   line 8: 11
   line 9: 20
   line 10: 23
   line 11: 33
   line 12: 42
   line 13: 45
   line 15: 55
   line 16: 58
   line 18: 65
  LocalVariableTable: 
   Start  Length  Slot  Name   Signature
   6      60      0    this       LFoo;
   11      55      1    myLocal       Ljava/lang/String;
   45      12      2    local2       Ljava/lang/String;
   23      43      2    local1       Ljava/lang/String;

We see that the two occurences of the "local1" variable erroneously have been 
combined into one entry, starting at byte 23 and ending at byte 66. This is 
obviously wrong, since "local1" has no value in the "local2" block. Secondly, 
the "local2" variable end is wrongly offset by one instruction offset.</bugreport>
<pre-fix-testcases failing="177" file="output/101047/pre-fix/testresults.xml" passing="1582" size="1759"/>
<post-fix-testcases failing="177" file="output/101047/post-fix/testresults.xml" passing="1582" size="1759"/>
<fixedFiles>
<file name="org.aspectj/modules/bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java" revision="1.5" state="changed">89c89
&lt;  * @version $Id: MethodGen.java,v 1.4 2005/03/10 12:15:04 aclement Exp $
---
&gt;  * @version $Id: MethodGen.java,v 1.5 2005/09/28 20:10:19 acolyer Exp $
265a266,268
&gt; 	      // AMC, this actually gives us the first instruction AFTER the range,
&gt; 	      // so move back one... (findHandle can't cope with mid-instruction indices)
&gt; 	      if (end != null) end = end.getPrev();
</file>
<file name="org.aspectj/modules/lib/bcel/bcel.jar" revision="1.42" state="changed"/>
<file name="org.aspectj/modules/lib/bcel/bcel-src.zip" revision="1.39" state="changed"/>
</fixedFiles>
</bug>
<bug id="101854" transactionid="74413">
<property name="files-churned" value="10"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="7"/>
<property name="hunks" value="73"/>
<property name="lines-added" value="284"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="79"/>
<property name="lines-churned" value="364"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-else K-false K-for K-if K-import K-instanceof K-new K-null K-package K-return K-true M O-&lt; O-== O-! O-() O-* O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>From the accessibility guidelines at:
http://www.ibm.com/able/guidelines/software/accesssoftware.html
section 4.2 says:
   Use color as an enhancement, not as the only way to convey information or 
   indicate an action.

However the Visualiser colours stripes according to the corresponding aspect. An
alternative is needed to satisfy the above requirement, such as text labels, or
a dithering pattern perhaps. A good way to test this would be to take a project
such as the Spacewar example and display it in the Visualiser, then print a
screenshot in black and white, and then see if each aspect can be identified.</bugreport>
<pre-fix-testcases failing="177" file="output/101854/pre-fix/testresults.xml" passing="1531" size="1708"/>
<post-fix-testcases failing="178" file="output/101854/post-fix/testresults.xml" passing="1530" size="1708"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/plugin.properties" revision="1.4" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/internal/preference/VisualiserPreferences.java" revision="1.3" state="changed">35a36,37
&gt; 	public static final String USE_PATTERNS = "org.eclipse.contribution.visualiser.preferences.patterns"; //$NON-NLS-1$
&gt; 	
46a49,50
&gt; 	public static final boolean USE_PATTERNS_DEFAULT = false;
&gt; 	
55a60
&gt; 		store.setDefault(USE_PATTERNS, USE_PATTERNS_DEFAULT);
61c66
&lt; 	 * Get the name of the current provider
---
&gt; 	 * Get the maximum bar width for bars in the visualsier
63c68
&lt; 	 * @return the name of the current provider
---
&gt; 	 * @return the maximum bar width
65c70
&lt; 	static public String getProvider() {
---
&gt; 	static public int getMaxBarSize() {
68c73
&lt; 		return store.getString(PROVIDER);
---
&gt; 		return store.getInt(MAX_BAR);
83c88
&lt; 	 * Get the maximum bar width for bars in the visualsier
---
&gt; 	 * Get the name of the current provider
85c90
&lt; 	 * @return the maximum bar width
---
&gt; 	 * @return the name of the current provider
87c92
&lt; 	static public int getMaxBarSize() {
---
&gt; 	static public String getProvider() {
90c95
&lt; 		return store.getInt(MAX_BAR);
---
&gt; 		return store.getString(PROVIDER);
105c110
&lt; 	 * Get the default bar width for the visualiser
---
&gt; 	 * Get the stripe height for the visualiser
107c112
&lt; 	 * @return the default bar width
---
&gt; 	 * @return the current stripe height
109,110c114,117
&lt; 	public static int getDefaultBarWidth() {
&lt; 		return BAR_WIDTH_DEFAULT;
---
&gt; 	public static int getStripeHeight() {
&gt; 		IPreferenceStore store = VisualiserPlugin.getDefault()
&gt; 				.getPreferenceStore();
&gt; 		return store.getInt(STRIPE_HEIGHT);
114c121
&lt; 	 * Store the given size as the chosen the bar width
---
&gt; 	 * Get whether or not to use patterns
116,117c123
&lt; 	 * @param value
&lt; 	 *            width in pixels
---
&gt; 	 * @return boolean - whether or not to use patterns
119c125
&lt; 	public static void setBarWidth(int value) {
---
&gt; 	public static boolean getUsePatterns() {
122c128,139
&lt; 		store.setValue(BAR_WIDTH, value);
---
&gt; 		return store.getBoolean(USE_PATTERNS);
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Get the name of the chosen renderer
&gt; 	 * 
&gt; 	 * @return the current renderer's name
&gt; 	 */
&gt; 	public static String getRendererName() {
&gt; 		IPreferenceStore store = VisualiserPlugin.getDefault()
&gt; 				.getPreferenceStore();
&gt; 		return store.getString(RENDERER);
126c143
&lt; 	 * Get the stripe height for the visualiser
---
&gt; 	 * Store the given name as the chosen renderer name
128c145,146
&lt; 	 * @return the current stripe height
---
&gt; 	 * @param value
&gt; 	 *            the renderer name
130c148
&lt; 	public static int getStripeHeight() {
---
&gt; 	public static void setRendererName(String value) {
133c151,161
&lt; 		return store.getInt(STRIPE_HEIGHT);
---
&gt; 		store.setValue(RENDERER, value);
&gt; 		RendererManager.setCurrentRendererByName(value);
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * Get the default bar width for the visualiser
&gt; 	 * 
&gt; 	 * @return the default bar width
&gt; 	 */
&gt; 	public static int getDefaultBarWidth() {
&gt; 		return BAR_WIDTH_DEFAULT;
146c174
&lt; 	 * Store the given size as the chosen stripe height
---
&gt; 	 * Get the default option for whether or not to use patterns
148,149c176
&lt; 	 * @param value
&lt; 	 *            height in pixels
---
&gt; 	 * @return boolean - use patterns or not
151c178,189
&lt; 	public static void setStripeHeight(int value) {
---
&gt; 	public static boolean getDefaultUsePatterns() {
&gt; 		return USE_PATTERNS_DEFAULT;
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * Return the chosen palette id for the given provider if one has been
&gt; 	 * specified
&gt; 	 * 
&gt; 	 * @param providerID
&gt; 	 * @return the id of the palette chosen by the given provider
&gt; 	 */
&gt; 	public static String getPaletteIDForProvider(String providerID) {
154c192,193
&lt; 		store.setValue(STRIPE_HEIGHT, value);
---
&gt; 		String pref = PALETTE_PREFIX + providerID;
&gt; 		return store.getString(pref);
158c197
&lt; 	 * Get the name of the chosen renderer
---
&gt; 	 * Store the given size as the chosen the bar width
160c199,200
&lt; 	 * @return the current renderer's name
---
&gt; 	 * @param value
&gt; 	 *            width in pixels
162c202
&lt; 	public static String getRendererName() {
---
&gt; 	public static void setBarWidth(int value) {
165c205
&lt; 		return store.getString(RENDERER);
---
&gt; 		store.setValue(BAR_WIDTH, value);
169c209
&lt; 	 * Store the given name as the chosen renderer name
---
&gt; 	 * Store the given size as the chosen stripe height
172c212
&lt; 	 *            the renderer name
---
&gt; 	 *            height in pixels
174c214
&lt; 	public static void setRendererName(String value) {
---
&gt; 	public static void setStripeHeight(int value) {
177,178c217
&lt; 		store.setValue(RENDERER, value);
&lt; 		RendererManager.setCurrentRendererByName(value);
---
&gt; 		store.setValue(STRIPE_HEIGHT, value);
182,183c221
&lt; 	 * Return the chosen palette id for the given provider if one has been
&lt; 	 * specified
---
&gt; 	 * Set the option for whether or not to use patterns
185,186c223
&lt; 	 * @param providerID
&lt; 	 * @return the id of the palette chosen by the given provider
---
&gt; 	 * @param boolean value - use patterns or not
188c225
&lt; 	public static String getPaletteIDForProvider(String providerID) {
---
&gt; 	public static void setUsePatterns(boolean value) {
191,192c228
&lt; 		String pref = PALETTE_PREFIX + providerID;
&lt; 		return store.getString(pref);
---
&gt; 		store.setValue(USE_PATTERNS, value);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/text/VisualiserMessages.properties" revision="1.2" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/text/VisualiserMessages.java" revision="1.2" state="changed">36a37
&gt; 	public static String VisualiserPreferencePage_usePats;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/VisualiserCanvas.java" revision="1.18" state="changed">33a34
&gt; import org.eclipse.contribution.visualiser.renderers.PatternVisualiserRenderer;
126a128,129
&gt; 	
&gt; 	public static PatternVisualiserRenderer patternVisualiserRenderer;
218a222
&gt; 		patternVisualiserRenderer = new PatternVisualiserRenderer();
1214c1218,1222
&lt; 						gc.setBackground(kg.color);
---
&gt; 						if (VisualiserPreferences.getUsePatterns()) {
&gt; 							patternVisualiserRenderer.setDitherPattern(gc, kg.color);
&gt; 						} else {
&gt; 							gc.setBackground(kg.color);
&gt; 						}
1308c1316,1320
&lt; 				gc.setBackground(kg.color);
---
&gt; 				if (VisualiserPreferences.getUsePatterns()) {
&gt; 					patternVisualiserRenderer.setDitherPattern(gc, kg.color);
&gt; 				} else {
&gt; 					gc.setBackground(kg.color);
&gt; 				}				
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/Menu.java" revision="1.19" state="changed">25a26
&gt; import org.eclipse.contribution.visualiser.internal.preference.VisualiserPreferences;
113c114,118
&lt; 		gc.setBackground(color);
---
&gt; 		if (VisualiserPreferences.getUsePatterns()) {
&gt; 			VisualiserCanvas.patternVisualiserRenderer.setDitherPattern(gc, color);
&gt; 		} else {
&gt; 			gc.setBackground(color);
&gt; 		}
138c143
&lt; 		 * then redraws the square image with the chosen colour. 
---
&gt; 		 * then redraws the square image with the chosen colour.
142,147c147,167
&lt; 				if (e.getSource() instanceof Button) {
&lt; 					Button button = (Button) e.getSource();
&lt; 					int location = 0;
&lt; 					for (int j = 0; j &lt; buttons.length; j++) {
&lt; 						if ((buttons[j]).equals(button)) {
&lt; 							location = j;
---
&gt; 				// Do nothing if viewing with Pattern Palette
&gt; 				if (!VisualiserPreferences.getUsePatterns()) {
&gt; 					if (e.getSource() instanceof Button) {
&gt; 						Button button = (Button) e.getSource();
&gt; 						int location = 0;
&gt; 						for (int j = 0; j &lt; buttons.length; j++) {
&gt; 							if ((buttons[j]).equals(button)) {
&gt; 								location = j;
&gt; 							}
&gt; 						}
&gt; 						RGB rgb = colorDialogs[location].open();
&gt; 						if (rgb == null) {
&gt; 							return;
&gt; 						}
&gt; 						colors[location] = new Color(buttons[location].getDisplay(), rgb);
&gt; 						Image image = buttons[location].getImage();
&gt; 						drawImage(image, colors[location]);
&gt; 						buttons[location].setImage(image);
&gt; 						if (!(VisualiserPlugin.visualiser == null)) {
&gt; 							vmp.setColorFor((IMarkupKind)labels[location].getData(),colors[location]);
&gt; 							VisualiserPlugin.visualiser.draw();
149,160d168
&lt; 					}
&lt; 					RGB rgb = colorDialogs[location].open();
&lt; 					if (rgb == null) {
&lt; 						return;
&lt; 					}
&lt; 					colors[location] = new Color(buttons[location].getDisplay(), rgb);
&lt; 					Image image = buttons[location].getImage();
&lt; 					drawImage(image, colors[location]);
&lt; 					buttons[location].setImage(image);
&lt; 					if (!(VisualiserPlugin.visualiser == null)) {
&lt; 						vmp.setColorFor((IMarkupKind)labels[location].getData(),colors[location]);
&lt; 						VisualiserPlugin.visualiser.draw();
432c440,446
&lt; 		 		 		 buttons[i] = new Button(canvas, SWT.PUSH);
---
&gt; 		 		 		 // TODO: If we're using patterns, just want image, no button
&gt; 		 		 		 if (!VisualiserPreferences.getUsePatterns()) {
&gt; 			 		 		 buttons[i] = new Button(canvas, SWT.PUSH);
&gt; 		 		 		 } else {
&gt; 		 		 		 // Just an image
&gt; 			 		 		 buttons[i] = new Button(canvas, SWT.PUSH);
&gt; 		 		 		 }
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/plugin.xml" revision="1.11" state="changed">149a150,153
&gt;          &lt;palette class="org.eclipse.contribution.visualiser.palettes.PatternVisualiserPalette"
&gt;              name="%Palette.pattern.name"
&gt;              id="patternpalette"&gt;
&gt;          &lt;/palette&gt;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/internal/preference/VisualiserPreferencePage.java" revision="1.7" state="changed">27a28
&gt; import org.eclipse.contribution.visualiser.palettes.PatternVisualiserPalette;
30a32
&gt; import org.eclipse.contribution.visualiser.views.VisualiserCanvas;
89a92,95
&gt; 	private static RGB[] rgb;
&gt; 
&gt; 	private static Color[] staticColsForPatterns;
&gt; 
95a102,108
&gt; 		rgb = PaletteManager.getDefaultPalette().getPalette().getRGBValues();
&gt; 		staticColsForPatterns = new Color[] {
&gt; 				new Color(Display.getDefault(), rgb[0]),
&gt; 				new Color(Display.getDefault(), rgb[1]),
&gt; 				new Color(Display.getDefault(), rgb[2]),
&gt; 				new Color(Display.getDefault(), rgb[3]), };
&gt; 
269a283,288
&gt; 				String pname = colourList.getSelection()[0];
&gt; 				if (PaletteManager.getPaletteByName(pname).getPalette() instanceof PatternVisualiserPalette) {
&gt; 					preview.localUsePatterns = true;
&gt; 				} else {
&gt; 					preview.localUsePatterns = false;
&gt; 				}
298a318,320
&gt; 		private boolean localUsePatterns = VisualiserPreferences
&gt; 				.getUsePatterns();
&gt; 
343c365,370
&lt; 				sgc.setBackground(cols[0]);
---
&gt; 				if (localUsePatterns) {
&gt; 					VisualiserCanvas.patternVisualiserRenderer
&gt; 							.setDitherPattern(sgc, staticColsForPatterns[0]);
&gt; 				} else {
&gt; 					sgc.setBackground(cols[0]);
&gt; 				}
346c373,378
&lt; 				sgc.setBackground(cols[1]);
---
&gt; 				if (localUsePatterns) {
&gt; 					VisualiserCanvas.patternVisualiserRenderer
&gt; 							.setDitherPattern(sgc, staticColsForPatterns[1]);
&gt; 				} else {
&gt; 					sgc.setBackground(cols[1]);
&gt; 				}
348c380,386
&lt; 				sgc.setBackground(cols[2]);
---
&gt; 
&gt; 				if (localUsePatterns) {
&gt; 					VisualiserCanvas.patternVisualiserRenderer
&gt; 							.setDitherPattern(sgc, staticColsForPatterns[2]);
&gt; 				} else {
&gt; 					sgc.setBackground(cols[2]);
&gt; 				}
351c389,394
&lt; 				sgc.setBackground(cols[3]);
---
&gt; 				if (localUsePatterns) {
&gt; 					VisualiserCanvas.patternVisualiserRenderer
&gt; 							.setDitherPattern(sgc, staticColsForPatterns[3]);
&gt; 				} else {
&gt; 					sgc.setBackground(cols[3]);
&gt; 				}
384a428,430
&gt; 		public boolean getLocalUsePatterns() {
&gt; 			return localUsePatterns;
&gt; 		}
599,603c645,647
&lt; 			if (defp.equals(pname)) {
&lt; 				// going with provider defintion, clear preference setting
&lt; 				VisualiserPreferences.setPaletteIDForProvider(def, ""); //$NON-NLS-1$
&lt; 			} else {
&lt; 				// update preference setting for this provider
---
&gt; 			if (PaletteManager.getPaletteByName(pname).getPalette() instanceof PatternVisualiserPalette) {
&gt; 				// We're using patterns
&gt; 				VisualiserPreferences.setUsePatterns(true);
605a650,660
&gt; 			} else {
&gt; 				// We're not using patterns
&gt; 				VisualiserPreferences.setUsePatterns(false);
&gt; 				if (defp.equals(pname)) {
&gt; 					// going with provider defintion, clear preference setting
&gt; 					VisualiserPreferences.setPaletteIDForProvider(def, ""); //$NON-NLS-1$
&gt; 				} else {
&gt; 					// update preference setting for this provider
&gt; 					String pid = PaletteManager.getPaletteByName(pname).getID();
&gt; 					VisualiserPreferences.setPaletteIDForProvider(def, pid);
&gt; 				}
638d692
&lt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/palettes/PatternVisualiserPalette.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Ben Dalziel - initial version
 *******************************************************************************/
package org.eclipse.contribution.visualiser.palettes;

public class PatternVisualiserPalette extends DefaultVisualiserPalette {
	
	protected static byte[][] pattern1 = new byte[][] { 
		{ 2, 0, 0, 7, 0 }, { 2, 0, 2, 7, 2 }, { 2, 0, 4, 7, 4 }, { 2, 0, 6, 7, 6 },
		{ 2, 0, 0, 0, 7 }, { 2, 2, 0, 2, 7 }, { 2, 4, 0, 4, 7 }, { 2, 6, 0, 6, 7 } };
	
	protected static byte[][] pattern2 = new byte[][] { 
		{ 2, 0, 0, 0, 7 }, { 2, 2, 0, 2, 7 }, { 2, 4, 0, 4, 7 }, { 2, 6, 0, 6, 7 } };
	
	protected static byte[][] pattern3 = new byte[][] { 
		{ 2, 0, 0, 7, 0 }, { 2, 0, 2, 7, 2 }, { 2, 0, 4, 7, 4 }, { 2, 0, 6, 7, 6 } };
	
	protected static byte[][] pattern4 = new byte[][] { 
		{ 2, 0, 0, 0, 0 }, { 2, 0, 4, 0, 4 },
		                   { 2, 4, 0, 4, 0 },
		                   { 2, 4, 4, 4, 4 } };
	
	protected static byte[][] pattern5 = new byte[][] { 
		{ 2, 0, 0, 0, 7 }, { 2, 0, 0, 7, 0 },
		                   { 2, 0, 4, 7, 4 },
		                   { 2, 4, 0, 4, 7 } };

	protected static byte[][] pattern6 = new byte[][] { 
		{ 2, 0, 0, 0, 7 }, { 2, 4, 0, 4, 7 } };
	
	protected static byte[][] pattern7 = new byte[][] { 
		{ 2, 0, 0, 7, 0 }, { 2, 0, 4, 7, 4 } };

	protected static byte[][] pattern8 = new byte[][] { 
		{ 2, 0, 0, 0, 7 }, { 2, 1, 0, 1, 7 }, { 2, 4, 0, 4, 7 }, { 2, 5, 0, 5, 7 } };
	
	protected static byte[][] pattern9 = new byte[][] { 
		{ 2, 0, 0, 7, 0 }, { 2, 0, 1, 7, 1 }, { 2, 0, 4, 7, 4 }, { 2, 0, 5, 7, 5 } };
	
	protected static byte[][] pattern10 = new byte[][] { 
		{ 2, 0, 0, 7, 7 }, { 2, 4, 0, 7, 3 }, { 2, 0, 4, 3, 7 } };
	
	protected static byte[][] pattern11 = new byte[][] { 
		{ 2, 7, 0, 0, 7 }, { 2, 3, 0, 0, 3 }, { 2, 7, 4, 4, 7 } };
	
	protected static byte[][][] patternList = new byte[][][] {
		// First Four used for the Preferences Dialog
		pattern1,
		pattern2,
		pattern3,
		pattern4,
		
		pattern1,
		pattern2,
		pattern3,
		pattern4,
		pattern5,
		pattern6,
		pattern7,
		pattern8,
		pattern9,
		pattern10,
		pattern11
		};

	/**
	 * Returns a pattern with a number of randomly created lines
	 * The density, between 5 and 20 related to the number of lines in the pattern
	 * 
	 * @return randomly generated Color
	 */
	public byte[][] getRandomPattern() {		
		int density = ((int) (Math.random() * 15) + 5);

		byte[][] randomPattern = new byte[density][5];
		
		for (int i = 0; i &lt; density; i++) {
			int x1 = ((int) (Math.random() * 8));
			int y1 = ((int) (Math.random() * 8));
			// Could make into pattern of lines insted of points by including these coords
//			int x2 = ((int) (Math.random() * 8));
//			int y2 = ((int) (Math.random() * 8));
			
			randomPattern[i] = new byte[] {2, (byte) x1, (byte) y1, (byte) x1, (byte) y1};
		}
		return randomPattern;
	}
	
	public byte[][][] getPaletteContence() {
		return patternList;
	}
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/renderers/PatternVisualiserRenderer.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Ben Dalziel - initial version
 *******************************************************************************/
package org.eclipse.contribution.visualiser.renderers;

import java.util.HashMap;
import java.util.Map;

import org.eclipse.contribution.visualiser.palettes.PatternVisualiserPalette;
import org.eclipse.draw2d.ColorConstants;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.GC;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.Pattern;
import org.eclipse.swt.widgets.Display;

public class PatternVisualiserRenderer extends ClassicVisualiserRenderer {

	PatternVisualiserPalette palette = new PatternVisualiserPalette();
		
	private static int nextAvailablePattern = 0;
	
	private Map patternMemory = new HashMap();
	
	/**
	 * Get the next assignable pattern data and return it. If all the predefined patterns
	 * have been assigned, a new one is generated
	 * @return byte[][] - pattern data
	 */
	protected byte[][] getNextPattern() {
		byte[][][] pats = palette.getPaletteContence();
		if (nextAvailablePattern &lt; pats.length) {
			byte[][] patternData = pats[nextAvailablePattern++];
			return patternData;
		} else {
			byte[][] patternData = palette.getRandomPattern();
				return patternData;
		}		
	}
	
	/**
	 * Converts the patternData into a Pattern
	 * @param patternData - byte[][] used to create the image
	 * @return The Pattern to be used
	 */
	private Pattern createPattern(byte[][] patternData) {
		Image patternImg = new Image(Display.getCurrent(), 8, 8);
		GC gc = new GC(patternImg);

		for (int i = 0; i &lt; patternData.length; i++) {
			byte[] b = patternData[i];
			gc.setForeground(ColorConstants.black);
			if (b[1]==b[3] &amp;&amp; b[2]==b[4]) {
				gc.drawPoint(b[1], b[2]);
			} else {
				gc.drawLine(b[1], b[2], b[3], b[4]);
			}
		}
		Pattern pattern = new Pattern(Display.getCurrent(), patternImg);		
		gc.dispose();
		patternImg.dispose();
		return pattern;
	}

	/**
	 * Returns pattern data from the patternMemory if the colour is recognised
	 * or a new pattern if the colour is new to the renderer
	 * @param colour
	 * @return byte[][] - pattern data
	 */
	private byte[][] getPatternForColour(Color colour) {
		
		byte[][] stripePatternData = null;
		if (patternMemory.containsKey(colour)) {
			stripePatternData = (byte[][]) patternMemory.get(colour);
		} else {
			stripePatternData = getNextPattern();
			patternMemory.put(colour, stripePatternData);
		}
		return stripePatternData;
	}
	
	/**
	 * Uses a colour, associates a pattern with it and tiles it over the gc 
	 * @param gc
	 * @param colour - The colour assigned to the gc
	 */
	public void setDitherPattern(GC gc, Color colour) {
		gc.setBackgroundPattern(createPattern(getPatternForColour(colour)));
	}
}
</file>
</fixedFiles>
</bug>
<bug id="102459" transactionid="71059">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-this M T V Y</fullfingerprint>
<bugreport>When advice is executed, the object you have to work with is the joinpoint. This
can then be queried to get various information out of it. It would be nice, if
as part of the weaving you could get hold of the same information. 

This is particularly useful in the case of writing a coverage tool. In order to
measure where you've been, you have to know all the places you could possibly
go. The introduction of the -showWeaveInfo option means that we can record these
places, however, this would be greatly enhanced by providing similar information
as to that which is collected as the program is running.

The information which would be good is the same as that obtained from

JoinPoint.StaticPart.getSignature().toLongString().</bugreport>
<testsforfix ID="102459" type="changed">
    <file LOCATION="org.aspectj/modules/tests/java5/ataspectj/ajc-ant.xml">
      <test NAME="ltwlog.LTWLog"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/102459/pre-fix/testresults.xml" passing="1534" size="1714"/>
<post-fix-testcases failing="178" file="output/102459/post-fix/testresults.xml" passing="1536" size="1714"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Shadow.java" revision="1.34" state="changed">464a465
&gt; 			String joinPointDescription = this.toString();
466c467
&lt; 		    		new String[]{ advisedType, beautifyLocation(getSourceLocation()),
---
&gt; 		    		new String[]{ joinPointDescription, advisedType, beautifyLocation(getSourceLocation()),
</file>
<file name="org.aspectj/modules/ajde/testdata/WeaveInfoMessagesTest/expected/advice.txt" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/ajde/testdata/WeaveInfoMessagesTest/expected/advice.binary.nodebug.txt" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/ajde/testdata/WeaveInfoMessagesTest/expected/declare.soft.nodebug.txt" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/bridge/src/org/aspectj/bridge/WeaveMessage.java" revision="1.6" state="changed">25c25
&lt;     // %6 is information like "[with runtime test]"
---
&gt;     // %7 is information like "[with runtime test]"
27c27
&lt; 	  new WeaveMessageKind(3,"Type '%1' (%2) advised by %3 advice from '%4' (%5)%6");
---
&gt; 	  new WeaveMessageKind(3,"Join point '%1' in Type '%2' (%3) advised by %4 advice from '%5' (%6)%7");
</file>
<file name="org.aspectj/modules/ajde/testdata/WeaveInfoMessagesTest/expected/itd.nodebug.txt" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/ajde/testdata/WeaveInfoMessagesTest/expected/advice.binary.txt" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/ajde/testdata/WeaveInfoMessagesTest/expected/itd.txt" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java" revision="1.2" state="changed">28c28
&lt;                 "weaveinfo Type 'ataspectj.ltwlog.MainVerboseAndShow' (MainVerboseAndShow.java:22) advised by before advice from 'ataspectj.ltwlog.Aspect1' (Aspect1.java)",
---
&gt;                 "weaveinfo Join point 'method-execution(void ataspectj.ltwlog.MainVerboseAndShow.target())' in Type 'ataspectj.ltwlog.MainVerboseAndShow' (MainVerboseAndShow.java:22) advised by before advice from 'ataspectj.ltwlog.Aspect1' (Aspect1.java)",
</file>
</fixedFiles>
</bug>
<bug id="102652" transactionid="73532">
<property name="files-churned" value="5"/>
<property name="java-files-churned" value="5"/>
<property name="classes-churned" value="5"/>
<property name="methods-churned" value="5"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="27"/>
<property name="lines-deleted" value="24"/>
<property name="lines-modified" value="9"/>
<property name="lines-churned" value="60"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-import K-instanceof K-null K-true M O-== O-!= O-&amp;&amp; O-+ O-instanceof T V Y Z-cast Z-if</fullfingerprint>
<bugreport>Using Eclipse 3.1 and development build of AJDT, project can be built by using 
the "build" button, but when using incremental compilation the source code is 
not compiled. When a separate source folder was added the problem was resolved.</bugreport>
<testsforfix ID="102652" type="new">
    <file LOCATION="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/ui/tests/builder/BuilderTest.java">
      <test NAME="testIncrementalBuildWithSrcFolder"/>
      <test NAME="testIncrementalBuildWithoutSrcFolder"/>
    </file>
    <file LOCATION="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/builder/AJBuilderTest.java">
      <test NAME="testCleanBuild"/>
      <test NAME="testIncrementalBuildWithSrcFolder"/>
      <test NAME="testIncrementalBuildWithoutSrcFolder"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="177" file="output/102652/pre-fix/testresults.xml" passing="1544" size="1721"/>
<post-fix-testcases failing="178" file="output/102652/post-fix/testresults.xml" passing="1543" size="1721"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug101481/src/pack/C.java" revision="1.2" state="changed">1a2
&gt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/testutils/TestLogger.java" revision="1.2" state="changed">29c29
&lt;         if (log == null) {
---
&gt;          if (log == null) {
38,39c38
&lt;             StringBuffer sb = new StringBuffer(logEntry);
&lt;             if (sb.indexOf(msg) != -1) {
---
&gt;             if (logEntry.indexOf(msg) != -1) {
45a45,59
&gt;     /**
&gt;      * Return the first line in the log that contains the given string
&gt;      * @param msg
&gt;      * @return
&gt;      */
&gt;     public String getMostRecentMatchingMessage(String msg) {
&gt;     	for (int i = log.size()-1; i &gt;= 0; i--) {
&gt;            String logEntry = (String)log.get(i);
&gt;             if (logEntry.indexOf(msg) != -1) {
&gt;                 return logEntry;
&gt;             }
&gt;         }
&gt;         return null;
&gt;     }
&gt;     
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/builder/CoreProjectProperties.java" revision="1.9" state="changed">111,112c111,112
&lt; 					if ((res != null) &amp;&amp; (res.getType() == IResource.FOLDER)) {
&lt; 						List l = allFiles((IFolder) res);
---
&gt; 					if ((res != null) &amp;&amp; (res instanceof IContainer)) {
&gt; 						List l = allFiles((IContainer) res);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/builder/AJBuilder.java" revision="1.22" state="changed">26a27
&gt; import org.aspectj.asm.AsmManager;
154a156,181
&gt; 		buildManager = Ajde.getDefault().getBuildManager();
&gt; 		buildManager.setBuildModelMode(true);
&gt; 
&gt; //		String kindS = null;
&gt; //		if (kind == IncrementalProjectBuilder.AUTO_BUILD)
&gt; //			kindS = "AUTOBUILD";  //$NON-NLS-1$
&gt; //		if (kind == IncrementalProjectBuilder.INCREMENTAL_BUILD)
&gt; //			kindS = "INCREMENTALBUILD";  //$NON-NLS-1$
&gt; //		if (kind == IncrementalProjectBuilder.FULL_BUILD)
&gt; //			kindS = "FULLBUILD";  //$NON-NLS-1$
&gt; 
&gt; 		String mode = "";  //$NON-NLS-1$
&gt; 		boolean incremental = buildManager.getBuildOptions().getIncrementalMode();
&gt; 		if (incremental &amp;&amp; kind!=IncrementalProjectBuilder.FULL_BUILD) {
&gt; 			mode = "Incremental AspectJ compilation";
&gt; 		} else {
&gt; 			mode = "Full AspectJ compilation";
&gt; 		}
&gt; 		AJLog.log("Project="
&gt; 				+ project.getName() + "         kind of build requested =" + mode);
&gt; 
&gt; 		// if using incremental compiilation, then attempt the incremental model repairs.
&gt; 		AsmManager.attemptIncrementalModelRepairs = incremental;		
&gt; 
&gt; 		
&gt; 		
192,194d218
&lt; 		buildManager = Ajde.getDefault().getBuildManager();
&lt; 		buildManager.setBuildModelMode(true);
&lt; 		
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/actions/UICoreOperations.java" revision="1.6" state="changed">70c70,74
&lt; 				if (sourceFilesChanged(delta, includedFileNames,ijp.getOutputLocation())) {
---
&gt; 				IPath outputPath = ijp.getOutputLocation();
&gt; 				if (project.getFullPath().equals(outputPath)) {
&gt; 					outputPath = null;
&gt; 				}
&gt; 				if (sourceFilesChanged(delta, includedFileNames,outputPath)) {
87c91
&lt; 		if ( outputLocation.equals(dta.getFullPath()) ) {
---
&gt; 		if (outputLocation!=null &amp;&amp; outputLocation.equals(dta.getFullPath()) ) {
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/builder/CoreBuildOptions.java" revision="1.2" state="changed">46c46
&lt; 		return false;
---
&gt; 		return true;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/builder/UIBuildListener.java" revision="1.21" state="changed">67,87d66
&lt; 		String kindS = null;
&lt; 		if (kind == IncrementalProjectBuilder.AUTO_BUILD)
&lt; 			kindS = "AUTOBUILD";  //$NON-NLS-1$
&lt; 		if (kind == IncrementalProjectBuilder.INCREMENTAL_BUILD)
&lt; 			kindS = "INCREMENTALBUILD";  //$NON-NLS-1$
&lt; 		if (kind == IncrementalProjectBuilder.FULL_BUILD)
&lt; 			kindS = "FULLBUILD";  //$NON-NLS-1$
&lt; 
&lt; 		String mode = "";  //$NON-NLS-1$
&lt; 		if (AspectJUIPlugin.getDefault().getAjdtBuildOptionsAdapter()
&lt; 				.getIncrementalMode() &amp;&amp; kind!=IncrementalProjectBuilder.FULL_BUILD)
&lt; 			mode = "Incremental AspectJ compilation";
&lt; 		else
&lt; 			mode = "Full AspectJ compilation";
&lt; 		AJLog.log("Project="
&lt; 				+ project.getName() + "         kind of build requested =" + mode);
&lt; 
&lt; 		// if using incremental compiilation, then attempt the incremental model repairs.
&lt; 		boolean inc = AspectJPreferences.getIncrementalOption(project);
&lt; 		AsmManager.attemptIncrementalModelRepairs = inc;		
&lt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/ui/tests/builder/BuilderTest.java" revision="1.4" state="changed">23a24
&gt; import org.eclipse.ajdt.core.AspectJPlugin;
26a28
&gt; import org.eclipse.ajdt.ui.tests.testutils.TestLogger;
730a733,831
&gt; 	public void testIncrementalBuildWithSrcFolder() throws Exception {
&gt; 		TestLogger testLog = new TestLogger();
&gt; 		AspectJPlugin.getDefault().setAJLogger(testLog);
&gt; 		IProject project = Utils.createPredefinedProject("TJP Example");
&gt; 		try {
&gt; 			assertFalse("project should have no errors", testLog
&gt; 					.containsMessage("error"));
&gt; 			
&gt; 			IFolder src = project.getFolder("src");
&gt; 			if (!src.exists()) {
&gt; 				src.create(true, true, null);
&gt; 			}
&gt; 			IFolder pack = src.getFolder("tjp");
&gt; 			if (!pack.exists()) {
&gt; 				pack.create(true, true, null);
&gt; 			}
&gt; 			IFile c = pack.getFile("Demo.java");
&gt; 			assertNotNull("src folder should not be null", src);
&gt; 			assertNotNull("package tjp should not be null", pack);
&gt; 			assertNotNull("class Demo should not be null", c);
&gt; 			assertTrue("java file should exist", c.exists());
&gt; 
&gt; 			IFolder bin = project.getFolder("bin");
&gt; 			if (!bin.exists()) {
&gt; 				bin.create(true, true, null);
&gt; 			}
&gt; 			IFolder binPack = bin.getFolder("tjp");
&gt; 			if (!binPack.exists()) {
&gt; 				binPack.create(true, true, null);
&gt; 			}
&gt; 			IFile binC = binPack.getFile("Demo.class");
&gt; 			assertTrue("class file should exist", binC.exists());
&gt; 						
&gt; 			String rep = testLog.getMostRecentMatchingMessage("AspectJ reports build successful");
&gt; 			System.out.println("rep: "+rep);
&gt; 			
&gt; 			// add a comment to the class
&gt; 			StringReader sr = new StringReader("/* blah blah blah */");
&gt; 			c.appendContents(new ReaderInputStream(sr), IResource.FORCE, null);
&gt; 
&gt; 			Utils.waitForJobsToComplete();
&gt; 			
&gt; 			assertTrue("Successful build should have occurred", testLog
&gt; 					.containsMessage("AspectJ reports build successful"));
&gt; 			
&gt; 			rep = testLog.getMostRecentMatchingMessage("AspectJ reports build successful");
&gt; 			assertNotNull("Successful build should have been reported",rep);
&gt; 			
&gt; 			assertTrue("The build should have been an incremental one",wasIncrementalBuild(rep));
&gt; 		} finally {
&gt; 			AspectJPlugin.getDefault().setAJLogger(null);
&gt; 			Utils.deleteProject(project);
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	public void testIncrementalBuildWithoutSrcFolder() throws Exception {
&gt; 		TestLogger testLog = new TestLogger();
&gt; 		AspectJPlugin.getDefault().setAJLogger(testLog);
&gt; 		IProject project = Utils.createPredefinedProject("bug102652");
&gt; 		try {
&gt; 			assertFalse("project should have no errors", testLog
&gt; 					.containsMessage("error"));
&gt; 			
&gt; 			IFolder pack = project.getFolder("tjp");
&gt; 			if (!pack.exists()) {
&gt; 				pack.create(true, true, null);
&gt; 			}
&gt; 			IFile c = pack.getFile("Demo.java");
&gt; 			assertNotNull("package tjp should not be null", pack);
&gt; 			assertNotNull("class Demo should not be null", c);
&gt; 			assertTrue("java file should exist", c.exists());
&gt; 
&gt; 			IFile binC = pack.getFile("Demo.class");
&gt; 			assertTrue("class file should exist", binC.exists());
&gt; 			
&gt; 			// add a comment to the class
&gt; 			StringReader sr = new StringReader("/* blah blah blah */");
&gt; 			c.appendContents(new ReaderInputStream(sr), IResource.FORCE, null);
&gt; 
&gt; 			Utils.waitForJobsToComplete();
&gt; 
&gt; 			assertFalse("Source file changes should have been detected", testLog
&gt; 					.containsMessage("no source file changes for project bug102652"));
&gt; 
&gt; 			assertTrue("Successful build should have occurred", testLog
&gt; 					.containsMessage("AspectJ reports build successful"));
&gt; 			
&gt; 			String rep = testLog.getMostRecentMatchingMessage("AspectJ reports build successful");
&gt; 			assertNotNull("Successful build should have been reported",rep);
&gt; 			assertTrue("The build should have been an incremental one",wasIncrementalBuild(rep));
&gt; 		} finally {
&gt; 			AspectJPlugin.getDefault().setAJLogger(null);
&gt; 			Utils.deleteProject(project);
&gt; 		}
&gt; 	}
&gt; 		
&gt; 	private boolean wasIncrementalBuild(String msg) {
&gt; 		return msg.toLowerCase().indexOf("was: incremental") != -1;
&gt; 	}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/builder/AJBuilderTest.java" revision="1.3" state="changed">33,87c33,137
&lt;     IProject project;
&lt;     TestLogger testLog;
&lt;     
&lt;     /*
&lt;      * @see TestCase#setUp()
&lt;      */
&lt;     protected void setUp() throws Exception {
&lt;         super.setUp();
&lt;         testLog = new TestLogger();
&lt;         AspectJPlugin.getDefault().setAJLogger(testLog);
&lt;         project = createPredefinedProject("bug101481");
&lt;         Utils.setAutobuilding(false);
&lt;     }
&lt; 
&lt;     /*
&lt;      * @see TestCase#tearDown()
&lt;      */
&lt;     protected void tearDown() throws Exception {
&lt;         super.tearDown();
&lt;         AspectJPlugin.getDefault().setAJLogger(null);
&lt;         Utils.setAutobuilding(true);
&lt;         deleteProject(project);		
&lt;     }
&lt;     
&lt;     /**
&lt;      * Test for bug 101481 - "clean" build doesn't work
&lt;      * and refreshing of output directory
&lt;      * 
&lt;      * @throws Exception
&lt;      */
&lt;     public void testCleanBuild() throws Exception {
&lt;         assertFalse("autobuilding should be set to false",Utils.isAutobuilding());
&lt;         assertFalse("project should have no errors",testLog.containsMessage("error"));
&lt;         
&lt;         IFolder src = project.getFolder("src");
&lt; 		if (!src.exists()){
&lt; 			src.create(true, true, null);
&lt; 		}
&lt; 		IFolder pack = src.getFolder("pack");
&lt; 		if (!pack.exists()){
&lt; 			pack.create(true, true, null);
&lt; 		}
&lt; 		IFile c = pack.getFile("C.java");
&lt; 		assertNotNull("src folder should not be null", src);
&lt; 		assertNotNull("package pack should not be null", pack);
&lt; 		assertNotNull("class c should not be null", c);
&lt; 		assertTrue("java file should exist", c.exists());
&lt; 		
&lt;         IFolder bin = project.getFolder("bin");
&lt; 		if (!bin.exists()){
&lt; 		    bin.create(true, true, null);
&lt; 		}
&lt; 		IFolder binPack = bin.getFolder("pack");
&lt; 		if (!binPack.exists()){
&lt; 		    binPack.create(true, true, null);
---
&gt; 	/**
&gt; 	 * Test for bug 101481 - "clean" build doesn't work and refreshing of output
&gt; 	 * directory
&gt; 	 * 
&gt; 	 * @throws Exception
&gt; 	 */
&gt; 	public void testCleanBuild() throws Exception {
&gt; 		TestLogger testLog = new TestLogger();
&gt; 		AspectJPlugin.getDefault().setAJLogger(testLog);
&gt; 		IProject project = createPredefinedProject("bug101481");
&gt; 		try {
&gt; 			Utils.setAutobuilding(false);
&gt; 
&gt; 			assertFalse("autobuilding should be set to false", Utils
&gt; 					.isAutobuilding());
&gt; 			assertFalse("project should have no errors", testLog
&gt; 					.containsMessage("error"));
&gt; 
&gt; 			IFolder src = project.getFolder("src");
&gt; 			if (!src.exists()) {
&gt; 				src.create(true, true, null);
&gt; 			}
&gt; 			IFolder pack = src.getFolder("pack");
&gt; 			if (!pack.exists()) {
&gt; 				pack.create(true, true, null);
&gt; 			}
&gt; 			IFile c = pack.getFile("C.java");
&gt; 			assertNotNull("src folder should not be null", src);
&gt; 			assertNotNull("package pack should not be null", pack);
&gt; 			assertNotNull("class c should not be null", c);
&gt; 			assertTrue("java file should exist", c.exists());
&gt; 
&gt; 			IFolder bin = project.getFolder("bin");
&gt; 			if (!bin.exists()) {
&gt; 				bin.create(true, true, null);
&gt; 			}
&gt; 			IFolder binPack = bin.getFolder("pack");
&gt; 			if (!binPack.exists()) {
&gt; 				binPack.create(true, true, null);
&gt; 			}
&gt; 			IFile binC = binPack.getFile("C.class");
&gt; 
&gt; 			assertTrue("bin directory should contain class file",
&gt; 					outputDirContainsFile(project, "pack", "C.class"));
&gt; 			// testing the refresh output directory part of bug 101481
&gt; 			assertTrue("class file should exist", binC.exists());
&gt; 
&gt; 			StringBuffer origContents = new StringBuffer("package pack; ");
&gt; 			origContents.append(System.getProperty("line.separator"));
&gt; 			origContents.append("public class C {}");
&gt; 
&gt; 			// write "blah blah blah" to the class
&gt; 			// NOTE: we add a comment so that thet class file doesn't get
&gt; 			// deleted, as we test for it later, but this is a somewhat
&gt; 			// arbitrary test because the behaviour of AJC is different to the
&gt; 			// JDT compiler when the source has errors (see bug 102733)
&gt; 			StringBuffer sb = new StringBuffer("blah blah blah/*comment*/");
&gt; 			sb.append(origContents);
&gt; 			StringReader sr = new StringReader(sb.toString());
&gt; 			c.setContents(new ReaderInputStream(sr), IResource.FORCE, null);
&gt; 			sr.close();
&gt; 						
&gt; 			project.build(IncrementalProjectBuilder.INCREMENTAL_BUILD, null);
&gt; 			assertTrue("project should have errors", testLog
&gt; 					.containsMessage("error at blah blah blah"));
&gt; 			assertTrue("bin directory should contain class file",
&gt; 					outputDirContainsFile(project, "pack", "C.class"));
&gt; 			assertFalse(
&gt; 					"should not have cleaned the output folder",
&gt; 					testLog
&gt; 							.containsMessage("Cleared AJDT relationship map for project bug101481"));
&gt; 			int n = testLog
&gt; 					.numberOfEntriesForMessage("Builder: Tidied output folder, deleted 1 .class files from");
&gt; 
&gt; 			binC = binPack.getFile("C.class");
&gt; 			assertTrue("class file should exist", binC.exists());
&gt; 
&gt; 			project.build(IncrementalProjectBuilder.CLEAN_BUILD, null);
&gt; 			// testing the same steps are taken during a clean as they
&gt; 			// are in the javaBuilder part of bug 101481
&gt; 			assertTrue(
&gt; 					"should have deleted 1 class file from the output dir",
&gt; 					testLog
&gt; 							.containsMessage("Builder: Tidied output folder, deleted 1 .class files from"));
&gt; 			assertTrue(
&gt; 					"should have removed problems and tasks for the project",
&gt; 					testLog
&gt; 							.containsMessage("Removed problems and tasks for project"));
&gt; 			assertEquals(
&gt; 					"should have cleaned output folder " + (n + 1) + "times",
&gt; 					n + 1,
&gt; 					testLog
&gt; 							.numberOfEntriesForMessage("Builder: Tidied output folder, deleted 1 .class files from"));
&gt; 			assertFalse("bin directory should not contain class file",
&gt; 					outputDirContainsFile(project, "pack", "C.class"));
&gt; 
&gt; 			// testing the refresh output dir after a clean (without doing
&gt; 			// a build) part of bug 101481
&gt; 			binC = binPack.getFile("C.class");
&gt; 			assertFalse("class file should not exist", binC.exists());
&gt; 
&gt; 		} finally {
&gt; 			AspectJPlugin.getDefault().setAJLogger(null);
&gt; 			Utils.setAutobuilding(true);
&gt; 			deleteProject(project);
89,131c139,144
&lt; 		IFile binC = binPack.getFile("C.class");
&lt; 		
&lt; 		assertTrue("bin directory should contain class file",outputDirContainsFile("C.class"));
&lt; 		// testing the refresh output directory part of bug 101481
&lt; 		assertTrue("class file should exist",binC.exists());
&lt; 		
&lt; 		StringBuffer origContents = new StringBuffer("package pack; ");
&lt; 		origContents.append(System.getProperty("line.separator"));
&lt; 		origContents.append("public class C {}");
&lt; 		
&lt; 		// write "blah blah blah" to the class
&lt; 		StringBuffer sb = new StringBuffer("blah blah blah");	
&lt; 		sb.append(origContents);
&lt; 		StringReader sr = new StringReader(sb.toString());
&lt; 		c.setContents(new ReaderInputStream(sr),IResource.FORCE, null);		
&lt; 		sr.close();
&lt; 		
&lt; 		project.build(IncrementalProjectBuilder.INCREMENTAL_BUILD,null);
&lt;         assertTrue("project should have errors",testLog.containsMessage("error at blah blah blah"));
&lt; 		assertTrue("bin directory should contain class file",outputDirContainsFile("C.class"));
&lt;         assertFalse("should not have cleaned the output folder",testLog.containsMessage("Cleared AJDT relationship map for project bug101481"));
&lt; 		int n = testLog.numberOfEntriesForMessage("Builder: Tidied output folder, deleted 1 .class files from");
&lt; 		
&lt; 		binC = binPack.getFile("C.class");
&lt; 		assertTrue("class file should exist",binC.exists());
&lt; 		
&lt;         project.build(IncrementalProjectBuilder.CLEAN_BUILD,null);
&lt;         // testing the same steps are taken during a clean as they
&lt;         // are in the javaBuilder part of bug 101481
&lt;         assertTrue("should have deleted 1 class file from the output dir",testLog.containsMessage("Builder: Tidied output folder, deleted 1 .class files from"));        
&lt;         assertTrue("should have removed problems and tasks for the project",testLog.containsMessage("Removed problems and tasks for project"));        
&lt;         assertEquals("should have cleaned output folder " + (n+1) + "times",n+1,testLog.numberOfEntriesForMessage("Builder: Tidied output folder, deleted 1 .class files from"));
&lt;         assertFalse("bin directory should not contain class file",outputDirContainsFile("C.class"));
&lt;         
&lt;         // testing the refresh output dir after a clean (without doing
&lt;         // a build) part of bug 101481
&lt;         binC = binPack.getFile("C.class");
&lt; 		assertFalse("class file should not exist",binC.exists());
&lt;     }
&lt;     
&lt;     private boolean outputDirContainsFile(String fileName) throws JavaModelException  {
&lt;         IJavaProject javaProject = JavaCore.create(project);
&lt;         IPath workspaceRelativeOutputPath = javaProject.getOutputLocation();
---
&gt; 	}
&gt; 
&gt; 	private boolean outputDirContainsFile(IProject project, String packageName, String fileName)
&gt; 			throws JavaModelException {
&gt; 		IJavaProject javaProject = JavaCore.create(project);
&gt; 		IPath workspaceRelativeOutputPath = javaProject.getOutputLocation();
133c146
&lt;         String realOutputLocation = null;
---
&gt; 		String realOutputLocation = null;
139,140c152,153
&lt; 			IFolder out = ResourcesPlugin.getWorkspace().getRoot()
&lt; 					.getFolder(workspaceRelativeOutputPath);
---
&gt; 			IFolder out = ResourcesPlugin.getWorkspace().getRoot().getFolder(
&gt; 					workspaceRelativeOutputPath);
144c157
&lt; 		File outputDir = new File(realOutputLocation + File.separator + "pack");
---
&gt; 		File outputDir = new File(realOutputLocation + File.separator + packageName);
147,150c160,163
&lt;             if (outputFiles[i].getName().equals(fileName)) {
&lt;                 return true; 
&lt;             }
&lt;         }
---
&gt; 			if (outputFiles[i].getName().equals(fileName)) {
&gt; 				return true;
&gt; 			}
&gt; 		}
152,154c165,262
&lt;     }
&lt;     
&lt;     
---
&gt; 	}
&gt; 
&gt; 	public void testIncrementalBuildWithSrcFolder() throws Exception {
&gt; 		TestLogger testLog = new TestLogger();
&gt; 		AspectJPlugin.getDefault().setAJLogger(testLog);
&gt; 		IProject project = createPredefinedProject("TJP Example");
&gt; 		try {
&gt; 			assertFalse("project should have no errors", testLog
&gt; 					.containsMessage("error"));
&gt; 			
&gt; 			IFolder src = project.getFolder("src");
&gt; 			if (!src.exists()) {
&gt; 				src.create(true, true, null);
&gt; 			}
&gt; 			IFolder pack = src.getFolder("tjp");
&gt; 			if (!pack.exists()) {
&gt; 				pack.create(true, true, null);
&gt; 			}
&gt; 			IFile c = pack.getFile("Demo.java");
&gt; 			assertNotNull("src folder should not be null", src);
&gt; 			assertNotNull("package tjp should not be null", pack);
&gt; 			assertNotNull("class Demo should not be null", c);
&gt; 			assertTrue("java file should exist", c.exists());
&gt; 
&gt; 			IFolder bin = project.getFolder("bin");
&gt; 			if (!bin.exists()) {
&gt; 				bin.create(true, true, null);
&gt; 			}
&gt; 			IFolder binPack = bin.getFolder("tjp");
&gt; 			if (!binPack.exists()) {
&gt; 				binPack.create(true, true, null);
&gt; 			}
&gt; 			IFile binC = binPack.getFile("Demo.class");
&gt; 			assertTrue("class file should exist", binC.exists());
&gt; 						
&gt; 			String rep = testLog.getMostRecentMatchingMessage("AspectJ reports build successful");
&gt; 			System.out.println("rep: "+rep);
&gt; 			
&gt; 			// add a comment to the class
&gt; 			StringReader sr = new StringReader("/* blah blah blah */");
&gt; 			c.appendContents(new ReaderInputStream(sr), IResource.FORCE, null);
&gt; 
&gt; 			waitForAutoBuild();
&gt; 			
&gt; 			assertTrue("Successful build should have occurred", testLog
&gt; 					.containsMessage("AspectJ reports build successful"));
&gt; 			
&gt; 			rep = testLog.getMostRecentMatchingMessage("AspectJ reports build successful");
&gt; 			assertNotNull("Successful build should have been reported",rep);
&gt; 			
&gt; 			assertTrue("The build should have been an incremental one",wasIncrementalBuild(rep));
&gt; 		} finally {
&gt; 			AspectJPlugin.getDefault().setAJLogger(null);
&gt; 			deleteProject(project);
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	public void testIncrementalBuildWithoutSrcFolder() throws Exception {
&gt; 		TestLogger testLog = new TestLogger();
&gt; 		AspectJPlugin.getDefault().setAJLogger(testLog);
&gt; 		IProject project = createPredefinedProject("bug102652");
&gt; 		try {
&gt; 			assertFalse("project should have no errors", testLog
&gt; 					.containsMessage("error"));
&gt; 			
&gt; 			IFolder pack = project.getFolder("tjp");
&gt; 			if (!pack.exists()) {
&gt; 				pack.create(true, true, null);
&gt; 			}
&gt; 			IFile c = pack.getFile("Demo.java");
&gt; 			assertNotNull("package tjp should not be null", pack);
&gt; 			assertNotNull("class Demo should not be null", c);
&gt; 			assertTrue("java file should exist", c.exists());
&gt; 
&gt; 			IFile binC = pack.getFile("Demo.class");
&gt; 			assertTrue("class file should exist", binC.exists());
&gt; 						
&gt; 			// add a comment to the class
&gt; 			StringReader sr = new StringReader("/* blah blah blah */");
&gt; 			c.appendContents(new ReaderInputStream(sr), IResource.FORCE, null);
&gt; 
&gt; 			waitForAutoBuild();
&gt; 			
&gt; 			assertTrue("Successful build should have occurred", testLog
&gt; 					.containsMessage("AspectJ reports build successful"));
&gt; 			
&gt; 			String rep = testLog.getMostRecentMatchingMessage("AspectJ reports build successful");
&gt; 			assertNotNull("Successful build should have been reported",rep);
&gt; 			assertTrue("The build should have been an incremental one",wasIncrementalBuild(rep));
&gt; 		} finally {
&gt; 			AspectJPlugin.getDefault().setAJLogger(null);
&gt; 			deleteProject(project);
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	private boolean wasIncrementalBuild(String msg) {
&gt; 		return msg.toLowerCase().indexOf("was: incremental") != -1;
&gt; 	}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/workspace/bug102652/build.ajproperties" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/workspace/bug102652/tjp/GetInfo.aj" revision="1.1" state="new">/*&#13;
Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.&#13;
&#13;
Use and copying of this software and preparation of derivative works based&#13;
upon this software are permitted.  Any distribution of this software or&#13;
derivative works must comply with all applicable United States export control&#13;
laws.&#13;
&#13;
This software is made available AS IS, and Xerox Corporation makes no warranty&#13;
about the software, its performance or its conformity to any specification.&#13;
*/&#13;
&#13;
package tjp;&#13;
&#13;
import org.aspectj.lang.JoinPoint;&#13;
import org.aspectj.lang.reflect.CodeSignature;&#13;
&#13;
aspect GetInfo {&#13;
&#13;
   static final void println(String s){ System.out.println(s); }&#13;
&#13;
   pointcut goCut(): cflow(this(Demo) &amp;&amp; execution(void go()));&#13;
&#13;
   pointcut demoExecs(): within(Demo) &amp;&amp; execution(* *(..));&#13;
&#13;
   Object around(): demoExecs() &amp;&amp; !execution(* go()) &amp;&amp; goCut() {&#13;
      println("Intercepted message: " +&#13;
          thisJoinPointStaticPart.getSignature().getName());&#13;
      println("in class: " +&#13;
          thisJoinPointStaticPart.getSignature().getDeclaringType().getName());&#13;
      printParameters(thisJoinPoint);&#13;
      println("Running original method: \n" );&#13;
      Object result = proceed();&#13;
      println("  result: " + result );&#13;
      return result;&#13;
   }&#13;
&#13;
   static private void printParameters(JoinPoint jp) {&#13;
      println("Arguments: " );&#13;
      Object[] args = jp.getArgs();&#13;
      String[] names = ((CodeSignature)jp.getSignature()).getParameterNames();&#13;
      Class[] types = ((CodeSignature)jp.getSignature()).getParameterTypes();&#13;
      for (int i = 0; i &lt; args.length; i++) {&#13;
         println("  "  + i + ". " + names[i] +&#13;
             " : " +            types[i].getName() +&#13;
             " = " +            args[i]);&#13;
      }&#13;
   }&#13;
}&#13;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug102652/tjp/GetInfo.aj" revision="1.1" state="new">/*&#13;
Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.&#13;
&#13;
Use and copying of this software and preparation of derivative works based&#13;
upon this software are permitted.  Any distribution of this software or&#13;
derivative works must comply with all applicable United States export control&#13;
laws.&#13;
&#13;
This software is made available AS IS, and Xerox Corporation makes no warranty&#13;
about the software, its performance or its conformity to any specification.&#13;
*/&#13;
&#13;
package tjp;&#13;
&#13;
import org.aspectj.lang.JoinPoint;&#13;
import org.aspectj.lang.reflect.CodeSignature;&#13;
&#13;
aspect GetInfo {&#13;
&#13;
   static final void println(String s){ System.out.println(s); }&#13;
&#13;
   pointcut goCut(): cflow(this(Demo) &amp;&amp; execution(void go()));&#13;
&#13;
   pointcut demoExecs(): within(Demo) &amp;&amp; execution(* *(..));&#13;
&#13;
   Object around(): demoExecs() &amp;&amp; !execution(* go()) &amp;&amp; goCut() {&#13;
      println("Intercepted message: " +&#13;
          thisJoinPointStaticPart.getSignature().getName());&#13;
      println("in class: " +&#13;
          thisJoinPointStaticPart.getSignature().getDeclaringType().getName());&#13;
      printParameters(thisJoinPoint);&#13;
      println("Running original method: \n" );&#13;
      Object result = proceed();&#13;
      println("  result: " + result );&#13;
      return result;&#13;
   }&#13;
&#13;
   static private void printParameters(JoinPoint jp) {&#13;
      println("Arguments: " );&#13;
      Object[] args = jp.getArgs();&#13;
      String[] names = ((CodeSignature)jp.getSignature()).getParameterNames();&#13;
      Class[] types = ((CodeSignature)jp.getSignature()).getParameterTypes();&#13;
      for (int i = 0; i &lt; args.length; i++) {&#13;
         println("  "  + i + ". " + names[i] +&#13;
             " : " +            types[i].getName() +&#13;
             " = " +            args[i]);&#13;
      }&#13;
   }&#13;
}&#13;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug102652/tjp/Demo.java" revision="1.1" state="new">/*

Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.

Use and copying of this software and preparation of derivative works based
upon this software are permitted.  Any distribution of this software or
derivative works must comply with all applicable United States export control
laws.

This software is made available AS IS, and Xerox Corporation makes no warranty
about the software, its performance or its conformity to any specification.

*/
package tjp;

public class Demo {
    static Demo d;

    public static void main(String[] args){
        new Demo().go();
    }

    void go(){
        d = new Demo();
        d.foo(1,d);
        System.out.println(d.bar(new Integer(3)));
    }

    void foo(int i, Object o){
        System.out.println("Demo.foo(" + i + ", " + o + ")\n");
    }

    String bar (Integer j){
        System.out.println("Demo.bar(" + j + ")\n");
        return "Demo.bar(" + j  + ")";
    }
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/ui/tests/testutils/TestLogger.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others. All rights reserved. This
 * program and the accompanying materials are made available under the terms of
 * the Common Public License v1.0 which accompanies this distribution, and is
 * available at http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors: IBM Corporation - initial API and implementation 
 * 				 Helen Hawkins   - iniital version
 ******************************************************************************/
package org.eclipse.ajdt.ui.tests.testutils;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.eclipse.ajdt.core.IAJLogger;

/**
 * Logger to help with builder tests
 */
public class TestLogger implements IAJLogger {

    List log;
    
    /* (non-Javadoc)
     * @see org.eclipse.ajdt.core.IAJLogger#log(java.lang.String)
     */
    public void log(String msg) {
        if (log == null) {
            log = new ArrayList();
        }
        log.add(msg);
    }

    public boolean containsMessage(String msg) {
        for (Iterator iter = log.iterator(); iter.hasNext();) {
            String logEntry = (String) iter.next();
            if (logEntry.indexOf(msg) != -1) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Return the first line in the log that contains the given string
     * @param msg
     * @return
     */
    public String getMostRecentMatchingMessage(String msg) {
    	for (int i = log.size()-1; i &gt;= 0; i--) {
           String logEntry = (String)log.get(i);
            if (logEntry.indexOf(msg) != -1) {
                return logEntry;
            }
        }
        return null;
    }
    
    public int numberOfEntriesForMessage(String msg) {
        int occurances = 0;
        for (Iterator iter = log.iterator(); iter.hasNext();) {
            String logEntry = (String) iter.next();
            StringBuffer sb = new StringBuffer(logEntry);
            if (sb.indexOf(msg) != -1) {
                occurances++;
            }
        }
        return occurances;
    }
    
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/workspace/bug102652/.classpath" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/workspace/bug102652/tjp/Demo.java" revision="1.1" state="new">/*

Copyright (c) Xerox Corporation 1998-2002.  All rights reserved.

Use and copying of this software and preparation of derivative works based
upon this software are permitted.  Any distribution of this software or
derivative works must comply with all applicable United States export control
laws.

This software is made available AS IS, and Xerox Corporation makes no warranty
about the software, its performance or its conformity to any specification.

*/
package tjp;

public class Demo {
    static Demo d;

    public static void main(String[] args){
        new Demo().go();
    }

    void go(){
        d = new Demo();
        d.foo(1,d);
        System.out.println(d.bar(new Integer(3)));
    }

    void foo(int i, Object o){
        System.out.println("Demo.foo(" + i + ", " + o + ")\n");
    }

    String bar (Integer j){
        System.out.println("Demo.bar(" + j + ")\n");
        return "Demo.bar(" + j  + ")";
    }
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug102652/build.ajproperties" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug102652/.project" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/workspace/bug102652/.classpath" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/workspace/bug102652/.project" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="102721" transactionid="75099">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="15"/>
<property name="lines-added" value="5"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="39"/>
<property name="lines-churned" value="44"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-if K-import K-new K-null K-return M O-&lt; O-== O-&gt; O-! O-!= O-() O-++ O-cast T V Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>In Eclispe 3.1 the mechanism for handling key sequences has changed. Therefore,
once we branch the code, need to update the corresponding code in
XReferenceInplaceDialog.</bugreport>
<pre-fix-testcases failing="178" file="output/102721/pre-fix/testresults.xml" passing="1583" size="1761"/>
<post-fix-testcases failing="177" file="output/102721/post-fix/testresults.xml" passing="1584" size="1761"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/internal/ui/inplace/XReferenceInplaceDialog.java" revision="1.19" state="changed">10c10,11
&lt;  *     Helen Hawkins   - iniital version
---
&gt;  *     Helen Hawkins   - initial version
&gt;  *     Sian January    - removed deprecated API use in 1.3
27a29
&gt; import org.eclipse.core.commands.Command;
38a41,44
&gt; import org.eclipse.jface.bindings.TriggerSequence;
&gt; import org.eclipse.jface.bindings.keys.KeySequence;
&gt; import org.eclipse.jface.bindings.keys.SWTKeySupport;
&gt; import org.eclipse.jface.commands.ActionHandler;
101,109c107,111
&lt; import org.eclipse.ui.commands.ActionHandler;
&lt; import org.eclipse.ui.commands.HandlerSubmission;
&lt; import org.eclipse.ui.commands.ICommand;
&lt; import org.eclipse.ui.commands.ICommandManager;
&lt; import org.eclipse.ui.commands.IKeySequenceBinding;
&lt; import org.eclipse.ui.commands.Priority;
&lt; import org.eclipse.ui.contexts.IWorkbenchContextSupport;
&lt; import org.eclipse.ui.keys.KeySequence;
&lt; import org.eclipse.ui.keys.SWTKeySupport;
---
&gt; import org.eclipse.ui.commands.ICommandService;
&gt; import org.eclipse.ui.contexts.IContextService;
&gt; import org.eclipse.ui.handlers.IHandlerActivation;
&gt; import org.eclipse.ui.handlers.IHandlerService;
&gt; import org.eclipse.ui.keys.IBindingService;
172c174
&lt; 	private ICommand invokingCommand;
---
&gt; 	private Command invokingCommand;
174c176
&lt; 	private KeySequence[] invokingCommandKeySequences;
---
&gt; 	private TriggerSequence[] invokingCommandTriggerSequences;
193,195c195
&lt; 	private HandlerSubmission fShowViewMenuHandlerSubmission;
&lt; 	private KeySequence[] fInvokingCommandKeySequences;
&lt; 	private ICommand fInvokingCommand;
---
&gt; 	private IHandlerActivation handlerActivation;
224,225c224,225
&lt; 			ICommandManager commandManager= PlatformUI.getWorkbench().getCommandSupport().getCommandManager();
&lt; 			invokingCommand = commandManager.getCommand(invokingCommandId);
---
&gt; 			ICommandService commandService = (ICommandService)PlatformUI.getWorkbench().getAdapter(ICommandService.class);
&gt; 			invokingCommand = commandService.getCommand(invokingCommandId);
524c524
&lt; 		fKeyBindingService.setScopes(new String[] {IWorkbenchContextSupport.CONTEXT_ID_WINDOW});
---
&gt; 		fKeyBindingService.setScopes(new String[] {IContextService.CONTEXT_ID_WINDOW});
538,540c538,540
&lt; 		// Register action with command support
&lt; 		fShowViewMenuHandlerSubmission= new HandlerSubmission(null, dialogShell, null, fShowViewMenuAction.getActionDefinitionId(), new ActionHandler(fShowViewMenuAction), Priority.MEDIUM);
&lt; 		PlatformUI.getWorkbench().getCommandSupport().addHandlerSubmission(fShowViewMenuHandlerSubmission);
---
&gt; 		// Register action with handler service
&gt; 		IHandlerService handlerService = (IHandlerService)PlatformUI.getWorkbench().getAdapter(IHandlerService.class);
&gt; 		handlerActivation = handlerService.activateHandler(fShowViewMenuAction.getActionDefinitionId(), new ActionHandler(fShowViewMenuAction));
606c606
&lt; 		KeySequence[] sequences = getInvokingCommandKeySequences();
---
&gt; 		TriggerSequence[] sequences = getInvokingCommandKeySequences();
617,628c617,621
&lt; 	private KeySequence[] getInvokingCommandKeySequences() {
&lt; 		if (invokingCommandKeySequences == null) {
&lt; 			if (invokingCommand != null) {
&lt; 				List list = invokingCommand.getKeySequenceBindings();
&lt; 				if (!list.isEmpty()) {
&lt; 					invokingCommandKeySequences= new KeySequence[list.size()];
&lt; 					for (int i= 0; i &lt; invokingCommandKeySequences.length; i++) {
&lt; 						invokingCommandKeySequences[i]= ((IKeySequenceBinding) list.get(i)).getKeySequence();
&lt; 					}
&lt; 					return invokingCommandKeySequences;
&lt; 				}		
&lt; 			}
---
&gt; 	private TriggerSequence[] getInvokingCommandKeySequences() {
&gt; 		IBindingService bindingService = (IBindingService)PlatformUI.getWorkbench().getAdapter(IBindingService.class);
&gt; 		TriggerSequence[] bindings = bindingService.getActiveBindingsFor(invokingCommandId);
&gt; 		if(bindings.length &gt; 0) {
&gt; 			invokingCommandTriggerSequences = bindings;
630c623
&lt; 		return invokingCommandKeySequences;
---
&gt; 		return invokingCommandTriggerSequences;		
639c632
&lt; 					KeySequence[] sequences= getInvokingCommandKeySequences();
---
&gt; 					TriggerSequence[] sequences= getInvokingCommandKeySequences();
1156,1158c1149,1151
&lt; 		// Remove handler submission
&lt; 		PlatformUI.getWorkbench().getCommandSupport().removeHandlerSubmission(fShowViewMenuHandlerSubmission);
&lt; 
---
&gt; 		IHandlerService handlerService = (IHandlerService)PlatformUI.getWorkbench().getAdapter(IHandlerService.class);
&gt; 		handlerService.deactivateHandler(handlerActivation);
&gt; 		
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/META-INF/MANIFEST.MF" revision="1.6" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/ui/tests/visual/XReferenceInplaceDialogTest.java" revision="1.17" state="changed">8c8
&lt;  * 				 Helen Hawkins   - iniital version
---
&gt;  * 				 Helen Hawkins   - initial version
114d113
&lt; 
124c123
&lt; 
---
&gt; 		
133c132
&lt; 				assertTrue("The number of checked Filtes should equal the number of items in the list", xrefAction.getPopulatingList().size() == provider.getCheckedInplaceFilters().size()); //$NON-NLS-1$
---
&gt; 				assertEquals("The number of checked Filtes should equal the number of items in the list", xrefAction.getPopulatingList().size(), provider.getCheckedInplaceFilters().size()); //$NON-NLS-1$
184c183
&lt; 				assertTrue("provider.getCheckedFilters() should be of size() == 0", provider.getCheckedInplaceFilters().size() == 0); //$NON-NLS-1$
---
&gt; 				assertEquals("provider.getCheckedFilters() should be of size() == 0", provider.getCheckedInplaceFilters().size(), 0); //$NON-NLS-1$
209c208
&lt; 				assertTrue("provider.getCheckedFilters() should be of size() == 3", provider.getCheckedInplaceFilters().size() == 3); //$NON-NLS-1$
---
&gt; 				assertEquals("provider.getCheckedFilters() should be of size() == 3", 3,  provider.getCheckedInplaceFilters().size()); //$NON-NLS-1$
234c233
&lt; 				assertTrue("provider.getCheckedFilters() should be of size() == 0", provider.getCheckedInplaceFilters().size() == 0); //$NON-NLS-1$
---
&gt; 				assertEquals("provider.getCheckedFilters() should be of size() == 0", provider.getCheckedInplaceFilters().size(), 0); //$NON-NLS-1$
265c264
&lt; 				assertTrue("provider.getCheckedFilters() should be of size() == 0", provider.getCheckedInplaceFilters().size() == 0); //$NON-NLS-1$
---
&gt; 				assertEquals("provider.getCheckedFilters() should be of size() == 0", provider.getCheckedInplaceFilters().size(), 0); //$NON-NLS-1$
</file>
</fixedFiles>
</bug>
<bug id="102865" transactionid="72005">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-instanceof O-instanceof T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>If you bring up the inplace xref view and then type some text in such that
there's nothing in the view (nothing matches the text), press TAB and then
RETURN, you get the following NPE:

java.lang.NullPointerException
	at
org.eclipse.contribution.xref.internal.ui.actions.DoubleClickAction.run(DoubleClickAction.java:44)
	at
org.eclipse.contribution.xref.internal.ui.inplace.XReferenceInplaceDialog$6.doubleClick(XReferenceInplaceDialog.java:392)
	at org.eclipse.jface.viewers.StructuredViewer$1.run(StructuredViewer.java:720)
	at
org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)
	at org.eclipse.core.runtime.Platform.run(Platform.java:783)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:44)
........

What should happen is nothing (the view shouldn't disappear or anything).</bugreport>
<pre-fix-testcases failing="177" file="output/102865/pre-fix/testresults.xml" passing="1544" size="1721"/>
<post-fix-testcases failing="177" file="output/102865/post-fix/testresults.xml" passing="1544" size="1721"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/internal/ui/actions/DoubleClickAction.java" revision="1.6" state="changed">44,53c44,55
&lt; 			Object data = ((TreeObject) sel).getData();
&lt; 			if (data != null) {
&lt; 			    if (data instanceof IXReferenceNode) {
&lt; 			        XRefUIUtils.revealInEditor(((IXReferenceNode)data).getJavaElement());  
&lt; 			    } else if (data instanceof IJavaElement) {
&lt; 			    	XRefUIUtils.revealInEditor((IJavaElement) data);
&lt; 				} else if (data instanceof IDeferredXReference) {
&lt; 					XRefUIUtils.evaluateXReferences((IDeferredXReference) data, viewer, shell);
&lt; 				} else if (data instanceof IResource) {
&lt; 					XRefUIUtils.revealInEditor((IResource) data);
---
&gt; 			if (sel instanceof TreeObject) {
&gt; 				Object data = ((TreeObject) sel).getData();
&gt; 				if (data != null) {
&gt; 				    if (data instanceof IXReferenceNode) {
&gt; 				        XRefUIUtils.revealInEditor(((IXReferenceNode)data).getJavaElement());  
&gt; 				    } else if (data instanceof IJavaElement) {
&gt; 				    	XRefUIUtils.revealInEditor((IJavaElement) data);
&gt; 					} else if (data instanceof IDeferredXReference) {
&gt; 						XRefUIUtils.evaluateXReferences((IDeferredXReference) data, viewer, shell);
&gt; 					} else if (data instanceof IResource) {
&gt; 						XRefUIUtils.revealInEditor((IResource) data);
&gt; 					}
55a58
&gt; 			
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/xref/xref inplace view tests.txt" revision="1.5" state="changed"/>
</fixedFiles>
</bug>
<bug id="103001" transactionid="72004">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="252"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="252"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-if K-import K-new K-null K-package K-return K-super K-this M O-! O-!= O-?: O-() O-&amp;&amp; T V Y Z-cond Z-if</fullfingerprint>
<bugreport>The forward and back navigation buttons are redundent in the xref view -
therefore, we need to remove them.</bugreport>
<pre-fix-testcases failing="178" file="output/103001/pre-fix/testresults.xml" passing="1543" size="1721"/>
<post-fix-testcases failing="178" file="output/103001/post-fix/testresults.xml" passing="1543" size="1721"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/internal/ui/actions/NavigationHistoryActionGroup.java" revision="1.3" state="deleted"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/xref/xref view tests.txt" revision="1.7" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/ui/XReferenceUIPluginResources.properties" revision="1.2" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/internal/ui/actions/NavigationHistoryManager.java" revision="1.2" state="deleted"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/TestSheet.doc" revision="1.23" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/ui/views/XReferenceView.java" revision="1.27" state="changed">20d19
&lt; import org.eclipse.contribution.xref.internal.ui.actions.NavigationHistoryActionGroup;
75d73
&lt; 	private NavigationHistoryActionGroup navigationHistoryGroup;
104d101
&lt; 		navigationHistoryGroup = new NavigationHistoryActionGroup(viewer);
293,296d289
&lt; 
&lt; 	public NavigationHistoryActionGroup getNavigationHistoryActionGroup() {
&lt; 		return navigationHistoryGroup;
&lt; 	}
342d334
&lt; 		navigationHistoryGroup.addNavigationActions(manager);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui.tests/src/org/eclipse/contribution/xref/ui/tests/views/NavigationHistoryManagerTest.java" revision="1.2" state="deleted"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui.tests/src/org/eclipse/contribution/xref/ui/tests/AllTests.java" revision="1.2" state="changed">14,16d13
&lt; import org.eclipse.contribution.xref.ui.tests.views.NavigationHistoryManagerTest;
&lt; import org.eclipse.contribution.xref.ui.tests.views.XReferenceViewTest;
&lt; 
19a17,18
&gt; import org.eclipse.contribution.xref.ui.tests.views.XReferenceViewTest;
&gt; 
31d29
&lt; 		suite.addTestSuite(NavigationHistoryManagerTest.class);
</file>
</fixedFiles>
</bug>
<bug id="103741" transactionid="71208">
<property name="files-churned" value="10"/>
<property name="java-files-churned" value="9"/>
<property name="classes-churned" value="9"/>
<property name="methods-churned" value="9"/>
<property name="hunks" value="18"/>
<property name="lines-added" value="66"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="66"/>
<property name="priority" value="P2"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-null K-return K-this K-true M O-== O-! O-?: T V Y Z-cond Z-if</fullfingerprint>
<bugreport>I had a project that I was compiling using Java 5 source support. I turned off 
java 5 support but accidentally left in an @annotation pointcut in it. When 
recompiling, I get an error dialog BCException thrown: Bad type signature: 
&lt;missing&gt;

When I restart I get this in my error log, and if I compile the same message.

java.lang.ClassCastException: org.eclipse.core.internal.resources.Project
at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.&lt;init&gt;
(AJCompilationUnit.java:118)
at org.eclipse.ajdt.core.AspectJCore.create(AspectJCore.java:137)
at org.eclipse.ajdt.core.AspectJCore.create(AspectJCore.java:38)
at org.eclipse.ajdt.core.model.AJProjectModel$Persistence.loadJavaElements
(AJProjectModel.java:633)
at org.eclipse.ajdt.core.model.AJProjectModel$Persistence.loadModel
(AJProjectModel.java:568)
at org.eclipse.ajdt.core.model.AJProjectModel.loadModel
(AJProjectModel.java:136)
at org.eclipse.ajdt.core.model.AJModel.getModelForProject(AJModel.java:83)
at org.eclipse.ajdt.core.model.AJModel.isAdvised(AJModel.java:126)
at org.eclipse.ajdt.internal.buildconfig.ImageDecorator.decorateImage
(ImageDecorator.java:207)
at org.eclipse.ui.internal.decorators.FullDecoratorDefinition.decorateImage
(FullDecoratorDefinition.java:111)
at org.eclipse.ui.internal.decorators.FullImageDecoratorRunnable.run
(FullImageDecoratorRunnable.java:28)
at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:1044)
at org.eclipse.core.runtime.Platform.run(Platform.java:783)
at org.eclipse.ui.internal.decorators.DecoratorManager.safeDecorateImage
(DecoratorManager.java:395)
at org.eclipse.ui.internal.decorators.DecoratorManager.decorateImage
(DecoratorManager.java:360)
at org.eclipse.jface.viewers.DecoratingLabelProvider.getImage
(DecoratingLabelProvider.java:84)
at org.eclipse.jface.viewers.DecoratingLabelProvider.updateLabel
(DecoratingLabelProvider.java:212)
at org.eclipse.jface.viewers.StructuredViewer.buildLabel
(StructuredViewer.java:1855)
at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:228)
at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run
(AbstractTreeViewer.java:85)
at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:1044)
at org.eclipse.core.runtime.Platform.run(Platform.java:783)
at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:44)
at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:148)
at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem
(AbstractTreeViewer.java:621)
at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run
(StructuredViewer.java:434)
at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:1044)
at org.eclipse.core.runtime.Platform.run(Platform.java:783)
at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:44)
at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:148)</bugreport>
<testsforfix ID="103741" type="changed">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/AnnotationPatternTestCase.java">
      <test NAME="testParseAndAnnotationPattern"/>
      <test NAME="testParseNotAnnotationPattern"/>
      <test NAME="testParseComboPattern"/>
      <test NAME="testMaybeParseAnnotationPattern"/>
      <test NAME="testAndAnnotationPatternMatching"/>
      <test NAME="testOrAnnotationPatternMatching"/>
      <test NAME="testNotAnnotationPatternMatching"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="177" file="output/103741/pre-fix/testresults.xml" passing="1592" size="1769"/>
<post-fix-testcases failing="177" file="output/103741/post-fix/testresults.xml" passing="1592" size="1769"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java" revision="1.10" state="changed">19a20
&gt; import org.aspectj.bridge.MessageUtil;
25a27
&gt; import org.aspectj.weaver.WeaverMessages;
108a111,120
&gt; 		if (!scope.getWorld().isInJava5Mode()) {
&gt; 			String msg = null;
&gt; 			if (kind == AT_TYPE) { msg = WeaverMessages.DECLARE_ATTYPE_ONLY_SUPPORTED_AT_JAVA5_LEVEL; }
&gt; 			else if (kind == AT_METHOD) { msg = WeaverMessages.DECLARE_ATMETHOD_ONLY_SUPPORTED_AT_JAVA5_LEVEL;}
&gt; 			else if (kind == AT_FIELD) { msg = WeaverMessages.DECLARE_ATFIELD_ONLY_SUPPORTED_AT_JAVA5_LEVEL;}
&gt; 			else if (kind == AT_CONSTRUCTOR) { msg = WeaverMessages.DECLARE_ATCONS_ONLY_SUPPORTED_AT_JAVA5_LEVEL;}
&gt; 			scope.message(MessageUtil.error(WeaverMessages.format(msg),
&gt; 					getSourceLocation()));
&gt; 			return;
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java" revision="1.18" state="changed">22a23
&gt; import org.aspectj.bridge.MessageUtil;
88a90,94
&gt; 		if (!scope.getWorld().isInJava5Mode()) {
&gt; 			scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.ATARGS_ONLY_SUPPORTED_AT_JAVA5_LEVEL),
&gt; 					getSourceLocation()));
&gt; 			return;
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java" revision="1.18" state="changed">20a21
&gt; import org.aspectj.bridge.MessageUtil;
33a35
&gt; import org.aspectj.weaver.WeaverMessages;
114a117,121
&gt; 		if (!scope.getWorld().isInJava5Mode()) {
&gt; 			scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.ATWITHINCODE_ONLY_SUPPORTED_AT_JAVA5_LEVEL),
&gt; 					getSourceLocation()));
&gt; 			return;
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java" revision="1.16" state="changed">22a23
&gt; import org.aspectj.bridge.MessageUtil;
103a105,109
&gt; 		if (!scope.getWorld().isInJava5Mode()) {
&gt; 			scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.ATWITHIN_ONLY_SUPPORTED_AT_JAVA5_LEVEL),
&gt; 					getSourceLocation()));
&gt; 			return;
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeaverMessages.java" revision="1.34" state="changed">144a145,157
&gt; 	// &lt; Java5 messages
&gt; 	public static final String ATANNOTATION_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "atannotationNeedsJava5";
&gt; 	public static final String ATWITHIN_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "atwithinNeedsJava5";
&gt; 	public static final String ATWITHINCODE_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "atwithincodeNeedsJava5";
&gt; 	public static final String ATTHIS_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "atthisNeedsJava5";
&gt; 	public static final String ATTARGET_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "attargetNeedsJava5";
&gt; 	public static final String ATARGS_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "atargsNeedsJava5";
&gt; 	public static final String DECLARE_ATTYPE_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "declareAtTypeNeedsJava5";
&gt; 	public static final String DECLARE_ATMETHOD_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "declareAtMethodNeedsJava5";
&gt; 	public static final String DECLARE_ATFIELD_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "declareAtFieldNeedsJava5";
&gt; 	public static final String DECLARE_ATCONS_ONLY_SUPPORTED_AT_JAVA5_LEVEL = "declareAtConsNeedsJava5";
&gt; 	public static final String ANNOTATIONS_NEED_JAVA5 = "annotationsRequireJava5";
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.17" state="changed">37a38
&gt; import org.aspectj.util.LangUtil;
146a148,150
&gt; 		if (LangUtil.is15VMOrGreater()) {
&gt; 			bcelWorld.setBehaveInJava5Way(true);
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java" revision="1.22" state="changed">120a121,126
&gt; 		if (!scope.getWorld().isInJava5Mode()) {
&gt; 			scope.message(MessageUtil.error(WeaverMessages.format(
&gt; 					isThis ? WeaverMessages.ATTHIS_ONLY_SUPPORTED_AT_JAVA5_LEVEL : WeaverMessages.ATTARGET_ONLY_SUPPORTED_AT_JAVA5_LEVEL),
&gt; 					getSourceLocation()));
&gt; 			return;
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/weaver-messages.properties" revision="1.37" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java" revision="1.19" state="changed">21a22
&gt; import org.aspectj.bridge.MessageUtil;
36a38
&gt; import org.aspectj.weaver.WeaverMessages;
163a166,170
&gt; 		if (!scope.getWorld().isInJava5Mode()) {
&gt; 			scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.ATANNOTATION_ONLY_SUPPORTED_AT_JAVA5_LEVEL),
&gt; 					getSourceLocation()));
&gt; 			return;
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java" revision="1.15" state="changed">83c83,88
&lt; 		if (resolved) return this;
---
&gt; 	if (!scope.getWorld().isInJava5Mode()) {
&gt; 		scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.ANNOTATIONS_NEED_JAVA5),
&gt; 				getSourceLocation()));
&gt; 		return this;
&gt; 	}
&gt; 	if (resolved) return this;
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/AnnotationPatternTestCase.java" revision="1.14" state="changed">326a327
&gt; 		bWorld.setBehaveInJava5Way(true);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/AnnotationPatternMatchingTestCase.java" revision="1.11" state="changed">67a68
&gt; 		  world.setBehaveInJava5Way(true);
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/ParserTestCase.java" revision="1.19" state="changed">679a680
&gt; 		world.setBehaveInJava5Way(true);
</file>
</fixedFiles>
</bug>
<bug id="104218" transactionid="71575">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="17"/>
<property name="lines-churned" value="18"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-null M O-! T V Y Z-if</fullfingerprint>
<bugreport>If I weave a class with Aspect1 using -Xreweavable then load-time weave it 
with Aspect2 (using org.aspectj.weaver.loadtime.Aj) then Aspect1 is not 
rewoven. This is confirmed by the lack of weaveinfo messages for Aspect1. This 
works for post-compile weaving although there are no explicit tests. Attached 
is a reweavable test for binary weaving. It needs to be adapted to run under 
org.aspectj.systemtest.ajc150.ataspectj.</bugreport>
<testsforfix ID="104218" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
      <test NAME="testLTWDecp"/>
      <test NAME="testCompileTimeAspectsDeclaredToLTWWeaver"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.java">
      <test NAME="test1"/>
      <test NAME="test2"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml">
      <test NAME="Compile time aspects declared to ltw weaver"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="177" file="output/104218/pre-fix/testresults.xml" passing="1584" size="1761"/>
<post-fix-testcases failing="177" file="output/104218/post-fix/testresults.xml" passing="1584" size="1761"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/WeaverMessages.java" revision="1.32" state="changed">74,75c74,76
&lt; 	
&lt; 	public static final String CANT_FIND_TYPE = "cantFindType";
---
&gt;     public static final String REWEAVABLE_ASPECT_NOT_REGISTERED = "reweavableAspectNotRegistered";
&gt; 
&gt;     public static final String CANT_FIND_TYPE = "cantFindType";
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.58" state="changed">941,942c941,942
&lt;                         AnnotationGen ag = new AnnotationGen(a,weaver.getLazyClassGen().getConstantPoolGen(),true);
&lt;                         mg.addAnnotation(new AnnotationX(ag.getAnnotation(),weaver.getWorld()));
---
&gt;                         AnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPoolGen(), true);
&gt;                         mg.addAnnotation(new AnnotationX(ag.getAnnotation(), weaver.getWorld()));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java" revision="1.69" state="changed">1182,1183c1182,1197
&lt; 							if (!world.getMessageHandler().isIgnoring(IMessage.INFO))
&lt; 							  world.showMessage(IMessage.INFO,
---
&gt;                             // weaved in aspect that are not declared in aop.xml trigger an error for now
&gt;                             // may cause headhache for LTW and packaged lib without aop.xml in
&gt;                             // see #104218
&gt;                             if(!xcutSet.containsAspect(rtx)){
&gt;                                 world.showMessage(
&gt;                                         IMessage.ERROR,
&gt;                                         WeaverMessages.format(
&gt;                                                 WeaverMessages.REWEAVABLE_ASPECT_NOT_REGISTERED,
&gt;                                                 requiredTypeName,
&gt;                                                 className
&gt;                                         ),
&gt;                                         null,
&gt;                                         null
&gt;                                 );
&gt;                             } else if (!world.getMessageHandler().isIgnoring(IMessage.INFO))
&gt; 							    world.showMessage(IMessage.INFO,
1186c1200
&lt; 							alreadyConfirmedReweavableState.add(requiredTypeName);
---
&gt; 							    alreadyConfirmedReweavableState.add(requiredTypeName);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/weaver-messages.properties" revision="1.35" state="changed"/>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java" revision="1.15" state="changed">85,88c85,87
&lt;     // FIXME asc need to comment this out for now - I need a build through...
&lt; //    public void testLTWDecp() {
&lt; //        runTest("LTW Decp");
&lt; //    }
---
&gt;     public void testLTWDecp() {
&gt;         runTest("LTW Decp");
&gt;     }
92a92,96
&gt; 
&gt;     public void testCompileTimeAspectsDeclaredToLTWWeaver() {
&gt;         runTest("Compile time aspects declared to ltw weaver");
&gt;     }
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml" revision="1.11" state="changed">10,11c10,11
&lt;             files="ataspectj/PerClauseTest.java,ataspectj/PerClauseTestAspects.java,ataspectj/TestHelper.java"
&lt;             options="-1.5 -XnoWeave"/&gt;
---
&gt;                 files="ataspectj/PerClauseTest.java,ataspectj/PerClauseTestAspects.java,ataspectj/TestHelper.java"
&gt;                 options="-1.5 -XnoWeave"/&gt;
17,18c17,18
&lt;             files="ataspectj/PerClauseTest.java,ataspectj/PerClauseTestAspects.java,ataspectj/TestHelper.java"
&lt;             options="-1.5"/&gt;
---
&gt;                 files="ataspectj/PerClauseTest.java,ataspectj/PerClauseTestAspects.java,ataspectj/TestHelper.java"
&gt;                 options="-1.5"/&gt;
24,25c24,25
&lt;             files="ataspectj/PerClauseTest.java,ataspectj/TestHelper.java,ataspectj/PerClauseTestAspects.java"
&lt;             options="-1.5 -XnoWeave"/&gt;
---
&gt;                 files="ataspectj/PerClauseTest.java,ataspectj/TestHelper.java,ataspectj/PerClauseTestAspects.java"
&gt;                 options="-1.5 -XnoWeave"/&gt;
27,28c27,28
&lt;         aspectOf methods will be pushed in, ignore warning for adviceDidNotMatch but still do the logic for them
&lt;         since such just added methods are an interesting case (percflow ajc$perCflowStack advice)
---
&gt;             aspectOf methods will be pushed in, ignore warning for adviceDidNotMatch but still do the logic for them
&gt;             since such just added methods are an interesting case (percflow ajc$perCflowStack advice)
31,33c31,33
&lt;             files="ataspectj/PerClauseTestAspects.java"
&lt;             options="-1.5 -Xdev:NoAtAspectJProcessing"&gt;
&lt;                 &lt;message kind="warning"/&gt;
---
&gt;                 files="ataspectj/PerClauseTestAspects.java"
&gt;                 options="-1.5 -Xdev:NoAtAspectJProcessing"&gt;
&gt;             &lt;message kind="warning"/&gt;
40,41c40,41
&lt;             files="ataspectj/AroundInlineMungerTest.java,ataspectj/AroundInlineMungerTestAspects.java,ataspectj/TestHelper.java"
&lt;             options="-1.5 -XnoWeave"/&gt;
---
&gt;                 files="ataspectj/AroundInlineMungerTest.java,ataspectj/AroundInlineMungerTestAspects.java,ataspectj/TestHelper.java"
&gt;                 options="-1.5 -XnoWeave"/&gt;
47,48c47,48
&lt;             files="ataspectj/AroundInlineMungerTest.java,ataspectj/AroundInlineMungerTestAspects.java,ataspectj/TestHelper.java"
&lt;             options="-1.5"/&gt;
---
&gt;                 files="ataspectj/AroundInlineMungerTest.java,ataspectj/AroundInlineMungerTestAspects.java,ataspectj/TestHelper.java"
&gt;                 options="-1.5"/&gt;
54,55c54,55
&lt;             files="ataspectj/AroundInlineMungerTestAspects.java"
&lt;             options="-1.5 -Xlint:ignore"/&gt;
---
&gt;                 files="ataspectj/AroundInlineMungerTestAspects.java"
&gt;                 options="-1.5 -Xlint:ignore"/&gt;
57,58c57,58
&lt;             files="ataspectj/AroundInlineMungerTest.java,ataspectj/TestHelper.java"
&lt;             options="-1.5"/&gt;
---
&gt;                 files="ataspectj/AroundInlineMungerTest.java,ataspectj/TestHelper.java"
&gt;                 options="-1.5"/&gt;
64,65c64,65
&lt;             files="ataspectj/AroundInlineMungerTestAspects.java"
&lt;             options="-1.5 -Xlint:ignore -XnoInline"/&gt;
---
&gt;                 files="ataspectj/AroundInlineMungerTestAspects.java"
&gt;                 options="-1.5 -Xlint:ignore -XnoInline"/&gt;
67,68c67,68
&lt;             files="ataspectj/AroundInlineMungerTest.java,ataspectj/TestHelper.java"
&lt;             options="-1.5 -XnoInline"/&gt;
---
&gt;                 files="ataspectj/AroundInlineMungerTest.java,ataspectj/TestHelper.java"
&gt;                 options="-1.5 -XnoInline"/&gt;
74,75c74,75
&lt;             files="ataspectj/AroundInlineMungerTestAspects2.aj"
&lt;             options="-1.5 -Xlint:ignore"/&gt;
---
&gt;                 files="ataspectj/AroundInlineMungerTestAspects2.aj"
&gt;                 options="-1.5 -Xlint:ignore"/&gt;
77,78c77,78
&lt;             files="ataspectj/AroundInlineMungerTest2.aj,ataspectj/TestHelper.java"
&lt;             options="-1.5"/&gt;
---
&gt;                 files="ataspectj/AroundInlineMungerTest2.aj,ataspectj/TestHelper.java"
&gt;                 options="-1.5"/&gt;
84,85c84,85
&lt;             files="ataspectj/DumpTest.java,ataspectj/DumpTestTheDump.java,ataspectj/TestHelper.java"
&lt;             options="-1.5"/&gt;
---
&gt;                 files="ataspectj/DumpTest.java,ataspectj/DumpTestTheDump.java,ataspectj/TestHelper.java"
&gt;                 options="-1.5"/&gt;
91,93c91,93
&lt;             files="ataspectj/ltwreweavable/Main.java,ataspectj/ltwreweavable/Aspect1.java,ataspectj/ltwreweavable/Advisable.java"
&lt;             options="-1.5"
&lt;             outjar="main1.jar"/&gt;
---
&gt;                 files="ataspectj/ltwreweavable/Main.java,ataspectj/ltwreweavable/Aspect1.java,ataspectj/ltwreweavable/Advisable.java"
&gt;                 options="-1.5"
&gt;                 outjar="main1.jar"/&gt;
108,110c108,111
&lt;             files="ataspectj/DeclareParentsInterfaceTest.java,ataspectj/DeclareParentsImplementsTest.java,ataspectj/TestHelper.java"
&lt;             options="-1.5"
&lt;             /&gt;
---
&gt;                 files="ataspectj/DeclareParentsInterfaceTest.java,ataspectj/DeclareParentsImplementsTest.java,ataspectj/TestHelper.java"
&gt;                 options="-1.5"
&gt;                 /&gt;
&gt;         &lt;!--&lt;run class="ataspectj.DeclareParentsInterfaceTest" ltw="ataspectj/aop-decptest.xml"/&gt;--&gt;
117,119c118,120
&lt;             files="ataspectj/DeclareParentsImplementsReweavableTest.java,ataspectj/TestHelper.java"
&lt;             options="-1.5"
&lt;             /&gt;
---
&gt;                 files="ataspectj/DeclareParentsImplementsReweavableTest.java,ataspectj/TestHelper.java"
&gt;                 options="-1.5"
&gt;                 /&gt;
122a124,133
&gt; 
&gt; 
&gt;     &lt;ajc-test dir="java5/ataspectj" title="Compile time aspects declared to ltw weaver"&gt;
&gt;         &lt;compile
&gt;                 files="ataspectj/ltwlog/MessageHolder.java,ataspectj/ltwreweavable/MainReweavableLogging.java,ataspectj/ltwreweavable/AspectReweavableLogging.java,ataspectj/ltwreweavable/Advisable.java"
&gt;                 options="-1.5"
&gt;                 outjar="main1.jar"/&gt;
&gt;         &lt;ant file="ajc-ant.xml" target="ltw.oldAspectsDeclared" verbose="true"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/aop-decptest.xml" revision="1.2" state="changed">3c3
&lt;     &lt;weaver options="-XmessageHandlerClass:ataspectj.TestHelper"/&gt;
---
&gt;     &lt;weaver options="-XmessageHandlerClass:ataspectj.TestHelper -1.5 -Xlint:ignore"/&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwreweavable/aop-ltwreweavable-omitted.xml" revision="1.1" state="new">&lt;aspectj&gt;
    &lt;weaver options="-XmessageHandlerClass:ataspectj.ltwlog.MessageHolder"/&gt;
    &lt;!--aspect is not declared here so as to produce an error --&gt;
    &lt;aspects/&gt;
&lt;/aspectj&gt;</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ajc-ant.xml" revision="1.17" state="changed">151d150
&lt;                 &lt;pathelement path="${aj.sandbox}"/&gt;
162a162,188
&gt; 
&gt;     &lt;target name="ltw.oldAspectsDeclared"&gt;
&gt;         &lt;!--Aspects woven at compile time must be declared in an aop.xml file.
&gt;         If they are not declared, then they will be lost during reweaving--&gt;
&gt; 
&gt;         &lt;!--First test that the error is produced if the declaration is not made--&gt;
&gt;         &lt;java fork="yes" classname="ataspectj.ltwreweavable.MainReweavableLogging" failonerror="yes"&gt;
&gt;             &lt;classpath refid="aj.path"/&gt;
&gt;             &lt;classpath&gt;
&gt;                 &lt;pathelement path="${aj.sandbox}/main1.jar"/&gt;
&gt;             &lt;/classpath&gt;
&gt;             &lt;jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/&gt;
&gt;             &lt;jvmarg value="-Daj5.def=ataspectj/ltwreweavable/aop-ltwreweavable-declared.xml"/&gt;
&gt;             &lt;jvmarg value="-DaspectDeclared=true"/&gt;
&gt;         &lt;/java&gt;
&gt;         &lt;!--Now ensure that the error is not produced when the declaration is made.--&gt;
&gt;         &lt;java fork="yes" classname="ataspectj.ltwreweavable.MainReweavableLogging" failonerror="yes"&gt;
&gt;             &lt;classpath refid="aj.path"/&gt;
&gt;             &lt;classpath&gt;
&gt;                 &lt;pathelement path="${aj.sandbox}/main1.jar"/&gt;
&gt;             &lt;/classpath&gt;
&gt;             &lt;jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/&gt;
&gt;             &lt;jvmarg value="-Daj5.def=ataspectj/ltwreweavable/aop-ltwreweavable-omitted.xml"/&gt;
&gt;             &lt;jvmarg value="-DaspectDeclared=false"/&gt;
&gt;         &lt;/java&gt;
&gt;     &lt;/target&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
package ataspectj.ltwreweavable;

import ataspectj.ltwlog.MessageHolder;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * Contributed by David Knibb
 * @author &lt;a href="mailto:alex AT gnilux DOT com"&gt;Alexandre Vasseur&lt;/a&gt;
 */
public class MainReweavableLogging implements Advisable {
    private static List joinPoints = new ArrayList();

    public void test1 () {

    }

    public void test2 () {

    }

    public void addJoinPoint (String name) {
        joinPoints.add(name);
    }

    public static void main (String[] args) {
        String ERROR_STRING = "error aspect 'ataspectj.ltwreweavable.AspectReweavableLogging' woven into 'ataspectj.ltwreweavable.MainReweavableLogging' must be declared in an aop.xml file.";
        if(Boolean.getBoolean("aspectDeclared")){
            //if the aspect is declared there should not be an error
            if (MessageHolder.startsAs( Arrays.asList(  new String[]{ ERROR_STRING }  )) ) {
                MessageHolder.dump();
                throw new RuntimeException("Error in MainReweavableLogging - unexpected error message - \"" + ERROR_STRING + "\"");
            }
        }
        else{
            //and if the aspect is not declared then there should
            if (!MessageHolder.startsAs( Arrays.asList(  new String[]{ ERROR_STRING }  )) ) {
                MessageHolder.dump();
                throw new RuntimeException("Error in MainReweavableLogging - missing expected error message - \"" + ERROR_STRING + "\"");
            }
        }
    }
}
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwreweavable/AspectReweavableLogging.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
package ataspectj.ltwreweavable;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

/**
 * Contributed by David Knibb
 * @author &lt;a href="mailto:alex AT gnilux DOT com"&gt;Alexandre Vasseur&lt;/a&gt;
 */
@Aspect
public class AspectReweavableLogging {

        @Before("execution(void ataspectj.ltwreweavable.MainReweavableLogging.test1()) &amp;&amp; this(a)")
        public void before(Advisable a, JoinPoint thisJoinPoint) {
            System.err.println(thisJoinPoint);
            a.addJoinPoint(thisJoinPoint.getSignature().getName());
    }
}
    </file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwreweavable/aop-ltwreweavable-declared.xml" revision="1.1" state="new">&lt;aspectj&gt;
    &lt;weaver options="-XmessageHandlerClass:ataspectj.ltwlog.MessageHolder"/&gt;
    &lt;aspects&gt;
        &lt;aspect name="ataspectj.ltwreweavable.AspectReweavableLogging"/&gt;
    &lt;/aspects&gt;
&lt;/aspectj&gt;</file>
</fixedFiles>
</bug>
<bug id="104331" transactionid="75116">
<property name="files-churned" value="20"/>
<property name="java-files-churned" value="12"/>
<property name="classes-churned" value="12"/>
<property name="methods-churned" value="12"/>
<property name="hunks" value="36"/>
<property name="lines-added" value="557"/>
<property name="lines-deleted" value="8"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="565"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-else K-if K-import K-instanceof K-interface K-new K-null K-package K-return K-super K-this K-try M O-&gt; O-!= O-() O-&amp;&amp; O-+ O-cast O-instanceof T V Y Z-cast Z-if</fullfingerprint>
<bugreport>In Eclipse 3.1 you can select Help &gt; Dynamic Help, and a new view is shown which
displays information about the currently selected view. We need to provide the
appropriate information to populate this for every view that AJDT contributes.</bugreport>
<pre-fix-testcases failing="179" file="output/104331/pre-fix/testresults.xml" passing="1529" size="1708"/>
<post-fix-testcases failing="177" file="output/104331/post-fix/testresults.xml" passing="1531" size="1708"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJEditor.java" revision="1.33" state="changed">24a25,26
&gt; import org.eclipse.ajdt.internal.ui.help.AspectJUIHelp;
&gt; import org.eclipse.ajdt.internal.ui.help.IAJHelpContextIds;
29a32
&gt; import org.eclipse.help.IContextProvider;
35a39
&gt; import org.eclipse.jdt.internal.ui.IJavaHelpContextIds;
39a44
&gt; import org.eclipse.jdt.internal.ui.util.JavaUIHelp;
161,168d165
&lt; 	/**
&lt; 	 * Get an adapter - if they want an outliner, give them ours! Other adapters
&lt; 	 * we could consider providing:
&lt; 	 * &lt;ol&gt;
&lt; 	 * &lt;li&gt;ITextOperationTarget&lt;/li&gt;
&lt; 	 * &lt;li&gt;IFindReplaceTarget&lt;/li&gt;
&lt; 	 * &lt;/ol&gt;
&lt; 	 */
186a184,187
&gt; 		if (key.equals(IContextProvider.class)) {
&gt; 			return AspectJUIHelp.getHelpContextProvider(this, IAJHelpContextIds.ASPECTJ_EDITOR);
&gt; 		}
&gt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/ui/views/XReferenceView.java" revision="1.31" state="changed">23a24,25
&gt; import org.eclipse.contribution.xref.internal.ui.help.IXRefHelpContextIds;
&gt; import org.eclipse.contribution.xref.internal.ui.help.XRefUIHelp;
27a30
&gt; import org.eclipse.help.IContextProvider;
116a120
&gt; 		getSite().setSelectionProvider(viewer);
461a466,474
&gt; 	
&gt; 	
&gt; 	public Object getAdapter(Class key) {
&gt; 		if (key.equals(IContextProvider.class)) {
&gt; 			return XRefUIHelp.getHelpContextProvider(this, IXRefHelpContextIds.XREF_VIEW);
&gt; 		}
&gt; 		return super.getAdapter(key);
&gt; 	}
&gt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/Visualiser.java" revision="1.20" state="changed">27a28,29
&gt; import org.eclipse.contribution.visualiser.internal.help.IVisualiserHelpContextIds;
&gt; import org.eclipse.contribution.visualiser.internal.help.VisualiserHelp;
35a38
&gt; import org.eclipse.help.IContextProvider;
41a45,47
&gt; import org.eclipse.jface.viewers.ISelection;
&gt; import org.eclipse.jface.viewers.ISelectionChangedListener;
&gt; import org.eclipse.jface.viewers.ISelectionProvider;
125a132,144
&gt; 		
&gt; 		// Add an empty ISelectionProvider so that this view works with dynamic help (bug 104331)
&gt; 		getSite().setSelectionProvider(new ISelectionProvider() {
&gt; 			public void addSelectionChangedListener(ISelectionChangedListener listener) {
&gt; 			}
&gt; 			public ISelection getSelection() {
&gt; 				return null;
&gt; 			}
&gt; 			public void removeSelectionChangedListener(ISelectionChangedListener listener) {
&gt; 			}
&gt; 			public void setSelection(ISelection selection) {
&gt; 			}
&gt; 		});
675a695,700
&gt; 	public Object getAdapter(Class key) {
&gt; 		if (key.equals(IContextProvider.class)) {
&gt; 			return VisualiserHelp.getHelpContextProvider(this, IVisualiserHelpContextIds.VISUALISER_VIEW);
&gt; 		}
&gt; 		return super.getAdapter(key);
&gt; 	}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/diff/ChangesView.java" revision="1.8" state="changed">25a26,27
&gt; import org.eclipse.ajdt.internal.ui.help.AspectJUIHelp;
&gt; import org.eclipse.ajdt.internal.ui.help.IAJHelpContextIds;
32a35
&gt; import org.eclipse.help.IContextProvider;
37a41,43
&gt; import org.eclipse.jface.viewers.ISelection;
&gt; import org.eclipse.jface.viewers.ISelectionChangedListener;
&gt; import org.eclipse.jface.viewers.ISelectionProvider;
226a233,245
&gt; 
&gt; 		// Add an empty ISelectionProvider so that this view works with dynamic help (bug 104331)
&gt; 		getSite().setSelectionProvider(new ISelectionProvider() {
&gt; 			public void addSelectionChangedListener(ISelectionChangedListener listener) {
&gt; 			}
&gt; 			public ISelection getSelection() {
&gt; 				return null;
&gt; 			}
&gt; 			public void removeSelectionChangedListener(ISelectionChangedListener listener) {
&gt; 			}
&gt; 			public void setSelection(ISelection selection) {
&gt; 			}
&gt; 		});
432a452,459
&gt; 	
&gt; 	public Object getAdapter(Class key) {
&gt; 		if (key.equals(IContextProvider.class)) {
&gt; 			return AspectJUIHelp.getHelpContextProvider(this, IAJHelpContextIds.CROSSCUTTING_COMPARISON_VIEW);
&gt; 		}
&gt; 		return super.getAdapter(key);
&gt; 	}
&gt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/AJDTEventTraceView.java" revision="1.4" state="changed">13a14,15
&gt; import org.eclipse.ajdt.internal.ui.help.AspectJUIHelp;
&gt; import org.eclipse.ajdt.internal.ui.help.IAJHelpContextIds;
15a18
&gt; import org.eclipse.help.IContextProvider;
16a20,22
&gt; import org.eclipse.jface.viewers.ISelection;
&gt; import org.eclipse.jface.viewers.ISelectionChangedListener;
&gt; import org.eclipse.jface.viewers.ISelectionProvider;
51a58,70
&gt; 		
&gt; 		// Add an empty ISelectionProvider so that this view works with dynamic help (bug 104331)
&gt; 		getSite().setSelectionProvider(new ISelectionProvider() {
&gt; 			public void addSelectionChangedListener(ISelectionChangedListener listener) {
&gt; 			}
&gt; 			public ISelection getSelection() {
&gt; 				return null;
&gt; 			}
&gt; 			public void removeSelectionChangedListener(ISelectionChangedListener listener) {
&gt; 			}
&gt; 			public void setSelection(ISelection selection) {
&gt; 			}
&gt; 		});
82a102,108
&gt; 	
&gt; 	public Object getAdapter(Class key) {
&gt; 		if (key.equals(IContextProvider.class)) {
&gt; 			return AspectJUIHelp.getHelpContextProvider(this, IAJHelpContextIds.EVENT_TRACE_VIEW);
&gt; 		}
&gt; 		return super.getAdapter(key);
&gt; 	}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/META-INF/MANIFEST.MF" revision="1.4" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/plugin.xml" revision="1.10" state="changed">114a115,118
&gt;    
&gt;  	&lt;extension point="org.eclipse.help.contexts"&gt; 
&gt; 		&lt;contexts file="contexts_Visualiser.xml" plugin="org.eclipse.contribution.visualiser"/&gt;
&gt; 	&lt;/extension&gt;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/META-INF/MANIFEST.MF" revision="1.3" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/plugin.xml" revision="1.49" state="changed">1413c1413,1418
&lt;    
---
&gt;   	
&gt;   	&lt;extension point="org.eclipse.help.contexts"&gt; 
&gt; 		&lt;contexts file="contexts_AJDT.xml" plugin="org.eclipse.ajdt.ui"/&gt; 
&gt; 		&lt;contexts file="contexts_XRef.xml" plugin="org.eclipse.contribution.xref.ui"/&gt; 
&gt; 	&lt;/extension&gt;
&gt; 	 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/META-INF/MANIFEST.MF" revision="1.3" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/Menu.java" revision="1.18" state="changed">23a24,25
&gt; import org.eclipse.contribution.visualiser.internal.help.IVisualiserHelpContextIds;
&gt; import org.eclipse.contribution.visualiser.internal.help.VisualiserHelp;
28a31
&gt; import org.eclipse.help.IContextProvider;
31a35,37
&gt; import org.eclipse.jface.viewers.ISelection;
&gt; import org.eclipse.jface.viewers.ISelectionChangedListener;
&gt; import org.eclipse.jface.viewers.ISelectionProvider;
173a180,193
&gt; 		
&gt; 		// Add an empty ISelectionProvider so that this view works with dynamic help (bug 104331)
&gt; 		getSite().setSelectionProvider(new ISelectionProvider() {
&gt; 			public void addSelectionChangedListener(ISelectionChangedListener listener) {
&gt; 			}
&gt; 			public ISelection getSelection() {
&gt; 				return null;
&gt; 			}
&gt; 			public void removeSelectionChangedListener(ISelectionChangedListener listener) {
&gt; 			}
&gt; 			public void setSelection(ISelection selection) {
&gt; 			}
&gt; 		});
&gt; 
459a480,486
&gt; 	public Object getAdapter(Class key) {
&gt; 		if (key.equals(IContextProvider.class)) {
&gt; 			return VisualiserHelp.getHelpContextProvider(this, IVisualiserHelpContextIds.VISUALISER_MENU_VIEW);
&gt; 		}
&gt; 		return super.getAdapter(key);
&gt; 	}
&gt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/contexts_AJDT.xml" revision="1.1" state="new">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?NLS TYPE="org.eclipse.help.contexts"?&gt;
&lt;contexts&gt;

    &lt;context id="aspectj_editor_context"&gt;
        &lt;description&gt;The AspectJ editor provides you with AspectJ specific text editing support.&lt;/description&gt;
        &lt;topic label="AspectJ editor concepts" href="doc/concepts/editor.htm"/&gt;
        &lt;topic label="Aspects" href="doc/concepts/aspects.htm"/&gt;
        &lt;topic label="Creating a new aspect" href="doc/tasks/newaspect.htm"/&gt;
        &lt;topic label="Converting file extensions" href="doc/tasks/convertingextensions.htm"/&gt;
    &lt;/context&gt;
    
	&lt;context id="crosscutting_comparison_view_context"&gt;
	    &lt;description&gt;The Crosscutting Comparison view enables you to compare two sets of crosscutting relationships.&lt;/description&gt;
        &lt;topic label="AspectJ views" href="doc/concepts/views.htm"/&gt;
        &lt;topic label="Comparing crosscutting" href="doc/tasks/compare.htm"/&gt;
    &lt;/context&gt;

	&lt;context id="event_trace_view_context"&gt;
	    &lt;description&gt;The AJDT Event Trace view displays information about AJDT events.&lt;/description&gt;
        &lt;topic label="AspectJ views" href="doc/concepts/views.htm"/&gt;
    &lt;/context&gt;    

&lt;/contexts&gt;
    </file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/internal/help/VisualiserHelp.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2000, 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.eclipse.contribution.visualiser.internal.help;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.help.HelpSystem;
import org.eclipse.help.IContext;
import org.eclipse.help.IContextProvider;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.ui.actions.SelectionConverter;
import org.eclipse.jdt.internal.ui.util.JavadocHelpContext;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.StructuredViewer;
import org.eclipse.swt.events.HelpEvent;
import org.eclipse.swt.events.HelpListener;
import org.eclipse.ui.IWorkbenchPart;

// Partly copied from JavaUIHelp
public class VisualiserHelp {

	public static void setHelp(StructuredViewer viewer, String contextId) {
		XRefUIHelpListener listener= new XRefUIHelpListener(viewer, contextId);
		viewer.getControl().addHelpListener(listener);
	}
	
	/**
	 * Creates and returns a help context provider for the given part.
	 * 
	 * @param part the part for which to create the help context provider
	 * @param contextId	the optional context ID used to retrieve static help
	 * @return the help context provider 
	 */
	public static IContextProvider getHelpContextProvider(IWorkbenchPart part, String contextId) {
		IStructuredSelection selection;
		try {
			selection= SelectionConverter.getStructuredSelection(part);
		} catch (JavaModelException ex) {
			selection= StructuredSelection.EMPTY;
		}
		Object[] elements= selection.toArray();
		return new XRefUIHelpContextProvider(contextId, elements);
	}

	private static class XRefUIHelpListener implements HelpListener {

		private StructuredViewer fViewer;
		private String fContextId;
		
		public XRefUIHelpListener(StructuredViewer viewer, String contextId) {
			fViewer= viewer;
			fContextId= contextId;
		}
		
		/*
		 * @see HelpListener#helpRequested(HelpEvent)
		 * 
		 */
		public void helpRequested(HelpEvent e) {
			try {
				Object[] selected= null;
				ISelection selection= fViewer.getSelection();
				if (selection instanceof IStructuredSelection) {
					selected= ((IStructuredSelection)selection).toArray();
				}				
				JavadocHelpContext.displayHelp(fContextId, selected);
			} catch (CoreException x) {
			}
		}
	}

	private static class XRefUIHelpContextProvider implements IContextProvider {
		private String fId;
		private Object[] fSelected;
		public XRefUIHelpContextProvider(String id, Object[] selected) {
			fId= id;
			fSelected= selected;
		}
		public int getContextChangeMask() {
			return SELECTION;
		}
		public IContext getContext(Object target) {
			IContext context= HelpSystem.getContext(fId);
			if (fSelected != null &amp;&amp; fSelected.length &gt; 0) {
				try {
					context= new JavadocHelpContext(context, fSelected);
				} catch (JavaModelException e) {
				}
			}
			return context;
		}
		public String getSearchExpression(Object target) {
			return null;
		}
	}
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/internal/ui/help/XRefUIHelp.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2000, 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.eclipse.contribution.xref.internal.ui.help;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.help.HelpSystem;
import org.eclipse.help.IContext;
import org.eclipse.help.IContextProvider;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.ui.actions.SelectionConverter;
import org.eclipse.jdt.internal.ui.util.JavadocHelpContext;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.StructuredViewer;
import org.eclipse.swt.events.HelpEvent;
import org.eclipse.swt.events.HelpListener;
import org.eclipse.ui.IWorkbenchPart;

// Partly copied from JavaUIHelp
public class XRefUIHelp {

	public static void setHelp(StructuredViewer viewer, String contextId) {
		XRefUIHelpListener listener= new XRefUIHelpListener(viewer, contextId);
		viewer.getControl().addHelpListener(listener);
	}
	
	/**
	 * Creates and returns a help context provider for the given part.
	 * 
	 * @param part the part for which to create the help context provider
	 * @param contextId	the optional context ID used to retrieve static help
	 * @return the help context provider 
	 */
	public static IContextProvider getHelpContextProvider(IWorkbenchPart part, String contextId) {
		IStructuredSelection selection;
		try {
			selection= SelectionConverter.getStructuredSelection(part);
		} catch (JavaModelException ex) {
			selection= StructuredSelection.EMPTY;
		}
		Object[] elements= selection.toArray();
		return new XRefUIHelpContextProvider(contextId, elements);
	}

	private static class XRefUIHelpListener implements HelpListener {

		private StructuredViewer fViewer;
		private String fContextId;
		
		public XRefUIHelpListener(StructuredViewer viewer, String contextId) {
			fViewer= viewer;
			fContextId= contextId;
		}
		
		/*
		 * @see HelpListener#helpRequested(HelpEvent)
		 * 
		 */
		public void helpRequested(HelpEvent e) {
			try {
				Object[] selected= null;
				ISelection selection= fViewer.getSelection();
				if (selection instanceof IStructuredSelection) {
					selected= ((IStructuredSelection)selection).toArray();
				}				
				JavadocHelpContext.displayHelp(fContextId, selected);
			} catch (CoreException x) {
			}
		}
	}

	private static class XRefUIHelpContextProvider implements IContextProvider {
		private String fId;
		private Object[] fSelected;
		public XRefUIHelpContextProvider(String id, Object[] selected) {
			fId= id;
			fSelected= selected;
		}
		public int getContextChangeMask() {
			return SELECTION;
		}
		public IContext getContext(Object target) {
			IContext context= HelpSystem.getContext(fId);
			if (fSelected != null &amp;&amp; fSelected.length &gt; 0) {
				try {
					context= new JavadocHelpContext(context, fSelected);
				} catch (JavaModelException e) {
				}
			}
			return context;
		}
		public String getSearchExpression(Object target) {
			return null;
		}
	}
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/contexts_XRef.xml" revision="1.1" state="new">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?NLS TYPE="org.eclipse.help.contexts"?&gt;
&lt;contexts&gt;

   &lt;context id="xref_view_context"&gt;
	    &lt;description&gt;The Cross References view enables you to view the crosscutting relationships for a file.&lt;/description&gt;
        &lt;topic label="AspectJ views" href="doc/concepts/views.htm"/&gt;
        &lt;topic label="Using the Cross References view" href="doc/tasks/xrefview.htm"/&gt;
    &lt;/context&gt;
    

&lt;/contexts&gt;
    </file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.xref.ui/src/org/eclipse/contribution/xref/internal/ui/help/IXRefHelpContextIds.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2000, 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *     Sian January - inital version
 *******************************************************************************/
package org.eclipse.contribution.xref.internal.ui.help;

import org.eclipse.contribution.xref.ui.XReferenceUIPlugin;

/**
 * Help context ids for the Cross References UI Plug-in.
 * &lt;p&gt;
 * This interface contains constants only; it is not intended to be implemented
 * or extended.
 * &lt;/p&gt;
 * 
 */
public interface IXRefHelpContextIds {
	
	public static final String PREFIX= XReferenceUIPlugin.PLUGIN_ID + '.';
	
	public static final String XREF_VIEW= PREFIX + "xref_view_context"; //$NON-NLS-1$
	
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/internal/help/IVisualiserHelpContextIds.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2000, 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *     Sian January - inital version
 *******************************************************************************/
package org.eclipse.contribution.visualiser.internal.help;

import org.eclipse.contribution.visualiser.VisualiserPlugin;

/**
 * Help context ids for the Cross References UI Plug-in.
 * &lt;p&gt;
 * This interface contains constants only; it is not intended to be implemented
 * or extended.
 * &lt;/p&gt;
 * 
 */
public interface IVisualiserHelpContextIds {
	
	public static final String PREFIX= VisualiserPlugin.PLUGIN_ID + '.';
	
	public static final String VISUALISER_VIEW= PREFIX + "visualiser_view_context"; //$NON-NLS-1$
	public static final String VISUALISER_MENU_VIEW= PREFIX + "visualiser_menu_view_context"; //$NON-NLS-1$
	
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/help/AspectJUIHelp.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2000, 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.eclipse.ajdt.internal.ui.help;

import org.eclipse.ajdt.internal.ui.editor.AspectJEditor;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.help.HelpSystem;
import org.eclipse.help.IContext;
import org.eclipse.help.IContextProvider;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.ui.actions.ActionUtil;
import org.eclipse.jdt.internal.ui.actions.SelectionConverter;
import org.eclipse.jdt.internal.ui.util.JavadocHelpContext;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.StructuredViewer;
import org.eclipse.swt.custom.StyledText;
import org.eclipse.swt.events.HelpEvent;
import org.eclipse.swt.events.HelpListener;
import org.eclipse.ui.IWorkbenchPart;

// Partly copied from JavaUIHelp
public class AspectJUIHelp {

	public static void setHelp(StructuredViewer viewer, String contextId) {
		AspectJUIHelpListener listener= new AspectJUIHelpListener(viewer, contextId);
		viewer.getControl().addHelpListener(listener);
	}

	public static void setHelp(AspectJEditor editor, StyledText text, String contextId) {
		AspectJUIHelpListener listener= new AspectJUIHelpListener(editor, contextId);
		text.addHelpListener(listener);
	}
	
	/**
	 * Creates and returns a help context provider for the given part.
	 * 
	 * @param part the part for which to create the help context provider
	 * @param contextId	the optional context ID used to retrieve static help
	 * @return the help context provider 
	 */
	public static IContextProvider getHelpContextProvider(IWorkbenchPart part, String contextId) {
		IStructuredSelection selection;
		try {
			selection= SelectionConverter.getStructuredSelection(part);
		} catch (JavaModelException ex) {
			selection= StructuredSelection.EMPTY;
		}
		Object[] elements= selection.toArray();
		return new AspectJUIHelpContextProvider(contextId, elements);
	}

	private static class AspectJUIHelpListener implements HelpListener {

		private StructuredViewer fViewer;
		private String fContextId;
		private AspectJEditor fEditor;

		public AspectJUIHelpListener(StructuredViewer viewer, String contextId) {
			fViewer= viewer;
			fContextId= contextId;
		}

		public AspectJUIHelpListener(AspectJEditor editor, String contextId) {
			fContextId= contextId;
			fEditor= editor;
		}

		/*
		 * @see HelpListener#helpRequested(HelpEvent)
		 * 
		 */
		public void helpRequested(HelpEvent e) {
			try {
				Object[] selected= null;
				if (fViewer != null) {
					ISelection selection= fViewer.getSelection();
					if (selection instanceof IStructuredSelection) {
						selected= ((IStructuredSelection)selection).toArray();
					}
				} else if (fEditor != null) {
					IJavaElement input= SelectionConverter.getInput(fEditor);
					if (ActionUtil.isOnBuildPath(input)) {
						selected= SelectionConverter.codeResolve(fEditor);
					}
				}
				JavadocHelpContext.displayHelp(fContextId, selected);
			} catch (CoreException x) {
			}
		}
	}

	private static class AspectJUIHelpContextProvider implements IContextProvider {
		private String fId;
		private Object[] fSelected;
		public AspectJUIHelpContextProvider(String id, Object[] selected) {
			fId= id;
			fSelected= selected;
		}
		public int getContextChangeMask() {
			return SELECTION;
		}
		public IContext getContext(Object target) {
			IContext context= HelpSystem.getContext(fId);
			if (fSelected != null &amp;&amp; fSelected.length &gt; 0) {
				try {
					context= new JavadocHelpContext(context, fSelected);
				} catch (JavaModelException e) {
				}
			}
			return context;
		}
		public String getSearchExpression(Object target) {
			return null;
		}
	}
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/contexts_Visualiser.xml" revision="1.1" state="new">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?NLS TYPE="org.eclipse.help.contexts"?&gt;
&lt;contexts&gt;

   &lt;context id="visualiser_view_context"&gt;
	    &lt;description&gt;The Visualiser view displays a bars-and-stripes style view of the information it is given.  The information given depends on which Visualiser provider is active.&lt;/description&gt;
        &lt;topic label="Using the Visualiser" href="doc/userguide/main.html"/&gt;
        &lt;topic label="Writing a plug-in for the Visualiser" href="doc/extenderguide/main.html"/&gt;
    &lt;/context&gt;
    
   &lt;context id="visualiser_menu_view_context"&gt;
	    &lt;description&gt;The Visualiser Menu view displays a list of the stripe kinds shown in the Visualiser view and enables you to manage them.&lt;/description&gt;
        &lt;topic label="Using the Visualiser" href="doc/userguide/main.html"/&gt;
        &lt;topic label="Writing a plug-in for the Visualiser" href="doc/extenderguide/main.html"/&gt;
     &lt;/context&gt;
    
&lt;/contexts&gt;
    </file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/help/IAJHelpContextIds.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2000, 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *     Sian January - inital version
 *******************************************************************************/
package org.eclipse.ajdt.internal.ui.help;

import org.eclipse.ajdt.ui.AspectJUIPlugin;

/**
 * Help context ids for AJDT UI Plug-in.
 * &lt;p&gt;
 * This interface contains constants only; it is not intended to be implemented
 * or extended.
 * &lt;/p&gt;
 * 
 */
public interface IAJHelpContextIds {
	
	public static final String PREFIX= AspectJUIPlugin.PLUGIN_ID + '.';
	
	public static final String ASPECTJ_EDITOR= PREFIX + "aspectj_editor_context"; //$NON-NLS-1$
	public static final String CROSSCUTTING_COMPARISON_VIEW= PREFIX + "crosscutting_comparison_view_context"; //$NON-NLS-1$
	public static final String EVENT_TRACE_VIEW = PREFIX + "event_trace_view_context";
	
}
</file>
</fixedFiles>
</bug>
<bug id="105203" transactionid="74833">
<property name="files-churned" value="7"/>
<property name="java-files-churned" value="5"/>
<property name="classes-churned" value="5"/>
<property name="methods-churned" value="5"/>
<property name="hunks" value="108"/>
<property name="lines-added" value="220"/>
<property name="lines-deleted" value="115"/>
<property name="lines-modified" value="185"/>
<property name="lines-churned" value="520"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-false K-if K-import K-new K-null K-package K-return K-this K-true K-try M O-== O-| O-|| O-() O-&amp;&amp; O-+ T V Y Z-if Z-throw Z-while</fullfingerprint>
<bugreport>Hi Sian,
I see we have our own AJJarPackagerMessages.properties file copied from JDT. Is
this a direct copy, just so we could keep it common with Eclipse 3.0 and 3.1? If
so, we can presumably remove it in the 3.1 line, and refer to JDT's
JarPackagerMessages class directly.</bugreport>
<pre-fix-testcases failing="107" file="output/105203/pre-fix/testresults.xml" passing="852" size="959"/>
<post-fix-testcases failing="177" file="output/105203/post-fix/testresults.xml" passing="1531" size="1708"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/exports/AJJarPackagerUtil.java" revision="1.3" state="changed">28a29
&gt; import org.eclipse.jdt.internal.corext.util.Messages;
51,53c52
&lt; 		// AspectJ Change Begin
&lt; 		return queryDialog(parent, AJJarPackagerMessages.getString("JarPackage.confirmCreate.title"), AJJarPackagerMessages.getFormattedString("JarPackage.confirmCreate.message", directory.toString())); //$NON-NLS-2$ //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		return queryDialog(parent, JarPackagerMessages.JarPackage_confirmCreate_title, Messages.format(JarPackagerMessages.JarPackage_confirmCreate_message, directory.toString())); 
80,82c79
&lt; //		 AspectJ Change Begin
&lt; 		return queryDialog(parent, AJJarPackagerMessages.getString("JarPackage.confirmReplace.title"), AJJarPackagerMessages.getFormattedString("JarPackage.confirmReplace.message", filePath)); //$NON-NLS-2$ //$NON-NLS-1$
&lt; //		 AspectJ Change End
---
&gt; 		return queryDialog(parent, JarPackagerMessages.JarPackage_confirmReplace_title, Messages.format(JarPackagerMessages.JarPackage_confirmReplace_message, filePath)); 
182c179
&lt; 					// can be ignored
---
&gt; 					// ignore this folder
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/exports/AJJarFileExportOperation.java" revision="1.4" state="changed">60a61
&gt; import org.eclipse.jdt.internal.corext.util.Messages;
107a109
&gt; 	private boolean fFilesSaved;
142,144c144
&lt; 			// AspectJ Change Begin
&lt; 			message= AJJarPackagerMessages.getString("JarFileExportOperation.coreErrorDuringExport"); //$NON-NLS-1$
&lt; 			// AspectJ Change End
---
&gt; 			message= JarPackagerMessages.JarFileExportOperation_coreErrorDuringExport; 
154c154
&lt; 	 * @param	exception	the throwable that caused the warning, or &lt;code&gt;null&lt;/code&gt;
---
&gt; 	 * @param	error 	the throwable that caused the warning, or &lt;code&gt;null&lt;/code&gt;
164c164
&lt; 	 * @param	exception	the throwable that caused the warning, or &lt;code&gt;null&lt;/code&gt;
---
&gt; 	 * @param	error	the throwable that caused the warning, or &lt;code&gt;null&lt;/code&gt;
174c174
&lt; 	 * @param	exception	the throwable that caused the error, or &lt;code&gt;null&lt;/code&gt;
---
&gt; 	 * @param	error 	the throwable that caused the error, or &lt;code&gt;null&lt;/code&gt;
284,286c284
&lt; 					// AspectJ Change Begin
&lt; 					addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.underlyingResourceNotFound", je.getElementName()), ex); //$NON-NLS-1$
&lt; 					// AspectJ Change End
---
&gt; 					addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_underlyingResourceNotFound, je.getElementName()), ex); 
296,298c294
&lt; 				// AspectJ Change Begin
&lt; 				addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.resourceNotFound", resource.getFullPath()), null); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_resourceNotFound, resource.getFullPath()), null); 
307,309c303
&lt; 						// AspectJ Change Begin
&lt; 						addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.resourceNotLocal", resource.getFullPath()), ex); //$NON-NLS-1$
&lt; 						// AspectJ Change End
---
&gt; 						addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_resourceNotLocal, resource.getFullPath()), ex); 
317,319c311
&lt; 						// AspectJ Change Begin
&lt; 						addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.projectNatureNotDeterminable", resource.getFullPath()), ex); //$NON-NLS-1$
&lt; 						//  AspectJ Change End
---
&gt; 						addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_projectNatureNotDeterminable, resource.getFullPath()), ex); 
331,333c323
&lt; 							// AspectJ Change Begin
&lt; 							addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.javaPackageNotDeterminable", resource.getFullPath()), ex); //$NON-NLS-1$
&lt; 							// AspectJ Change End
---
&gt; 							addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_javaPackageNotDeterminable, resource.getFullPath()), ex); 
386,388c376
&lt; 				// AspectJ Change Begin
&lt; 				addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.errorDuringExport", container.getFullPath()), e); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_errorDuringExport, container.getFullPath()), e); 
396,398c384
&lt; 				// AspectJ Change Begin
&lt; 				progressMonitor.subTask(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.exporting", destinationPath.toString())); //$NON-NLS-1$
&lt; 				//  AspectJ Change End
---
&gt; 				progressMonitor.subTask(Messages.format(JarPackagerMessages.JarFileExportOperation_exporting, destinationPath.toString())); 
422,424c408
&lt; 			// AspectJ Change Begin
&lt; 			addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.errorDuringExport", container.getFullPath()), e); //$NON-NLS-1$
&lt; 			// AspectJ Change End
---
&gt; 			addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_errorDuringExport, container.getFullPath()), e); 
445,447c429
&lt; 				// AspectJ Change Begin
&lt; 				addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.didNotAddManifestToJar", resource.getFullPath()), null); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_didNotAddManifestToJar, resource.getFullPath()), null); 
456,458c438
&lt; 			// AspectJ Change Begin
&lt; 			addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.cantGetRootKind", resource.getFullPath()), ex); //$NON-NLS-1$
&lt; 			// AspectJ Change End
---
&gt; 			addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_cantGetRootKind, resource.getFullPath()), ex); 
465,467c445
&lt; 				// AspectJ Change Begin
&lt; 				progressMonitor.subTask(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.exporting", destinationPath.toString())); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				progressMonitor.subTask(Messages.format(JarPackagerMessages.JarFileExportOperation_exporting, destinationPath.toString())); 
508,510c486
&lt; 						// AspectJ Change Begin
&lt; 						progressMonitor.subTask(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.exporting", classFilePath.toString())); //$NON-NLS-1$
&lt; 						// AspectJ Change End
---
&gt; 						progressMonitor.subTask(Messages.format(JarPackagerMessages.JarFileExportOperation_exporting, classFilePath.toString())); 
549,551c525
&lt; 				// AspectJ Change Begin
&lt; 				addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.projectNatureNotDeterminable", project.getFullPath()), ex); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_projectNatureNotDeterminable, project.getFullPath()), ex); 
609,611c583
&lt; 					// AspectJ Change Begin
&lt; 					String msg= AJJarPackagerMessages.getString("JarFileExportOperation.outputContainerNotAccessible"); //$NON-NLS-1$
&lt; 					// AspectJ Change End
---
&gt; 					String msg= JarPackagerMessages.JarFileExportOperation_outputContainerNotAccessible; 
669,671c641
&lt; 				// AspectJ Change Begin
&lt; 				String msg= AJJarPackagerMessages.getString("JarFileExportOperation.outputContainerNotAccessible"); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				String msg= JarPackagerMessages.JarFileExportOperation_outputContainerNotAccessible; 
698,700c668
&lt; 				// AspectJ Change Begin
&lt; 				String msg= AJJarPackagerMessages.getFormattedString("JarFileExportOperation.missingSourceFileAttributeExportedAll", containerName); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				String msg= Messages.format(JarPackagerMessages.JarFileExportOperation_missingSourceFileAttributeExportedAll, containerName); 
709,711c677
&lt; 			// AspectJ Change Begin
&lt; 			String msg= AJJarPackagerMessages.getFormattedString("JarFileExportOperation.classFileOnClasspathNotAccessible", file.getFullPath()); //$NON-NLS-1$
&lt; 			// AspectJ Change End
---
&gt; 			String msg= Messages.format(JarPackagerMessages.JarFileExportOperation_classFileOnClasspathNotAccessible, file.getFullPath()); 
783,785c749
&lt; 							// AspectJ Change Begin
&lt; 							addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.classFileWithoutSourceFileAttribute", file), null); //$NON-NLS-1$
&lt; 							// AspectJ Change End
---
&gt; 							addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_classFileWithoutSourceFileAttribute, file), null); 
844,846c808
&lt; 				// AspectJ Change Begin
&lt; 				message= AJJarPackagerMessages.getString("JarFileExportOperation.exportFinishedWithInfo"); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				message= JarPackagerMessages.JarFileExportOperation_exportFinishedWithInfo; 
849,851c811
&lt; 				// AspectJ Change Begin
&lt; 				message= AJJarPackagerMessages.getString("JarFileExportOperation.exportFinishedWithWarnings"); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				message= JarPackagerMessages.JarFileExportOperation_exportFinishedWithWarnings; 
855,857c815
&lt; 					// AspectJ Change Begin
&lt; 					message= AJJarPackagerMessages.getString("JarFileExportOperation.creationOfSomeJARsFailed"); //$NON-NLS-1$
&lt; 					// AspectJ Change End
---
&gt; 					message= JarPackagerMessages.JarFileExportOperation_creationOfSomeJARsFailed; 
859,861c817
&lt; 					// AspectJ Change Begin
&lt; 					message= AJJarPackagerMessages.getString("JarFileExportOperation.jarCreationFailed"); //$NON-NLS-1$
&lt; 					// AspectJ Change End
---
&gt; 					message= JarPackagerMessages.JarFileExportOperation_jarCreationFailed; 
898d853
&lt; 		// AspectJ Change Begin		
901c856
&lt; 				addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.exportedWithCompileErrors", file.getFullPath()), null); //$NON-NLS-1$
---
&gt; 				addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_exportedWithCompileErrors, file.getFullPath()), null); 
903c858
&lt; 				addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.notExportedDueToCompileErrors", file.getFullPath()), null); //$NON-NLS-1$
---
&gt; 				addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_notExportedDueToCompileErrors, file.getFullPath()), null); 
907c862
&lt; 				addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.exportedWithCompileWarnings", file.getFullPath()), null); //$NON-NLS-1$
---
&gt; 				addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_exportedWithCompileWarnings, file.getFullPath()), null); 
909c864
&lt; 				addWarning(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.notExportedDueToCompileWarnings", file.getFullPath()), null); //$NON-NLS-1$
---
&gt; 				addWarning(Messages.format(JarPackagerMessages.JarFileExportOperation_notExportedDueToCompileWarnings, file.getFullPath()), null); 
911d865
&lt; 		// AspectJ Change End
938,940c892
&lt; 				// AspectJ Change Begin
&lt; 				throw new InvocationTargetException(null, AJJarPackagerMessages.getString("JarFileExportOperation.jarCreationFailedSeeDetails")); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				throw new InvocationTargetException(null, JarPackagerMessages.JarFileExportOperation_jarCreationFailedSeeDetails); 
942c894,896
&lt; 			if (!isAutoBuilding() &amp;&amp; fJarPackage.isBuildingIfNeeded() &amp;&amp; fJarPackage.areGeneratedFilesExported()) {
---
&gt; 			if (fJarPackage.areGeneratedFilesExported() 
&gt; 				&amp;&amp; ((!isAutoBuilding() &amp;&amp; fJarPackage.isBuildingIfNeeded())
&gt; 					|| (isAutoBuilding() &amp;&amp; fFilesSaved))) {
954,956c908
&lt; 				// AspectJ Change Begin
&lt; 				progressMonitor.subTask(AJJarPackagerMessages.getString("JarFileExportOperation.savingFiles")); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				progressMonitor.subTask(JarPackagerMessages.JarFileExportOperation_savingFiles); 
973d924
&lt; 		// AspectJ Change Begin
975c926
&lt; 			addError(AJJarPackagerMessages.getString("JarFileExportOperation.noExportTypeChosen"), null); //$NON-NLS-1$
---
&gt; 			addError(JarPackagerMessages.JarFileExportOperation_noExportTypeChosen, null); 
979c930
&lt; 			addError(AJJarPackagerMessages.getString("JarFileExportOperation.noResourcesSelected"), null); //$NON-NLS-1$
---
&gt; 			addError(JarPackagerMessages.JarFileExportOperation_noResourcesSelected, null); 
983c934
&lt; 			addError(AJJarPackagerMessages.getString("JarFileExportOperation.invalidJarLocation"), null); //$NON-NLS-1$
---
&gt; 			addError(JarPackagerMessages.JarFileExportOperation_invalidJarLocation, null); 
988c939
&lt; 			addError(AJJarPackagerMessages.getString("JarFileExportOperation.jarFileExistsAndNotWritable"), null); //$NON-NLS-1$
---
&gt; 			addError(JarPackagerMessages.JarFileExportOperation_jarFileExistsAndNotWritable, null); 
992c943
&lt; 			addError(AJJarPackagerMessages.getString("JarFileExportOperation.manifestDoesNotExist"), null); //$NON-NLS-1$
---
&gt; 			addError(JarPackagerMessages.JarFileExportOperation_manifestDoesNotExist, null); 
996c947
&lt; 			addError(AJJarPackagerMessages.getString("JarFileExportOperation.invalidMainClass"), null); //$NON-NLS-1$
---
&gt; 			addError(JarPackagerMessages.JarFileExportOperation_invalidMainClass, null); 
999,1000c950
&lt; 		// AspectJ Change End
&lt; 				
---
&gt; 		
1022d971
&lt; 			// AspectJ Change Begin			
1024d972
&lt; 			// AspectJ Change End
1028d975
&lt; 					// AspectJ Change Begin
1030d976
&lt; 					// AspectJ Change End
1078,1080c1024
&lt; 			// AspectJ Change Begin
&lt; 			addError(AJJarPackagerMessages.getFormattedString("JarFileExportOperation.fileUnsaved", dirtyFiles[i].getFullPath()), null); //$NON-NLS-1$
&lt; 			// AspectJ Change End
---
&gt; 			addError(Messages.format(JarPackagerMessages.JarFileExportOperation_fileUnsaved, dirtyFiles[i].getFullPath()), null); 
1105,1107c1049
&lt; 					// AspectJ Change Begin
&lt; 					addError(AJJarPackagerMessages.getString("JarFileExportOperation.errorSavingModifiedResources"), ex); //$NON-NLS-1$
&lt; 					// AspectJ Change End
---
&gt; 					addError(JarPackagerMessages.JarFileExportOperation_errorSavingModifiedResources, ex); 
1115a1058
&gt; 		fFilesSaved= false;
1116a1060,1061
&gt; 		if (retVal[0])
&gt; 			fFilesSaved= true;
1124,1126c1069
&lt; 				// AspectJ Change Begin
&lt; 				pm.beginTask(AJJarPackagerMessages.getString("JarFileExportOperation.savingModifiedResources"), editorsToSave.length); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				pm.beginTask(JarPackagerMessages.JarFileExportOperation_savingModifiedResources, editorsToSave.length); 
1150,1152c1093
&lt; 				// AspectJ Change Begin
&lt; 				addError(AJJarPackagerMessages.getString("JarFileExportOperation.errorSavingManifest"), ex); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				addError(JarPackagerMessages.JarFileExportOperation_errorSavingManifest, ex); 
1154,1156c1095
&lt; 				// AspectJ Change Begin
&lt; 				addError(AJJarPackagerMessages.getString("JarFileExportOperation.errorSavingManifest"), ex); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				addError(JarPackagerMessages.JarFileExportOperation_errorSavingManifest, ex); 
1165,1167c1104
&lt; 				// AspectJ Change Begin
&lt; 				addError(AJJarPackagerMessages.getString("JarFileExportOperation.errorSavingDescription"), ex); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				addError(JarPackagerMessages.JarFileExportOperation_errorSavingDescription, ex); 
1169,1171c1106
&lt; 				// AspectJ Change Begin
&lt; 				addError(AJJarPackagerMessages.getString("JarFileExportOperation.errorSavingDescription"), ex); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				addError(JarPackagerMessages.JarFileExportOperation_errorSavingDescription, ex); 
1256,1258c1191
&lt; 					// AspectJ Change Begin
&lt; 					String message= AJJarPackagerMessages.getFormattedString("JarFileExportOperation.errorDuringProjectBuild", project.getFullPath()); //$NON-NLS-1$
&lt; 					// AspectJ Change End
---
&gt; 					String message= Messages.format(JarPackagerMessages.JarFileExportOperation_errorDuringProjectBuild, project.getFullPath()); 
1274c1207
&lt; 	 * @throws import org.eclipse.core.runtime.CoreException if there's a marker problem
---
&gt; 	 * @throws CoreException import org.eclipse.core.runtime.CoreException if there's a marker problem
1291c1224
&lt; 	 * @throws import org.eclipse.core.runtime.CoreException if there's a marker problem
---
&gt; 	 * @throws CoreException import org.eclipse.core.runtime.CoreException if there's a marker problem
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/exports/AJJarPackagerMessages.java" revision="1.2" state="deleted"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/exports/AJJarPackageWizardPage.java" revision="1.3" state="changed">38a39
&gt; import org.eclipse.jdt.internal.ui.jarpackager.JarPackageWizard;
64a66
&gt; import org.eclipse.ui.PlatformUI;
67d68
&lt; import org.eclipse.ui.help.WorkbenchHelp;
80d80
&lt; 	private Text	fSourceNameField;	
89a90
&gt; 	private Button		fIncludeDirectoryEntriesCheckbox;
102a104
&gt; 	private final static String STORE_INCLUDE_DIRECTORY_ENTRIES= PAGE_NAME + ".INCLUDE_DIRECTORY_ENTRIES"; //$NON-NLS-1$
113,116c115,116
&lt; 		// AspectJ Change Begin
&lt; 		setTitle(AJJarPackagerMessages.getString("JarPackageWizardPage.title")); //$NON-NLS-1$
&lt; 		setDescription(AJJarPackagerMessages.getString("JarPackageWizardPage.description")); //$NON-NLS-1$
&lt; 		// AspectJ Change End 
---
&gt; 		setTitle(JarPackagerMessages.JarPackageWizardPage_title); 
&gt; 		setDescription(JarPackagerMessages.JarPackageWizardPage_description); 
133,135c133
&lt; 		// AspectJ Change Begin
&lt; 		createPlainLabel(composite, AJJarPackagerMessages.getString("JarPackageWizardPage.whatToExport.label")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		createPlainLabel(composite, JarPackagerMessages.JarPackageWizardPage_whatToExport_label); 
142,144c140,141
&lt; 		// AspectJ Change Begin
&lt; 		createPlainLabel(composite, AJJarPackagerMessages.getString("JarPackageWizardPage.whereToExport.label")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 
&gt; 		createPlainLabel(composite, JarPackagerMessages.JarPackageWizardPage_whereToExport_label); 
147,149c144
&lt; 		// AspectJ Change Begin
&lt; 		createPlainLabel(composite, AJJarPackagerMessages.getString("JarPackageWizardPage.options.label")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		createPlainLabel(composite, JarPackagerMessages.JarPackageWizardPage_options_label); 
166c161
&lt; 		WorkbenchHelp.setHelp(composite, IJavaHelpContextIds.JARPACKAGER_WIZARD_PAGE);
---
&gt; 		PlatformUI.getWorkbench().getHelpSystem().setHelp(composite, IJavaHelpContextIds.JARPACKAGER_WIZARD_PAGE);
181,183c176
&lt; 		// AspectJ Change Begin
&lt; 		fCompressCheckbox.setText(AJJarPackagerMessages.getString("JarPackageWizardPage.compress.text")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		fCompressCheckbox.setText(JarPackagerMessages.JarPackageWizardPage_compress_text); 
184a178,181
&gt; 		
&gt; 		fIncludeDirectoryEntriesCheckbox= new Button(optionsGroup, SWT.CHECK | SWT.LEFT);
&gt; 		fIncludeDirectoryEntriesCheckbox.setText(JarPackagerMessages.JarPackageWizardPage_includeDirectoryEntries_text); 
&gt; 		fIncludeDirectoryEntriesCheckbox.addListener(SWT.Selection, this);
187,189c184
&lt; 		// AspectJ Change Begin
&lt; 		fOverwriteCheckbox.setText(AJJarPackagerMessages.getString("JarPackageWizardPage.overwrite.text")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		fOverwriteCheckbox.setText(JarPackagerMessages.JarPackageWizardPage_overwrite_text); 
212,214c207
&lt; 		// AspectJ Change Begin
&lt; 		return AJJarPackagerMessages.getString("JarPackageWizardPage.destination.label"); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		return JarPackagerMessages.JarPackageWizardPage_destination_label; 
225d217
&lt; //		 AspectJ Change Begin
227d218
&lt; //		 AspectJ Change End
262a254
&gt; 			settings.put(STORE_INCLUDE_DIRECTORY_ENTRIES, fJarPackage.areDirectoryEntriesIncluded());
280d271
&lt; //		 AspectJ Change Begin
282d272
&lt; //			 AspectJ Change End
306a297
&gt; 		fIncludeDirectoryEntriesCheckbox.setSelection(fJarPackage.areDirectoryEntriesIncluded());
323a315
&gt; 			fJarPackage.setIncludeDirectoryEntries(settings.getBoolean(STORE_INCLUDE_DIRECTORY_ENTRIES));
330c322
&lt; 			fJarPackage.setJarLocation(new Path(directoryNames[0]));
---
&gt; 			fJarPackage.setJarLocation(Path.fromOSString(directoryNames[0]));
353c345
&lt; 		IPath path= new Path(comboText);
---
&gt; 		IPath path= Path.fromOSString(comboText);
364a357
&gt; 		fJarPackage.setIncludeDirectoryEntries(fIncludeDirectoryEntriesCheckbox.getSelection());
376,378c369
&lt; 			// AspectJ Change Begin
&lt; 			setErrorMessage(AJJarPackagerMessages.getString("JarPackageWizardPage.error.exportDestinationMustNotBeDirectory")); //$NON-NLS-1$
&lt; 			// AspectJ Change End
---
&gt; 			setErrorMessage(JarPackagerMessages.JarPackageWizardPage_error_exportDestinationMustNotBeDirectory); 
384,386c375
&lt; 				// AspectJ Change Begin
&lt; 				setErrorMessage(AJJarPackagerMessages.getString("JarPackageWizardPage.error.jarFileExistsAndNotWritable")); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				setErrorMessage(JarPackagerMessages.JarPackageWizardPage_error_jarFileExistsAndNotWritable); 
420,422c409
&lt; 		// AspectJ Change Begin
&lt; 		fDestinationBrowseButton.setText(AJJarPackagerMessages.getString("JarPackageWizardPage.browseButton.text")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		fDestinationBrowseButton.setText(JarPackagerMessages.JarPackageWizardPage_browseButton_text); 
439,442c426,427
&lt; 		// AspectJ Change Begin
&lt; 		dialog.getShell().setText(AJJarPackagerMessages.getString("JarPackageWizardPage.saveAsDialog.title")); //$NON-NLS-1$
&lt; 		dialog.setMessage(AJJarPackagerMessages.getString("JarPackageWizardPage.saveAsDialog.message")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		dialog.getShell().setText(JarPackagerMessages.JarPackageWizardPage_saveAsDialog_title); 
&gt; 		dialog.setMessage(JarPackagerMessages.JarPackageWizardPage_saveAsDialog_message); 
446d430
&lt; //			 AspectJ Change Begin
448d431
&lt; //			 AspectJ Change End
538,540c521
&lt; 		// AspectJ Change Begin
&lt; 		fExportClassFilesCheckbox.setText(AJJarPackagerMessages.getString("JarPackageWizardPage.exportClassFiles.text")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		fExportClassFilesCheckbox.setText(JarPackagerMessages.JarPackageWizardPage_exportClassFiles_text); 
544,546c525
&lt; 		// AspectJ Change Begin
&lt; 		fExportOutputFoldersCheckbox.setText(AJJarPackagerMessages.getString("JarPackageWizardPage.exportOutputFolders.text")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		fExportOutputFoldersCheckbox.setText(JarPackagerMessages.JarPackageWizardPage_exportOutputFolders_text); 
550,552c529
&lt; 		// AspectJ Change Begin
&lt; 		fExportJavaFilesCheckbox.setText(AJJarPackagerMessages.getString("JarPackageWizardPage.exportJavaFiles.text")); //$NON-NLS-1$
&lt; 		// AspectJ Change End
---
&gt; 		fExportJavaFilesCheckbox.setText(JarPackagerMessages.JarPackageWizardPage_exportJavaFiles_text); 
609,611c586
&lt; 			// AspectJ Change Begin
&lt; 			setErrorMessage(AJJarPackagerMessages.getString("JarPackageWizardPage.error.exportDestinationMustNotBeDirectory")); //$NON-NLS-1$
&lt; 			// AspectJ Change End
---
&gt; 			setErrorMessage(JarPackagerMessages.JarPackageWizardPage_error_exportDestinationMustNotBeDirectory); 
621d595
&lt; //				 AspectJ Change Begin
623,624c597
&lt; //					 AspectJ Change Begin
&lt; 					setErrorMessage(AJJarPackagerMessages.getString("JarPackageWizardPage.error.cantExportJARIntoItself")); //$NON-NLS-1$
---
&gt; 					setErrorMessage(JarPackagerMessages.JarPackageWizardPage_error_cantExportJARIntoItself); 
633,635c606
&lt; 				// AspectJ Change Begin
&lt; 				setMessage(AJJarPackagerMessages.getString("JarPackageWizardPage.info.relativeExportDestination"), IMessageProvider.INFORMATION); //$NON-NLS-1$
&lt; 				// AspectJ Change End
---
&gt; 				setMessage(JarPackagerMessages.JarPackageWizardPage_info_relativeExportDestination, IMessageProvider.INFORMATION); 
655,657c626
&lt; 			// AspectJ Change Begin
&lt; 			setErrorMessage(AJJarPackagerMessages.getString("JarPackageWizardPage.error.noExportTypeChecked")); //$NON-NLS-1$
&lt; 			// AspectJ Change End
---
&gt; 			setErrorMessage(JarPackagerMessages.JarPackageWizardPage_error_noExportTypeChecked); 
696,702d664
&lt; 	/*
&lt; 	 * Overwrides method from WizardExportPage
&lt; 	 */
&lt; 	protected IPath getResourcePath() {
&lt; 		return getPathFromText(fSourceNameField);
&lt; 	}
&lt; 
729,731c691,693
&lt; 		Iterator iter= fInitialSelection.iterator();
&lt; 		while (iter.hasNext()) {
&lt; 			Object selectedElement= iter.next();
---
&gt; 		Iterator iterator= fInitialSelection.iterator();
&gt; 		while (iterator.hasNext()) {
&gt; 			Object selectedElement= iterator.next();
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/exports/AJJarPackagerMessages.properties" revision="1.2" state="deleted"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/exports/JarPackagerMessages.properties" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/exports/JarPackagerMessages.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2000, 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.eclipse.ajdt.internal.ui.wizards.exports;

import org.eclipse.osgi.util.NLS;

/**
 * Copied from org.eclipse.jdt.internal.ui.jarpackager.JarPackagerMessages.
 * Changes marked with // AspectJ Change
 */
public final class JarPackagerMessages extends NLS {

	// AspectJ Change
	private static final String BUNDLE_NAME = "org.eclipse.ajdt.internal.ui.wizards.exports.JarPackagerMessages";//$NON-NLS-1$

	private JarPackagerMessages() {
		// Do not instantiate
	}

	public static String CreateJarActionDelegate_jarExportError_title;
	public static String CreateJarActionDelegate_jarExport_title;
	public static String CreateJarActionDelegate_jarExportError_message;
	public static String JarPackage_confirmCreate_title;
	public static String JarPackage_confirmCreate_message;
	public static String JarPackage_confirmReplace_title;
	public static String JarPackage_confirmReplace_message;
	public static String JarPackageWizard_windowTitle;
	public static String JarPackageWizard_jarExport_title;
	public static String JarPackageWizard_jarExportError_title;
	public static String JarPackageWizard_jarExportError_message;
	public static String OpenJarPackageWizardDelegate_badXmlFormat;
	public static String OpenJarPackageWizardDelegate_error_openJarPackager_title;
	public static String OpenJarPackageWizardDelegate_error_openJarPackager_message;
	public static String OpenJarPackageWizardDelegate_jarDescriptionReaderWarnings_title;
	public static String JarWriter_error_fileNotAccessible;
	public static String JarWriter_writeProblem;
	public static String JarWriter_writeProblemWithMessage;
	public static String JarFileExportOperation_exportFinishedWithInfo;
	public static String JarFileExportOperation_exportFinishedWithWarnings;
	public static String JarFileExportOperation_creationOfSomeJARsFailed;
	public static String JarFileExportOperation_jarCreationFailed;
	public static String JarFileExportOperation_underlyingResourceNotFound;
	public static String JarFileExportOperation_resourceNotFound;
	public static String JarFileExportOperation_resourceNotLocal;
	public static String JarFileExportOperation_projectNatureNotDeterminable;
	public static String JarFileExportOperation_javaPackageNotDeterminable;
	public static String JarFileExportOperation_coreErrorDuringExport;
	public static String JarFileExportOperation_errorDuringExport;
	public static String JarFileExportOperation_outputContainerNotAccessible;
	public static String JarFileExportOperation_classFileOnClasspathNotAccessible;
	public static String JarFileExportOperation_classFileWithoutSourceFileAttribute;
	public static String JarFileExportOperation_missingSourceFileAttributeExportedAll;
	public static String JarFileExportOperation_exportedWithCompileErrors;
	public static String JarFileExportOperation_exportedWithCompileWarnings;
	public static String JarFileExportOperation_notExportedDueToCompileErrors;
	public static String JarFileExportOperation_notExportedDueToCompileWarnings;
	public static String JarFileExportOperation_exporting;
	public static String JarFileExportOperation_jarCreationFailedSeeDetails;
	public static String JarFileExportOperation_savingFiles;
	public static String JarFileExportOperation_savingModifiedResources;
	public static String JarFileExportOperation_noExportTypeChosen;
	public static String JarFileExportOperation_noResourcesSelected;
	public static String JarFileExportOperation_invalidJarLocation;
	public static String JarFileExportOperation_manifestDoesNotExist;
	public static String JarFileExportOperation_invalidMainClass;
	public static String JarFileExportOperation_jarFileExistsAndNotWritable;
	public static String JarFileExportOperation_cantGetRootKind;
	public static String JarFileExportOperation_fileUnsaved;
	public static String JarFileExportOperation_didNotAddManifestToJar;
	public static String JarFileExportOperation_errorSavingManifest;
	public static String JarFileExportOperation_errorSavingDescription;
	public static String JarFileExportOperation_errorReadingFile;
	public static String JarFileExportOperation_errorClosingJarPackageDescriptionReader;
	public static String JarFileExportOperation_errorDuringProjectBuild;
	public static String JarFileExportOperation_errorSavingModifiedResources;
	public static String JarOptionsPage_title;
	public static String JarOptionsPage_description;
	public static String JarOptionsPage_howTreatProblems_label;
	public static String JarOptionsPage_exportErrors_text;
	public static String JarOptionsPage_exportWarnings_text;
	public static String JarOptionsPage_useSourceFoldersHierarchy;
	public static String JarOptionsPage_saveDescription_text;
	public static String JarOptionsPage_saveAsDialog_title;
	public static String JarOptionsPage_saveAsDialog_message;
	public static String JarOptionsPage_error_descriptionMustBeAbsolute;
	public static String JarOptionsPage_error_descriptionMustNotBeExistingContainer;
	public static String JarOptionsPage_error_descriptionContainerDoesNotExist;
	public static String JarOptionsPage_error_invalidDescriptionExtension;
	public static String JarOptionsPage_descriptionFile_label;
	public static String JarOptionsPage_browseButton_text;
	public static String JarOptionsPage_buildIfNeeded;
	public static String JarPackageWizardPage_title;
	public static String JarPackageWizardPage_description;
	public static String JarPackageWizardPage_whatToExport_label;
	public static String JarPackageWizardPage_whereToExport_label;
	public static String JarPackageWizardPage_options_label;
	public static String JarPackageWizardPage_compress_text;
	public static String JarPackageWizardPage_overwrite_text;
	public static String JarPackageWizardPage_includeDirectoryEntries_text;
	public static String JarPackageWizardPage_destination_label;
	public static String JarPackageWizardPage_browseButton_text;
	public static String JarPackageWizardPage_saveAsDialog_title;
	public static String JarPackageWizardPage_saveAsDialog_message;
	public static String JarPackageWizardPage_exportClassFiles_text;
	public static String JarPackageWizardPage_exportOutputFolders_text;
	public static String JarPackageWizardPage_exportJavaFiles_text;
	public static String JarPackageWizardPage_info_relativeExportDestination;
	public static String JarPackageWizardPage_error_exportDestinationMustNotBeDirectory;
	public static String JarPackageWizardPage_error_jarFileExistsAndNotWritable;
	public static String JarPackageWizardPage_error_noExportTypeChecked;
	public static String JarPackageWizardPage_error_cantExportJARIntoItself;
	public static String JarPackageReader_error_badFormat;
	public static String JarPackageReader_jarPackageReaderWarnings;
	public static String JarPackageReader_error_illegalValueForBooleanAttribute;
	public static String JarPackageReader_error_tagNameNotFound;
	public static String JarPackageReader_error_tagPathNotFound;
	public static String JarPackageReader_error_tagHandleIdentifierNotFoundOrEmpty;
	public static String JarPackageReader_warning_javaElementDoesNotExist;
	public static String JarPackageReader_error_duplicateTag;
	public static String JarPackageReader_warning_mainClassDoesNotExist;
	public static String JarManifestWizardPage_title;
	public static String JarManifestWizardPage_description;
	public static String JarManifestWizardPage_manifestSource_label;
	public static String JarManifestWizardPage_sealingHeader_label;
	public static String JarManifestWizardPage_mainClassHeader_label;
	public static String JarManifestWizardPage_genetateManifest_text;
	public static String JarManifestWizardPage_saveManifest_text;
	public static String JarManifestWizardPage_reuseManifest_text;
	public static String JarManifestWizardPage_useManifest_text;
	public static String JarManifestWizardPage_newManifestFile_text;
	public static String JarManifestWizardPage_newManifestFileBrowseButton_text;
	public static String JarManifestWizardPage_manifestFile_text;
	public static String JarManifestWizardPage_manifestFileBrowse_text;
	public static String JarManifestWizardPage_sealJar_text;
	public static String JarManifestWizardPage_unsealPackagesButton_text;
	public static String JarManifestWizardPage_sealPackagesButton_text;
	public static String JarManifestWizardPage_sealedPackagesDetailsButton_text;
	public static String JarManifestWizardPage_mainClass_label;
	public static String JarManifestWizardPage_mainClassBrowseButton_text;
	public static String JarManifestWizardPage_saveAsDialog_title;
	public static String JarManifestWizardPage_saveAsDialog_message;
	public static String JarManifestWizardPage_manifestSelectionDialog_title;
	public static String JarManifestWizardPage_manifestSelectionDialog_message;
	public static String JarManifestWizardPage_error_onlyOneManifestMustBeSelected;
	public static String JarManifestWizardPage_error_noResourceSelected;
	public static String JarManifestWizardPage_warning_noManifestVersion;
	public static String JarManifestWizardPage_mainTypeSelectionDialog_title;
	public static String JarManifestWizardPage_mainTypeSelectionDialog_message;
	public static String JarManifestWizardPage_sealedPackagesSelectionDialog_title;
	public static String JarManifestWizardPage_sealedPackagesSelectionDialog_message;
	public static String JarManifestWizardPage_unsealedPackagesSelectionDialog_title;
	public static String JarManifestWizardPage_unsealedPackagesSelectionDialog_message;
	public static String JarManifestWizardPage_jarSealed;
	public static String JarManifestWizardPage_jarSealedExceptOne;
	public static String JarManifestWizardPage_jarSealedExceptSome;
	public static String JarManifestWizardPage_nothingSealed;
	public static String JarManifestWizardPage_onePackageSealed;
	public static String JarManifestWizardPage_somePackagesSealed;
	public static String JarManifestWizardPage_error_manifestPathMustBeAbsolute;
	public static String JarManifestWizardPage_error_manifestMustNotBeExistingContainer;
	public static String JarManifestWizardPage_error_manifestContainerDoesNotExist;
	public static String JarManifestWizardPage_error_invalidManifestFile;
	public static String JarManifestWizardPage_error_noManifestFile;
	public static String JarManifestWizardPage_error_unsealedPackagesNotInSelection;
	public static String JarManifestWizardPage_error_sealedPackagesNotInSelection;
	public static String JarManifestWizardPage_error_jarPackageWizardError_title;
	public static String JarManifestWizardPage_error_jarPackageWizardError_message;
	public static String JarManifestWizardPage_error_mustContainPackages;
	public static String JarManifestWizardPage_error_invalidMainClass;
	public static String JarWriter_error_couldNotGetXmlBuilder;
	public static String JarWriter_error_couldNotTransformToXML;
	public static String JarWriter_output_title;
	public static String JarWriter_output_exportBin;
	public static String JarWriter_output_exportOutputFolders;
	public static String JarWriter_output_exportJava;
	public static String JarWriter_output_jarFileName;
	public static String JarWriter_output_compressed;
	public static String JarWriter_output_overwrite;
	public static String JarWriter_output_saveDescription;
	public static String JarWriter_output_descriptionFile;
	public static String JarWriter_output_lineSeparator;
	public static String JarWriter_output_generateManifest;
	public static String JarWriter_output_saveManifest;
	public static String JarWriter_output_reuseManifest;
	public static String JarWriter_output_manifestName;
	public static String JarWriter_output_jarSealed;
	public static String JarWriter_output_mainClass;
	public static String ConfirmSaveModifiedResourcesDialog_title;
	public static String ConfirmSaveModifiedResourcesDialog_message;

	static {
		NLS.initializeMessages(BUNDLE_NAME, JarPackagerMessages.class);
	}
}</file>
</fixedFiles>
</bug>
<bug id="107299" transactionid="75952">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-! O-() T V Z-if</fullfingerprint>
<bugreport>ajc doesn't recognize Windows absolute file paths that don't start with a drive 
letter, e.g., run:
ajc -inpath \test.jar
[error] build config error: bad inpath component: \test.jar

but

ajc -inpath c:\test.jar
works

ajc -aspectpath \test.jar Test.aj

[error] build config error: bad aspectpath: \test.jar

ajc -aspectpath c:\test.jar Test.aj
(works)</bugreport>
<pre-fix-testcases failing="177" file="output/107299/pre-fix/testresults.xml" passing="1584" size="1761"/>
<post-fix-testcases failing="179" file="output/107299/post-fix/testresults.xml" passing="1582" size="1761"/>
<fixedFiles>
<file name="org.aspectj/modules/util/src/org/aspectj/util/ConfigParser.java" revision="1.7" state="changed">220c220
&lt;         if (dir != null &amp;&amp; !ret.isAbsolute()) { 
---
&gt;         if (!ret.exists() &amp;&amp; (dir != null) &amp;&amp; !ret.isAbsolute()) { 
</file>
</fixedFiles>
</bug>
<bug id="107309" transactionid="73359">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-null M T V Y</fullfingerprint>
<bugreport>When accessed from the Visualiser view, the drawing options pane of the
preferences dialog can become truncated. This happens on the Mac, and on Windows
when large fonts are used. When accessed via Window &gt; Preferences, the dialog is
sized appropriately, and the problem doesn't occur.</bugreport>
<pre-fix-testcases failing="176" file="output/107309/pre-fix/testresults.xml" passing="1537" size="1713"/>
<post-fix-testcases failing="176" file="output/107309/post-fix/testresults.xml" passing="1537" size="1713"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/Visualiser.java" revision="1.21" state="changed">31d30
&lt; import org.eclipse.contribution.visualiser.internal.preference.VisualiserPreferencesDialog;
52a52
&gt; import org.eclipse.ui.dialogs.PreferencesUtil;
205,208c205,207
&lt; 				VisualiserPreferencesDialog vpd = new VisualiserPreferencesDialog(
&lt; 						Visualiser.this.getViewSite().getShell());
&lt; 				vpd.create();
&lt; 				vpd.open();
---
&gt; 				String id= "org.eclipse.contribution.visualiser.prefspage"; //$NON-NLS-1$
&gt; 				PreferencesUtil.createPreferenceDialogOn(Visualiser.this.getViewSite().getShell(),
&gt; 						id, new String[] { id }, null).open();
</file>
</fixedFiles>
</bug>
<bug id="108118" transactionid="70349">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="30"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="11"/>
<property name="lines-churned" value="41"/>
<property name="priority" value="P2"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-null K-return K-super M O-!= T V Z-if</fullfingerprint>
<bugreport>ensure that @SuppressAJWarnings are indeed suppressed during pointcut
operations. This requires wrapping major pointcut operations with calls to Lint
from the associated advice.</bugreport>
<testsforfix ID="108118" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java">
      <test NAME="testSuppressionOfMessagesIssuedDuringMatching"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="SuppressAjWarnings raised during matching"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="177" file="output/108118/pre-fix/testresults.xml" passing="1582" size="1759"/>
<post-fix-testcases failing="177" file="output/108118/post-fix/testresults.xml" passing="1582" size="1759"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/Utility.java" revision="1.24" state="changed">737c737,738
&lt; 					suppressedWarnings.add(lint.getLintKind(value.getValueString()));
---
&gt; 					Lint.Kind lintKind = lint.getLintKind(value.getValueString());
&gt; 					if (lintKind != null) suppressedWarnings.add(lintKind);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java" revision="1.33" state="changed">35a36
&gt; import org.aspectj.weaver.ShadowMunger;
42a44
&gt; import org.aspectj.weaver.patterns.PerClause;
78a81,94
&gt; 	public ShadowMunger concretize(ResolvedType fromType, World world, PerClause clause) {
&gt; 		suppressLintWarnings(world);
&gt; 		ShadowMunger ret = super.concretize(fromType, world, clause);
&gt; 		clearLintSuppressions(world);
&gt; 		return ret;
&gt; 	}
&gt; 	
&gt; 	public boolean match(Shadow shadow, World world) {
&gt; 		suppressLintWarnings(world);
&gt; 		boolean ret = super.match(shadow, world);
&gt; 		clearLintSuppressions(world);
&gt; 		return ret;
&gt; 	}
&gt; 	
101,108c117
&lt;     	if (suppressedLintKinds == null) {
&lt;     		if (signature instanceof BcelMethod) {
&lt;     			this.suppressedLintKinds = Utility.getSuppressedWarnings(signature.getAnnotations(), world.getLint());
&lt;     		} else {
&lt;     			this.suppressedLintKinds = Collections.EMPTY_LIST;
&lt;     		}
&lt;     	}
&lt;     	world.getLint().suppressKinds(suppressedLintKinds);
---
&gt;     	suppressLintWarnings(world);
110c119
&lt; 		world.getLint().clearSuppressions();
---
&gt; 		clearLintSuppressions(world);
568a578,591
&gt; 	protected void suppressLintWarnings(World inWorld) {
&gt; 		if (suppressedLintKinds == null) {
&gt;     		if (signature instanceof BcelMethod) {
&gt;     			this.suppressedLintKinds = Utility.getSuppressedWarnings(signature.getAnnotations(), inWorld.getLint());
&gt;     		} else {
&gt;     			this.suppressedLintKinds = Collections.EMPTY_LIST;
&gt;     		}
&gt;     	}
&gt;     	inWorld.getLint().suppressKinds(suppressedLintKinds);
&gt; 	}
&gt; 	
&gt; 	protected void clearLintSuppressions(World inWorld) {
&gt; 		inWorld.getLint().clearSuppressions();
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.149" state="changed">2785a2786,2790
&gt;    
&gt;    &lt;ajc-test dir="java5/suppressedWarnings" title="SuppressAjWarnings raised during matching"&gt;
&gt;        &lt;compile files="SuppressionDuringMatching.aj" options="-1.5"&gt;
&gt;        &lt;/compile&gt;
&gt;    &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java" revision="1.3" state="changed">48a49,52
&gt;   
&gt;   public void testSuppressionOfMessagesIssuedDuringMatching() {
&gt; 	  runTest("SuppressAjWarnings raised during matching");
&gt;   }
</file>
<file name="org.aspectj/modules/tests/java5/suppressedWarnings/SuppressionDuringMatching.aj" revision="1.1" state="new">import org.aspectj.lang.annotation.*;

public aspect SuppressionDuringMatching {
	
//	// XLint:unmatchedSuperTypeInCall
//	// XLint:adviceDidNotApply
//	before() : call(* Sub.foo()) {
//		
//	}
//	
//	@SuppressAjWarnings
//	before() : call(* Sub.foo()) {
//		
//	}
//	
//	// XLint:unmatchedSuperTypeInCall
//	@SuppressAjWarnings("adviceDidNotApply")
//	before() : call(* Sub.foo()) {
//		
//	}
//	
	
	// XLint:adviceDidNotApply
	@SuppressAjWarnings("unmatchedSuperTypeInCall")
	before() : call(* Sub.foo()) {
		
	}
	
	
}

class Super {
	
	public void foo() {}
	
	void bar() {
		foo();
	}
}

class Sub extends Super {
	
	void bar() {
		foo();
	}
}</file>
<file name="org.aspectj/modules/tests/java5/annotations/aspectMembers/a/AnnotatedAspect05.aj" revision="1.3" state="changed">24c24
&lt; 	@SuppressAjWarnings
---
&gt; 	@SuppressAjWarnings("adviceDidNotMatch")
</file>
<file name="org.aspectj/modules/tests/java5/covariance/CovAspect06.aj" revision="1.3" state="changed">5c5
&lt;   @org.aspectj.lang.annotation.SuppressAjWarnings&#13;
---
&gt;   @org.aspectj.lang.annotation.SuppressAjWarnings("adviceDidNotMatch")&#13;
</file>
</fixedFiles>
</bug>
<bug id="108341" transactionid="72868">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="196"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="197"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-break K-catch K-class K-false K-for K-if K-import K-instanceof K-new K-null K-package K-return K-super K-true K-try K-while M O-&lt; O-== O-&gt; O-&gt;= O-|| O-- O--- O-! O-!= O-?: O-() O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-cond Z-for Z-if Z-vardecl Z-while</fullfingerprint>
<bugreport>Following on from enhancement 107582, it would be good to be able to hold down
the control key and for the occurrences of pointcuts to become hyperlinks, such
that they are highlighted with a mouse-over, and clicking jumps to the definition.</bugreport>
<pre-fix-testcases failing="180" file="output/108341/pre-fix/testresults.xml" passing="1534" size="1714"/>
<post-fix-testcases failing="178" file="output/108341/post-fix/testresults.xml" passing="1536" size="1714"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AJSourceViewerConfiguration.java" revision="1.6" state="changed">24a25
&gt; import org.eclipse.jface.text.hyperlink.IHyperlinkDetector;
32a34
&gt; import org.eclipse.ui.texteditor.AbstractDecoratedTextEditorPreferenceConstants;
160a163,184
&gt; 	/*
&gt; 	 * @see org.eclipse.jface.text.source.SourceViewerConfiguration#getHyperlinkDetectors(org.eclipse.jface.text.source.ISourceViewer)
&gt; 	 * @since 3.1
&gt; 	 */
&gt; 	public IHyperlinkDetector[] getHyperlinkDetectors(ISourceViewer sourceViewer) {
&gt; 		if (!fPreferenceStore.getBoolean(AbstractDecoratedTextEditorPreferenceConstants.EDITOR_HYPERLINKS_ENABLED))
&gt; 			return null;
&gt; 
&gt; 		IHyperlinkDetector[] inheritedDetectors= super.getHyperlinkDetectors(sourceViewer);
&gt; 
&gt; 		if (getEditor() == null)
&gt; 			return inheritedDetectors;
&gt; 
&gt; 		int inheritedDetectorsLength= inheritedDetectors != null ? inheritedDetectors.length : 0;
&gt; 		IHyperlinkDetector[] detectors= new IHyperlinkDetector[inheritedDetectorsLength + 1];
&gt; 		detectors[0]= new PointcutElementHyperlinkDetector(getEditor());
&gt; 		for (int i= 0; i &lt; inheritedDetectorsLength; i++)
&gt; 			detectors[i+1]= inheritedDetectors[i];
&gt; 
&gt; 		return detectors;
&gt; 	}
&gt; 	
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJCodeScanner.java" revision="1.5" state="changed">131c131
&lt; 	private static String[] ajKeywords = { "aspect", "pointcut", "privileged",
---
&gt;     static String[] ajKeywords = { "aspect", "pointcut", "privileged",
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/TestSheet.doc" revision="1.47" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/editor/EditorTests.txt" revision="1.13" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/PointcutElementHyperlinkDetector.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *     Matt Chapman  - initial version
 *******************************************************************************/
package org.eclipse.ajdt.internal.ui.editor;

import org.eclipse.ajdt.core.javaelements.AJCompilationUnit;
import org.eclipse.ajdt.core.javaelements.AdviceElement;
import org.eclipse.ajdt.core.javaelements.PointcutElement;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.ISourceRange;
import org.eclipse.jdt.core.ISourceReference;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.ui.actions.SelectionConverter;
import org.eclipse.jdt.internal.ui.javaeditor.JavaEditor;
import org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlink;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.text.Assert;
import org.eclipse.jface.text.IRegion;
import org.eclipse.jface.text.ITextViewer;
import org.eclipse.jface.text.Region;
import org.eclipse.jface.text.hyperlink.IHyperlink;
import org.eclipse.jface.text.hyperlink.IHyperlinkDetector;
import org.eclipse.ui.texteditor.ITextEditor;

public class PointcutElementHyperlinkDetector implements IHyperlinkDetector {
	private ITextEditor fTextEditor;

	/**
	 * Creates a new Java element hyperlink detector.
	 * 
	 * @param editor
	 *            the editor in which to detect the hyperlink
	 */
	public PointcutElementHyperlinkDetector(ITextEditor editor) {
		Assert.isNotNull(editor);
		fTextEditor = editor;
	}

	public IHyperlink[] detectHyperlinks(ITextViewer textViewer,
			IRegion region, boolean canShowMultipleHyperlinks) {
		if (region == null || canShowMultipleHyperlinks
				|| !(fTextEditor instanceof AspectJEditor)) {
			return null;
		}
		IAction openAction = fTextEditor.getAction("OpenEditor"); //$NON-NLS-1$
		if (openAction == null) {
			return null;
		}
		int offset = region.getOffset();

		IJavaElement input = SelectionConverter
				.getInput((JavaEditor) fTextEditor);
		if (input instanceof AJCompilationUnit) {
			AJCompilationUnit ajcu = (AJCompilationUnit) input;
			try {
				IJavaElement el = ajcu.getElementAt(offset);
				if ((el instanceof AdviceElement)
						|| (el instanceof PointcutElement)) {
					// now narrow down to after the colon and before
					// the start of the advice body or the end of the pointcut
					ajcu.requestOriginalContentMode();
					String source = ajcu.getSource();
					ajcu.discardOriginalContentMode();
					ISourceRange range = ((ISourceReference) el)
							.getSourceRange();
					int start = range.getOffset();
					int end = start + range.getLength();
					int colon = findNextChar(source, start, end, ':');
					// we need to be after a colon
					if ((colon != -1) &amp;&amp; (offset &gt; colon)) {
						int openBrace = findNextChar(source, colon, end, '{');
						int endZone = openBrace;
						if (endZone == -1) {
							int semiColon = findNextChar(source, colon, end,
									';');
							endZone = semiColon;
						}
						// we need to be before the end zone
						if ((endZone &gt; 0) &amp;&amp; (offset &lt; endZone)) {
							IRegion reg = selectWord(source, offset);
							if (reg != null) {
								return new IHyperlink[] { new JavaElementHyperlink(
										reg, openAction) };
							}
						}
					}
				}
			} catch (JavaModelException e) {
			}
		}
		return null;
	}

	private IRegion selectWord(String document, int anchor) {
		int offset = anchor;
		char c;

		while (offset &gt;= 0) {
			c = document.charAt(offset);
			if (!Character.isJavaIdentifierPart(c))
				break;
			--offset;
		}

		int start = offset;

		offset = anchor;
		int length = document.length();

		while (offset &lt; length) {
			c = document.charAt(offset);
			if (!Character.isJavaIdentifierPart(c))
				break;
			++offset;
		}

		int end = offset;

		if (start == end) {
			return null;
		}
		if (isAjKeyword(document.substring(start + 1, end))) {
			return null;
		}
		return new Region(start + 1, end - start - 1);
	}

	private boolean isAjKeyword(String word) {
		for (int i = 0; i &lt; AspectJCodeScanner.ajKeywords.length; i++) {
			if (AspectJCodeScanner.ajKeywords[i].equals(word)) {
				return true;
			}
		}
		// "this" and "if" are not in the aj list as they are java keywords
		if ("this".equals(word)) { //$NON-NLS-1$
			return true;
		}
		if ("if".equals(word)) { //$NON-NLS-1$
			return true;
		}
		return false;
	}

	/**
	 * Returns the index of the first occurrence of the given character in the
	 * source string, between the start offset and the limit. Returns -1 if the
	 * character is not found in the defined range.
	 * 
	 * @param source
	 * @param offset
	 * @param limit
	 * @param c
	 * @return
	 */
	private int findNextChar(String source, int offset, int limit, char c) {
		while (source.charAt(offset) != c) {
			offset++;
			if ((offset == limit) || (offset == source.length())) {
				return -1;
			}
		}
		return offset;
	}
}
</file>
</fixedFiles>
</bug>
<bug id="109016" transactionid="74040">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P2"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if M T V Z-cast Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>The exception below seems to be happening with any .lst file:

Message: NullPointerException thrown: null
Stack trace: java.lang.NullPointerException
	at
org.aspectj.ajde.internal.CompilerAdapter.configureBuildOptions(CompilerAdapter.java:296)
	at
org.aspectj.ajde.internal.CompilerAdapter.genBuildConfig(CompilerAdapter.java:170)
	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:95)
	at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</bugreport>
<pre-fix-testcases failing="179" file="output/109016/pre-fix/testresults.xml" passing="1536" size="1715"/>
<post-fix-testcases failing="178" file="output/109016/post-fix/testresults.xml" passing="1537" size="1715"/>
<fixedFiles>
<file name="org.aspectj/modules/ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java" revision="1.30" state="changed">295,299c295,301
&lt; 				String setCompliance = (String) optionsToSet.get( CompilerOptions.OPTION_Compliance);
&lt; 				if ( ! (setCompliance.equals(CompilerOptions.VERSION_1_4 )
&lt; 			         &amp;&amp; slVersion.equals(CompilerOptions.VERSION_1_3)) ) {
&lt; 				    optionsToSet.put(CompilerOptions.OPTION_Source, slVersion);		
&lt; 				} 
---
&gt; 				if (optionsToSet.containsKey(CompilerOptions.OPTION_Compliance)) {
&gt; 					String setCompliance = (String) optionsToSet.get(CompilerOptions.OPTION_Compliance);
&gt; 					if ( ! (setCompliance.equals(CompilerOptions.VERSION_1_4 )
&gt; 				         &amp;&amp; slVersion.equals(CompilerOptions.VERSION_1_3)) ) {
&gt; 					    optionsToSet.put(CompilerOptions.OPTION_Source, slVersion);		
&gt; 					} 
&gt; 				}
</file>
</fixedFiles>
</bug>
<bug id="109173" transactionid="70340">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="17"/>
<property name="lines-added" value="221"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="7"/>
<property name="lines-churned" value="229"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-else K-false K-if K-import K-interface K-new K-null K-package K-return K-this K-true K-try K-while M O-== O-&gt; O-- O-!= O-() O-+ O-cast T V Y Z-cast Z-if Z-while</fullfingerprint>
<bugreport>Here are some suggested enhancements as a result of exhaustive testing in the 
Eclipse/OSGi environment.

1.	If no aspects are declared for a particular class loader, either 
because there are no visible aop.xml files or they contain no aspect 
definitions, then we should short-circuit the implementation of weaveClass() 
so that byte-code is not unnecessarily passed to the weaver. This is 
especially important under OSGi where there may be hundreds of class bundles, 
each with their own class loader only some of which are being woven. We can 
use the existing enabled flag.
2.	As previously discussed on aspectj-dev the META-INF directory is 
considered private in OSGi and is therefore an inappropriate location for 
aop.xml files declaring shared aspects. I therefore propose a System property 
to set the a resource names for finding aop.xml files which would default 
to META-INF/aop.xml e.g. -Dorg.aspectj.weaver.loadtime.configuration=META-
INF/aop.xml;org/aspectj/aop.xml.
3.	We should not be catching Throwable  in Aj. Instead we should catch 
known exceptions e.g. BCException and issue messages while letting other 
runtime exceptions pass back to the class loader. A user provided 
IMessageHandler implementation can decide under what circumstances to abort. 
Alternatively if Aj is considered to be a safe interface for weaving agents 
e.g. JVMTI then the dump logic it contains should be moved to the 
WeavingAdaptor so that it can be used directly from a class loader.</bugreport>
<pre-fix-testcases failing="179" file="output/109173/pre-fix/testresults.xml" passing="1532" size="1711"/>
<post-fix-testcases failing="182" file="output/109173/post-fix/testresults.xml" passing="1529" size="1711"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/Aj.java" revision="1.10" state="changed">30a31,41
&gt; 	private IWeavingContext weavingContext;
&gt; 	
&gt; 	public Aj(){
&gt; 		this(null);
&gt; 	}
&gt; 	
&gt; 	
&gt; 	public Aj(IWeavingContext context){
&gt; 		weavingContext = context;
&gt; 	}
&gt; 
54c65
&lt;             WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader);
---
&gt;             WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
76c87
&lt;         static WeavingAdaptor getWeaver(ClassLoader loader) {
---
&gt;         static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingContext) {
81c92
&lt;                         weavingAdaptor = new ClassLoaderWeavingAdaptor(loader);
---
&gt;                         weavingAdaptor = new ClassLoaderWeavingAdaptor(loader, weavingContext);
138a150,175
&gt;     
&gt;     /*
&gt;      * Shared classes methods
&gt;      */
&gt; 
&gt;     /**
&gt;      * Returns a namespace based on the contest of the aspects available
&gt;      */
&gt;     public String getNamespace (ClassLoader loader) {
&gt;         ClassLoaderWeavingAdaptor weavingAdaptor = (ClassLoaderWeavingAdaptor)WeaverContainer.getWeaver(loader, weavingContext);
&gt;     	return weavingAdaptor.getNamespace();
&gt;     }
&gt;     
&gt;     /**
&gt;      * Check to see if any classes have been generated for a particular classes loader.
&gt;      * Calls ClassLoaderWeavingAdaptor.generatedClassesExist()
&gt;      * @param loader the class cloder
&gt;      * @return       true if classes have been generated.
&gt;      */
&gt;     public boolean generatedClassesExist(ClassLoader loader){
&gt;     	return ((ClassLoaderWeavingAdaptor)WeaverContainer.getWeaver(loader, weavingContext)).generatedClassesExist();
&gt;     }
&gt;     
&gt;     public void flushGeneratedClasses(ClassLoader loader){
&gt;     	((ClassLoaderWeavingAdaptor)WeaverContainer.getWeaver(loader, weavingContext)).flushGeneratedClasses();
&gt;     }
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.13" state="changed">10a11
&gt;  *   David Knibb		       weaving context enhancments
37a39
&gt; import java.util.HashMap;
40a43
&gt; import java.util.StringTokenizer;
52a56,58
&gt;     
&gt;     private StringBuffer namespace;
&gt;     private IWeavingContext weavingContext;
54c60
&lt;     public ClassLoaderWeavingAdaptor(final ClassLoader loader) {
---
&gt;     public ClassLoaderWeavingAdaptor(final ClassLoader loader, IWeavingContext wContext) {
74a81,86
&gt;         
&gt;         if(wContext==null){
&gt;         	weavingContext = new DefaultWeavingContext(loader);
&gt;         }else{
&gt;         	weavingContext = wContext ;
&gt;         }
110d121
&lt;             Enumeration xmls = loader.getResources(AOP_XML);
120a132,138
&gt;             
&gt;             String resourcePath = System.getProperty("org.aspectj.weaver.loadtime.configuration",AOP_XML);
&gt;     		StringTokenizer st = new StringTokenizer(resourcePath,";");
&gt; 
&gt;     		while(st.hasMoreTokens()){
&gt;     			Enumeration xmls = weavingContext.getResources(st.nextToken());
&gt; //    			System.out.println("? registerDefinitions: found-aop.xml=" + xmls.hasMoreElements() + ", loader=" + loader);
122,126c140,146
&lt;             while (xmls.hasMoreElements()) {
&lt;                 URL xml = (URL) xmls.nextElement();
&lt;                 MessageUtil.info(messageHandler, "using " + xml.getFile());
&lt;                 definitions.add(DocumentParser.parse(xml));
&lt;             }
---
&gt; 
&gt;     			while (xmls.hasMoreElements()) {
&gt;     			    URL xml = (URL) xmls.nextElement();
&gt;     			    MessageUtil.info(messageHandler, "using " + xml.getFile());
&gt;     			    definitions.add(DocumentParser.parse(xml));
&gt;     			}
&gt;     		}
233a254,261
&gt;                 	
&gt;                 	//generate key for SC
&gt;                 	String aspectCode = readAspect(aspectClassName, loader);
&gt;                     if(namespace==null){
&gt;                     	namespace=new StringBuffer(aspectCode);
&gt;                     }else{
&gt;                     	namespace = namespace.append(";"+aspectCode);
&gt;                     }
346a375,433
&gt;     
&gt;     /*
&gt;      *  shared classes methods
&gt;      */
&gt;     
&gt;     /**
&gt; 	 * @return Returns the key.
&gt; 	 */
&gt; 	public String getNamespace() {
&gt; 		if(namespace==null) return "";
&gt; 		else return new String(namespace);
&gt; 	}
&gt; 
&gt;     /**
&gt;      * Check to see if any classes are stored in the generated classes cache.
&gt;      * Then flush the cache if it is not empty
&gt;      * @return true if a class has been generated and is stored in the cache
&gt;      */
&gt;     public boolean generatedClassesExist(){
&gt;     	if(generatedClasses.size()&gt;0) {
&gt;     		return true;
&gt;     	}
&gt;     	return false;
&gt;     }
&gt;     
&gt;     /**
&gt;      * Flush the generated classes cache
&gt;      */
&gt;     public void flushGeneratedClasses(){
&gt;     	generatedClasses = new HashMap();
&gt;     }
&gt;     
&gt; 
&gt;     /**
&gt;      * Read in an aspect from the disk and return its bytecode as a String
&gt;      * @param name	the name of the aspect to read in
&gt;      * @return the bytecode representation of the aspect
&gt;      */
&gt;     private String readAspect(String name, ClassLoader loader){
&gt;     	try {
&gt;     		String result = "";
&gt;         	InputStream is = loader.getResourceAsStream(name.replace('.','/')+".class");
&gt; 			int b = is.read();
&gt; 			while(b!=-1){
&gt; 				result = result + b;
&gt; 				b=is.read();
&gt; 			}
&gt; 			is.close();
&gt; 	    	return result;
&gt; 		} catch (IOException e) {
&gt; 			e.printStackTrace();
&gt; 			return "";
&gt; 		}catch (NullPointerException e) {
&gt; 			//probably tried to read in a "non aspect @missing@" aspect
&gt; 			System.err.println("ClassLoaderWeavingAdaptor.readAspect() name: "+name+"  Exception: "+e);
&gt; 			return "";
&gt; 		}
&gt;     }
&gt;     
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   David Knibb         initial implementation
 *******************************************************************************/
package org.aspectj.weaver.loadtime;

import java.io.IOException;
import java.net.URL;
import java.util.Enumeration;

/**
 * Use in non-OSGi environment
 * 
 * @author David Knibb
 */
public class DefaultWeavingContext implements IWeavingContext {
	
	private ClassLoader loader;
	
	public DefaultWeavingContext(){
		loader = getClass().getClassLoader();
	}

	/**
	 * Construct a new WeavingContext to use the specifed ClassLoader
	 * This is the constructor which should be used.
	 * @param loader
	 */
	public DefaultWeavingContext(ClassLoader loader) {
		this.loader = loader;
	}

	/**
	 * Same as ClassLoader.getResources()
	 */
	public Enumeration getResources(String name) throws IOException {
		return loader.getResources(name);
	}

	/**
	 * @return null as we are not in an OSGi environment (therefore no bundles)
	 */
	public String getBundleIdFromURL(URL url) {
		return null;
	}

}
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/IWeavingContext.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   David Knibb         initial implementation
 *******************************************************************************/
package org.aspectj.weaver.loadtime;

import java.io.IOException;
import java.net.URL;
import java.util.Enumeration;

/**
 * This class adds support to AspectJ for an OSGi environment
 * 
 * @author David Knibb
 */
public interface IWeavingContext {
	
	/**
	 * Allows the standard ClassLoader.getResources() mechanisms to be
	 * replaced with a different implementation.
	 * In an OSGi environment, this will allow for filtering to take 
	 * place on the results of ClassLoader.getResources(). In a non-OSGi
	 * environment, ClassLoader.getResources should be returned.
	 * @param name the name of the resource to search for
	 * @return an enumeration containing all of the matching resources found
	 * @throws IOException
	 */
	public Enumeration getResources(String name) throws IOException;
	
	/**
	 * In an OSGi environment, determin which bundle a URL originated from.
	 * In a non-OSGi environment, implementors should return &lt;code&gt;null&lt;code&gt;.
	 * @param url
	 * @return
	 */
	public String getBundleIdFromURL(URL url);

}
</file>
</fixedFiles>
</bug>
<bug id="109484" transactionid="72061">
<property name="files-churned" value="8"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="7"/>
<property name="hunks" value="185"/>
<property name="lines-added" value="208"/>
<property name="lines-deleted" value="35"/>
<property name="lines-modified" value="380"/>
<property name="lines-churned" value="623"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-continue K-else K-false K-for K-if K-import K-instanceof K-new K-null K-return K-true K-try K-while M O-&lt; O-== O-&gt; O-|| O-! O-!= O-/ O-() O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl Z-while</fullfingerprint>
<bugreport>In Eclipse 3.1 we need to give users the opportunity to specify the jre source
compatibility to be 1.5 when they generate their ajdoc.</bugreport>
<pre-fix-testcases failing="178" file="output/109484/pre-fix/testresults.xml" passing="1537" size="1715"/>
<post-fix-testcases failing="179" file="output/109484/post-fix/testresults.xml" passing="1536" size="1715"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ajdocexport/AJdocSpecificsWizardPage.java" revision="1.5" state="changed">2c2
&lt;  * Copyright (c) 2000, 2003 IBM Corporation and others.
---
&gt;  * Copyright (c) 2005 IBM Corporation and others.
10c10,11
&lt;  * 	   Luzius Meisser - adjusted for ajdoc 
---
&gt;  * 	   Luzius Meisser  - adjusted for ajdoc 
&gt;  *     Helen Hawkins   - updated for Eclipse 3.1 (bug 109484) 
22a24
&gt; import org.eclipse.swt.widgets.Combo;
28a31
&gt;  * Updated for Eclipse 3.1 - bug 109484
33,34c36,37
&lt; 	// AspectJ Extension - commenting out unused code
&lt; 	//private Button fAntBrowseButton;
---
&gt; //  AspectJ Extension begin - commenting out unused code
&gt; //  private Button fAntBrowseButton;
36,40c39,43
&lt; 	//private Text fAntText;
&lt; 	//private Button fOverViewButton;
&lt; 	//private Button fOverViewBrowseButton;
&lt; 	//private Button fAntButton;
&lt; 	private Button fJDK14Button;
---
&gt; /*  private Text fAntText;
&gt; 	private Button fOverViewButton;
&gt; 	private Button fOverViewBrowseButton;
&gt; 	private Button fAntButton;
&gt; */	private Combo fSourceCombo;
43c46
&lt; 	//private Text fOverViewText;
---
&gt; 	// private Text fOverViewText;
47,48c50,51
&lt; 	//private StatusInfo fOverviewStatus;
&lt; 	//private StatusInfo fAntStatus;
---
&gt; 	// private StatusInfo fOverviewStatus;
&gt; 	// private StatusInfo fAntStatus;
49a53,56
&gt; 	// private JavadocTreeWizardPage fFirstPage;
&gt; 	// AspectJ Extension end
&gt; 	
&gt; 	// AspectJ Extension - using AJdocOptionsManager rather than JavadocOptionsManager
52,53c59,61
&lt; 	//private final int OVERVIEWSTATUS= 1;
&lt; 	//private final int ANTSTATUS= 2;
---
&gt; //  AspectJ Extension - commenting out unused code
&gt; //  private final int OVERVIEWSTATUS= 1;
&gt; //  private final int ANTSTATUS= 2;
54a63
&gt; 	// AspectJ Extension - using AJdocTreeWizardPage and AJdocOptionsManager in constructor
56a66
&gt;         // AspectJ Extension - using AJDT messages to set the description	
58a69,73
&gt; 		
&gt;         // AspectJ Extension - commenting out unused code
&gt; 		/* fOverviewStatus= new StatusInfo();
&gt; 		fAntStatus= new StatusInfo();
&gt; 		fFirstPage= firstPage;*/
89,109c104,123
&lt; //		 AspectJ Extension - commenting out unused code
&lt; //		fOverViewButton= createButton(c, SWT.CHECK, JavadocExportMessages.getString("JavadocSpecificsWizardPage.overviewbutton.label"), createGridData(1)); //$NON-NLS-1$
&lt; //		fOverViewText= createText(c, SWT.SINGLE | SWT.BORDER, null, createGridData(GridData.FILL_HORIZONTAL, 1, 0));
&lt; //		fOverViewButton.setEnabled(false);
&lt; //		
&lt; //		//there really aught to be a way to specify this
&lt; //		 ((GridData) fOverViewText.getLayoutData()).widthHint= 200;
&lt; //		fOverViewBrowseButton= createButton(c, SWT.PUSH, JavadocExportMessages.getString("JavadocSpecificsWizardPage.overviewbrowse.label"), createGridData(GridData.HORIZONTAL_ALIGN_END, 1, 0)); //$NON-NLS-1$
&lt; //		SWTUtil.setButtonDimensionHint(fOverViewBrowseButton);
&lt; //
&lt; //		String str= fStore.getOverview();
&lt; //		if (str.length() == 0) {
&lt; //			//default
&lt; //			fOverViewText.setEnabled(false);
&lt; //			fOverViewBrowseButton.setEnabled(false);
&lt; //		} else {
&lt; //			fOverViewButton.setSelection(true);
&lt; //			fOverViewText.setText(str);
&lt; //		}
&lt; 
&lt; 		createLabel(c, SWT.NONE, UIMessages.ajdocSpecificsWizardPage_vmoptionsfield_label, createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 3, 0));
---
&gt; 		// AspectJ Extension - commenting out unused code
&gt; /*		fOverViewButton= createButton(c, SWT.CHECK, JavadocExportMessages.JavadocSpecificsWizardPage_overviewbutton_label, createGridData(1)); 
&gt; 		fOverViewText= createText(c, SWT.SINGLE | SWT.BORDER, null, createGridData(GridData.FILL_HORIZONTAL, 1, 0));
&gt; 		there really aught to be a way to specify this
&gt; 		((GridData) fOverViewText.getLayoutData()).widthHint= 200;
&gt; 		fOverViewBrowseButton= createButton(c, SWT.PUSH, JavadocExportMessages.JavadocSpecificsWizardPage_overviewbrowse_label, createGridData(GridData.HORIZONTAL_ALIGN_END, 1, 0)); 
&gt; 		SWTUtil.setButtonDimensionHint(fOverViewBrowseButton);
&gt; 
&gt; 		String str= fStore.getOverview();
&gt; 		if (str.length() == 0) {
&gt; 			//default
&gt; 			fOverViewText.setEnabled(false);
&gt; 			fOverViewBrowseButton.setEnabled(false);
&gt; 		} else {
&gt; 			fOverViewButton.setSelection(true);
&gt; 			fOverViewText.setText(str);
&gt; 		}
&gt; */
&gt; 		// AspectJ Extension - changing message string to use AJDT one
&gt; 		createLabel(composite, SWT.NONE, UIMessages.ajdocSpecificsWizardPage_vmoptionsfield_label, createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 3, 0)); 
113c127,128
&lt; 		createLabel(composite, SWT.NONE, UIMessages.ajdocSpecificsWizardPage_extraoptionsfield_label, createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 3, 0));
---
&gt; 		
&gt; 		createLabel(composite, SWT.NONE, JavadocExportMessages.JavadocSpecificsWizardPage_extraoptionsfield_label, createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 3, 0)); 
115c130
&lt; 		fExtraOptionsText.setSize(convertWidthInCharsToPixels(60), convertHeightInCharsToPixels(8));
---
&gt; 		//fExtraOptionsText.setSize(convertWidthInCharsToPixels(60), convertHeightInCharsToPixels(10));
118,121d132
&lt; 
&lt; 		// TODO: fix the ajdoc pages to fit with Eclipse 3.1
&lt; 		fJDK14Button= createButton(composite, SWT.CHECK, UIMessages.jre_1_4_src_compatability, createGridData(3));
&lt; 		fJDK14Button.setSelection(fStore.isJDK14Mode());
123,141c134,141
&lt; //		 AspectJ Extension - commenting out unused code
&lt; 		//Listeners
&lt; //		fOverViewButton.addSelectionListener(new ToggleSelectionAdapter(new Control[] { fOverViewBrowseButton, fOverViewText }) {
&lt; //			public void validate() {
&lt; //				doValidation(OVERVIEWSTATUS);
&lt; //			}
&lt; //		});
&lt; //
&lt; //		fOverViewText.addModifyListener(new ModifyListener() {
&lt; //			public void modifyText(ModifyEvent e) {
&lt; //				doValidation(OVERVIEWSTATUS);
&lt; //			}
&lt; //		});
&lt; //
&lt; //		fOverViewBrowseButton.addSelectionListener(new SelectionAdapter() {
&lt; //			public void widgetSelected(SelectionEvent event) {
&lt; //				handleFileBrowseButtonPressed(fOverViewText, new String[] { "*.html" }, JavadocExportMessages.getString("JavadocSpecificsWizardPage.overviewbrowsedialog.title")); //$NON-NLS-1$ //$NON-NLS-2$
&lt; //			}
&lt; //		});
---
&gt; 		Composite inner= new Composite(composite, SWT.NONE);
&gt; 		inner.setLayoutData(new GridData(GridData.FILL, GridData.BEGINNING, false, false, 3, 1));
&gt; 		GridLayout layout= new GridLayout(2, false);
&gt; 		layout.marginHeight= 0;
&gt; 		layout.marginWidth= 0;
&gt; 		inner.setLayout(layout);
&gt; 		
&gt; 		createLabel(inner, SWT.NONE, JavadocExportMessages.JavadocSpecificsWizardPage_sourcecompatibility_label, createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 1, 0)); 
142a143,168
&gt; 		fSourceCombo= createCombo(inner, SWT.NONE, fStore.getSource(), createGridData(1));
&gt; 		String[] versions= { "-", "1.3", "1.4", "1.5" };//$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$ //$NON-NLS-4$
&gt; 		fSourceCombo.setItems(versions);   
&gt; 		fSourceCombo.setText(fStore.getSource());
&gt; 		
&gt; 		
&gt; 		// AspectJ Extension - commenting out unused code
&gt; /*		//Listeners
&gt; 		fOverViewButton.addSelectionListener(new ToggleSelectionAdapter(new Control[] { fOverViewBrowseButton, fOverViewText }) {
&gt; 			public void validate() {
&gt; 				doValidation(OVERVIEWSTATUS);
&gt; 			}
&gt; 		});
&gt; 
&gt; 		fOverViewText.addModifyListener(new ModifyListener() {
&gt; 			public void modifyText(ModifyEvent e) {
&gt; 				doValidation(OVERVIEWSTATUS);
&gt; 			}
&gt; 		});
&gt; 
&gt; 		fOverViewBrowseButton.addSelectionListener(new SelectionAdapter() {
&gt; 			public void widgetSelected(SelectionEvent event) {
&gt; 				handleFileBrowseButtonPressed(fOverViewText, new String[] { "*.html" }, JavadocExportMessages.JavadocSpecificsWizardPage_overviewbrowsedialog_title);  //$NON-NLS-1$
&gt; 			}
&gt; 		});
&gt; */
145d170
&lt; 	
152,167c177,191
&lt; //		 AspectJ Extension - commenting out unused code
&lt; //		fAntButton= createButton(c, SWT.CHECK, JavadocExportMessages.getString("JavadocSpecificsWizardPage.antscriptbutton.label"), createGridData(3)); //$NON-NLS-1$
&lt; //		fAntButton.setEnabled(false);
&lt; //		createLabel(c, SWT.NONE, JavadocExportMessages.getString("JavadocSpecificsWizardPage.antscripttext.label"), createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 1, 0)); //$NON-NLS-1$
&lt; //		fAntText= createText(c, SWT.SINGLE | SWT.BORDER, null, createGridData(GridData.FILL_HORIZONTAL, 1, 0));
&lt; //		//there really aught to be a way to specify this
&lt; //		 ((GridData) fAntText.getLayoutData()).widthHint= 200;
&lt; //
&lt; //		fAntText.setText(fStore.getAntpath());
&lt; //
&lt; //		fAntBrowseButton= createButton(c, SWT.PUSH, JavadocExportMessages.getString("JavadocSpecificsWizardPage.antscriptbrowse.label"), createGridData(GridData.HORIZONTAL_ALIGN_END, 1, 0)); //$NON-NLS-1$
&lt; //		SWTUtil.setButtonDimensionHint(fAntBrowseButton);
&lt; //		fAntText.setEnabled(false);
&lt; //		fAntBrowseButton.setEnabled(false);
&lt; 		
&lt; 		fCheckbrowser= createButton(c, SWT.CHECK, JavadocExportMessages.JavadocSpecificsWizardPage_openbrowserbutton_label, createGridData(3));
---
&gt; //		AspectJ Extension - commenting out unused code
&gt; /*		fAntButton= createButton(c, SWT.CHECK, JavadocExportMessages.JavadocSpecificsWizardPage_antscriptbutton_label, createGridData(3)); 
&gt; 		createLabel(c, SWT.NONE, JavadocExportMessages.JavadocSpecificsWizardPage_antscripttext_label, createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 1, 0)); 
&gt; 		fAntText= createText(c, SWT.SINGLE | SWT.BORDER, null, createGridData(GridData.FILL_HORIZONTAL, 1, 0));
&gt; 		//there really aught to be a way to specify this
&gt; 		 ((GridData) fAntText.getLayoutData()).widthHint= 200;
&gt; 
&gt; 		fAntText.setText(fStore.getAntpath());
&gt; 
&gt; 		fAntBrowseButton= createButton(c, SWT.PUSH, JavadocExportMessages.JavadocSpecificsWizardPage_antscriptbrowse_label, createGridData(GridData.HORIZONTAL_ALIGN_END, 1, 0)); 
&gt; 		SWTUtil.setButtonDimensionHint(fAntBrowseButton);
&gt; 		fAntText.setEnabled(false);
&gt; 		fAntBrowseButton.setEnabled(false);
&gt; */		
&gt; 		fCheckbrowser= createButton(c, SWT.CHECK, JavadocExportMessages.JavadocSpecificsWizardPage_openbrowserbutton_label, createGridData(3)); 
170,208c194,223
&lt; //		 AspectJ Extension - commenting out unused code
&lt; //		fAntButton.addSelectionListener(new ToggleSelectionAdapter(new Control[] { fAntText, fAntBrowseButton }) {
&lt; //			public void validate() {
&lt; //				doValidation(ANTSTATUS);
&lt; //			}
&lt; //		});
&lt; //
&lt; //		fAntText.addModifyListener(new ModifyListener() {
&lt; //			public void modifyText(ModifyEvent e) {
&lt; //				doValidation(ANTSTATUS);
&lt; //			}
&lt; //		});
&lt; //
&lt; //		fAntBrowseButton.addSelectionListener(new SelectionAdapter() {
&lt; //			public void widgetSelected(SelectionEvent event) {
&lt; //
&lt; //				String temp= fAntText.getText();
&lt; //				IPath path= new Path(temp);
&lt; //				String file= path.lastSegment();
&lt; //				if (file == null)
&lt; //					file= "javadoc.xml";//$NON-NLS-1$
&lt; //				path= path.removeLastSegments(1);
&lt; //
&lt; //				temp= handleFolderBrowseButtonPressed(path.toOSString(), fAntText.getShell(), JavadocExportMessages.getString("JavadocSpecificsWizardPage.antscriptbrowsedialog.title"), JavadocExportMessages.getString("JavadocSpecificsWizardPage.antscriptbrowsedialog.label")); //$NON-NLS-1$ //$NON-NLS-2$
&lt; //
&lt; //				path= new Path(temp);
&lt; //				path= path.addTrailingSeparator().append(file);
&lt; //				fAntText.setText(path.toOSString());
&lt; //
&lt; //			}
&lt; //		});
&lt; 	} //end method createExtraOptionsGroup
&lt; 	
&lt; //	 AspectJ Extension - commenting out unused code	
&lt; 	/*
&lt; 	private void doValidation(int val) {
&lt; 		File file= null;
&lt; 		String ext= null;
&lt; 		Path path= null;
---
&gt; // 	    AspectJ Extension - commenting out unused code
&gt; /*		fAntButton.addSelectionListener(new ToggleSelectionAdapter(new Control[] { fAntText, fAntBrowseButton }) {
&gt; 			public void validate() {
&gt; 				doValidation(ANTSTATUS);
&gt; 			}
&gt; 		});
&gt; 
&gt; 		fAntText.addModifyListener(new ModifyListener() {
&gt; 			public void modifyText(ModifyEvent e) {
&gt; 				doValidation(ANTSTATUS);
&gt; 			}
&gt; 		});
&gt; 
&gt; 		fAntBrowseButton.addSelectionListener(new SelectionAdapter() {
&gt; 			public void widgetSelected(SelectionEvent event) {
&gt; 				String temp= fAntText.getText();
&gt; 				IPath path= Path.fromOSString(temp);
&gt; 				String file= path.lastSegment();
&gt; 				if (file == null)
&gt; 					file= "javadoc.xml";//$NON-NLS-1$
&gt; 				path= path.removeLastSegments(1);
&gt; 
&gt; 				String selected= handleFolderBrowseButtonPressed(path.toOSString(), JavadocExportMessages.JavadocSpecificsWizardPage_antscriptbrowsedialog_title, JavadocExportMessages.JavadocSpecificsWizardPage_antscriptbrowsedialog_label); 
&gt; 
&gt; 				path= Path.fromOSString(selected).append(file);
&gt; 				fAntText.setText(path.toOSString());
&gt; 
&gt; 			}
&gt; 		});
&gt; */	} //end method createExtraOptionsGroup
209a225,226
&gt; //  AspectJ Extension - commenting out unused code
&gt; /*	private void doValidation(int val) {
215,221c232,242
&lt; 					path= new Path(fOverViewText.getText());
&lt; 					file= path.toFile();
&lt; 					ext= path.getFileExtension();
&lt; 					if ((file == null) || !file.exists()) {
&lt; 						fOverviewStatus.setError(JavadocExportMessages.getString("JavadocSpecificsWizardPage.overviewnotfound.error")); //$NON-NLS-1$
&lt; 					} else if ((ext == null) || !ext.equalsIgnoreCase("html")) { //$NON-NLS-1$
&lt; 						fOverviewStatus.setError(JavadocExportMessages.getString("JavadocSpecificsWizardPage.overviewincorrect.error")); //$NON-NLS-1$
---
&gt; 					String filename= fOverViewText.getText();
&gt; 					if (filename.length() == 0) {
&gt; 						fOverviewStatus.setError(JavadocExportMessages.JavadocSpecificsWizardPage_overviewnotfound_error); 
&gt; 					} else {
&gt; 						File file= new File(filename);
&gt; 						String ext= filename.substring(filename.lastIndexOf('.') + 1);
&gt; 						if (!file.isFile()) {
&gt; 							fOverviewStatus.setError(JavadocExportMessages.JavadocSpecificsWizardPage_overviewnotfound_error); 
&gt; 						} else if (!ext.equalsIgnoreCase("html")) { //$NON-NLS-1$
&gt; 							fOverviewStatus.setError(JavadocExportMessages.JavadocSpecificsWizardPage_overviewincorrect_error); 
&gt; 						}
228,235c249,259
&lt; 					path= new Path(fAntText.getText());
&lt; 					ext= path.getFileExtension();
&lt; 					IPath antSeg= path.removeLastSegments(1);
&lt; 
&lt; 					if ((!antSeg.isValidPath(antSeg.toOSString())) || (ext == null) || !(ext.equalsIgnoreCase("xml"))) //$NON-NLS-1$
&lt; 						fAntStatus.setError(JavadocExportMessages.getString("JavadocSpecificsWizardPage.antfileincorrect.error")); //$NON-NLS-1$
&lt; 					else if (path.toFile().exists())
&lt; 						fAntStatus.setWarning(JavadocExportMessages.getString("JavadocSpecificsWizardPage.antfileoverwrite.warning")); //$NON-NLS-1$
---
&gt; 					String filename= fAntText.getText();
&gt; 					if (filename.length() == 0) {
&gt; 						fOverviewStatus.setError(JavadocExportMessages.JavadocSpecificsWizardPage_antfileincorrect_error); 
&gt; 					} else {
&gt; 						File file= new File(filename);
&gt; 						String ext= filename.substring(filename.lastIndexOf('.') + 1);
&gt; 						if (file.isDirectory() || !(ext.equalsIgnoreCase("xml"))) //$NON-NLS-1$
&gt; 							fAntStatus.setError(JavadocExportMessages.JavadocSpecificsWizardPage_antfileincorrect_error); 
&gt; 						else if (file.exists())
&gt; 							fAntStatus.setWarning(JavadocExportMessages.JavadocSpecificsWizardPage_antfileoverwrite_warning); 
&gt; 					}
242,244c266,267
&lt; 	}
&lt; 	*/
&lt; 	
---
&gt; 	} */
&gt; 
246c269
&lt; 	 * @see AJdocWizardPage#onFinish()
---
&gt; 	 * @see JavadocWizardPage#onFinish()
254,258c277,281
&lt; //		 AspectJ Extension - commenting out unused code
&lt; //		if (fOverViewText.getEnabled())
&lt; //			fStore.setOverview(fOverViewText.getText());
&lt; //		else
&lt; //			fStore.setOverview(""); //$NON-NLS-1$
---
&gt; //      AspectJ Extension - commenting out unused code
&gt; /*		if (fOverViewText.getEnabled())
&gt; 			fStore.setOverview(fOverViewText.getText());
&gt; 		else
&gt; 			fStore.setOverview(""); //$NON-NLS-1$
261,265c284,288
&lt; //		if (fAntText.getEnabled()) {
&lt; //			fStore.setGeneralAntpath(fAntText.getText());
&lt; //		}
&lt; 		fStore.setOpenInBrowser(fCheckbrowser.getSelection());
&lt; 		fStore.setJDK14Mode(fJDK14Button.getSelection());
---
&gt; 		if (fAntText.getEnabled()) {
&gt; 			fStore.setGeneralAntpath(fAntText.getText());
&gt; 		}
&gt; */		fStore.setOpenInBrowser(fCheckbrowser.getSelection());
&gt; 		fStore.setSource(fSourceCombo.getText());
271,277c294,300
&lt; //		 AspectJ Extension - commenting out unused code
&lt; 		//if (visible) {
&lt; 			//doValidation(OVERVIEWSTATUS);
&lt; 			//doValidation(ANTSTATUS);
&lt; 			//fCheckbrowser.setVisible(!fFirstPage.getCustom());
&lt; 		//}
&lt; 	}
---
&gt; //		AspectJ Extension - commenting out unused code
&gt; /*		if (visible) {
&gt; 			doValidation(OVERVIEWSTATUS);
&gt; 			doValidation(ANTSTATUS);
&gt; 			fCheckbrowser.setVisible(!fFirstPage.getCustom());
&gt; 		}
&gt; */	}
283,284c306,307
&lt; //	 AspectJ Extension - commenting out unused code
&lt; 	/*private IStatus findMostSevereStatus() {
---
&gt; //  AspectJ Extension - commenting out unused code
&gt; /*	private IStatus findMostSevereStatus() {
287,290c310,311
&lt; 	*/
&lt; 	
&lt; //	 AspectJ Extension - commenting out unused code
&lt; 	/*public boolean generateAnt() {
---
&gt; 
&gt; 	public boolean generateAnt() {
293c314,315
&lt; 	*/
---
&gt; */
&gt; 	
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ajdocexport/AJdocTreeWizardPage.java" revision="1.4" state="changed">10c10,11
&lt;  *     Luzius Meisser - adjusted for ajdoc 
---
&gt;  *     Luzius Meisser  - adjusted for ajdoc 
&gt;  *     Helen Hawkins   - updated to Eclipse 3.1
17,19d17
&lt; import java.util.Iterator;
&lt; import java.util.Set;
&lt; import java.util.StringTokenizer;
22a21,22
&gt; import org.eclipse.core.resources.IWorkspaceRoot;
&gt; import org.eclipse.core.resources.ResourcesPlugin;
67a68
&gt;  * Updated for Eclipse 3.1 - bug 109484
70c71
&lt; public class AJdocTreeWizardPage extends AJdocWizardPage{
---
&gt; public class AJdocTreeWizardPage extends AJdocWizardPage {
74a76
&gt; 	// AspectJ Extension - renaming fJavadocCommandText to be fAJdocCommandText
76,78c78,80
&lt; //	 AspectJ Extension - commenting out unused code
&lt; //	private Text fDocletText;
&lt; //	private Text fDocletTypeText;
---
&gt; 	// AspectJ Extension begin - commenting out unused code
&gt; 	//private Text fDocletText;
&gt; 	//private Text fDocletTypeText;
81c83
&lt; //	private Button fCustomButton;
---
&gt; 	//private Button fCustomButton;
86,87c88,90
&lt; //	private Label fDocletLabel;
&lt; //	private Label fDocletTypeLabel;
---
&gt; 	//private Label fDocletLabel;
&gt; 	//private Label fDocletTypeLabel;
&gt; 	// AspectJ Extension end
93c96
&lt; //	 AspectJ Extension
---
&gt; 	// AspectJ Extension - using AJdocOptionsManager instead
115,116c118,120
&lt; //		 AspectJ Extension - message
&lt; 		setDescription(UIMessages.ajdocTreeWizardPage_javadoctreewizardpage_description);
---
&gt; 		// AspectJ Extension - message
&gt; 		setDescription(UIMessages.ajdocTreeWizardPage_javadoctreewizardpage_description); 
&gt; 
138a143
&gt; 		// AspectJ Extension - renaming method to be ajdoc
149c154
&lt; 	
---
&gt; 	// AspectJ Extension - renaming method to be ajdoc
175a181
&gt; 				// AspectJ Extension - updating method name
179a186
&gt; 	
194a202
&gt; 		// AspectJ Extension - using aj equivalents
237a246
&gt; 					// AspectJ Extension - messages
245a255
&gt; 					// AspectJ Extension - messages
253a264
&gt; 					// AspectJ Extension - messages
262a274
&gt; 					// AspectJ Extension - messages
273c285
&lt; //		 AspectJ Extension - message
---
&gt; //		 AspectJ Extension - messages
318,320c330,332
&lt; //		 AspectJ Extension - commenting out unused code
&lt; 		//Option to use custom doclet
&lt; 		//fCustomButton= createButton(group, SWT.RADIO, JavadocExportMessages.getString("JavadocTreeWizardPage.customdocletbutton.label"), createGridData(GridData.HORIZONTAL_ALIGN_FILL, numColumns, 0)); //$NON-NLS-1$
---
&gt; //      AspectJ Extension - commenting out unused code
&gt; /*		//Option to use custom doclet
&gt; 		fCustomButton= createButton(group, SWT.RADIO, JavadocExportMessages.JavadocTreeWizardPage_customdocletbutton_label, createGridData(GridData.HORIZONTAL_ALIGN_FILL, numColumns, 0)); 
323,344c335,355
&lt; //		fDocletTypeLabel= createLabel(group, SWT.NONE, JavadocExportMessages.getString("JavadocTreeWizardPage.docletnamefield.label"), createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 1, convertWidthInCharsToPixels(3))); //$NON-NLS-1$
&lt; //		fDocletTypeText= createText(group, SWT.SINGLE | SWT.BORDER, null, createGridData(GridData.HORIZONTAL_ALIGN_FILL, numColumns - 1, 0));
&lt; //		((GridData) fDocletTypeText.getLayoutData()).widthHint= 0;
&lt; 		
&lt; 		
&lt; //		fDocletTypeText.addModifyListener(new ModifyListener() {
&lt; //			public void modifyText(ModifyEvent e) {
&lt; //				doValidation(CUSTOMSTATUS);
&lt; //			}
&lt; //
&lt; //		});
&lt; //
&lt; //		fDocletLabel= createLabel(group, SWT.NONE, JavadocExportMessages.getString("JavadocTreeWizardPage.docletpathfield.label"), createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 1, convertWidthInCharsToPixels(3))); //$NON-NLS-1$
&lt; //		fDocletText= createText(group, SWT.SINGLE | SWT.BORDER, null, createGridData(GridData.HORIZONTAL_ALIGN_FILL, numColumns - 1, 0));
&lt; //		((GridData) fDocletText.getLayoutData()).widthHint= 0;
&lt; //		
&lt; //		fDocletText.addModifyListener(new ModifyListener() {
&lt; //			public void modifyText(ModifyEvent e) {
&lt; //				doValidation(CUSTOMSTATUS);
&lt; //			}
&lt; //
&lt; //		});
---
&gt; 		fDocletTypeLabel= createLabel(group, SWT.NONE, JavadocExportMessages.JavadocTreeWizardPage_docletnamefield_label, createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 1, convertWidthInCharsToPixels(3))); 
&gt; 		fDocletTypeText= createText(group, SWT.SINGLE | SWT.BORDER, null, createGridData(GridData.HORIZONTAL_ALIGN_FILL, numColumns - 1, 0));
&gt; 		((GridData) fDocletTypeText.getLayoutData()).widthHint= 0;
&gt; 		
&gt; 		
&gt; 		fDocletTypeText.addModifyListener(new ModifyListener() {
&gt; 			public void modifyText(ModifyEvent e) {
&gt; 				doValidation(CUSTOMSTATUS);
&gt; 			}
&gt; 		});
&gt; 
&gt; 		fDocletLabel= createLabel(group, SWT.NONE, JavadocExportMessages.JavadocTreeWizardPage_docletpathfield_label, createGridData(GridData.HORIZONTAL_ALIGN_BEGINNING, 1, convertWidthInCharsToPixels(3))); 
&gt; 		fDocletText= createText(group, SWT.SINGLE | SWT.BORDER, null, createGridData(GridData.HORIZONTAL_ALIGN_FILL, numColumns - 1, 0));
&gt; 		((GridData) fDocletText.getLayoutData()).widthHint= 0;
&gt; 		
&gt; 		fDocletText.addModifyListener(new ModifyListener() {
&gt; 			public void modifyText(ModifyEvent e) {
&gt; 				doValidation(CUSTOMSTATUS);
&gt; 			}
&gt; 
&gt; 		});
347,359c358,370
&lt; //		fCustomButton.addSelectionListener(new EnableSelectionAdapter(new Control[] { fDocletLabel, fDocletText, fDocletTypeLabel, fDocletTypeText }, new Control[] { fDestinationLabel, fDestinationText, fDestinationBrowserButton }));
&lt; //		fCustomButton.addSelectionListener(new SelectionAdapter() {
&lt; //			public void widgetSelected(SelectionEvent e) {
&lt; //				doValidation(CUSTOMSTATUS);
&lt; //			}
&lt; //		});
&lt; //		fStandardButton.addSelectionListener(new EnableSelectionAdapter(new Control[] { fDestinationLabel, fDestinationText, fDestinationBrowserButton }, new Control[] { fDocletLabel, fDocletText, fDocletTypeLabel, fDocletTypeText }));
&lt; //		fStandardButton.addSelectionListener(new SelectionAdapter() {
&lt; //			public void widgetSelected(SelectionEvent e) {
&lt; //				doValidation(STANDARDSTATUS);
&lt; //			}
&lt; //		});
&lt; 		fDestinationBrowserButton.addSelectionListener(new SelectionAdapter() {
---
&gt; 		fCustomButton.addSelectionListener(new EnableSelectionAdapter(new Control[] { fDocletLabel, fDocletText, fDocletTypeLabel, fDocletTypeText }, new Control[] { fDestinationLabel, fDestinationText, fDestinationBrowserButton }));
&gt; 		fCustomButton.addSelectionListener(new SelectionAdapter() {
&gt; 			public void widgetSelected(SelectionEvent e) {
&gt; 				doValidation(CUSTOMSTATUS);
&gt; 			}
&gt; 		});
&gt; 		fStandardButton.addSelectionListener(new EnableSelectionAdapter(new Control[] { fDestinationLabel, fDestinationText, fDestinationBrowserButton }, new Control[] { fDocletLabel, fDocletText, fDocletTypeLabel, fDocletTypeText }));
&gt; 		fStandardButton.addSelectionListener(new SelectionAdapter() {
&gt; 			public void widgetSelected(SelectionEvent e) {
&gt; 				doValidation(STANDARDSTATUS);
&gt; 			}
&gt; 		});
&gt; */		fDestinationBrowserButton.addSelectionListener(new SelectionAdapter() {
370,374c381,385
&lt; //	 AspectJ Extension - commenting out unused code
&lt; //	public boolean getCustom() {
&lt; //		return fCustomButton.getSelection();
&lt; //	}
&lt; 
---
&gt; 	// AspectJ Extension - commenting out unused code
&gt; /*	public boolean getCustom() {
&gt; 		return fCustomButton.getSelection();
&gt; 	}
&gt; */
378,382c389,393
&lt; //			 AspectJ Extension - commenting out unused code
&lt; //			fCustomButton.setSelection(true);
&lt; //			fDocletText.setText(fStore.getDocletPath());
&lt; //			fDocletTypeText.setText(fStore.getDocletName());
&lt; 			fDestinationText.setText(fStore.getDestination());
---
&gt; 		    // AspectJ Extension - commenting out unused code
&gt; /*			fCustomButton.setSelection(true);
&gt; 			fDocletText.setText(fStore.getDocletPath());
&gt; 			fDocletTypeText.setText(fStore.getDocletName());
&gt; */			fDestinationText.setText(fStore.getDestination());
390,397c401,408
&lt; //			 AspectJ Extension - commenting out unused code
&lt; //			fDocletText.setText(fStore.getDocletPath());
&lt; //			fDocletTypeText.setText(fStore.getDocletName());
&lt; //			fDocletText.setEnabled(false);
&lt; //			fDocletLabel.setEnabled(false);
&lt; //			fDocletTypeText.setEnabled(false);
&lt; //			fDocletTypeLabel.setEnabled(false);
&lt; 		}
---
&gt; 		    // AspectJ Extension - commenting out unused code
&gt; /*			fDocletText.setText(fStore.getDocletPath());
&gt; 			fDocletTypeText.setText(fStore.getDocletName());
&gt; 			fDocletText.setEnabled(false);
&gt; 			fDocletLabel.setEnabled(false);
&gt; 			fDocletTypeText.setEnabled(false);
&gt; 			fDocletTypeLabel.setEnabled(false);
&gt; */		}
398a410
&gt; 		// AspectJ Extension - using fAJdocCommandText instead
455a468
&gt; 		IWorkspaceRoot root= ResourcesPlugin.getWorkspace().getRoot();
458d470
&lt; 
460,462c472,476
&lt; 				IPath p= curr.getProject().getLocation();
&lt; 				if (p == null)
&lt; 					continue;
---
&gt; 				IPath outputLocation= null;
&gt; 				
&gt; 				IResource outputPathFolder= root.findMember(curr.getOutputLocation());
&gt; 				if (outputPathFolder != null)
&gt; 					outputLocation= outputPathFolder.getLocation();
464d477
&lt; 				IPath outputLocation= p.append(curr.getOutputLocation());
466d478
&lt; 
468,469c480,481
&lt; 					IPath path= new Path(classPath[i]);
&lt; 					if (!outputLocation.equals(path)) {
---
&gt; 					IPath path= Path.fromOSString(classPath[i]);
&gt; 					if (!path.equals(outputLocation)) {
479a492
&gt; 	
484c497,498
&lt; 	private IJavaElement[] getSourceElements(IJavaProject[] projects) {
---
&gt; //	 AspectJ Extension - commenting out unused code
&gt; /*	private IJavaElement[] getSourceElements(IJavaProject[] projects) {
542c556
&lt; 
---
&gt; */
544,550c558,564
&lt; //		 AspectJ Extension - commenting out unused code
&lt; //		if (fCustomButton.getSelection()) {
&lt; //			fStore.setDocletName(fDocletTypeText.getText());
&lt; //			fStore.setDocletPath(fDocletText.getText());
&lt; //			fStore.setFromStandard(false);
&lt; //		}
&lt; 		if (fStandardButton.getSelection()) {
---
&gt; 	    // AspectJ Extension - commenting out unused code
&gt; /*		if (fCustomButton.getSelection()) {
&gt; 			fStore.setDocletName(fDocletTypeText.getText());
&gt; 			fStore.setDocletPath(fDocletText.getText());
&gt; 			fStore.setFromStandard(false);
&gt; 		}
&gt; */		if (fStandardButton.getSelection()) {
559c573,576
&lt; 		fStore.setCheckedProjects(checkedProjects);
---
&gt; 		// AspectJ Extension - setting the selected elements to be the checked
&gt; 		// projects because that's all we're interested in - the build
&gt; 		// configs will sort out what needs to be included. 
&gt; 		fStore.setSelectedElements(checkedProjects);
561a579
&gt; 		// AspectJ Extension - adding ajdoc command instead of javadoc
597,613c615,631
&lt; //				 AspectJ Extension - comemnting out unused code
&lt; //				if (fCustomButton.getSelection()) {
&lt; //					fDestinationStatus= new StatusInfo();
&lt; //					fDocletStatus= new StatusInfo();
&lt; //					String doclet= fDocletTypeText.getText();
&lt; //					String docletPath= fDocletText.getText();
&lt; //					if (doclet.length() == 0) {
&lt; //						fDocletStatus.setError(JavadocExportMessages.getString("JavadocTreeWizardPage.nodocletname.error")); //$NON-NLS-1$
&lt; //
&lt; //					} else if (JavaConventions.validateJavaTypeName(doclet).matches(IStatus.ERROR)) {
&lt; //						fDocletStatus.setError(JavadocExportMessages.getString("JavadocTreeWizardPage.invaliddocletname.error")); //$NON-NLS-1$
&lt; //					} else if ((docletPath.length() == 0) || !validDocletPath(docletPath)) {
&lt; //						fDocletStatus.setError(JavadocExportMessages.getString("JavadocTreeWizardPage.invaliddocletpath.error")); //$NON-NLS-1$
&lt; //					}
&lt; //					updateStatus(findMostSevereStatus());
&lt; //				}
&lt; 				break;
---
&gt; 				// AspectJ Extension - commenting out unused code
&gt; /*				if (fCustomButton.getSelection()) {
&gt; 					fDestinationStatus= new StatusInfo();
&gt; 					fDocletStatus= new StatusInfo();
&gt; 					String doclet= fDocletTypeText.getText();
&gt; 					String docletPath= fDocletText.getText();
&gt; 					if (doclet.length() == 0) {
&gt; 						fDocletStatus.setError(JavadocExportMessages.JavadocTreeWizardPage_nodocletname_error); 
&gt; 
&gt; 					} else if (JavaConventions.validateJavaTypeName(doclet).matches(IStatus.ERROR)) {
&gt; 						fDocletStatus.setError(JavadocExportMessages.JavadocTreeWizardPage_invaliddocletname_error); 
&gt; 					} else if ((docletPath.length() == 0) || !validDocletPath(docletPath)) {
&gt; 						fDocletStatus.setError(JavadocExportMessages.JavadocTreeWizardPage_invaliddocletpath_error); 
&gt; 					}
&gt; 					updateStatus(findMostSevereStatus());
&gt; 				}
&gt; */				break;
619,620c637,638
&lt; 					IPath path= new Path(fDestinationText.getText());
&lt; 					if (Path.ROOT.equals(path) || Path.EMPTY.equals(path)) {
---
&gt; 					String dest= fDestinationText.getText();
&gt; 					if (dest.length() == 0) {
623,624c641,642
&lt; 					File file= new File(path.toOSString());
&lt; 					if (!path.isValidPath(path.toOSString()) || file.isFile()) {
---
&gt; 					File file= new File(dest);
&gt; 					if (!Path.ROOT.isValidPath(dest) || file.isFile()) {
627,629c645,647
&lt; //					 AspectJ Extension - message
&lt; 					if ((path.append("package-list").toFile().exists()) || (path.append("index.html").toFile().exists())) //$NON-NLS-1$//$NON-NLS-2$
&lt; 						fDestinationStatus.setWarning(UIMessages.ajdocTreeWizardPage_warning_mayoverwritefiles);
---
&gt; 					// AspectJ Extension - message
&gt; 					if (new File(dest, "package-list").exists() || new File(dest, "index.html").exists()) //$NON-NLS-1$//$NON-NLS-2$
&gt; 						fDestinationStatus.setWarning(UIMessages.ajdocTreeWizardPage_warning_mayoverwritefiles); 
637,640c655,661
&lt; //				 AspectJ Extension - message
&lt; 				if (fInputGroup.getCheckedElementCount() == 0){
&lt; 					fTreeStatus.setError(UIMessages.ajdoc_error_noProjectSelected);
&lt; 				}
---
&gt; 				// AspectJ Extension - there is just a list of projects, thefore we need
&gt; 				// to check if there are any checked projects rather than getting all the 
&gt; 				// checked items. 
&gt; 				//if (!fInputGroup.getAllCheckedListItems().hasNext())
&gt; 				if (fInputGroup.getCheckedElementCount() == 0)
&gt; 					// AspectJ Extension - updated message
&gt; 					fTreeStatus.setError(UIMessages.ajdoc_error_noProjectSelected); 
646a668
&gt; 				// AspectJ Extension - using fAJdocCommandText instead
648c670
&lt; //				 AspectJ Extension - message
---
&gt; 				// AspectJ Extension - messages
650,651c672,673
&lt; 					fJavadocStatus.setError(UIMessages.ajdocTreeWizardPage_ajdoccmd_error_enterpath);
&lt; 					} else {
---
&gt; 					fJavadocStatus.setError(UIMessages.ajdocTreeWizardPage_ajdoccmd_error_enterpath);  
&gt; 				} else {
654c676
&lt; 						fJavadocStatus.setError(UIMessages.ajdocTreeWizardPage_ajdoccmd_error_notexists);
---
&gt; 						fJavadocStatus.setError(UIMessages.ajdocTreeWizardPage_ajdoccmd_error_notexists);  
664c686
&lt; 	// AspectJ Extension - changed name to "browserForAJdocCommand"
---
&gt; 	// AspectJ Extension - changed name to "browseForAJDocCommand"
688c710,711
&lt; 	private boolean validDocletPath(String docletPath) {
---
&gt; 	// AspectJ Extension - commenting out unused code
&gt; /*	private boolean validDocletPath(String docletPath) {
697c720
&lt; 
---
&gt; */
702c725
&lt; 		return StatusUtil.getMostSevere(new IStatus[] { fTreeStatus, fPreferenceStatus, fDestinationStatus, fDocletStatus, fJavadocStatus, fWizardStatus });
---
&gt; 		return StatusUtil.getMostSevere(new IStatus[] { fJavadocStatus, fPreferenceStatus, fDestinationStatus, fDocletStatus, fTreeStatus, fWizardStatus });
710d732
&lt; 		super.setVisible(visible);
712d733
&lt; 			doValidation(JAVADOCSTATUS);
716a738
&gt; 			doValidation(JAVADOCSTATUS);
717a740
&gt; 		super.setVisible(visible);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/text/UIMessages.java" revision="1.11" state="changed">391a392,393
&gt; 	public static String ajdocWizard_error_cant_find_ajde_jar;
&gt; 	public static String ajdocWizard_error_cant_find_runtime_jar;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ajdocexport/AJdocOptionsManager.java" revision="1.3" state="changed">11c11,12
&lt;  *     Luzius Meisser - adjusted for ajdoc 
---
&gt;  *     Luzius Meisser  - adjusted for ajdoc 
&gt;  *     Helen Hawkins   - updated for Eclipse 3.1 (bug 109484)
13d13
&lt; 
68a69
&gt;  * Updated for Eclipse 3.1 - bug 109484
72d72
&lt; 
108c108
&lt; 	private boolean fJDK14Mode;
---
&gt; 	private String fSource;
146d145
&lt; 	// AspectJ Extension
157c156
&lt; 	// AspectJ Extension
---
&gt; 	// AspectJ Extension - changing JAVADOC to AJDOC
160c159,162
&lt; 	
---
&gt; /*	private final String SECTION_JAVADOC= "javadoc"; //$NON-NLS-1$
&gt; 
&gt; 	private static final String JAVADOC_COMMAND_HISTORY= "javadoc_command_history"; //$NON-NLS-1$
&gt; */	
164a167
&gt;         // AspectJ Extension begin - changing javadoc to ajdoc
201a205
&gt; 		// AspectJ Extension end
219c223,226
&lt; 		return res;
---
&gt; 		if (res != null &amp;&amp; res.isOpen()) {
&gt; 			return res;
&gt; 		}
&gt; 		return null;
295c302,305
&lt; 		fJDK14Mode= loadBoolean(settings.get(SOURCE));
---
&gt; 		fSource= settings.get(SOURCE);
&gt; 		if (project != null) {
&gt; 			fSource= project.getOption(JavaCore.COMPILER_SOURCE, true);
&gt; 		}
341c351,354
&lt; 		fJDK14Mode= false;
---
&gt; 		fSource= "1.3"; //$NON-NLS-1$
&gt; 		if (project != null) {
&gt; 			fSource= project.getOption(JavaCore.COMPILER_SOURCE, true);
&gt; 		}
355c368
&lt; 		fDestination= makeAbsolutePathFromRelative(destination).toOSString();
---
&gt; 		fDestination= makeAbsolutePathFromRelative(new Path(destination)).toOSString();
436a450,451
&gt; 		
&gt; 		fSource= element.getAttribute(SOURCE); //$NON-NLS-1$
444c459
&lt; 	 * @param pathStr
---
&gt; 	 * @param path
447,448c462
&lt; 	private IPath makeAbsolutePathFromRelative(String pathStr) {
&lt; 		IPath path= new Path(pathStr);
---
&gt; 	private IPath makeAbsolutePathFromRelative(IPath path) {
457c471
&lt; 			return basePath.append(pathStr);
---
&gt; 			return basePath.append(path);
470c484
&lt; 			IPath path= makeAbsolutePathFromRelative(tokenizer.nextToken().trim());
---
&gt; 			IPath path= makeAbsolutePathFromRelative(new Path(tokenizer.nextToken().trim()));
515c529
&lt; 					IPath path= makeAbsolutePathFromRelative(name);
---
&gt; 					IPath path= makeAbsolutePathFromRelative(new Path(name));
684a699
&gt; 		
689,700d703
&lt; 			if (fAdditionalParams.length() + fVMParams.length() != 0) {
&lt; 				ExecutionArguments tokens= new ExecutionArguments(fVMParams, fAdditionalParams); //$NON-NLS-1$
&lt; 				String[] vmArgsArray= tokens.getVMArgumentsArray();
&lt; 				for (int i= 0; i &lt; vmArgsArray.length; i++) {
&lt; 					vmArgs.add(vmArgsArray[i]);
&lt; 				}
&lt; 				
&lt; 				String[] argsArray= tokens.getProgramArgumentsArray();
&lt; 				for (int i= 0; i &lt; argsArray.length; i++) {
&lt; 					toolArgs.add(argsArray[i]);
&lt; 				}
&lt; 			}
707,710c710,718
&lt; 		toolArgs.add("-sourcepath"); //$NON-NLS-1$
&lt; 		toolArgs.add(flatPathList(fSourcepath));
&lt; 		toolArgs.add("-classpath"); //$NON-NLS-1$
&lt; 		toolArgs.add(flatPathList(fClasspath));
---
&gt; 		if (fSourcepath.length &gt; 0) {
&gt; 			toolArgs.add("-sourcepath"); //$NON-NLS-1$
&gt; 			toolArgs.add(flatPathList(fSourcepath));
&gt; 		}
&gt; 		
&gt; 		if (fClasspath.length &gt; 0) {
&gt; 			toolArgs.add("-classpath"); //$NON-NLS-1$
&gt; 			toolArgs.add(flatPathList(fClasspath));
&gt; 		}
714c722
&lt; 			if (fJDK14Mode) {
---
&gt; 			if (fSource.length() &gt; 0 &amp;&amp; !fSource.equals("-")) { //$NON-NLS-1$
716,717c724,725
&lt; 				toolArgs.add("1.4"); //$NON-NLS-1$
&lt; 			}			
---
&gt; 				toolArgs.add(fSource); //$NON-NLS-1$
&gt; 			}
719,720c727,729
&lt; //			if (fUse)
&lt; //				toolArgs.add("-use"); //$NON-NLS-1$
---
&gt; 			// AspectJ Extension - commenting out unsupported -use option (in aj)
&gt; 			/*if (fUse)
&gt; 				toolArgs.add("-use"); //$NON-NLS-1$ */
748,761c757
&lt; 
&lt; 			if (fAdditionalParams.length() + fVMParams.length() != 0) {
&lt; 				ExecutionArguments tokens= new ExecutionArguments(fVMParams, fAdditionalParams); //$NON-NLS-1$
&lt; 				String[] vmArgsArray= tokens.getVMArgumentsArray();
&lt; 				for (int i= 0; i &lt; vmArgsArray.length; i++) {
&lt; 					vmArgs.add(vmArgsArray[i]);
&lt; 				}
&lt; 				
&lt; 				String[] argsArray= tokens.getProgramArgumentsArray();
&lt; 				for (int i= 0; i &lt; argsArray.length; i++) {
&lt; 					toolArgs.add(argsArray[i]);
&lt; 				}
&lt; 			}
&lt; 
---
&gt; 			
766c762
&lt; 
---
&gt; 			
768a765,778
&gt; 		if (fAdditionalParams.length() + fVMParams.length() != 0) {
&gt; 			ExecutionArguments tokens= new ExecutionArguments(fVMParams, fAdditionalParams); //$NON-NLS-1$
&gt; 			String[] vmArgsArray= tokens.getVMArgumentsArray();
&gt; 			for (int i= 0; i &lt; vmArgsArray.length; i++) {
&gt; 				vmArgs.add(vmArgsArray[i]);
&gt; 			}
&gt; 			String[] argsArray= tokens.getProgramArgumentsArray();
&gt; 			for (int i= 0; i &lt; argsArray.length; i++) {
&gt; 				toolArgs.add(argsArray[i]);
&gt; 			}
&gt; 		}
&gt; 		// AspectJ Extension - don't add proxy options
&gt; 		//addProxyOptions(vmArgs);
&gt; 		
775a786
&gt; 			// AspectJ Extension - we need to get the included files from the build configuration
785a797
&gt; 			// AspectJ Extension end
787a800,822
&gt; 	
&gt; 	// AspectJ Extension - commenting out unused code
&gt; /*	private void addProxyOptions(List vmOptions) {
&gt; 		// bug 74132
&gt; 		String hostPrefix= "-J-Dhttp.proxyHost="; //$NON-NLS-1$
&gt; 		String portPrefix= "-J-Dhttp.proxyPort="; //$NON-NLS-1$
&gt; 		for (int i= 0; i &lt; vmOptions.size(); i++) {
&gt; 			String curr= (String) vmOptions.get(i);
&gt; 			if (curr.startsWith(hostPrefix) || curr.startsWith(portPrefix)) {
&gt; 				return;
&gt; 			}
&gt; 		}
&gt; 		String proxyHost= System.getProperty("http.proxyHost"); //$NON-NLS-1$
&gt; 		if (proxyHost != null) {
&gt; 			vmOptions.add(hostPrefix + proxyHost); //$NON-NLS-1$
&gt; 		}
&gt; 		
&gt; 		String proxyPort= System.getProperty("http.proxyPort"); //$NON-NLS-1$
&gt; 		if (proxyPort != null) {
&gt; 			vmOptions.add(portPrefix + proxyPort); //$NON-NLS-1$
&gt; 		}
&gt; 	}
&gt; */	
789c824
&lt; 	public void createXML(IJavaProject[] projects) throws CoreException {
---
&gt; 	public File createXML(IJavaProject[] projects) throws CoreException {
798c833
&lt; 				IPath antPath= new Path(antpath);
---
&gt; 				IPath antPath= Path.fromOSString(antpath);
809a845
&gt; 				// AspectJ Extension - changing JavadocWriter to AJdocWriter
811a848
&gt; 				return file;
829a867
&gt; 		return null;
832a871
&gt; 		// AspectJ Extension begin - replacing JAVADOC with AJDOC
835a875
&gt; 		// AspectJ Extension end
837c877
&lt; 			// AspectJ Extension
---
&gt; 			// AspectJ Extension - using our own preference store
841c881
&lt; 			store.setValue(AspectJPreferences.AJDOC_COMMAND,fJavadocCommandHistory[0]);
---
&gt; 			store.setValue(AspectJPreferences.AJDOC_COMMAND,fJavadocCommandHistory[0]);			
862c902
&lt; 		settings.put(SOURCE, fJDK14Mode);
---
&gt; 		settings.put(SOURCE, fSource);
931c971
&lt; 	public void setCheckedProjects(IJavaProject[] elements) {
---
&gt; 	public void setSelectedElements(IJavaElement[] elements) {
973,974c1013,1018
&lt; 	public boolean isJDK14Mode() {
&lt; 		return fJDK14Mode;
---
&gt; 	public void setSource(String source) {
&gt; 		fSource= source;
&gt; 	}
&gt; 	
&gt; 	public String getSource() {
&gt; 		return fSource;
976,979d1019
&lt; 
&lt; 	public void setJDK14Mode(boolean jdk14Mode) {
&lt; 		fJDK14Mode= jdk14Mode;
&lt; 	}	
1033,1039c1073,1074
&lt; 		if (project != null &amp;&amp; project.exists()) {
&lt; 			IPackageFragmentRoot[] roots= project.getPackageFragmentRoots();
&lt; 			for (int i= 0; i &lt; roots.length; i++) {
&lt; 				if (containsCompilationUnits(roots[i])) {
&lt; 					return true;
&lt; 				}
&lt; 			}
---
&gt; 		if (project != null &amp;&amp; project.exists() &amp;&amp; project.isOpen()) {
&gt; 			return true;
1078c1113,1115
&lt; 		IPreferenceStore store= AspectJUIPlugin.getDefault().getPreferenceStore();
---
&gt; 		// AspectJ Extension - using our own preference store
&gt; 		//IPreferenceStore store= JavaPlugin.getDefault().getPreferenceStore();
&gt; 		IPreferenceStore store= AspectJUIPlugin.getDefault().getPreferenceStore();	
1119c1156
&lt; 			// AspectJ Extension
---
&gt; 			// AspectJ Extension - using ajdoc command
1124c1161
&lt; 			// AspectJ Extension
---
&gt; 			// AspectJ Extension - using ajdoc command
1131d1167
&lt; 
1133a1170,1171
&gt; 
&gt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/text/UIMessages.properties" revision="1.12" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ajdocexport/AJdocProjectContentProvider.java" revision="1.3" state="changed">2c2
&lt;  * Copyright (c) 2000, 2003 IBM Corporation and others.
---
&gt;  * Copyright (c) 2000, 2003, 2005 IBM Corporation and others.
10c10,11
&lt;  *     Luzius Meisser - adjusted for ajdoc 
---
&gt;  *     Luzius Meisser  - adjusted for ajdoc 
&gt;  *     Helen Hawkins   - updated for Eclipse 3.1 (bug 109484)
24a26
&gt; import org.eclipse.jdt.internal.ui.JavaPlugin;
29a32
&gt;  * Updated for eclipse 3.1
37a41,52
&gt; 		// AspectJ Extension - we only want a list of projects since the
&gt; 		// build config determines what is built
&gt; /*		try {
&gt; 			if (parentElement instanceof IJavaProject) {
&gt; 				IJavaProject project= (IJavaProject) parentElement;
&gt; 				return getPackageFragmentRoots(project);
&gt; 			} else if (parentElement instanceof IPackageFragmentRoot) {
&gt; 				return getPackageFragments((IPackageFragmentRoot) parentElement);
&gt; 			}
&gt; 		} catch (JavaModelException e) {
&gt; 			JavaPlugin.log(e);
&gt; 		} */
39a55
&gt; 	
45a62
&gt; 			// AspectJ Extension begin - only return aspectj projects
53c70,71
&lt; 			return ajProjects.toArray();		
---
&gt; 			return ajProjects.toArray();
&gt; 			// AspectJ Extension end
54a73
&gt; 			JavaPlugin.log(e);
92a112,144
&gt; 	// AspectJ Extension - commenting out unused code
&gt; /*	private Object[] getPackageFragmentRoots(IJavaProject project) throws JavaModelException {
&gt; 		ArrayList result= new ArrayList();
&gt; 
&gt; 		IPackageFragmentRoot[] roots= project.getPackageFragmentRoots();
&gt; 		for (int i= 0; i &lt; roots.length; i++) {
&gt; 			IPackageFragmentRoot root= roots[i];
&gt; 			if (root.getKind() == IPackageFragmentRoot.K_SOURCE) {
&gt; 				if (root.getPath().equals(root.getJavaProject().getPath())) {
&gt; 					Object[] packageFragments= getPackageFragments(root);
&gt; 					for (int k= 0; k &lt; packageFragments.length; k++) {
&gt; 						result.add(packageFragments[k]);
&gt; 					}
&gt; 				} else {
&gt; 					result.add(root);
&gt; 				}
&gt; 			}
&gt; 		}
&gt; 		return result.toArray();
&gt; 	}
&gt; 
&gt; 	private Object[] getPackageFragments(IPackageFragmentRoot root) throws JavaModelException {
&gt; 		ArrayList packageFragments= new ArrayList();
&gt; 
&gt; 		IJavaElement[] children= root.getChildren();
&gt; 		for (int i= 0; i &lt; children.length; i++) {
&gt; 			if (((IPackageFragment) children[i]).containsJavaResources())
&gt; 				packageFragments.add(children[i]);
&gt; 		}
&gt; 		return packageFragments.toArray();
&gt; 	}*/
&gt; 
&gt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ajdocexport/AJdocWriter.java" revision="1.2" state="changed">2c2
&lt;  * Copyright (c) 2000, 2003 IBM Corporation and others.
---
&gt;  * Copyright (c) 2005 IBM Corporation and others.
9a10
&gt;  *     Helen Hawkins   - updated for Eclipse 3.1 (bug 109484)
31,35d31
&lt; import org.w3c.dom.DOMException;
&lt; import org.w3c.dom.Document;
&lt; import org.w3c.dom.Element;
&lt; 
&lt; import org.eclipse.ajdt.internal.ajdocexport.AJdocOptionsManager;
40,42d35
&lt; 
&lt; import org.eclipse.jface.util.Assert;
&lt; 
46a40,43
&gt; import org.eclipse.jface.util.Assert;
&gt; import org.w3c.dom.DOMException;
&gt; import org.w3c.dom.Document;
&gt; import org.w3c.dom.Element;
49a47
&gt;  * updated for Eclipse 3.1 (bug 109484)
53c51
&lt; 	
---
&gt; 
72a71
&gt; 	// AspectJ Extension - passing an AJdocOptionsManager as an argument
112a112
&gt; 	// AspectJ Extension - passing an AJdocOptionsManager as an argument
115c115
&lt; 		String destination= getPathString(new Path(store.getDestination()));
---
&gt; 		String destination= getPathString(Path.fromOSString(store.getDestination()));
119,120c119,121
&lt; 		if (store.isJDK14Mode()) {
&lt; 			xmlJavadocDesc.setAttribute(store.SOURCE, "1.4"); //$NON-NLS-1$
---
&gt; 		String source= store.getSource();
&gt; 		if (source.length() &gt; 0 &amp;&amp; !source.equals("-")) { //$NON-NLS-1$
&gt; 			xmlJavadocDesc.setAttribute(store.SOURCE, store.getSource());
146,156c147,157
&lt; 		String str= store.getOverview();
&lt; 		if (str.length() &gt; 0) //$NON-NLS-1$
&lt; 			xmlJavadocDesc.setAttribute(store.OVERVIEW, str);
&lt; 
&lt; 		str= store.getStyleSheet();
&lt; 		if (str.length() &gt; 0) //$NON-NLS-1$
&lt; 			xmlJavadocDesc.setAttribute(store.STYLESHEETFILE, str);
&lt; 
&lt; 		str= store.getTitle();
&lt; 		if (str.length() &gt; 0) //$NON-NLS-1$
&lt; 			xmlJavadocDesc.setAttribute(store.TITLE, str);
---
&gt; 		String overview= store.getOverview();
&gt; 		if (overview.length() &gt; 0)
&gt; 			xmlJavadocDesc.setAttribute(store.OVERVIEW, overview);
&gt; 
&gt; 		String styleSheet= store.getStyleSheet();
&gt; 		if (styleSheet.length() &gt; 0)
&gt; 			xmlJavadocDesc.setAttribute(store.STYLESHEETFILE, styleSheet);
&gt; 
&gt; 		String title= store.getTitle();
&gt; 		if (title.length() &gt; 0)
&gt; 			xmlJavadocDesc.setAttribute(store.TITLE, title);
162c163
&lt; 			str= vmArgs + ' ' + additionalArgs;
---
&gt; 			String str= vmArgs + ' ' + additionalArgs;
254a256
&gt;     // AspectJ Extension - passing an AJdocOptionsManager as an argument
313a316
&gt; 	
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ajdocexport/AJdocWizard.java" revision="1.5" state="changed">9a10
&gt;  * Helen Hawkins - updated for Eclipse 3.1 (bug 109484)
76a78
&gt; import org.eclipse.osgi.util.NLS;
89a92
&gt;  * Updated for Eclipse 3.1 - bug 109484
94c97
&lt; //	 AspectJ Extension
---
&gt; //	 AspectJ Extension - using AJDoc pages rather than javadoc
311a315,322
&gt; 				} else {
&gt; 					int lengthOfPath = ajdeFile.getAbsolutePath().length();
&gt; 					MessageDialog.openError(getShell(),
&gt; 							UIMessages.ajdocWizard_error_title,
&gt; 							NLS.bind(UIMessages.ajdocWizard_error_cant_find_ajde_jar, 
&gt; 									ajdeFile.getAbsolutePath().substring(0,(lengthOfPath/2)),
&gt; 									ajdeFile.getAbsolutePath().substring((lengthOfPath/2))));
&gt; 					return true;
314c325,331
&lt; 				if (coreFile.exists()) {
---
&gt; 				// need to check that have found a jar or the correct bundle. In the case when
&gt; 				// you're running ajdoc in a runtime workbench and you have imported org.eclipse.core.runtime
&gt; 				// into your workbench coreFile is just this directory and ajdoc doesn't run
&gt; 				// (and it's not immediately obvious why).
&gt; 				if (coreFile.exists() &amp;&amp; 
&gt; 						(coreFile.getName().endsWith("jar") //$NON-NLS-1$ 
&gt; 								|| coreFile.getName().endsWith("cp"))) { //$NON-NLS-1$
315a333,340
&gt; 				} else {
&gt; 					int lengthOfPath = coreFile.getAbsolutePath().length();
&gt; 					MessageDialog.openError(getShell(),
&gt; 							UIMessages.ajdocWizard_error_title,
&gt; 							NLS.bind(UIMessages.ajdocWizard_error_cant_find_runtime_jar, 
&gt; 									coreFile.getAbsolutePath().substring(0,(lengthOfPath/2)),
&gt; 									coreFile.getAbsolutePath().substring((lengthOfPath/2)))); 
&gt; 					return true;
</file>
</fixedFiles>
</bug>
<bug id="109614" transactionid="68780">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="P2"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-instanceof M O-cast O-instanceof T V Y Z-cast Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>I am getting following error when compiling code using iajc ant task:


[iajc.task] trouble in:
[iajc.task] public class admin.modelbean.AdminUserMB extends web.FormSupport:
[iajc.task]   private static final org.apache.log4j.Logger log
....

(Ljava/lang/String;)Ljava/lang/StringBuffer;
[iajc.task]     | method-call(java.lang.StringBuffer
java.lang.StringBuffer.append(java.lang.String))
[iajc.task]     |               LDC_W "}"   (line 249)
[iajc.task]     | method-call(java.lang.StringBuffer
java.lang.StringBuffer.append(java.lang.String))
[iajc.task]     | |             INVOKEVIRTUAL java.lang.StringBuffer.append
(Ljava/lang/String;)Ljava/lang/StringBuffer;
[iajc.task]     | method-call(java.lang.StringBuffer
java.lang.StringBuffer.append(java.lang.String))
[iajc.task]     | method-call(java.lang.String java.lang.StringBuffer.toString())
[iajc.task]     | |             INVOKEVIRTUAL java.lang.StringBuffer.toString
()Ljava/lang/String;   (line 236)
[iajc.task]     | method-call(java.lang.String java.lang.StringBuffer.toString())
[iajc.task]     |               ARETURN
[iajc.task]     method-execution(java.lang.String
admin.modelbean.AdminUserMB.toString())
[iajc.task]   end public String toString()
[iajc.task] end public class admin.modelbean.AdminUserMB
[iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing
instructionList
[iajc.task]     at org.aspectj.weaver.bcel.Range.updateTarget(Range.java:170)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.retargetFrom(BcelShadow.java:235)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:212)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:252)
[iajc.task]     at org.aspectj.weaver.Shadow.implement(Shadow.java:374)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1754)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:393)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1372)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1337)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1114)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1001)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
[iajc.task]     at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[iajc.task]     at org.aspectj.tools.ajc.Main.run(Main.java:324)
[iajc.task]     at org.aspectj.tools.ajc.Main.runMain(Main.java:238)
[iajc.task]     at org.aspectj.tools.ajc.Main.main(Main.java:82)
[iajc.task] ABORT
[iajc.task]
[iajc.task] Exception thrown from AspectJ 1.5.0_M3a

[iajc.task] This might be logged as a bug already -- find current bugs at
[iajc.task]  
http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

[iajc.task] Bugs for exceptions thrown have titles File:line from the top stack,
[iajc.task] e.g., "SomeFile.java:243"

[iajc.task] If you don't find the exception below in a bug, please add a new bug
[iajc.task] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
[iajc.task] To make the bug a priority, please include a test program
[iajc.task] that can reproduce this exception.
[iajc.task] Ranges must be updated with an enclosing instructionList
[iajc.task] Ranges must be updated with an enclosing instructionList
[iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing
instructionList
[iajc.task]     at org.aspectj.weaver.bcel.Range.updateTarget(Range.java:170)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.retargetFrom(BcelShadow.java:235)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:212)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:252)
[iajc.task]     at org.aspectj.weaver.Shadow.implement(Shadow.java:374)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1754)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:393)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1372)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1337)
[iajc.task]     at
org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1114)
[iajc.task]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1001)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)
[iajc.task]     at
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
[iajc.task]     at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)
[iajc.task]     at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
[iajc.task]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
[iajc.task]     at org.aspectj.tools.ajc.Main.run(Main.java:324)
[iajc.task]     at org.aspectj.tools.ajc.Main.runMain(Main.java:238)
[iajc.task]     at org.aspectj.tools.ajc.Main.main(Main.java:82)


[iajc.task] 1 fail|abort

BUILD FAILED
/home/sbhatti/workspace/devint/build.xml:100: The following error occurred while
executing this line:
/home/sbhatti/workspace/devint/build.xml:164: The following error occurred while
executing this line:
/home/sbhatti/workspace/devint/modules/novo/build.xml:59: The following error
occurred while executing this line:
/opt/sbhatti/dev/current/novo/build.xml:326: failure[-1] running ajc</bugreport>
<testsforfix ID="109614" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testRangeProblem_pr109614"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="Range problem"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/109614/pre-fix/testresults.xml" passing="1604" size="1784"/>
<post-fix-testcases failing="180" file="output/109614/post-fix/testresults.xml" passing="1604" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.83" state="changed">200c200
&lt; 		// by the actual instruciton we care about.  
---
&gt; 		// by the actual instruction we care about.  
216a217
&gt; 			// Now make any jumps to the 'new', the 'dup' or the 'end' now target the nextHandle
240c241,247
&lt; 				sources[i].updateTarget(old, fresh);
---
&gt; 				if (sources[i] instanceof ExceptionRange) {
&gt; 					ExceptionRange it = (ExceptionRange)sources[i];
&gt; 					System.err.println("...");
&gt; 					it.updateTarget(old,fresh,it.getBody());
&gt; 				} else {
&gt; 				  sources[i].updateTarget(old, fresh);
&gt; 				}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.160" state="changed">60a61
&gt;   public void testRangeProblem_pr109614() { runTest("Range problem");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.241" state="changed">177a178
&gt; 
230a232,237
&gt; 
&gt; 	&lt;ajc-test dir="bugs150" title="Range problem"&gt;
&gt; 		&lt;compile files="pr109614.java"/&gt;
&gt; 		&lt;run class="pr109614"/&gt;
&gt; 	&lt;/ajc-test&gt;
&gt; 	    
</file>
<file name="org.aspectj/modules/tests/bugs150/pr109614.java" revision="1.1" state="new">public aspect pr109614 {  
    Object around() : call( NoClassDefFoundError.new(..)) {
      return proceed();
    } 
    
    public static void main(String []argv) {
    	new ContractChecking();
    }
}    

class ContractChecking {
    public static final boolean enabled = Boolean.getBoolean(ContractChecking.class.getName());
}</file>
</fixedFiles>
</bug>
<bug id="111053" transactionid="74606">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="8"/>
<property name="lines-modified" value="10"/>
<property name="lines-churned" value="19"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new M O-! O-+ T V Y Z-if</fullfingerprint>
<bugreport>It is not a good idea to have buttons that do nothing when pressed - we should 
either introduce a means of selecting different patterns or switch the buttons 
to be icons instead when the patterns mode is selected.</bugreport>
<pre-fix-testcases failing="178" file="output/111053/pre-fix/testresults.xml" passing="1581" size="1759"/>
<post-fix-testcases failing="179" file="output/111053/post-fix/testresults.xml" passing="1580" size="1759"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/text/VisualiserMessages.java" revision="1.6" state="changed">85a86
&gt; 	public static String Pattern_for;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/views/Menu.java" revision="1.23" state="changed">148,168c148,153
&lt; 				// Do nothing if viewing with Pattern Palette
&lt; 				if (!VisualiserPreferences.getUsePatterns()) {
&lt; 					if (e.getSource() instanceof Button) {
&lt; 						Button button = (Button) e.getSource();
&lt; 						int location = 0;
&lt; 						for (int j = 0; j &lt; buttons.length; j++) {
&lt; 							if ((buttons[j]).equals(button)) {
&lt; 								location = j;
&lt; 							}
&lt; 						}
&lt; 						RGB rgb = colorDialogs[location].open();
&lt; 						if (rgb == null) {
&lt; 							return;
&lt; 						}
&lt; 						colors[location] = new Color(buttons[location].getDisplay(), rgb);
&lt; 						Image image = buttons[location].getImage();
&lt; 						drawImage(image, colors[location]);
&lt; 						buttons[location].setImage(image);
&lt; 						if (!(VisualiserPlugin.visualiser == null)) {
&lt; 							vmp.setColorFor((IMarkupKind)labels[location].getData(),colors[location]);
&lt; 							VisualiserPlugin.visualiser.draw();
---
&gt; 				if (e.getSource() instanceof Button) {
&gt; 					Button button = (Button) e.getSource();
&gt; 					int location = 0;
&gt; 					for (int j = 0; j &lt; buttons.length; j++) {
&gt; 						if ((buttons[j]).equals(button)) {
&gt; 							location = j;
170a156,167
&gt; 					RGB rgb = colorDialogs[location].open();
&gt; 					if (rgb == null) {
&gt; 						return;
&gt; 					}
&gt; 					colors[location] = new Color(buttons[location].getDisplay(), rgb);
&gt; 					Image image = buttons[location].getImage();
&gt; 					drawImage(image, colors[location]);
&gt; 					buttons[location].setImage(image);
&gt; 					if (!(VisualiserPlugin.visualiser == null)) {
&gt; 						vmp.setColorFor((IMarkupKind)labels[location].getData(),colors[location]);
&gt; 						VisualiserPlugin.visualiser.draw();
&gt; 					}					
441d437
&lt; 		 		 		 // TODO: If we're using patterns, just want image, no button
444c440,449
&lt; 			 		 		 buttons[i].setToolTipText(VisualiserMessages.Change_color_for + " " + element.getName()); //$NON-NLS-1$
---
&gt; 			 		 		 buttons[i].setToolTipText(VisualiserMessages.Change_color_for + " " + element.getName()); //$NON-NLS-1$		 		 		 
&gt; 			 		 		 shells[i] = buttons[i].getShell();
&gt; 			 		 		 colorDialogs[i] = new ColorDialog(shells[i]);
&gt; 			 		 		 Display display = shells[i].getDisplay();
&gt; 			 		 		 colorSquares[i] = new Image(display, imageSize, imageSize);
&gt; 			 		 		 buttons[i].setImage(colorSquares[i]);
&gt; 			 		 		 buttons[i].addSelectionListener(selectionListener);
&gt; 			 		 		 Image image = buttons[i].getImage();
&gt; 			 		 		 drawImage(image, colors[i]);
&gt; 			 		 		 buttons[i].setImage(image);
446,458c451,459
&lt; 		 		 		 // Just an image
&lt; 			 		 		 buttons[i] = new Button(canvas, SWT.PUSH);
&lt; 		 		 		 }
&lt; 		 		 		 shells[i] = buttons[i].getShell();
&lt; 		 		 		 colorDialogs[i] = new ColorDialog(shells[i]);
&lt; 		 		 		 Display display = shells[i].getDisplay();
&lt; 		 		 		 colorSquares[i] = new Image(display, imageSize, imageSize);
&lt; 		 		 		 buttons[i].setImage(colorSquares[i]);
&lt; 		 		 		 buttons[i].addSelectionListener(selectionListener);
&lt; 		 		 		 Image image = buttons[i].getImage();
&lt; 		 		 		 drawImage(image, colors[i]);
&lt; 		 		 		 buttons[i].setImage(image);
&lt; 		 		 		 
---
&gt; 		 		 			 // We're using patterns so make a plain label rather than a button
&gt; 		 		 			 Label l = new Label(canvas, SWT.NONE);		 		 			 
&gt; 			 		 		 colorSquares[i] = new Image(canvas.getDisplay(), imageSize, imageSize);
&gt; 		 		 			 l.setImage(colorSquares[i]);
&gt; 		 		 			 l.setToolTipText(VisualiserMessages.Pattern_for + " " + element.getName()); //$NON-NLS-1$
&gt; 			 		 		 Image image = l.getImage();
&gt; 			 		 		 drawImage(image, colors[i]);
&gt; 			 		 		 l.setImage(image);
&gt; 			 		 	 }	 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.contribution.visualiser/src/org/eclipse/contribution/visualiser/text/VisualiserMessages.properties" revision="1.9" state="changed"/>
</fixedFiles>
</bug>
<bug id="111575" transactionid="74555">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="21"/>
<property name="lines-added" value="311"/>
<property name="lines-deleted" value="57"/>
<property name="lines-modified" value="14"/>
<property name="lines-churned" value="382"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-else K-false K-for K-if K-import K-new K-null K-return K-super K-true K-try M O-&lt; O-== O-&gt;= O-|| O-- O--- O-! O-!= O-?: O-() O-&amp;&amp; O-++ O-cast T V Y Z-cast Z-cond Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>When large fonts are used the second radio button (Use Project Settings) on 
the AspectJ Compiler property page disappears, which means that it is not 
possible to change the settingd for an individual project.  The solution is to 
use a checkbox instead like the Java Compiler property page.</bugreport>
<pre-fix-testcases failing="177" file="output/111575/pre-fix/testresults.xml" passing="1583" size="1760"/>
<post-fix-testcases failing="177" file="output/111575/post-fix/testresults.xml" passing="1583" size="1760"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/preferences/AspectJPreferences.java" revision="1.35" state="changed">247c247
&lt; 				CompilerPropertyPage.setDefaults(projectNode);
---
&gt; 				AJCompilerPreferencePage.setProjectDefaults(projectNode);
249c249
&lt; 				CompilerPropertyPage.setDefaultsIfValueNotAlreadySet(projectNode);
---
&gt; 				AJCompilerPreferencePage.setProjectDefaultsIfValueNotAlreadySet(projectNode);
253c253
&lt; 			CompilerPropertyPage.removeValues(projectNode);
---
&gt; 			AJCompilerPreferencePage.removeProjectValues(projectNode);
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/preferences/PreferencePageBuilder.aj" revision="1.9" state="changed">22d21
&lt; import org.eclipse.ajdt.internal.ui.CompilerPropertyPage;&#13;
43c42
&lt; import org.eclipse.ui.dialogs.PropertyPage;&#13;
---
&gt; import org.eclipse.ui.IWorkbenchPropertyPage;&#13;
62c61
&lt;     private Hashtable /* PropertyPage -&gt; (Hashtable of Button -&gt; Boolean)*/ buttonOriginalValues = new Hashtable();&#13;
---
&gt;     private Hashtable /* IWorkbenchPropertyPage -&gt; (Hashtable of Button -&gt; Boolean)*/ buttonOriginalValues = new Hashtable();&#13;
64c63
&lt;     private Hashtable /* PropertyPage -&gt; (Hashtable of Combo -&gt; Integer)*/ comboOriginalValues = new Hashtable();&#13;
---
&gt;     private Hashtable /* IWorkbenchPropertyPage -&gt; (Hashtable of Combo -&gt; Integer)*/ comboOriginalValues = new Hashtable();&#13;
66c65
&lt;     private Hashtable /* PropertyPage -&gt; (Hashtable of StringFieldEditors -&gt; String)*/ stringFieldEditorsOriginalValues = new Hashtable();&#13;
---
&gt;     private Hashtable /* IWorkbenchPropertyPage -&gt; (Hashtable of StringFieldEditors -&gt; String)*/ stringFieldEditorsOriginalValues = new Hashtable();&#13;
68c67
&lt;     private Hashtable /* PropertyPage -&gt; (Hashtable of SelectionButtonDialogField -&gt; Boolean)*/ selectionButtonOriginalValues = new Hashtable();&#13;
---
&gt;     private Hashtable /* IWorkbenchPropertyPage -&gt; (Hashtable of SelectionButtonDialogField -&gt; Boolean)*/ selectionButtonOriginalValues = new Hashtable();&#13;
70,71c69,73
&lt;     private Hashtable /* PropertyPage -&gt; (Hashtable of ListDialogField -&gt; List)*/ dialogFieldOriginalValues = new Hashtable();&#13;
&lt; &#13;
---
&gt;     private Hashtable /* IWorkbenchPropertyPage -&gt; (Hashtable of ListDialogField -&gt; List)*/ dialogFieldOriginalValues = new Hashtable();&#13;
&gt;     &#13;
&gt;     private boolean useProjectSettingsOriginalValue;&#13;
&gt;        &#13;
&gt;     &#13;
79c81
&lt; 	    within(CompilerPropertyPage) ||&#13;
---
&gt; 	    within(AJCompilerPreferencePage) ||&#13;
84c86
&lt;     pointcut creationOfAnInterestingPage(PropertyPage page) : &#13;
---
&gt;     pointcut creationOfAnInterestingPage(IWorkbenchPropertyPage page) : &#13;
89c91
&lt;     before(PropertyPage page) : creationOfAnInterestingPage(page) {&#13;
---
&gt;     before(IWorkbenchPropertyPage page) : creationOfAnInterestingPage(page) {&#13;
91a94,96
&gt;         if(page instanceof AJCompilerPreferencePage) {&#13;
&gt;         	useProjectSettingsOriginalValue = ((AJCompilerPreferencePage)page).hasProjectSpecificOptions(((AJCompilerPreferencePage)page).getProject());&#13;
&gt;         }&#13;
95c100
&lt;     pointcut disposalOfAnInterestingPage(PropertyPage page) :&#13;
---
&gt;     pointcut disposalOfAnInterestingPage(IWorkbenchPropertyPage page) :&#13;
100c105
&lt;     before(PropertyPage page) : disposalOfAnInterestingPage(page) {&#13;
---
&gt;     before(IWorkbenchPropertyPage page) : disposalOfAnInterestingPage(page) {&#13;
107c112
&lt;         if (page instanceof CompilerPropertyPage) {&#13;
---
&gt;         if (page instanceof AJCompilerPreferencePage) {&#13;
115c120
&lt;     pointcut setSelection(Button button, boolean val, PropertyPage page):&#13;
---
&gt;     pointcut setSelection(Button button, boolean val, IWorkbenchPropertyPage page):&#13;
119c124
&lt;     before(Button b, boolean val, PropertyPage page):&#13;
---
&gt;     before(Button b, boolean val, IWorkbenchPropertyPage page):&#13;
133c138
&lt;     pointcut comboSelect(Combo combo, int selection, PropertyPage page) :&#13;
---
&gt;     pointcut comboSelect(Combo combo, int selection, IWorkbenchPropertyPage page) :&#13;
137c142
&lt;     before(Combo combo, int selection, PropertyPage page) :&#13;
---
&gt;     before(Combo combo, int selection, IWorkbenchPropertyPage page) :&#13;
151c156
&lt;     pointcut setStringValue(StringFieldEditor editor, String value, PropertyPage page) :&#13;
---
&gt;     pointcut setStringValue(StringFieldEditor editor, String value, IWorkbenchPropertyPage page) :&#13;
155c160
&lt;     before(StringFieldEditor editor, String value, PropertyPage page) :&#13;
---
&gt;     before(StringFieldEditor editor, String value, IWorkbenchPropertyPage page) :&#13;
169,185c174,190
&lt;     pointcut setButtonSelection(SelectionButtonDialogField button, boolean value, PropertyPage page) :&#13;
&lt;         call(* setSelection(boolean)) &amp;&amp; args(value) &amp;&amp; target(button) &amp;&amp; this(page);&#13;
&lt;     &#13;
&lt;     // remember the first value put into the SelectionButtonDialogFields&#13;
&lt;     before(SelectionButtonDialogField button, boolean value, PropertyPage page) :&#13;
&lt;         setButtonSelection(button,value,page) &amp;&amp; interestingPage() {&#13;
&lt;         if (!selectionButtonOriginalValues.containsKey(page)) {&#13;
&lt;             Hashtable buttonValues = new Hashtable();&#13;
&lt;             buttonValues.put(button,new Boolean(value));&#13;
&lt;             selectionButtonOriginalValues.put(page,buttonValues);&#13;
&lt;         } else {&#13;
&lt;             Hashtable buttonValues = (Hashtable)selectionButtonOriginalValues.get(page);&#13;
&lt;             if (!buttonValues.containsKey(button)) {&#13;
&lt;                 buttonValues.put(button, new Boolean(value)); &#13;
&lt;             }&#13;
&lt;         }    &#13;
&lt;     }&#13;
---
&gt; //    pointcut setButtonSelection(SelectionButtonDialogField button, boolean value, IWorkbenchPropertyPage page) :&#13;
&gt; //        call(* setSelection(boolean)) &amp;&amp; args(value) &amp;&amp; target(button) &amp;&amp; this(page);&#13;
&gt; //    &#13;
&gt; //    // remember the first value put into the SelectionButtonDialogFields&#13;
&gt; //    before(SelectionButtonDialogField button, boolean value, IWorkbenchPropertyPage page) :&#13;
&gt; //        setButtonSelection(button,value,page) &amp;&amp; interestingPage() {&#13;
&gt; //        if (!selectionButtonOriginalValues.containsKey(page)) {&#13;
&gt; //            Hashtable buttonValues = new Hashtable();&#13;
&gt; //            buttonValues.put(button,new Boolean(value));&#13;
&gt; //            selectionButtonOriginalValues.put(page,buttonValues);&#13;
&gt; //        } else {&#13;
&gt; //            Hashtable buttonValues = (Hashtable)selectionButtonOriginalValues.get(page);&#13;
&gt; //            if (!buttonValues.containsKey(button)) {&#13;
&gt; //                buttonValues.put(button, new Boolean(value)); &#13;
&gt; //            }&#13;
&gt; //        }    &#13;
&gt; //    }&#13;
194,195c199,200
&lt;         PropertyPage page = null;&#13;
&lt;         // We need to associate the ListDialogField with the related PropertyPage object&#13;
---
&gt;         IWorkbenchPropertyPage page = null;&#13;
&gt;         // We need to associate the ListDialogField with the related IWorkbenchPropertyPage object&#13;
197c202
&lt;         // of the ListDialogField more easily in settingsHaveChanged(PropertyPage)).&#13;
---
&gt;         // of the ListDialogField more easily in settingsHaveChanged(IWorkbenchPropertyPage)).&#13;
202c207
&lt;             PropertyPage ajdtPage = (PropertyPage) iter.next();&#13;
---
&gt;             IWorkbenchPropertyPage ajdtPage = (IWorkbenchPropertyPage) iter.next();&#13;
231c236
&lt;             PropertyPage page = (PropertyPage) iterator.next();&#13;
---
&gt;             IWorkbenchPropertyPage page = (IWorkbenchPropertyPage) iterator.next();&#13;
239c244
&lt;     private boolean settingsHaveChangedOnPage(PropertyPage page) {&#13;
---
&gt;     private boolean settingsHaveChangedOnPage(IWorkbenchPropertyPage page) {&#13;
296a302,307
&gt;         if(page instanceof AJCompilerPreferencePage) {&#13;
&gt; 			AJCompilerPreferencePage ajPage = (AJCompilerPreferencePage) page;&#13;
&gt; 			if(ajPage.useProjectSettings() != useProjectSettingsOriginalValue) {&#13;
&gt; 				return true;&#13;
&gt; 			}&#13;
&gt; 		}&#13;
300c311
&lt;     private void resetButtonsOnPage(PropertyPage page) {&#13;
---
&gt;     private void resetButtonsOnPage(IWorkbenchPropertyPage page) {&#13;
311c322
&lt;     private void resetComboBoxesOnPage(PropertyPage page) {&#13;
---
&gt;     private void resetComboBoxesOnPage(IWorkbenchPropertyPage page) {&#13;
322c333
&lt;     private void resetEditorsOnPage(PropertyPage page) {&#13;
---
&gt;     private void resetEditorsOnPage(IWorkbenchPropertyPage page) {&#13;
333c344
&lt;     private void resetSelectionButtonsOnPage(PropertyPage page) {&#13;
---
&gt;     private void resetSelectionButtonsOnPage(IWorkbenchPropertyPage page) {&#13;
344c355
&lt;     private void resetDialogFieldsOnPage(PropertyPage page) {&#13;
---
&gt;     private void resetDialogFieldsOnPage(IWorkbenchPropertyPage page) {&#13;
355c366
&lt;     pointcut pageCompleting(PropertyPage page) : &#13;
---
&gt;     pointcut pageCompleting(IWorkbenchPropertyPage page) : &#13;
359c370
&lt;     after(PropertyPage page) returning: pageCompleting(page) &amp;&amp; !cflow(execution(* performApply())) {&#13;
---
&gt;     after(IWorkbenchPropertyPage page) returning: pageCompleting(page) &amp;&amp; !cflow(execution(* performApply())) {&#13;
377c388
&lt;     after(PropertyPage page) returning: pageCompleting(page) &amp;&amp; cflow(execution(* performApply())) {&#13;
---
&gt;     after(IWorkbenchPropertyPage page) returning: pageCompleting(page) &amp;&amp; cflow(execution(* performApply())) {&#13;
386c397
&lt;         if (page instanceof CompilerPropertyPage) {&#13;
---
&gt;         if (page instanceof AJCompilerPreferencePage) {&#13;
391c402
&lt;     pointcut openingMessageDialog(MessageDialog dialog, PropertyPage page) :&#13;
---
&gt;     pointcut openingMessageDialog(MessageDialog dialog, IWorkbenchPropertyPage page) :&#13;
394,395c405,406
&lt;     after(MessageDialog dialog, PropertyPage page ) returning : &#13;
&lt;         openingMessageDialog(dialog,page) &amp;&amp; within(CompilerPropertyPage) {        &#13;
---
&gt;     after(MessageDialog dialog, IWorkbenchPropertyPage page ) returning : &#13;
&gt;         openingMessageDialog(dialog,page) &amp;&amp; within(AJCompilerPreferencePage) {        &#13;
407,408c418,419
&lt;             PropertyPage page = (PropertyPage) iter.next();&#13;
&lt;             if ((page instanceof CompilerPropertyPage) &amp;&amp; settingsHaveChangedOnPage(page)) {&#13;
---
&gt;             IWorkbenchPropertyPage page = (IWorkbenchPropertyPage) iter.next();&#13;
&gt;             if ((page instanceof AJCompilerPreferencePage) &amp;&amp; settingsHaveChangedOnPage(page)) {&#13;
418c429
&lt;     private void doProjectBuild(PropertyPage prefPage) {&#13;
---
&gt;     private void doProjectBuild(IWorkbenchPropertyPage prefPage) {&#13;
424,425c435,436
&lt;         } else if (prefPage instanceof CompilerPropertyPage) {&#13;
&lt;             tempProject = ((CompilerPropertyPage) prefPage).getThisProject();&#13;
---
&gt;         } else if (prefPage instanceof AJCompilerPreferencePage) {&#13;
&gt;             tempProject = ((AJCompilerPreferencePage) prefPage).getProject();&#13;
431,445c442,457
&lt;         ProgressMonitorDialog dialog = new ProgressMonitorDialog(&#13;
&lt;                 ((PreferencePage) prefPage).getShell());&#13;
&lt;         try {&#13;
&lt;             dialog.run(true, true, new IRunnableWithProgress() {&#13;
&lt;                 public void run(IProgressMonitor monitor)&#13;
&lt;                         throws InvocationTargetException {&#13;
&lt;                     monitor.beginTask("", 2); //$NON-NLS-1$&#13;
&lt;                     try {&#13;
&lt;                         monitor&#13;
&lt;                                 .setTaskName(UIMessages.OptionsConfigurationBlock_buildproject_taskname);&#13;
&lt;                         project.build(IncrementalProjectBuilder.FULL_BUILD,&#13;
&lt;                                 AspectJPlugin.ID_BUILDER, null,&#13;
&lt;                                 new SubProgressMonitor(monitor, 2));&#13;
&lt;                     } catch (CoreException e) {&#13;
&lt;                     	ErrorHandler&#13;
---
&gt;         if(project != null) {&#13;
&gt; 	        ProgressMonitorDialog dialog = new ProgressMonitorDialog(&#13;
&gt; 	                ((PreferencePage) prefPage).getShell());&#13;
&gt; 	        try {&#13;
&gt; 	            dialog.run(true, true, new IRunnableWithProgress() {&#13;
&gt; 	                public void run(IProgressMonitor monitor)&#13;
&gt; 	                        throws InvocationTargetException {&#13;
&gt; 	                    monitor.beginTask("", 2); //$NON-NLS-1$&#13;
&gt; 	                    try {&#13;
&gt; 	                        monitor&#13;
&gt; 	                                .setTaskName(UIMessages.OptionsConfigurationBlock_buildproject_taskname);&#13;
&gt; 	                        project.build(IncrementalProjectBuilder.FULL_BUILD,&#13;
&gt; 	                                AspectJPlugin.ID_BUILDER, null,&#13;
&gt; 	                                new SubProgressMonitor(monitor, 2));&#13;
&gt; 	                    } catch (CoreException e) {&#13;
&gt; 	                       ErrorHandler&#13;
449,457c461,470
&lt;                     } finally {&#13;
&lt;                         monitor.done();&#13;
&lt;                     }&#13;
&lt;                 }&#13;
&lt;             });&#13;
&lt;         } catch (InterruptedException e) {&#13;
&lt;             // cancelled by user&#13;
&lt;         } catch (InvocationTargetException e) {&#13;
&lt;         }&#13;
---
&gt; 	                    } finally {&#13;
&gt; 	                        monitor.done();&#13;
&gt; 	                    }&#13;
&gt; 	                }&#13;
&gt; 	            });&#13;
&gt; 	        } catch (InterruptedException e) {&#13;
&gt; 	            // cancelled by user&#13;
&gt; 	        } catch (InvocationTargetException e) {&#13;
&gt; 	        }&#13;
&gt;     	}&#13;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/preferences/AJCompilerPreferencePage.java" revision="1.19" state="changed">16a17,18
&gt; import java.util.Arrays;
&gt; import java.util.HashMap;
17a20
&gt; import java.util.Map;
18a22
&gt; import org.eclipse.ajdt.core.AspectJPlugin;
23a28
&gt; import org.eclipse.core.resources.IProject;
24a30
&gt; import org.eclipse.core.resources.ProjectScope;
28a35,36
&gt; import org.eclipse.core.runtime.preferences.IEclipsePreferences;
&gt; import org.eclipse.core.runtime.preferences.IScopeContext;
29a38
&gt; import org.eclipse.jdt.internal.ui.preferences.PropertyAndPreferencePage;
35d43
&lt; import org.eclipse.jface.preference.PreferencePage;
49d56
&lt; import org.eclipse.ui.IWorkbench;
50a58
&gt; import org.osgi.service.prefs.BackingStoreException;
58c66
&lt; public class AJCompilerPreferencePage extends PreferencePage 
---
&gt; public class AJCompilerPreferencePage extends PropertyAndPreferencePage 
61c69,77
&lt; 
---
&gt; 	
&gt; 	public static final String PREF_ID= "org.eclipse.ajdt.ui.preferences.AJCompilerPreferencePage"; //$NON-NLS-1$
&gt; 	public static final String PROP_ID= "org.eclipse.ajdt.ui.propertyPages.AJCompilerPreferencePage"; //$NON-NLS-1$
&gt; 	
&gt; 	// bug 90174 - leave these as strings to keep the code simple
&gt; 	private static final String VALUE_TRUE = "true"; //$NON-NLS-1$
&gt; 	private static final String VALUE_FALSE = "false"; //$NON-NLS-1$
&gt; 	
&gt; 	
95a112,187
&gt; 	/**
&gt; 	 * The default values used when the plugin is first installed or when
&gt; 	 * "restore defaults" is clicked.
&gt; 	 */
&gt; 	private static final Map defaultValueMap = new HashMap();
&gt; 	static {
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportInvalidAbsoluteTypeName, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportShadowNotInStructure, AspectJPreferences.VALUE_IGNORE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportCannotImplementLazyTJP, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportInvalidWildcardTypeName, AspectJPreferences.VALUE_IGNORE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportTypeNotExposedToWeaver, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportUnresolvableMember, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportUnmatchedSuperTypeInCall, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportIncompatibleSerialVersion, AspectJPreferences.VALUE_IGNORE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportNeedSerialVersionUIDField, AspectJPreferences.VALUE_IGNORE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_ReportNoInterfaceCtorJoinpoint, AspectJPreferences.VALUE_WARNING);
&gt; 		
&gt; 		// these options are being set to "true" or "false" (rather than AspectJPreferences.VALUE_ENABLED
&gt; 		// or AspectJPreferences.VALUE_DISABLED) because the underlying code works in true/false
&gt; 		// (mimic behaviour of AJCompilerPreferencePage) - bug 87128
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_NoWeave, VALUE_FALSE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_XSerializableAspects, VALUE_FALSE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_XLazyThisJoinPoint, VALUE_FALSE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_XNoInline, VALUE_FALSE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_XReweavable, VALUE_FALSE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_XReweavableCompress,VALUE_FALSE);
&gt; 		
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_Incremental, VALUE_TRUE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_BuildASM, VALUE_TRUE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_WeaveMessages, VALUE_FALSE);
&gt; 		
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_noJoinpointsForBridgeMethods, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_cantMatchArrayTypeOnVarargs, AspectJPreferences.VALUE_IGNORE);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_enumAsTargetForDecpIgnored, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_annotationAsTargetForDecpIgnored, AspectJPreferences.VALUE_WARNING);
&gt; 
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_invalidTargetForAnnotation, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_elementAlreadyAnnotated, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_runtimeExceptionNotSoftened, AspectJPreferences.VALUE_WARNING);
&gt; 		defaultValueMap.put(AspectJPreferences.OPTION_adviceDidNotMatch, AspectJPreferences.VALUE_WARNING);
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * List of all the preference keys for this page
&gt; 	 */
&gt; 	private static final String[] keys = new String[] {
&gt; 		AspectJPreferences.OPTION_ReportInvalidAbsoluteTypeName,
&gt; 		AspectJPreferences.OPTION_ReportShadowNotInStructure,
&gt;     	AspectJPreferences.OPTION_ReportCannotImplementLazyTJP,
&gt;     	AspectJPreferences.OPTION_ReportInvalidWildcardTypeName,
&gt;     	AspectJPreferences.OPTION_ReportTypeNotExposedToWeaver,
&gt;     	AspectJPreferences.OPTION_ReportUnresolvableMember,
&gt;     	AspectJPreferences.OPTION_ReportUnmatchedSuperTypeInCall,
&gt;     	AspectJPreferences.OPTION_ReportIncompatibleSerialVersion,
&gt;     	AspectJPreferences.OPTION_ReportNeedSerialVersionUIDField,
&gt;     	AspectJPreferences.OPTION_ReportNoInterfaceCtorJoinpoint,
&gt;     	AspectJPreferences.OPTION_NoWeave,
&gt;     	AspectJPreferences.OPTION_XSerializableAspects,
&gt;     	AspectJPreferences.OPTION_XLazyThisJoinPoint,
&gt;     	AspectJPreferences.OPTION_XNoInline,
&gt;     	AspectJPreferences.OPTION_XReweavable,
&gt;     	AspectJPreferences.OPTION_XReweavableCompress,
&gt;     	AspectJPreferences.OPTION_BuildASM,
&gt; 		AspectJPreferences.OPTION_Incremental,
&gt; 		AspectJPreferences.OPTION_WeaveMessages,
&gt; 		AspectJPreferences.OPTION_annotationAsTargetForDecpIgnored,
&gt; 		AspectJPreferences.OPTION_cantMatchArrayTypeOnVarargs,
&gt; 		AspectJPreferences.OPTION_enumAsTargetForDecpIgnored,
&gt; 		AspectJPreferences.OPTION_noJoinpointsForBridgeMethods,
&gt; 		AspectJPreferences.OPTION_invalidTargetForAnnotation,
&gt; 		AspectJPreferences.OPTION_elementAlreadyAnnotated,
&gt; 		AspectJPreferences.OPTION_runtimeExceptionNotSoftened,
&gt; 		AspectJPreferences.OPTION_adviceDidNotMatch
&gt; 	};
&gt; 
&gt; 	
174,228d265
&lt; 	/**
&lt; 	 * from IWorkbenchPreferencePage
&lt; 	 */
&lt; 	public void init(IWorkbench workbench) {
&lt; 	}
&lt; 
&lt; 	/**
&lt; 	 * from IWorkbenchPreferencePage
&lt; 	 */
&lt; 	public void createControl(Composite parent) {
&lt; 		super.createControl(parent);
&lt; 
&lt; 	}
&lt; 
&lt; 	/*
&lt; 	 * (non-Javadoc)
&lt; 	 * 
&lt; 	 * @see org.eclipse.jface.preference.PreferencePage#createContents(org.eclipse.swt.widgets.Composite)
&lt; 	 */
&lt; 	protected Control createContents(Composite parent) {
&lt; 		TabFolder folder = new TabFolder(parent, SWT.NONE);
&lt; 		folder.setLayout(new TabFolderLayout());
&lt; 		folder.setLayoutData(new GridData(GridData.FILL_BOTH));
&lt; 
&lt; 		Composite aspectjComposite = createMessagesTabContent(folder);
&lt; 		TabItem item = new TabItem(folder, SWT.NONE);
&lt; 		item
&lt; 				.setText(UIMessages.CompilerConfigurationBlock_aj_messages_tabtitle);
&lt; 		item.setControl(aspectjComposite);
&lt; 
&lt; 		aspectjComposite = createAdvancedTabContent(folder);
&lt; 		item = new TabItem(folder, SWT.NONE);
&lt; 		item
&lt; 				.setText(UIMessages.CompilerConfigurationBlock_aj_advanced_tabtitle);
&lt; 		item.setControl(aspectjComposite);
&lt; 
&lt; 		aspectjComposite = createOtherTabContent(folder);
&lt; 		item = new TabItem(folder, SWT.NONE);
&lt; 		item
&lt; 				.setText(UIMessages.CompilerConfigurationBlock_aj_other_tabtitle);
&lt; 		item.setControl(aspectjComposite);
&lt; 
&lt; 		// AJ5 options do not apply to Eclipse 3.0
&lt; 		if (!((EclipseVersion.MAJOR_VERSION == 3) &amp;&amp; (EclipseVersion.MINOR_VERSION == 0))) {
&lt; 			aspectjComposite = createAJ5TabContent(folder);
&lt; 			item = new TabItem(folder, SWT.NONE);
&lt; 			item
&lt; 					.setText(UIMessages.CompilerConfigurationBlock_aj_5_tabtitle);
&lt; 			item.setControl(aspectjComposite);
&lt; 		}
&lt; 		
&lt; 		return folder;
&lt; 	}
&lt; 
&lt; 
462c499,563
&lt; 		IPreferenceStore store = getPreferenceStore();
---
&gt; 		if(isProjectPreferencePage()) {
&gt; 			return projectPerformOK();
&gt; 		} else {
&gt; 			IPreferenceStore store = getPreferenceStore();
&gt; 	
&gt; 			boolean lintChanges = false;
&gt; 			for (int i = fComboBoxes.size() - 1; i &gt;= 0; i--) {
&gt; 				Combo curr = (Combo) fComboBoxes.get(i);
&gt; 				ControlData data = (ControlData) curr.getData();
&gt; 				String value = data.getValue(curr.getSelectionIndex());
&gt; 				if (!value.equals(store.getString(data.getKey()))) {
&gt; 					lintChanges = true;
&gt; 					store.setValue(data.getKey(), value);
&gt; 				}
&gt; 			}
&gt; 	
&gt; 			boolean advancedOrOtherChanges = false;
&gt; 			for (int i = fCheckBoxes.size() - 1; i &gt;= 0; i--) {
&gt; 				Button curr = (Button) fCheckBoxes.get(i);
&gt; 				ControlData data = (ControlData) curr.getData();
&gt; 				boolean value = curr.getSelection();
&gt; 				if (value != store.getBoolean(data.getKey())) {
&gt; 					advancedOrOtherChanges = true;
&gt; 					store.setValue(data.getKey(), value);
&gt; 				}
&gt; 			}
&gt; 	
&gt; 			AspectJUIPlugin.getDefault().savePluginPreferences();
&gt; 	
&gt; 			if (lintChanges || advancedOrOtherChanges) {
&gt; 				boolean doBuild = false;
&gt; 				String[] strings = getFullBuildDialogStrings();
&gt; 				if (strings != null) {
&gt; 					MessageDialog dialog = new MessageDialog(getShell(),
&gt; 							strings[0], null, strings[1], MessageDialog.QUESTION,
&gt; 							new String[]{IDialogConstants.YES_LABEL,
&gt; 									IDialogConstants.NO_LABEL,
&gt; 									IDialogConstants.CANCEL_LABEL}, 2);
&gt; 					int res = dialog.open();
&gt; 					if (res == 0) {
&gt; 						doBuild = true;
&gt; 					} else if (res != 1) {
&gt; 						return false; // cancel pressed
&gt; 					}
&gt; 				}
&gt; 				if (doBuild) {
&gt; 					doFullBuild();
&gt; 				}
&gt; 			}
&gt; 	
&gt; 			return true;
&gt; 		}
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * Checks whether the project settings have changed and 
&gt; 	 * updates the store accordingly if there is a change.
&gt; 	 */
&gt; 	private boolean updateProjectSettings() {
&gt; 		List tempComboBoxes = new ArrayList();
&gt; 		tempComboBoxes.addAll(fComboBoxes);
&gt; 		List tempCheckBoxes = new ArrayList();
&gt; 		tempCheckBoxes.addAll(fCheckBoxes);
&gt; 
&gt; 		boolean settingsChanged = false;
464d564
&lt; 		boolean lintChanges = false;
469,471c569,571
&lt; 			if (!value.equals(store.getString(data.getKey()))) {
&lt; 				lintChanges = true;
&lt; 				store.setValue(data.getKey(), value);
---
&gt; 			if (!value.equals(AspectJPreferences.getStringPrefValue(getProject(), data.getKey()))) {
&gt; 				settingsChanged = true;
&gt; 				setPrefValue(getProject(), data.getKey(), value);
475d574
&lt; 		boolean advancedOrOtherChanges = false;
480,482c579,581
&lt; 			if (value != store.getBoolean(data.getKey())) {
&lt; 				advancedOrOtherChanges = true;
&lt; 				store.setValue(data.getKey(), value);
---
&gt; 			if (value != getBooleanForString(AspectJPreferences.getStringPrefValue(getProject(), data.getKey()))) {
&gt; 				settingsChanged = true;
&gt; 				setPrefValue(getProject(), data.getKey(), value ? VALUE_TRUE : VALUE_FALSE);
484a584,589
&gt; 		
&gt; 		if (settingsChanged) {
&gt; 			flushPrefs(getProject());
&gt; 		}
&gt; 		return settingsChanged;
&gt; 	}
485a591,631
&gt; 	private void flushPrefs(IProject project) {
&gt; 			IScopeContext projectScope = new ProjectScope(project);
&gt; 			IEclipsePreferences projectNode = projectScope.getNode(AspectJPlugin.PLUGIN_ID);
&gt; 	       	try {
&gt; 				projectNode.flush();
&gt; 			} catch (BackingStoreException e) {
&gt; 			}
&gt; 	}
&gt; 	
&gt; 	private void setPrefValue(IProject project, String key, String value) {
&gt;     	IScopeContext projectScope = new ProjectScope(project);
&gt;     	IEclipsePreferences projectNode = projectScope.getNode(AspectJPlugin.PLUGIN_ID);
&gt;     	projectNode.put(key,value);
&gt; }
&gt; 	
&gt; 	private boolean getBooleanForString(String stringPrefValue) {
&gt; 		return stringPrefValue.equals(VALUE_TRUE);
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * Get the preference store for AspectJ mode
&gt; 	 */
&gt; 	protected String[] getProjectBuildDialogStrings() {
&gt; 		String title = UIMessages.CompilerConfigurationBlock_needsbuild_title;
&gt; 		String message = UIMessages.CompilerConfigurationBlock_needsprojectbuild_message;
&gt; 		return new String[]{title, message};
&gt; 	}
&gt; 
&gt; 	private boolean projectPerformOK() {
&gt; 		boolean projectSettingsChanged = updateProjectSettings();
&gt; 
&gt; 		boolean projectWorkspaceChanges = false;
&gt; 		if(AspectJPreferences.isUsingProjectSettings(getProject()) !=  useProjectSettings()) {
&gt; 			projectWorkspaceChanges = true;
&gt; 			// don't want to overwrite existing project settings
&gt; 			// because have just set them in the above call to 
&gt; 			// updateProjectSettings();
&gt; 			AspectJPreferences.setUsingProjectSettings(getProject(), useProjectSettings(),false);
&gt; 		}
&gt; 
&gt; 		
488c634
&lt; 		if (lintChanges || advancedOrOtherChanges) {
---
&gt; 		if (projectWorkspaceChanges || (projectSettingsChanged &amp;&amp; useProjectSettings())) {
490c636
&lt; 			String[] strings = getFullBuildDialogStrings();
---
&gt; 			String[] strings = getProjectBuildDialogStrings();
498c644,647
&lt; 				if (res == 0) {
---
&gt; 				if ((res == 0)) {
&gt; 				    // by only setting compilerSettingsUpdated to be true here, means that
&gt; 				    // the user wont select "don't want to build" here and then get a build
&gt; 				    // from other pages.
500a650
&gt; 				    doBuild = false;
501a652,653
&gt; 				} else {
&gt; 				    doBuild = false;
504,506d655
&lt; 			if (doBuild) {
&lt; 				doFullBuild();
&lt; 			}
509c658
&lt; 		return true;
---
&gt; 		return true;		
610,612c759,768
&lt; 		
&lt; 
&lt; 		boolean currValue = getPreferenceStore().getBoolean(key);
---
&gt; 		boolean currValue;
&gt; 		if(isProjectPreferencePage()) {
&gt; 			if(hasProjectSpecificOptions(getProject())) {
&gt; 				currValue = getBooleanForString(AspectJPreferences.getStringPrefValue(getProject(), key));
&gt; 			} else {
&gt; 				currValue = getPreferenceStore().getBoolean(key);
&gt; 			}
&gt; 		} else {
&gt; 			currValue = getPreferenceStore().getBoolean(key);
&gt; 		}
697a854,958
&gt; 
&gt; 	protected Control createPreferenceContent(Composite composite) {
&gt; 		TabFolder folder = new TabFolder(composite, SWT.NONE);
&gt; 		folder.setLayout(new TabFolderLayout());
&gt; 		folder.setLayoutData(new GridData(GridData.FILL_BOTH));
&gt; 
&gt; 		Composite aspectjComposite = createMessagesTabContent(folder);
&gt; 		TabItem item = new TabItem(folder, SWT.NONE);
&gt; 		item
&gt; 				.setText(UIMessages.CompilerConfigurationBlock_aj_messages_tabtitle);
&gt; 		item.setControl(aspectjComposite);
&gt; 
&gt; 		aspectjComposite = createAdvancedTabContent(folder);
&gt; 		item = new TabItem(folder, SWT.NONE);
&gt; 		item
&gt; 				.setText(UIMessages.CompilerConfigurationBlock_aj_advanced_tabtitle);
&gt; 		item.setControl(aspectjComposite);
&gt; 
&gt; 		aspectjComposite = createOtherTabContent(folder);
&gt; 		item = new TabItem(folder, SWT.NONE);
&gt; 		item
&gt; 				.setText(UIMessages.CompilerConfigurationBlock_aj_other_tabtitle);
&gt; 		item.setControl(aspectjComposite);
&gt; 
&gt; 		// AJ5 options do not apply to Eclipse 3.0
&gt; 		if (!((EclipseVersion.MAJOR_VERSION == 3) &amp;&amp; (EclipseVersion.MINOR_VERSION == 0))) {
&gt; 			aspectjComposite = createAJ5TabContent(folder);
&gt; 			item = new TabItem(folder, SWT.NONE);
&gt; 			item
&gt; 					.setText(UIMessages.CompilerConfigurationBlock_aj_5_tabtitle);
&gt; 			item.setControl(aspectjComposite);
&gt; 		}
&gt; 		
&gt; 		return folder;
&gt; 	}
&gt; 
&gt; 	protected boolean hasProjectSpecificOptions(IProject project) {
&gt; 		return project != null &amp;&amp; AspectJPreferences.isUsingProjectSettings(project);
&gt; 	}
&gt; 
&gt; 	public static void setProjectDefaults(IEclipsePreferences projectNode) {
&gt; 		for (int i = 0; i &lt; keys.length; i++) {
&gt; 			String value = (String)defaultValueMap.get(keys[i]);
&gt; 			projectNode.put(keys[i], value);
&gt; 		}
&gt; 	}
&gt; 
&gt; 	public static void setProjectDefaultsIfValueNotAlreadySet(IEclipsePreferences projectNode) {
&gt; 		List existingKeysList = new ArrayList();
&gt; 		try {
&gt; 			existingKeysList = Arrays.asList(projectNode.keys());
&gt; 		} catch (BackingStoreException e) {
&gt; 		}
&gt; 		for (int i = 0; i &lt; keys.length; i++) {
&gt; 			String value = (String)defaultValueMap.get(keys[i]);
&gt; 			boolean keyExists = false;
&gt; 			if (existingKeysList.contains(keys[i])) {
&gt; 				keyExists = true;
&gt; 			}
&gt; 			if (!keyExists) {
&gt; 				projectNode.put(keys[i], value);				
&gt; 			}
&gt; 		}
&gt; 	}
&gt; 
&gt; 	public static void removeProjectValues(IEclipsePreferences projectNode) {
&gt; 		for (int i = 0; i &lt; keys.length; i++) {
&gt; 			projectNode.remove(keys[i]);
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	/* (non-Javadoc)
&gt; 	 * @see org.eclipse.jdt.internal.ui.preferences.PropertyAndPreferencePage#getPreferencePageID()
&gt; 	 */
&gt; 	protected String getPreferencePageID() {
&gt; 		return PREF_ID;
&gt; 	}
&gt; 	
&gt; 	/* (non-Javadoc)
&gt; 	 * @see org.eclipse.jdt.internal.ui.preferences.PropertyAndPreferencePage#getPropertyPageID()
&gt; 	 */
&gt; 	protected String getPropertyPageID() {
&gt; 		return PROP_ID;
&gt; 	}
&gt; 	
&gt; 	// Override to make visible to PreferencePageBuilder aspect
&gt; 	protected IProject getProject() {
&gt; 		return super.getProject();
&gt; 	}
&gt; 	
&gt; //	 Override to make it possible to be advised by PreferencePageBuilder aspect
&gt; 	public void dispose() {
&gt; 		super.dispose();
&gt; 	}
&gt; 	
&gt; //	 Override to make it possible to be advised by PreferencePageBuilder aspect
&gt; 	protected Control createContents(Composite parent) {
&gt; 		return super.createContents(parent);
&gt; 	}
&gt; 
&gt; //	 Override to make it possible to be called by PreferencePageBuilder aspect
&gt; 	protected boolean useProjectSettings() {
&gt; 		return super.useProjectSettings();
&gt; 	}
&gt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/plugin.xml" revision="1.63" state="changed">666c666
&lt;             class="org.eclipse.ajdt.internal.ui.CompilerPropertyPage"
---
&gt;             class="org.eclipse.ajdt.internal.ui.preferences.AJCompilerPreferencePage"
668c668
&lt;             id="org.eclipse.ajdt.ui.Compiler"&gt;
---
&gt;             id="org.eclipse.ajdt.ui.propertyPages.AJCompilerPreferencePage"&gt;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/wizards/Project preferences wizard tests.txt" revision="1.9" state="deleted"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/property pages/Project properties tests.txt" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="112243" transactionid="69889">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="6"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="12"/>
<property name="lines-churned" value="18"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-instanceof K-new K-null K-return K-throw M O-! O-!= O-() O-&amp;&amp; O-+ O-instanceof T V Y Z-cast Z-if Z-throw</fullfingerprint>
<bugreport>I am seeing this exception when using ajc to do binary weaving:

     [iajc] Exception thrown from AspectJ 1.5.0M4

     [iajc] This might be logged as a bug already -- find current bugs at
     [iajc]   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component
=Compiler

     [iajc] Bugs for exceptions thrown have titles File:line from the top stack,

     [iajc] e.g., "SomeFile.java:243"

     [iajc] If you don't find the exception below in a bug, please add a new bug

     [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
     [iajc] To make the bug a priority, please include a test program
     [iajc] that can reproduce this exception.
     [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature

     [iajc] when batch building with classpath: ...
     [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature
     [iajc] java.lang.ClassCastException: org.aspectj.weaver.MissingResolvedType
WithKnownSignature
     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWor
ld.java:277)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.addClassFile(BcelWeaver.ja
va:373)
     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.addJarFile(BcelWeaver.java
:306)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBce
lWorld(AjBuildManager.java:598)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:204)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu
ild(AjBuildManager.java:151)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1
12)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:
60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:326)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
     [iajc]     at org.aspectj.tools.ajc.Main.main(Main.java:83)


     [iajc] 1 fail|abort

I see this also in HEAD and used the debugger to determine it is trying to 
resolve the type that it's trying to load!

I am able to get it to finish the weave with no errors by changing BcelWorld as 
follows:

	public BcelObjectType addSourceObjectType(JavaClass jc) {
		BcelObjectType ret = null;
		String signature = UnresolvedType.forName(jc.getClassName
()).getSignature();
		ReferenceType nameTypeX = null;
		Object lookup = typeMap.get(signature);
		if (lookup instanceof ReferenceType) {
			nameTypeX = (ReferenceType)lookup;
		}

Instead of just casting. Then the result is null and it falls through to the 
usual lookup unresolved type logic. Is this fix correct?

I suspect it would take a few hours to narrow down a test case for this one.</bugreport>
<pre-fix-testcases failing="177" file="output/112243/pre-fix/testresults.xml" passing="1583" size="1760"/>
<post-fix-testcases failing="178" file="output/112243/post-fix/testresults.xml" passing="1582" size="1760"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWorld.java" revision="1.31" state="changed">43a44
&gt; import org.aspectj.weaver.BCException;
276,277c277,289
&lt;         ReferenceType nameTypeX = (ReferenceType)typeMap.get(signature);
&lt; 
---
&gt; 		
&gt; 		Object fromTheMap = typeMap.get(signature);
&gt; 		
&gt; 		if (fromTheMap!=null &amp;&amp; !(fromTheMap instanceof ReferenceType)) {
&gt; 			// what on earth is it then? See pr 112243
&gt; 			StringBuffer exceptionText = new StringBuffer();
&gt; 			exceptionText.append("Found invalid (not a ReferenceType) entry in the type map. ");
&gt; 			exceptionText.append("Signature=["+signature+"] Found=["+fromTheMap+"] Class=["+fromTheMap.getClass()+"]");
&gt; 			throw new BCException(exceptionText.toString());
&gt; 		}
&gt; 		
&gt; 		ReferenceType nameTypeX = (ReferenceType)fromTheMap;
&gt;         
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.59" state="changed">686a687,691
&gt; 			if (type instanceof MissingResolvedTypeWithKnownSignature) {
&gt; 				if (debug) 
&gt; 					System.err.println("Not putting a missing type into the typemap: key="+key+" type="+type);
&gt; 				return type;
&gt; 			}
</file>
</fixedFiles>
</bug>
<bug id="112736" transactionid="68472">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="75"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="75"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-false K-for K-if K-import K-new K-null K-package K-return K-true M O-! O-!= O-cast T V Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>If you convert file extensions between .aj and .java, the compiler doesn't 
properly clear its symbol table, generating bogus warnings about conflicting 
inter-type declarations. It should avoid this. Work around: full rebuild.

See screenshot for an example. After recompiling the "errors" go away...</bugreport>
<testsforfix ID="112736" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr112736"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/112736/pre-fix/testresults.xml" passing="1604" size="1784"/>
<post-fix-testcases failing="135" file="output/112736/post-fix/testresults.xml" passing="1317" size="1452"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java" revision="1.20" state="changed">40a41
&gt; import org.aspectj.weaver.ResolvedType;
149a151,154
&gt; 			
&gt; 		boolean couldStillBeIncremental = processDeletedFiles(deletedFiles);
&gt; 		
&gt; 		if (!couldStillBeIncremental) return false;
154a160,188
&gt; 		
&gt; 	/**
&gt; 	 * Checks if any of the files in the set passed in contains an aspect declaration.  If one is found
&gt; 	 * then we start the process of batch building, i.e. we remove all the results of the last build,
&gt; 	 * call any registered listener to tell them whats happened and return false.
&gt; 	 * 
&gt; 	 * @return false if we discovered an aspect declaration
&gt; 	 */
&gt;     private boolean processDeletedFiles(Set deletedFiles) {
&gt; 		for (Iterator iter = deletedFiles.iterator(); iter.hasNext();) {
&gt; 			File  aDeletedFile = (File ) iter.next();
&gt; 			InterimCompilationResult cr = (InterimCompilationResult)resultsFromFile.get(aDeletedFile);
&gt; 			if (cr!=null) {
&gt; 				Map compiledTypes = cr.result().compiledTypes;
&gt; 				if (compiledTypes!=null) {
&gt; 					for (Iterator iterator = compiledTypes.keySet().iterator(); iterator.hasNext();) {
&gt; 						char[] className = (char[])iterator.next();
&gt; 						ResolvedType rt = world.resolve(new String(className).replace('/','.'));
&gt; 						if (rt.isAspect()) { 
&gt; 							removeAllResultsOfLastBuild();
&gt; 							if (stateListener!=null) stateListener.detectedAspectDeleted(aDeletedFile);
&gt; 							return false;
&gt; 						}
&gt; 					}
&gt; 				}
&gt; 			}
&gt; 		}
&gt; 		return true;
&gt;     }
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/IStateListener.java" revision="1.3" state="changed">34a35,40
&gt; 	
&gt; 	/**
&gt; 	 * Called if state processing detects a file was deleted that contained an aspect declaration.
&gt; 	 * Incremental compilation will not be attempted if this occurs.
&gt; 	 */
&gt; 	public void detectedAspectDeleted(File f);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.14" state="changed">371,381c371,381
&lt; //	public void testPr112736() {
&lt; //		AjdeInteractionTestbed.VERBOSE = true;
&lt; //		initialiseProject("PR112736");
&lt; //		build("PR112736");
&lt; //		checkWasFullBuild();
&lt; //		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR112736" + File.separatorChar + "src" + File.separatorChar + "pack" + File.separatorChar + "A.java";
&lt; //		(new File(fileC2)).delete();
&lt; //		alter("PR112736","inc1");
&lt; //		build("PR112736");
&lt; //		checkWasntFullBuild();
&lt; //	}
---
&gt; 	public void testPr112736() {
&gt; 		AjdeInteractionTestbed.VERBOSE = true;
&gt; 		initialiseProject("PR112736");
&gt; 		build("PR112736");
&gt; 		checkWasFullBuild();
&gt; 		String fileC2 = getWorkingDir().getAbsolutePath() + File.separatorChar + "PR112736" + File.separatorChar + "src" + File.separatorChar + "pack" + File.separatorChar + "A.java";
&gt; 		(new File(fileC2)).delete();
&gt; 		alter("PR112736","inc1");
&gt; 		build("PR112736");
&gt; 		checkWasFullBuild();
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/IncrementalTests.java" revision="1.10" state="changed">16a17
&gt; import org.aspectj.ajdt.internal.core.builder.AbstractStateListener;
18d18
&lt; import org.aspectj.ajdt.internal.core.builder.IStateListener;
115c115
&lt; 	  class MyStateListener implements IStateListener {
---
&gt; 	  class MyStateListener extends AbstractStateListener {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java" revision="1.7" state="changed">31a32
&gt; import org.aspectj.ajdt.internal.core.builder.AbstractStateListener;
33d33
&lt; import org.aspectj.ajdt.internal.core.builder.IStateListener;
697c697
&lt; 	static class MyStateListener implements IStateListener {
---
&gt; 	static class MyStateListener extends AbstractStateListener {
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AbstractStateListener.java" revision="1.1" state="new">/**
 * Copyright (c) 2005 IBM and other contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Andy Clement     initial implementation 
 * ******************************************************************/
package org.aspectj.ajdt.internal.core.builder;

import java.io.File;
import java.util.List;

/**
 * Subtypes can override whatever they want...
 * 
 * @author AndyClement
 *
 */
public abstract class AbstractStateListener implements IStateListener {

	public void detectedClassChangeInThisDir(File f) {	}

	public void aboutToCompareClasspaths(List oldClasspath, List newClasspath) {	}

	public void pathChangeDetected() {	}

	public void detectedAspectDeleted(File f) {	}

	public void buildSuccessful(boolean wasFullBuild) {	}

}
</file>
</fixedFiles>
</bug>
<bug id="113257" transactionid="69128">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="12"/>
<property name="lines-added" value="111"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="32"/>
<property name="lines-churned" value="143"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-for K-if K-import K-instanceof K-new K-return K-true M O-&lt; O-== O-|| O-- O-! O-() O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>I keep getting an incremental compilation error on this pointcut when I save 
other files (in AJDT):

    public pointcut scope() :
        within(DoMonitorErrors+) ||
        ((within(pkg1..*)|| within(pkg2..*) || within(pkg3..*)) &amp;&amp; 
        !within(pkg1.monitoring..*));

It is used as follows:
    after() throwing (Throwable t) : publicMethodExec() &amp;&amp; scope() &amp;&amp; 
adviceEnabled() {
...
        recordThrowable(t, thisJoinPointStaticPart, 
thisEnclosingJoinPointStaticPart);
    }

    before(Throwable t) : handler(*) &amp;&amp; args(t) &amp;&amp; scope() &amp;&amp; adviceEnabled() {
...
        recordThrowable(t, thisJoinPointStaticPart, 
thisEnclosingJoinPointStaticPart);
    }

The resulting incremental compilation produces an error which requires a full 
rebuild to clear:
	the parameter t is not bound in [all branches of] pointcut
	ErrorMonitor.aj	aspectjSupport/src/pkg1/monitoring	line 58</bugreport>
<testsforfix ID="113257" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr113257"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="182" file="output/113257/pre-fix/testresults.xml" passing="1608" size="1790"/>
<post-fix-testcases failing="182" file="output/113257/post-fix/testresults.xml" passing="1608" size="1790"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.java" revision="1.4" state="changed">17a18
&gt; import org.aspectj.weaver.patterns.Pointcut.MatchesNothingPointcut;
29,34c30,47
&lt; 	public Pointcut rewrite(Pointcut pc) {
&lt; 		if (WATCH_PROGRESS) System.out.println("Initial pointcut is        ==&gt; " + pc);
&lt; 		Pointcut result = distributeNot(pc);
&lt; 		if (WATCH_PROGRESS) System.out.println("Distributing NOT gives     ==&gt; " + result);
&lt; 		result = pullUpDisjunctions(result);
&lt; 		if (WATCH_PROGRESS) System.out.println("Pull up disjunctions gives ==&gt; " + result);
---
&gt; 	/**
&gt; 	 * Set forcerewrite if you want to override the checking for something already in DNF (useful for
&gt; 	 * some testing)
&gt; 	 * Repeated processing of something already in DNF is expensive (it ends up being done for
&gt; 	 * every pointcut on every incremental compile) - so let's not do it if we don't have to.
&gt; 	 * See pr113257
&gt; 	 */
&gt; 	public Pointcut rewrite(Pointcut pc,boolean forceRewrite) {
&gt; 		Pointcut result = pc;
&gt; 		if (forceRewrite || !isDNF(pc)) {
&gt; 			if (WATCH_PROGRESS) System.out.println("Initial pointcut is        ==&gt; " + format(pc));
&gt; 			result = distributeNot(result);
&gt; 			if (WATCH_PROGRESS) System.out.println("Distributing NOT gives     ==&gt; " + format(result));
&gt; 			result = pullUpDisjunctions(result);
&gt; 			if (WATCH_PROGRESS) System.out.println("Pull up disjunctions gives ==&gt; " + format(result));		
&gt; 	    } else {
&gt; 			if (WATCH_PROGRESS) System.out.println("Not distributing NOTs or pulling up disjunctions, already DNF ==&gt; "+format(pc));
&gt; 	    }
36c49
&lt; 		if (WATCH_PROGRESS) System.out.println("Simplifying ANDs gives     ==&gt; " + result);
---
&gt; 		if (WATCH_PROGRESS) System.out.println("Simplifying ANDs gives     ==&gt; " + format(result));
38c51,53
&lt; 		if (WATCH_PROGRESS) System.out.println("Sorting ORs gives          ==&gt; " + result);
---
&gt; 		if (WATCH_PROGRESS) System.out.println("Sorting ORs gives          ==&gt; " + format(result));
&gt; 		//result = removeNothings(result);
&gt; 	    //if (WATCH_PROGRESS) System.out.println("Removing nothings gives    ==&gt; " + format(result));
41a57,100
&gt; 	public Pointcut rewrite(Pointcut pc) {
&gt; 		return rewrite(pc,false);
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Check if a pointcut is in DNF - if it is then it should be lots of 'ORs' up the 
&gt; 	 * top with 'ANDs' beneath them.
&gt; 	 */
&gt; 	private boolean isDNF(Pointcut pc) {
&gt; 		return isDNFHelper(pc,true);
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Helper function for determining DNFness.  Records when we have crossed the point of allowing ORs.
&gt; 	 */
&gt; 	private boolean isDNFHelper(Pointcut pc,boolean canStillHaveOrs) {
&gt; 		if (isAnd(pc)) {
&gt; 			AndPointcut ap = (AndPointcut)pc;
&gt; 			return isDNFHelper(ap.getLeft(),false) &amp;&amp; isDNFHelper(ap.getRight(),false);
&gt; 		} else if (isOr(pc)) {
&gt; 			if (!canStillHaveOrs) return false;
&gt; 			OrPointcut op = (OrPointcut)pc;
&gt; 			return isDNFHelper(op.getLeft(),true) &amp;&amp; isDNFHelper(op.getRight(),true);
&gt; 		} else if (isNot(pc)) {
&gt; 			return isDNFHelper(((NotPointcut)pc).getNegatedPointcut(),canStillHaveOrs);
&gt; 		} else {
&gt; 			return true;
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	/** 
&gt; 	 * Allows formatting of the output pointcut for debugging...
&gt; 	 */
&gt; 	public static String format(Pointcut p) {
&gt; 		String s = p.toString();
&gt; 		// Regex param needs '(' and '*' changing to '.'
&gt; //		s = s.replaceAll("persingleton.pkg1.monitoring.ErrorMonitoring.","M");
&gt; //		s = s.replaceAll("args.BindingTypePattern.java.lang.Throwable, 0.","Z");
&gt; //		s = s.replaceAll("within.pkg1.monitoring.DoMonitorErrors+.","X");
&gt; //		s=s.replaceAll("within.pkg1.monitoring....","Y");
&gt; //		s=s.replaceAll("if.true.","N");
&gt; 		return s;
&gt; 	}
&gt; 	
85a145,146
&gt; 	// is this next one optimal??
&gt; 	// (A || B) &amp;&amp; (C || D) =&gt;  (A &amp;&amp; B &amp;&amp; C &amp;&amp; D) || (B &amp;&amp; C) || (A &amp;&amp; C &amp;&amp; D) || (A &amp;&amp; B &amp;&amp; C)
113,114c174,185
&lt; 				
&lt; 			} else {
---
&gt; 			}  else if (isOr(right) &amp;&amp; isOr(left)) {
&gt; 				// (A || B) &amp;&amp; (C || D) =&gt;  (A &amp;&amp; B &amp;&amp; C &amp;&amp; D) || (B &amp;&amp; C) || (A &amp;&amp; C &amp;&amp; D) || (A &amp;&amp; B &amp;&amp; C)
&gt; 				Pointcut A = pullUpDisjunctions(((OrPointcut)left).getLeft());
&gt; 				Pointcut B = pullUpDisjunctions(((OrPointcut)left).getRight());
&gt; 				Pointcut C = pullUpDisjunctions(((OrPointcut)right).getLeft());
&gt; 				Pointcut D = pullUpDisjunctions(((OrPointcut)right).getRight());
&gt; 				Pointcut newLeft = new OrPointcut(createAndsFor(new Pointcut[]{not(A),B,not(C),D}),
&gt; 						                          createAndsFor(new Pointcut[]{B,C}));
&gt; 				Pointcut newRight = new OrPointcut(createAndsFor(new Pointcut[]{A,not(C),not(D)}),
&gt; 						                           createAndsFor(new Pointcut[]{A,not(B),C}));
&gt; 				return pullUpDisjunctions(new OrPointcut(newLeft,newRight));
&gt; 			}	else {
125c196,223
&lt; 		
---
&gt; 	
&gt; 	/**
&gt; 	 * Returns a NOTted form of the pointcut p - we cope with already NOTted pointcuts.
&gt; 	 */
&gt; 	public Pointcut not(Pointcut p) {
&gt; 		if (isNot(p)) {
&gt; 			return ((NotPointcut)p).getNegatedPointcut();
&gt; 		}
&gt; 		return new NotPointcut(p);
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Passed an array of pointcuts, returns an AND tree with them in.
&gt; 	 */
&gt; 	public Pointcut createAndsFor(Pointcut[] ps) {
&gt; 		if (ps.length==1) return ps[0]; // dumb case
&gt; 		if (ps.length==2) { // recursion exit case
&gt; 			return new AndPointcut(ps[0],ps[1]);
&gt; 		}
&gt; 		// otherwise ...
&gt; 		Pointcut[] subset = new Pointcut[ps.length-1];
&gt; 		for (int i = 1; i &lt; ps.length; i++) {
&gt; 			subset[i-1]=ps[i];
&gt; 		}
&gt; 		return new AndPointcut(ps[0],createAndsFor(subset));
&gt; 	}
&gt; 
&gt; 	
177c275,281
&lt; 			return new NotPointcut(simplifyAnds(npc.getNegatedPointcut()));
---
&gt; 			Pointcut notBody = npc.getNegatedPointcut();
&gt; 			if (isNot(notBody)) {
&gt; 				// !!X =&gt; X
&gt; 				return simplifyAnds(((NotPointcut)notBody).getNegatedPointcut());
&gt; 			} else {
&gt; 				return new NotPointcut(simplifyAnds(npc.getNegatedPointcut()));
&gt; 			}
227a332,362
&gt; 	/**
&gt; 	 * Removes MATCHES_NOTHING pointcuts
&gt; 	 */
&gt; 	private Pointcut removeNothings(Pointcut pc) {
&gt; 		if (isAnd(pc)) {
&gt; 			AndPointcut apc = (AndPointcut)pc;
&gt; 			Pointcut right = removeNothings(apc.getRight());
&gt; 			Pointcut left  = removeNothings(apc.getLeft());
&gt; 			if (left instanceof MatchesNothingPointcut || right instanceof MatchesNothingPointcut) return new MatchesNothingPointcut();
&gt; 			return new AndPointcut(left,right);
&gt; 		} else if (isOr(pc)) {
&gt; 			OrPointcut opc = (OrPointcut)pc;
&gt; 			Pointcut right = removeNothings(opc.getRight());
&gt; 			Pointcut left  = removeNothings(opc.getLeft());
&gt; 			if (left instanceof MatchesNothingPointcut 
&gt; 					&amp;&amp; !(right instanceof MatchesNothingPointcut)) {
&gt; 				return right;
&gt; 			} else if (right instanceof MatchesNothingPointcut 
&gt; 					&amp;&amp; !(left instanceof MatchesNothingPointcut)) {
&gt; 				return left;
&gt; 			} else if (!(left instanceof MatchesNothingPointcut)
&gt; 					&amp;&amp; !(right instanceof MatchesNothingPointcut)) {
&gt; 				return new OrPointcut(left,right);
&gt; 			} else if (left instanceof MatchesNothingPointcut
&gt; 					&amp;&amp; right instanceof MatchesNothingPointcut) {
&gt; 				return new MatchesNothingPointcut();	
&gt; 			}			
&gt; 		}
&gt; 		return pc;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.24" state="changed">443a444,456
&gt; 	/**
&gt; 	 * We have problems with multiple rewrites of a pointcut across incremental builds.
&gt; 	 */
&gt; 	public void testPr113257() {
&gt; 		initialiseProject("PR113257");
&gt; 		build("PR113257");
&gt; 		alter("PR113257","inc1");
&gt; 		build("PR113257");
&gt; 		checkWasntFullBuild();
&gt; 		alter("PR113257","inc1");
&gt; 		build("PR113257");
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/patterns/PointcutRewriterTest.java" revision="1.4" state="changed">40c40
&lt; 		assertEquals("(!this(Foo) || !this(Goo))",prw.rewrite(and).toString());
---
&gt; 		assertEquals("(!this(Foo) || !this(Goo))",prw.rewrite(and,true).toString());
42c42
&lt; 		assertEquals("(!this(Foo) &amp;&amp; !this(Goo))",prw.rewrite(or).toString());
---
&gt; 		assertEquals("(!this(Foo) &amp;&amp; !this(Goo))",prw.rewrite(or,true).toString());
44c44
&lt; 		assertEquals("(!this(Foo) || this(Goo))",prw.rewrite(nestedNot).toString());
---
&gt; 		assertEquals("(!this(Foo) || this(Goo))",prw.rewrite(nestedNot,true).toString());
</file>
</fixedFiles>
</bug>
<bug id="113510" transactionid="69707">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="36"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="41"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-finally K-if K-noop K-null K-return K-true K-try K-while M O-== O-- O-!= O-?: O-() O-+ T V Y Z-cond Z-if Z-while</fullfingerprint>
<bugreport>clearly define what the goal for readAspect is
old byte per byte reading cause NPE in some test case
current impl is hashcode for aspect name + classloader - ie unstable across
startups.</bugreport>
<pre-fix-testcases failing="180" file="output/113510/pre-fix/testresults.xml" passing="1589" size="1769"/>
<post-fix-testcases failing="180" file="output/113510/post-fix/testresults.xml" passing="1589" size="1769"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.24" state="changed">286d285
&lt;                 	String aspectCode = readAspect(aspectClassName, loader);
288c287
&lt;                     	namespace=new StringBuffer(aspectCode);
---
&gt;                     	namespace=new StringBuffer(aspectClassName);
290c289
&lt;                     	namespace = namespace.append(";"+aspectCode);
---
&gt;                     	namespace = namespace.append(";"+aspectClassName);
314a314
&gt; 
316d315
&lt;                 	String aspectCode = readAspect(concreteAspect.name, loader);
318c317
&lt;                     	namespace=new StringBuffer(aspectCode);
---
&gt;                     	namespace=new StringBuffer(concreteAspect.name);
320c319
&lt;                     	namespace = namespace.append(";"+aspectCode);
---
&gt;                     	namespace = namespace.append(";"+concreteAspect.name);
540,573d538
&lt; 
&lt;     /**
&lt;      * Read in an aspect from the disk and return its bytecode as a String
&lt;      * @param name	the name of the aspect to read in
&lt;      * @return the bytecode representation of the aspect
&lt;      */
&lt;     private String readAspect(String name, ClassLoader loader){
&lt;         if (true) return name+"@"+(loader==null?"0":Integer.toString(loader.hashCode()));
&lt;         // FIXME AV - ?? can someone tell me why we read the whole bytecode
&lt;         // especially one byte by one byte
&lt;         // also it does some NPE sometime (see AtAjLTW "LTW Decp2")
&lt;         InputStream is = null;
&lt;         try {
&lt;     		String result = "";
&lt;         	is = loader.getResourceAsStream(name.replace('.','/')+".class");
&lt; 			int b = is.read();
&lt; 			while(b!=-1){
&lt; 				result = result + b;
&lt; 				b=is.read();
&lt; 			}
&lt; 			is.close();
&lt; 	    	return result;
&lt; 		} catch (IOException e) {
&lt; 			e.printStackTrace();
&lt; 			return "";
&lt; 		} catch (NullPointerException e) {
&lt; 			//probably tried to read in a "non aspect @missing@" aspect
&lt; 			System.err.println("ClassLoaderWeavingAdaptor.readAspect() name: "+name+"  Exception: "+e);
&lt; 			return "";
&lt; 		} finally {
&lt;             try {is.close();} catch (Throwable t) {;}
&lt;         }
&lt;     }
&lt;     
</file>
</fixedFiles>
</bug>
<bug id="113511" transactionid="71606">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="10"/>
<property name="lines-added" value="10"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="16"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if M O-! T V Z-cast Z-if</fullfingerprint>
<bugreport>Alex, here is the basic patch that is working well before you leave for the
weekend ;-) I'll let Matthew post it officially to bugzilla since it was his
idea. The earlier return from !enabled is a small addition I made that seems
to help further. It would be great to have this in HEAD so I can report
performance numbers based on it in part 2 of my article on developerworks
;-)

Hope you are enjoying your new addition!

Thanks!

Index: ClassLoaderWeavingAdaptor.java
===================================================================
RCS file:
/home/technology/org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtim
e/ClassLoaderWeavingAdaptor.java,v
retrieving revision 1.18
diff -u -r1.18 ClassLoaderWeavingAdaptor.java
--- ClassLoaderWeavingAdaptor.java      19 Oct 2005 13:11:36 -0000      1.18
+++ ClassLoaderWeavingAdaptor.java      21 Oct 2005 16:04:41 -0000
@@ -107,8 +107,13 @@

        // register the definitions
        registerDefinitions(weaver, loader);
+        if (!enabled) {
+               return;
+        }
        messageHandler = bcelWorld.getMessageHandler();

+
bcelWorld.setResolutionLoader((ClassLoader)null);//loader.getParent());
+
        // after adding aspects
        weaver.prepareForWeave();
    }
@@ -148,7 +153,11 @@
                           definitions.add(DocumentParser.parse(xml));
                       }
               }
-
+               if (definitions.isEmpty()) {
+                       enabled = false;
+                       return;
+               }
+
            // still go thru if definitions is empty since we will
configure
            // the default message handler in there
            registerOptions(weaver, loader, definitions);</bugreport>
<pre-fix-testcases failing="177" file="output/113511/pre-fix/testresults.xml" passing="1584" size="1761"/>
<post-fix-testcases failing="179" file="output/113511/post-fix/testresults.xml" passing="1582" size="1761"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/Aj.java" revision="1.12" state="changed">88c88
&lt;             ExplicitlyInitializedClassLaoderWeavingAdaptor adaptor = null;
---
&gt;             ExplicitlyInitializedClassLoaderWeavingAdaptor adaptor = null;
90c90
&lt;                 adaptor = (ExplicitlyInitializedClassLaoderWeavingAdaptor) weavingAdaptors.get(loader);
---
&gt;                 adaptor = (ExplicitlyInitializedClassLoaderWeavingAdaptor) weavingAdaptors.get(loader);
95c95
&lt;                     adaptor = new ExplicitlyInitializedClassLaoderWeavingAdaptor(weavingAdaptor);
---
&gt;                     adaptor = new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
117c117
&lt;     static class ExplicitlyInitializedClassLaoderWeavingAdaptor {
---
&gt;     static class ExplicitlyInitializedClassLoaderWeavingAdaptor {
121c121
&lt;         public ExplicitlyInitializedClassLaoderWeavingAdaptor(ClassLoaderWeavingAdaptor weavingAdaptor) {
---
&gt;         public ExplicitlyInitializedClassLoaderWeavingAdaptor(ClassLoaderWeavingAdaptor weavingAdaptor) {
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.19" state="changed">110d109
&lt;         messageHandler = bcelWorld.getMessageHandler();
112,113c111,116
&lt;         // after adding aspects
&lt;         weaver.prepareForWeave();
---
&gt;         // AV - see #113511 - not sure it is good to skip message handler
&gt;         if (enabled) {
&gt;             messageHandler = bcelWorld.getMessageHandler();
&gt;             // after adding aspects
&gt;             weaver.prepareForWeave();
&gt;         }
155,158c158,167
&lt;             registerAspectExclude(weaver, loader, definitions);
&lt;             registerAspects(weaver, loader, definitions);
&lt;             registerIncludeExclude(weaver, loader, definitions);
&lt;             registerDump(weaver, loader, definitions);
---
&gt; 
&gt;             // AV - see #113511
&gt;             if (!definitions.isEmpty()) {
&gt;                 registerAspectExclude(weaver, loader, definitions);
&gt;                 registerAspects(weaver, loader, definitions);
&gt;                 registerIncludeExclude(weaver, loader, definitions);
&gt;                 registerDump(weaver, loader, definitions);
&gt;             } else {
&gt;                 enabled = false;// will allow very fast skip in shouldWeave()
&gt;             }
</file>
</fixedFiles>
</bug>
<bug id="113723" transactionid="73772">
<property name="files-churned" value="15"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="7"/>
<property name="hunks" value="33"/>
<property name="lines-added" value="261"/>
<property name="lines-deleted" value="111"/>
<property name="lines-modified" value="82"/>
<property name="lines-churned" value="454"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-else K-false K-for K-if K-import K-instanceof K-new K-null K-package K-return K-this K-true K-try M O-== O-&gt; O-! O-() O-&amp;&amp; O-+ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>In its basic form, given a query in terms of aspectj pointcuts, an aspect 
refactoring verifier is able to compare the results of the query to the 
effective shadows produced by advices, if this query is used to start 
refactoring Java code with aspects. A fully featured verifier should also 
consider the refactored program logic as a part of the verification.

A simple usage scenario is as follows:

Suppose we want to refactor listeners from our beloved Figure.java
 
 class Figure {
   //fields
   public void moveBy(int x, int y){
     //move
     myMoveListener.notify(x,y); [location a]
   }
 
   public void refresh()
   {
     myDisplayListener.notify(); [location b]
   }
 }
 
 We could use declare warning :call("*.*Listener.*(..)"):"refactor" to capture 
location a and location b. On the method level, ARV reports Figure.moveBy() 
and Figure.refresh(). Our refactored aspect uses "execution" pointcuts such 
as :
 
 after():execution(Figure.refresh) {
   myDisplayListener.notify();
 }
 
On the method level, we see Figure.refresh(). In this case, the diff view in 
ARV can immediately show that the method "Figure.moveBy" is NOT captured by 
refactored aspects and should be further refactored.</bugreport>
<pre-fix-testcases failing="189" file="output/113723/pre-fix/testresults.xml" passing="1814" size="2003"/>
<post-fix-testcases failing="187" file="output/113723/post-fix/testresults.xml" passing="1816" size="2003"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/model/ModelComparison.java" revision="1.3" state="changed">2c2
&lt;  * Copyright (c) 2005 IBM Corporation and others.
---
&gt;  * Copyright (c) 2005, 2006 IBM Corporation and others.
14a15
&gt; import java.util.HashSet;
16a18
&gt; import java.util.Set;
17a20
&gt; import org.eclipse.ajdt.core.javaelements.AJCodeElement;
21c24
&lt;  * Compares two structure models
---
&gt;  * Compare two structure models or elements
24a28,33
&gt; 	private boolean propagateUp;
&gt; 	
&gt; 	public ModelComparison(boolean propagateUp) {
&gt; 		this.propagateUp = propagateUp;
&gt; 	}
&gt; 	
33c42,43
&lt; 	 * @return
---
&gt; 	 * @return a two element List array, containing the added list and removed
&gt; 	 *         list respectively
35c45
&lt; 	public static List[] compare(AJProjectModel fromModel,
---
&gt; 	public List[] compareProjects(AJProjectModel fromModel,
57c67
&lt; 				removedList.add(rel);
---
&gt; 				removedList.add(propagateRel(rel));
70c80
&lt; 			addedList.add(rel);
---
&gt; 			addedList.add(propagateRel(rel));
72c82
&lt; 
---
&gt; 		
76,77c86,156
&lt; 	private static boolean matchJavaElements(IJavaElement je1, IJavaElement je2) {
&lt; 		return je1.getHandleIdentifier().equals(je2.getHandleIdentifier());
---
&gt; 	/**
&gt; 	 * Compare the crosscutting of two Java elements, for example to see whether
&gt; 	 * two advice or declare statements advise the same places.
&gt; 	 * @param fromModel
&gt; 	 * @param toModel
&gt; 	 * @param fromEl
&gt; 	 * @param toEl
&gt; 	 * @return a two element List array, containing the added list and removed
&gt; 	 *         list respectively
&gt; 	 */
&gt; 	public List[] compareElements(AJProjectModel fromModel,
&gt; 			AJProjectModel toModel, IJavaElement fromEl,
&gt; 			IJavaElement toEl) {
&gt; 		List fromRels = fromModel
&gt; 			.getAllRelationships(AJRelationshipManager.allRelationshipTypes);
&gt; 		List toRels = toModel
&gt; 			.getAllRelationships(AJRelationshipManager.allRelationshipTypes);
&gt; 
&gt; 		// lists to return
&gt; 		List addedList = new ArrayList();
&gt; 		List removedList = new ArrayList();
&gt; 
&gt; 		Set fromTargets = new HashSet();
&gt; 		Set toTargets = new HashSet();
&gt; 		
&gt; 		for (Iterator iter = fromRels.iterator(); iter.hasNext();) {
&gt; 			AJRelationship rel = (AJRelationship) iter.next();
&gt; 			if (matchJavaElements(fromEl,rel.getSource())) {
&gt; 				fromTargets.add(propagate(rel.getTarget()).getHandleIdentifier());
&gt; 				removedList.add(propagateRel(rel));
&gt; 			}
&gt; 		}
&gt; 		for (Iterator iter = toRels.iterator(); iter.hasNext();) {
&gt; 			AJRelationship rel = (AJRelationship) iter.next();
&gt; 			if (matchJavaElements(toEl,rel.getSource())) {
&gt; 				String target = propagate(rel.getTarget()).getHandleIdentifier(); 
&gt; 				toTargets.add(target);
&gt; 				// only add to addedList if target is different
&gt; 				if (!fromTargets.contains(target)) {
&gt; 					addedList.add(propagateRel(rel));
&gt; 				}
&gt; 			}
&gt; 		}
&gt; 		
&gt; 		// remove matching targets from the removedList
&gt; 		for (Iterator iter = removedList.iterator(); iter.hasNext();) {
&gt; 			AJRelationship rel = (AJRelationship) iter.next();
&gt; 			if (toTargets.contains(propagate(rel.getTarget()).getHandleIdentifier())) {
&gt; 				iter.remove();
&gt; 			}
&gt; 		}
&gt; 		
&gt; 		return new List[] { addedList, removedList };
&gt; 	}
&gt; 	
&gt; 	private IJavaElement propagate(IJavaElement el) {
&gt; 		if (propagateUp &amp;&amp; (el instanceof AJCodeElement)) {
&gt; 			return el.getParent();
&gt; 		}
&gt; 		return el;
&gt; 	}
&gt; 	
&gt; 	private AJRelationship propagateRel(AJRelationship rel) {
&gt; 		rel.setSource(propagate(rel.getSource()));
&gt; 		rel.setTarget(propagate(rel.getTarget()));
&gt; 		return rel;
&gt; 	}
&gt; 	
&gt; 	private boolean matchJavaElements(IJavaElement je1, IJavaElement je2) {
&gt; 		return propagate(je1).getHandleIdentifier().equals(
&gt; 				propagate(je2).getHandleIdentifier());
80c159
&lt; 	private static boolean removeMatchingRel(List list, AJRelationship match) {
---
&gt; 	private boolean removeMatchingRel(List list, AJRelationship match) {
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/resources/AspectJImages.java" revision="1.17" state="changed">239a240,241
&gt; 	public static final AJDTIcon PROPAGATE_UP = new AJDTIcon(
&gt; 				"icons/diff/propagateup.gif"); //$NON-NLS-1$
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/diff/CompareAction.java" revision="1.4" state="deleted"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/topics_Tasks.xml" revision="1.21" state="changed">112a113
&gt; 		&lt;topic label="Comparing two elements" href="doc/tasks/compareelements.htm"&gt;&lt;/topic&gt;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/text/UIMessages.java" revision="1.27" state="changed">293c293,295
&lt; 	public static String changesView_filter_action_tooltip; 
---
&gt; 	public static String changesView_filter_action_tooltip;
&gt; 	public static String changesView_propagate_message;
&gt; 	public static String changesView_propagate_tooltip;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/plugin.properties" revision="1.30" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/diff/CrosscuttingComparisonTests.txt" revision="1.3" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/text/UIMessages.properties" revision="1.33" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/doc/concepts/views.htm" revision="1.8" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/doc/tasks/compare.htm" revision="1.3" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/manual testing/TestSheet.doc" revision="1.52" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/diff/ChangesView.java" revision="1.14" state="changed">38a39,40
&gt; import org.eclipse.jface.action.Action;
&gt; import org.eclipse.jface.action.IAction;
75a78,79
&gt; 	private Action propagateToggleAction;
&gt; 	
97a102,103
&gt; 	private IJavaElement currFromEl, currToEl;
&gt; 	
103a110,118
&gt; 	private boolean propagateUp = false;
&gt; 	
&gt; 	private static int EMPTY = 0;
&gt; 	private static int COMPARING_FILES = 1;
&gt; 	private static int COMPARING_ELEMENTS = 2;
&gt; 	
&gt; 	
&gt; 	private int compareMode = EMPTY;
&gt; 	
113c128,132
&lt; 			changesView.refreshIfCurrentBuild(force);
---
&gt; 			if (changesView.compareMode == COMPARING_FILES) {
&gt; 				changesView.refreshIfCurrentBuild(force);
&gt; 			} else if (changesView.compareMode == COMPARING_ELEMENTS) {
&gt; 				changesView.refresh();
&gt; 			}
116a136,139
&gt; 	private void refresh() {
&gt; 		compareElements(currFromEl, currToEl);
&gt; 	}
&gt; 	
121c144
&lt; 				performComparison(currFromProject, currFromName, currToProject,
---
&gt; 				compareProjects(currFromProject, currFromName, currToProject,
376c399
&lt; 	public void performComparison(IProject fromProject, String fromName,
---
&gt; 	public void compareProjects(IProject fromProject, String fromName,
377a401,402
&gt; 		compareMode = COMPARING_FILES;
&gt; 		
389c414
&lt; 		List[] ret = ModelComparison.compare(fromModel, toModel);
---
&gt; 		List[] ret = new ModelComparison(propagateUp).compareProjects(fromModel, toModel);
393,397d417
&lt; 		int numEntries = addedList.size() + removedList.size();
&lt; 		sourceElements = new IJavaElement[numEntries];
&lt; 		targetElements = new IJavaElement[numEntries];
&lt; 		int rowCount = 0;
&lt; 
401a422,455
&gt; 		updateTable(addedList, removedList, fromModel, toModel);
&gt; 	}
&gt; 	
&gt; 	public void compareElements(IJavaElement fromEl, IJavaElement toEl) {
&gt; 		compareMode = COMPARING_ELEMENTS;
&gt; 		currFromEl = fromEl;
&gt; 		currToEl = toEl;
&gt; 		
&gt; 		IProject fromProject = fromEl.getResource().getProject();
&gt; 		IProject toProject = toEl.getResource().getProject();
&gt; 
&gt; 		AJProjectModel fromModel = AJModel.getInstance().getModelForProject(
&gt; 				fromProject);
&gt; 		AJProjectModel toModel = AJModel.getInstance().getModelForProject(
&gt; 				toProject);
&gt; 
&gt; 		List[] ret = new ModelComparison(propagateUp).compareElements(fromModel, toModel,
&gt; 				fromEl, toEl);
&gt; 		List addedList = filterRelationshipList(ret[0]);
&gt; 		List removedList = filterRelationshipList(ret[1]);
&gt; 
&gt; 		int totalNoRelationships = ret[0].size() + ret[1].size();
&gt; 		updateDescription(fromEl.getElementName(), toEl.getElementName(),
&gt; 				(addedList.size() + removedList.size()), totalNoRelationships);
&gt; 
&gt; 		updateTable(addedList, removedList, fromModel, toModel);
&gt; 	}
&gt; 	
&gt; 	private void updateTable(List addedList, List removedList,
&gt; 			AJProjectModel fromModel, AJProjectModel toModel) {
&gt; 		int numEntries = addedList.size() + removedList.size();
&gt; 		sourceElements = new IJavaElement[numEntries];
&gt; 		targetElements = new IJavaElement[numEntries];
&gt; 
403a458,459
&gt; 		int rowCount = 0;
&gt; 
465a522
&gt; 		manager.add(propagateToggleAction);
468a526,540
&gt; 		propagateToggleAction = new Action() {
&gt; 			public int getStyle() {
&gt; 				return IAction.AS_CHECK_BOX;
&gt; 			}
&gt; 
&gt; 			public void run() {
&gt; 				propagateUp = !propagateUp;
&gt; 				refresh(true);
&gt; 			}
&gt; 		};
&gt; 		propagateToggleAction.setText(UIMessages.changesView_propagate_message);
&gt; 		propagateToggleAction
&gt; 				.setToolTipText(UIMessages.changesView_propagate_tooltip);
&gt; 		propagateToggleAction.setImageDescriptor(AspectJImages.PROPAGATE_UP.getImageDescriptor());
&gt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/plugin.xml" revision="1.76" state="changed">1727c1727
&lt;                class="org.eclipse.ajdt.internal.ui.diff.CompareAction"
---
&gt;                class="org.eclipse.ajdt.internal.ui.diff.CompareMapFileAction"
1734c1734
&lt;                class="org.eclipse.ajdt.internal.ui.diff.CompareAction"
---
&gt;                class="org.eclipse.ajdt.internal.ui.diff.CompareMapFileAction"
1767a1768,1794
&gt;      &lt;!-- Aspect Refactoring Verifier (ARV) --&gt;
&gt;      &lt;extension
&gt;          point="org.eclipse.ui.popupMenus"&gt;
&gt;       &lt;objectContribution
&gt;             objectClass="org.eclipse.ajdt.core.javaelements.AspectJMemberElement"
&gt;             id="arv.contribution1"&gt;
&gt;             &lt;visibility&gt;
&gt;              &lt;or&gt;
&gt;                	&lt;objectClass name="org.eclipse.ajdt.core.javaelements.AdviceElement"/&gt;
&gt;            		&lt;objectClass name="org.eclipse.ajdt.core.javaelements.DeclareElement"/&gt;
&gt;             &lt;/or&gt;	
&gt;        	  &lt;/visibility&gt;
&gt;          &lt;menu
&gt;                label="%CompareCrosscutting.context.with"
&gt;                path="additions"
&gt;                id="arv.menu1"&gt;
&gt;             &lt;separator name="group1"/&gt;
&gt;          &lt;/menu&gt;
&gt;          &lt;action
&gt;                enablesFor="2"
&gt;                label="%CompareCrosscutting.context.eachOther"
&gt;                class="org.eclipse.ajdt.internal.ui.diff.CompareElementAction"
&gt;                menubarPath="arv.menu1/group1"
&gt;                id="arv.sameProject"/&gt;       
&gt;       &lt;/objectContribution&gt;
&gt;    &lt;/extension&gt;  
&gt;        
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/model/ModelComparisonTest.java" revision="1.4" state="changed">14a15
&gt; import java.util.ArrayList;
17a19,23
&gt; import org.eclipse.ajdt.core.javaelements.AJCompilationUnit;
&gt; import org.eclipse.ajdt.core.javaelements.AJCompilationUnitManager;
&gt; import org.eclipse.ajdt.core.javaelements.AdviceElement;
&gt; import org.eclipse.ajdt.core.javaelements.AspectElement;
&gt; import org.eclipse.ajdt.core.javaelements.DeclareElement;
23a30
&gt; import org.eclipse.core.resources.IFile;
26a34,35
&gt; import org.eclipse.jdt.core.IJavaElement;
&gt; import org.eclipse.jdt.core.IType;
61c70,71
&lt; 			List[] results = ModelComparison.compare(mapModel, currentModel);
---
&gt; 			List[] results = new ModelComparison(false).compareProjects(
&gt; 					mapModel, currentModel);
80c90,91
&lt; 			assertTrue("Missing added relationship: Expected afterReturning advises fire()",found); //$NON-NLS-1$
---
&gt; 			assertTrue(
&gt; 					"Missing added relationship: Expected afterReturning advises fire()", found); //$NON-NLS-1$
96c107,108
&lt; 			results = ModelComparison.compare(mapModel, currentModel);
---
&gt; 			results = new ModelComparison(false).compareProjects(mapModel,
&gt; 					currentModel);
112a125,222
&gt; 	public void testCompareElements() throws Exception {
&gt; 		IProject project = createPredefinedProject("Comparisons"); //$NON-NLS-1$
&gt; 		try {
&gt; 			IResource aspectFile = project.findMember("src/foo/MyAspect.aj"); //$NON-NLS-1$
&gt; 			assertNotNull("Couldn't find MyAspect.aj file", aspectFile); //$NON-NLS-1$
&gt; 			AJCompilationUnit ajcu = AJCompilationUnitManager.INSTANCE
&gt; 					.getAJCompilationUnit((IFile) aspectFile);
&gt; 			assertNotNull("Couldn't find AJCompilationUnit for file " //$NON-NLS-1$
&gt; 					+ aspectFile, ajcu);
&gt; 			IType[] types = ajcu.getAllTypes();
&gt; 			assertTrue(
&gt; 					"First contained type should be an AspectElement", types[0] instanceof AspectElement); //$NON-NLS-1$
&gt; 			AspectElement aspect = (AspectElement) types[0];
&gt; 			AdviceElement[] advice = aspect.getAdvice();
&gt; 			assertEquals("Aspect should contain 2 advice elements", 2, //$NON-NLS-1$
&gt; 					advice.length);
&gt; 			IJavaElement before, after;
&gt; 			if (advice[0].getElementName().indexOf("before") != -1) { //$NON-NLS-1$
&gt; 				before = advice[0];
&gt; 				after = advice[1];
&gt; 			} else {
&gt; 				before = advice[1];
&gt; 				after = advice[0];
&gt; 			}
&gt; 			
&gt; 			DeclareElement[] declares = aspect.getDeclares();
&gt; 			assertEquals("Aspect should contain 1 declare element", 1, //$NON-NLS-1$
&gt; 					declares.length);
&gt; 			DeclareElement declare = declares[0];
&gt; 			
&gt; 			AJProjectModel model = AJModel.getInstance().getModelForProject(
&gt; 					project);
&gt; 			
&gt; 			// compare after with before, should be 1 added
&gt; 			List[] res = new ModelComparison(false).compareElements(model,
&gt; 					model, after, before);
&gt; 			List addedList = filterAdvisesMatchedByRels(res[0]);
&gt; 			List removedList = filterAdvisesMatchedByRels(res[1]);
&gt; 			assertEquals("AddedList should contain 1 element", 1, addedList.size()); //$NON-NLS-1$
&gt; 			assertEquals("RemovedList should be empty", 0, removedList.size()); //$NON-NLS-1$
&gt; 			AJRelationship rel = (AJRelationship)addedList.get(0);
&gt; 			assertEquals("Wrong name for added source element","before",rel.getSource().getElementName()); //$NON-NLS-1$ //$NON-NLS-2$
&gt; 			assertEquals("Wrong name for added target element","setup",rel.getTarget().getElementName()); //$NON-NLS-1$ //$NON-NLS-2$
&gt; 			
&gt; 			// compare before with after, should be 1 removed
&gt; 			res = new ModelComparison(true).compareElements(model, model,
&gt; 					before, after);
&gt; 			addedList = filterAdvisesMatchedByRels(res[0]);
&gt; 			removedList = filterAdvisesMatchedByRels(res[1]);			
&gt; 			assertEquals("AddedList should be empty", 0, addedList.size()); //$NON-NLS-1$
&gt; 			assertEquals("RemovedList should contain 1 element", 1, removedList.size()); //$NON-NLS-1$
&gt; 			rel = (AJRelationship)removedList.get(0);
&gt; 			assertEquals("Wrong name for removed source element","before",rel.getSource().getElementName());  //$NON-NLS-1$//$NON-NLS-2$
&gt; 			assertEquals("Wrong name for removed target element","setup",rel.getTarget().getElementName()); //$NON-NLS-1$ //$NON-NLS-2$
&gt; 
&gt; 			// compare declare with after, should be 2 added, 2 removed
&gt; 			res = new ModelComparison(false).compareElements(model, model,
&gt; 					declare, after);
&gt; 			addedList = filterAdvisesMatchedByRels(res[0]);
&gt; 			removedList = filterAdvisesMatchedByRels(res[1]);			
&gt; 			assertEquals("AddedList should contain 2 elements", 2, addedList.size()); //$NON-NLS-1$
&gt; 			assertEquals("RemovedList should contain 2 elements", 2, removedList.size()); //$NON-NLS-1$
&gt; 			
&gt; 			// propagate up this time, should be no changes
&gt; 			res = new ModelComparison(true).compareElements(model, model,
&gt; 					declare, after);
&gt; 			addedList = filterAdvisesMatchedByRels(res[0]);
&gt; 			removedList = filterAdvisesMatchedByRels(res[1]);			
&gt; 			assertEquals("AddedList should be empty", 0, addedList.size()); //$NON-NLS-1$
&gt; 			assertEquals("RemovedList should be empty", 0, removedList.size()); //$NON-NLS-1$
&gt; 			
&gt; 			// compare declare with before, should be 1 added
&gt; 			res = new ModelComparison(true).compareElements(model, model,
&gt; 					declare, before);
&gt; 			addedList = filterAdvisesMatchedByRels(res[0]);
&gt; 			removedList = filterAdvisesMatchedByRels(res[1]);			
&gt; 			assertEquals("AddedList should contain 1 element", 1, addedList.size()); //$NON-NLS-1$
&gt; 			assertEquals("RemovedList should be empty", 0, removedList.size()); //$NON-NLS-1$
&gt; 			rel = (AJRelationship)addedList.get(0);
&gt; 			assertEquals("Wrong name for added source element","before",rel.getSource().getElementName()); //$NON-NLS-1$ //$NON-NLS-2$
&gt; 			assertEquals("Wrong name for added target element","setup",rel.getTarget().getElementName()); //$NON-NLS-1$ //$NON-NLS-2$
&gt; 		} finally {
&gt; 			deleteProject(project);
&gt; 		}
&gt; 
&gt; 	}
&gt; 	
&gt; 	private List filterAdvisesMatchedByRels(List relationshipList) {
&gt; 		List filteredList = new ArrayList();
&gt; 		for (Iterator iter = relationshipList.iterator(); iter.hasNext();) {
&gt; 			AJRelationship element = (AJRelationship) iter.next();
&gt; 			if ((element.getRelationship() == AJRelationshipManager.ADVISES)
&gt; 					 || (element.getRelationship() == AJRelationshipManager.MATCHED_BY)) {
&gt; 				filteredList.add(element);
&gt; 			}
&gt; 		}
&gt; 		return filteredList;
&gt; 	}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/icons/diff/propagateup.gif" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/diff/CompareMapFileAction.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *     Matt Chapman - initial version
 *******************************************************************************/
package org.eclipse.ajdt.internal.ui.diff;

import org.eclipse.ajdt.ui.AspectJUIPlugin;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.ui.IViewPart;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.IWorkbenchWindowActionDelegate;
import org.eclipse.ui.PartInitException;

/**
 * Handles the selection of .ajmap files in the package explorer
 */
public class CompareMapFileAction implements IWorkbenchWindowActionDelegate {

	private ISelection fSelection;
	
	/* (non-Javadoc)
	 * @see org.eclipse.ui.IWorkbenchWindowActionDelegate#dispose()
	 */
	public void dispose() {
	}

	/* (non-Javadoc)
	 * @see org.eclipse.ui.IWorkbenchWindowActionDelegate#init(org.eclipse.ui.IWorkbenchWindow)
	 */
	public void init(IWorkbenchWindow window) {
	}

	/* (non-Javadoc)
	 * @see org.eclipse.ui.IActionDelegate#run(org.eclipse.jface.action.IAction)
	 */
	public void run(IAction action) {
		if (fSelection == null) {
			return;
		}
		try {
			IViewPart view = AspectJUIPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow()
				.getActivePage().showView(ChangesView.CROSSCUTTING_VIEW_ID);
			if (view instanceof ChangesView) {
				ChangesView changesView = (ChangesView)view;
				if (fSelection instanceof IStructuredSelection) {
					IStructuredSelection ss = (IStructuredSelection) fSelection;
					if (ss.size() == 1) {
						// compare with current build
						Object element = ss.getFirstElement();
						if (element instanceof IFile) {
							IFile file = (IFile)element;
							IProject project = file.getProject();
							String fromName = file.getName();
							String toName = ChangesView.CURRENT_BUILD;
							changesView.compareProjects(project, fromName, project, toName);
						}
					} else {
						// compare with each other
						Object[] elements = ss.toArray();
						if (elements.length == 2) {
							if ((elements[0] instanceof IFile) &amp;&amp;
									(elements[1] instanceof IFile)) {
								IFile fromFile = (IFile)elements[0];
								IFile toFile = (IFile)elements[1];
								
								// we want to compare the older file with the newer one
								if (fromFile.getLocalTimeStamp() &gt; toFile.getLocalTimeStamp()) {
									// swap files
									IFile tmp = fromFile;
									fromFile = toFile;
									toFile = tmp;
								}
								
								IProject fromProject = fromFile.getProject();
								IProject toProject = toFile.getProject();
								String fromName = fromFile.getName();
								String toName = toFile.getName();
								changesView.compareProjects(fromProject, fromName, toProject, toName);
							}
						}
					}
				}
				changesView.setFocus();
			}
		} catch (PartInitException e) {
		}
	}

	/* (non-Javadoc)
	 * @see org.eclipse.ui.IActionDelegate#selectionChanged(org.eclipse.jface.action.IAction, org.eclipse.jface.viewers.ISelection)
	 */
	public void selectionChanged(IAction action, ISelection selection) {
		fSelection = selection;
	}
}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/doc/tasks/compareelements.htm" revision="1.1" state="new"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/diff/CompareElementAction.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *     Matt Chapman  - initial version
 *******************************************************************************/
package org.eclipse.ajdt.internal.ui.diff;

import org.eclipse.ajdt.ui.AspectJUIPlugin;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.ui.IObjectActionDelegate;
import org.eclipse.ui.IViewPart;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.PartInitException;

public class CompareElementAction implements IObjectActionDelegate {

	private ISelection fSelection;

	public void setActivePart(IAction action, IWorkbenchPart targetPart) {
	}

	public void run(IAction action) {
		if (fSelection == null) {
			return;
		}
		if (fSelection instanceof IStructuredSelection) {
			IStructuredSelection ss = (IStructuredSelection) fSelection;
			// compare with each other
			Object[] elements = ss.toArray();
			if (elements.length == 2) {
				if ((elements[0] instanceof IJavaElement)
						&amp;&amp; (elements[1] instanceof IJavaElement)) {
					IJavaElement fromElement = (IJavaElement) elements[0];
					IJavaElement toElement = (IJavaElement) elements[1];
					try {
						IViewPart view = AspectJUIPlugin.getDefault()
								.getWorkbench().getActiveWorkbenchWindow()
								.getActivePage().showView(
										ChangesView.CROSSCUTTING_VIEW_ID);
						if (view instanceof ChangesView) {
							ChangesView changesView = (ChangesView) view;
							changesView.compareElements(fromElement, toElement);
							changesView.setFocus();
						}
					} catch (PartInitException e) {
					}
				}
			}
		}
	}

	public void selectionChanged(IAction action, ISelection selection) {
		fSelection = selection;
	}

}
</file>
</fixedFiles>
</bug>
<bug id="114343" transactionid="70078">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="9"/>
<property name="lines-added" value="14"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="11"/>
<property name="lines-churned" value="25"/>
<property name="priority" value="P2"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-new K-null K-return K-this K-while M O-== O-! O-() O-&amp;&amp; O-+ O-++ O-cast T V Y Z-cast Z-if Z-while</fullfingerprint>
<bugreport>Hi guys!

I've downloaded DEVELOPMENT-20051029200407.

There is some issue that I think is still open.
Take a look at the example:

Java Code:
----------

public class Test1 {

	Set&lt;Integer&gt; intsSet;

	public Set&lt;Integer&gt; foo() {
		return intsSet;
	}
}

public class Test2 {

	Set&lt;Double&gt; dSet;

	public Set&lt;Double&gt; foo() {
		return dSet;
	}
}

Aspect:
-------

public privileged aspect TestAspect {

    pointcut gettingMemberCollection(Test t) :
                target(t) &amp;&amp;
                get(!public Set&lt;Number+&gt; com.*.*) &amp;&amp;
                !within(TestAspect);

    Set around(Test t) : gettingMemberCollection(t)  {
        Set s =  proceed(t);
        return s;
    }
}

As you can see, I would like to replace access to member Set of something which 
derives from Number. But the problem is that around advice is stricted to 
return exact type of the member, and I'm getting the same error as earlier.

incompatible return type applying to field-get(java.util.Set 
com.mprv.secsph.Test.intsSet)

incompatible return type applying to field-get(java.util.Set 
com.mprv.secsph.Test.dSet)

In the M2 I just declared the advice this way and it worked fine.

May be now, you should allow to declare the advice this way:

    Set&lt;? extends Number&gt; around(Test t) : gettingMemberCollection(t) {
        Set s = proceed(t);
        return s;
    }

Thanks!
Misha.</bugreport>
<testsforfix ID="114343" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testFieldGet_pr114343_2"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="field-get, generics and around advice - 2"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="179" file="output/114343/pre-fix/testresults.xml" passing="1590" size="1769"/>
<post-fix-testcases failing="178" file="output/114343/post-fix/testresults.xml" passing="1591" size="1769"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedType.java" revision="1.30" state="changed">747c747
&lt;     	ResolvedType array = new Array("[" + type.getSignature(),type.getWorld(),type);
---
&gt;     	ResolvedType array = new Array("[" + type.getSignature(),"["+type.getErasureSignature(),type.getWorld(),type);
753,754c753,757
&lt;         Array(String s, World world, ResolvedType componentType) {
&lt;             super(s, world);
---
&gt;        
&gt;         
&gt;         // Sometimes the erasure is different, eg.  [TT;  and [Ljava/lang/Object; 
&gt;         Array(String sig, String erasureSig,World world, ResolvedType componentType) {
&gt;             super(sig,erasureSig, world);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ReferenceType.java" revision="1.30" state="changed">290a291,295
&gt;        	if (isTypeVariableReference() &amp;&amp; !other.isTypeVariableReference()) { // eg. this=T  other=Ljava/lang/Object;
&gt;        	    TypeVariable aVar = ((TypeVariableReference)this).getTypeVariable();
&gt;        	    return aVar.getFirstBound().resolve(world).isAssignableFrom(other);
&gt;        	} 
&gt;        	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.60" state="changed">207c207,209
&lt;             ret = new ResolvedType.Array(signature, 
---
&gt;         	ResolvedType componentType = resolve(ty.getComponentType(),allowMissing);
&gt;         	String brackets = signature.substring(0,signature.lastIndexOf("[")+1);
&gt;             ret = new ResolvedType.Array(signature, brackets+componentType.getErasureSignature(),
209,210c211
&lt;             		                     resolve(ty.getComponentType(), 
&lt;             		                     allowMissing));
---
&gt;             		                     componentType);
267c268,269
&lt; 	
---
&gt; 	private ResolvedType currentlyResolvingBaseType;
&gt; 
275a278
&gt; 			currentlyResolvingBaseType = genericType;
277a281
&gt; 			currentlyResolvingBaseType = null;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/TypeFactory.java" revision="1.6" state="changed">112a113,118
&gt; 		} else if (signature.startsWith("[")) {
&gt; 			int dims = 0;
&gt; 			while (signature.charAt(dims)=='[') dims++;
&gt; 			UnresolvedType componentType = createTypeFromSignature(signature.substring(dims));
&gt; 			return new UnresolvedType(signature,
&gt; 					signature.substring(0,dims)+componentType.getErasureSignature());
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.186" state="changed">31a32,46
&gt;     &lt;ajc-test dir="bugs150/pr114343/case2" title="field-get, generics and around advice - 2"&gt;
&gt;       &lt;compile files="Test.java,TTT.java,TestAspect.java" options="-1.5"/&gt;
&gt;       &lt;run class="TestAspect"&gt;
&gt;         &lt;stderr&gt;
&gt;           &lt;line text="TestAspect.main: Calling foo"/&gt;
&gt;           &lt;line text="Creating Test&amp;lt;Integer&amp;gt; instance"/&gt;
&gt;           &lt;line text="Calling toArray"/&gt;
&gt;           &lt;line text="In around advice"/&gt;
&gt;           &lt;line text="In toArray()"/&gt;
&gt;           &lt;line text="done"/&gt;
&gt;           &lt;line text="TestAspect.main: done"/&gt;
&gt;         &lt;/stderr&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.113" state="changed">58a59
&gt;   public void testFieldGet_pr114343_2()       { runTest("field-get, generics and around advice - 2");}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr114343/case2/Test.java" revision="1.1" state="new">import java.util.*;

public class Test&lt;T&gt; {

	Set&lt;T&gt; set = new HashSet&lt;T&gt;();

	public &lt;T&gt; T[] toArray(T[] a) {
    System.err.println("In toArray()");
		return set.toArray(a);
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr114343/case2/TestAspect.java" revision="1.1" state="new">import java.util.*;

public privileged aspect TestAspect {

      pointcut TestToArray(Test mt) :
                target(mt) &amp;&amp;
                !within(TestAspect);


    Object[] around(Test mt, Object[] objs) :
            TestToArray(mt) &amp;&amp;
            args(objs) &amp;&amp;
            execution(Object[] Test.toArray(Object[])) {

    System.err.println("In around advice");
        objs = proceed(mt, objs);
        return objs;
    }

  public static void main(String[] argv) {
     System.err.println("TestAspect.main: Calling foo");
     new TTT().foo();   
     System.err.println("TestAspect.main: done");
  }
}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr114343/case2/TTT.java" revision="1.1" state="new">import java.util.*;

public class TTT {
  public void foo() {
    System.err.println("Creating Test&lt;Integer&gt; instance");
    Test&lt;Integer&gt; mt = new Test&lt;Integer&gt;();
    System.err.println("Calling toArray");
    Integer[] arr = mt.toArray(new Integer[]{});
    System.err.println("done");
  }
}
</file>
</fixedFiles>
</bug>
<bug id="114728" transactionid="73508">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="10"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-import K-null M O-!= T V Z-if</fullfingerprint>
<bugreport>Using the dev. build as of Monday 31st October...

In a workspace with default compiler compliance lewvel of 1.4:
Create a new AspectJ project and set the compiler compliance level to 1.5 on the
first page of the wizard. Click finish. Now look at the build properties of the
new project, compiler settings -&gt; compliance level will be 1.4, not 1.5...</bugreport>
<pre-fix-testcases failing="181" file="output/114728/pre-fix/testresults.xml" passing="1588" size="1769"/>
<post-fix-testcases failing="178" file="output/114728/post-fix/testresults.xml" passing="1591" size="1769"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/wizards/AspectJProjectWizardSecondPage.java" revision="1.5" state="changed">16a17
&gt; import java.util.Map;
30a32
&gt; import org.eclipse.jdt.core.IJavaProject;
31a34
&gt; import org.eclipse.jdt.internal.corext.util.JavaModelUtil;
192a196,202
&gt; 			String compliance= fFirstPage.getJRECompliance();
&gt; 			if (compliance != null) {
&gt; 				IJavaProject project= JavaCore.create(fCurrProject);
&gt; 				Map options= project.getOptions(false);
&gt; 				JavaModelUtil.setCompilanceOptions(options, compliance);
&gt; 				project.setOptions(options);
&gt; 			}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui.tests/src/org/eclipse/ajdt/ui/tests/wizards/JavaProjectWizardFirstPageExtension.java" revision="1.3" state="changed">13a14,15
&gt; import java.util.HashMap;
&gt; import java.util.Map;
25a28,29
&gt; import org.eclipse.jdt.core.JavaCore;
&gt; import org.eclipse.jdt.internal.corext.util.Messages;
26a31
&gt; import org.eclipse.jdt.internal.ui.preferences.CompliancePreferencePage;
27a33
&gt; import org.eclipse.jdt.internal.ui.preferences.PropertyAndPreferencePage;
28a35,36
&gt; import org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathSupport;
&gt; import org.eclipse.jdt.internal.ui.wizards.dialogfields.ComboDialogField;
40a49,50
&gt; import org.eclipse.swt.events.SelectionEvent;
&gt; import org.eclipse.swt.events.SelectionListener;
43a54
&gt; import org.eclipse.swt.widgets.Combo;
46a58
&gt; import org.eclipse.swt.widgets.Link;
47a60
&gt; import org.eclipse.ui.dialogs.PreferencesUtil;
295a309,432
&gt; 	private final class JREGroup implements Observer, SelectionListener, IDialogFieldListener {
&gt; 
&gt; 		private final SelectionButtonDialogField fUseDefaultJRE, fUseProjectJRE;
&gt; 		private final ComboDialogField fJRECombo;
&gt; 		private final Group fGroup;
&gt; 		private final String[] fComplianceLabels;
&gt; 		private final String[] fComplianceData;
&gt; 		private final Link fPreferenceLink;
&gt; 		
&gt; 		public JREGroup(Composite composite) {
&gt; 			fComplianceLabels= new String[] { NewWizardMessages.getString("JavaProjectWizardFirstPage_JREGroup_compliance_13"), NewWizardMessages.getString("JavaProjectWizardFirstPage_JREGroup_compliance_14"), NewWizardMessages.getString("JavaProjectWizardFirstPage_JREGroup_compliance_50") };
&gt; 			fComplianceData= new String[] { JavaCore.VERSION_1_3,  JavaCore.VERSION_1_4,  JavaCore.VERSION_1_5 };
&gt; 			
&gt; 			fGroup= new Group(composite, SWT.NONE);
&gt; 			fGroup.setFont(composite.getFont());
&gt; 			fGroup.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
&gt; 			fGroup.setLayout(initGridLayout(new GridLayout(3, false), true));
&gt; 			fGroup.setText(NewWizardMessages.getString("JavaProjectWizardFirstPage_JREGroup_title")); 
&gt; 						
&gt; 			fUseDefaultJRE= new SelectionButtonDialogField(SWT.RADIO);
&gt; 			fUseDefaultJRE.setLabelText(getDefaultComplianceLabel());
&gt; 			fUseDefaultJRE.doFillIntoGrid(fGroup, 2);
&gt; 			
&gt; 			fPreferenceLink= new Link(fGroup, SWT.NONE);
&gt; 			fPreferenceLink.setFont(fGroup.getFont());
&gt; 			fPreferenceLink.setText(NewWizardMessages.getString("JavaProjectWizardFirstPage_JREGroup_link_description"));
&gt; 			fPreferenceLink.setLayoutData(new GridData(GridData.END, GridData.CENTER, false, false));
&gt; 			fPreferenceLink.addSelectionListener(this);
&gt; 		
&gt; 			fUseProjectJRE= new SelectionButtonDialogField(SWT.RADIO);
&gt; 			fUseProjectJRE.setLabelText(NewWizardMessages.getString("JavaProjectWizardFirstPage_JREGroup_specific_compliance"));
&gt; 			fUseProjectJRE.doFillIntoGrid(fGroup, 1);
&gt; 			fUseProjectJRE.setDialogFieldListener(this);
&gt; 						
&gt; 			fJRECombo= new ComboDialogField(SWT.READ_ONLY);
&gt; 			fJRECombo.setItems(fComplianceLabels);
&gt; 			fJRECombo.selectItem(getCurrentCompliance());
&gt; 			fJRECombo.setDialogFieldListener(this);
&gt; 
&gt; 			Combo comboControl= fJRECombo.getComboControl(fGroup);
&gt; 			comboControl.setLayoutData(new GridData(GridData.BEGINNING, GridData.CENTER, true, false)); // make sure column 2 is grabing (but no fill)
&gt; 			
&gt; 			DialogField.createEmptySpace(fGroup);
&gt; 			
&gt; 			fUseDefaultJRE.setSelection(true);
&gt; 			fJRECombo.setEnabled(fUseProjectJRE.isSelected());
&gt; 		}
&gt; 
&gt; 		private String getCurrentCompliance() {
&gt; 			String compliance= JavaCore.getOption(JavaCore.COMPILER_COMPLIANCE);
&gt; 			for (int i= 0; i &lt; fComplianceData.length; i++) {
&gt; 				if (compliance.equals(fComplianceData[i])) {
&gt; 					return fComplianceLabels[i];
&gt; 				}
&gt; 			}
&gt; 			return fComplianceLabels[2];
&gt; 		}
&gt; 
&gt; 		private String getDefaultComplianceLabel() {
&gt; 			return Messages.format(NewWizardMessages.getString("JavaProjectWizardFirstPage_JREGroup_default_compliance"), getCurrentCompliance());
&gt; 		}
&gt; 
&gt; 		public void update(Observable o, Object arg) {
&gt; 			updateEnableState();
&gt; 		}
&gt; 
&gt; 		private void updateEnableState() {
&gt; 			final boolean detect= fDetectGroup.mustDetect();
&gt; 			fUseDefaultJRE.setEnabled(!detect);
&gt; 			fUseProjectJRE.setEnabled(!detect);
&gt; 			fJRECombo.setEnabled(!detect &amp;&amp; fUseProjectJRE.isSelected());
&gt; 			fPreferenceLink.setEnabled(!detect);
&gt; 			fGroup.setEnabled(!detect);
&gt; 		}
&gt; 		
&gt; 		/* (non-Javadoc)
&gt; 		 * @see org.eclipse.swt.events.SelectionListener#widgetSelected(org.eclipse.swt.events.SelectionEvent)
&gt; 		 */
&gt; 		public void widgetSelected(SelectionEvent e) {
&gt; 			widgetDefaultSelected(e);
&gt; 		}
&gt; 
&gt; 		/* (non-Javadoc)
&gt; 		 * @see org.eclipse.swt.events.SelectionListener#widgetDefaultSelected(org.eclipse.swt.events.SelectionEvent)
&gt; 		 */
&gt; 		public void widgetDefaultSelected(SelectionEvent e) {
&gt; 			String jreID= BuildPathSupport.JRE_PREF_PAGE_ID;
&gt; 			String complianceId= CompliancePreferencePage.PREF_ID;
&gt; 			Map data= new HashMap();
&gt; 			data.put(PropertyAndPreferencePage.DATA_NO_LINK, Boolean.TRUE);
&gt; 			PreferencesUtil.createPreferenceDialogOn(getShell(), complianceId, new String[] { jreID, complianceId  }, data).open();
&gt; 			
&gt; 			handlePossibleComplianceChange();
&gt; 			fDetectGroup.handleComplianceChange();
&gt; 		}
&gt; 		
&gt; 		public void handlePossibleComplianceChange() {
&gt; 			fUseDefaultJRE.setLabelText(getDefaultComplianceLabel());
&gt; 		}
&gt; 		
&gt; 
&gt; 		/* (non-Javadoc)
&gt; 		 * @see org.eclipse.jdt.internal.ui.wizards.dialogfields.IDialogFieldListener#dialogFieldChanged(org.eclipse.jdt.internal.ui.wizards.dialogfields.DialogField)
&gt; 		 */
&gt; 		public void dialogFieldChanged(DialogField field) {
&gt; 			updateEnableState();
&gt; 			fDetectGroup.handleComplianceChange();
&gt; 		}
&gt; 		
&gt; 		public boolean isUseSpecific() {
&gt; 			return fUseProjectJRE.isSelected();
&gt; 		}
&gt; 		
&gt; 		public String getJRECompliance() {
&gt; 			if (fUseProjectJRE.isSelected()) {
&gt; 				int index= fJRECombo.getSelectionIndex();
&gt; 				if (index &gt;= 0 &amp;&amp; index &lt; fComplianceData.length) { // paranoia
&gt; 					return fComplianceData[index];
&gt; 				}
&gt; 			}
&gt; 			return null;
&gt; 		}
&gt; 	}
&gt; 
314a452,455
&gt; 		public void handleComplianceChange() {
&gt; 		}
&gt; 
&gt; 		
419a561
&gt; 	private JREGroup fJREGroup;
455a598
&gt; 		fJREGroup= new JREGroup(composite);
519a663,665
&gt; 	public String getJRECompliance() {
&gt; 		return fJREGroup.getJRECompliance();
&gt; 	}
</file>
</fixedFiles>
</bug>
<bug id="114875" transactionid="68769">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null O-!= T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Eclipse 3.1
AJDT 1.3.0.20051102174241

package com.aspectj.test;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public abstract class Base {

    @Pointcut                                     --&gt;Seems to be the problem
    abstract void method();
	

    public static void main(String args[]){
    }
}

package com.aspectj.test;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class Sub extends Base{

    @Pointcut( "execution(* com.aspectj.test.Base.main(..))" )
    void method(){};

    @Before("method()")
    public void test(){
		
    }
}


The code above shows

java.lang.NullPointerException
	at org.aspectj.weaver.patterns.BasicTokenSource.makeTokenSource
(BasicTokenSource.java:84)
	at org.aspectj.weaver.patterns.PatternParser.&lt;init&gt;
(PatternParser.java:1373)
	at 
org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.conv
ertToPointcutDeclaration(ValidateAtAspectJAnnotationsVisitor.java:493)
	at 
org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visi
t(ValidateAtAspectJAnnotationsVisitor.java:188)
	at 
org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse
(MethodDeclaration.java:185)
	at 
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse
(TypeDeclaration.java:1183)
	at 
org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.tr
averse(CompilationUnitDeclaration.java:339)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing
(AjCompilerAdapter.java:154)
	at 
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_
internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process
(Compiler.java:517)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:329)
	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:759)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:225)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:180)
	at 
org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild
(AjBuildManager.java:158)
	at org.aspectj.ajde.internal.CompilerAdapter.compile
(CompilerAdapter.java:117)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:191)


The syntax @Pointcut("") is shown as error too. If this is not a bug then a 
proper message instead of an exception is helpful.</bugreport>
<testsforfix ID="114875" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr114875"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/multiIncremental/pr114875/inc1/Sub.java">
      <test NAME="test"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/114875/pre-fix/testresults.xml" passing="1605" size="1785"/>
<post-fix-testcases failing="180" file="output/114875/post-fix/testresults.xml" passing="1605" size="1785"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java" revision="1.15" state="changed">243,246c243,248
&lt; 				TypeDeclaration parentDecl = parentSTB.scope.referenceContext;
&lt; 				if (isAspect(parentDecl) &amp;&amp; !Modifier.isAbstract(parentDecl.modifiers)) {
&lt; 					typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart,typeDecl.sourceEnd,"cannot extend a concrete aspect");
&lt; 				}			
---
&gt; 				if (parentSTB.scope!=null) { // scope is null if its a binarytypebinding (in AJ world, thats a subclass of SourceTypeBinding)
&gt; 					TypeDeclaration parentDecl = parentSTB.scope.referenceContext; 
&gt; 					if (isAspect(parentDecl) &amp;&amp; !Modifier.isAbstract(parentDecl.modifiers)) {
&gt; 						typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart,typeDecl.sourceEnd,"cannot extend a concrete aspect");
&gt; 					}			
&gt; 				}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.10" state="changed">291a292,302
&gt; 	public void testPr114875() {
&gt; 		initialiseProject("pr114875");
&gt; 		build("pr114875");
&gt; 		alter("pr114875","inc1");
&gt; 		build("pr114875");
&gt; 		checkWasntFullBuild();
&gt; 		alter("pr114875","inc2");
&gt; 		build("pr114875");
&gt; 		checkWasntFullBuild();
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/multiIncremental/pr114875/inc2/Base.java" revision="1.1" state="new">package com.aspectj.test;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public abstract class Base {

    @Pointcut //
    abstract void method();


    public static void main(String args[]){
    }
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/pr114875/inc1/Sub.java" revision="1.1" state="new">package com.aspectj.test;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class Sub extends Base{

    @Pointcut( "execution(* com.aspectj.test.Base.main(..))" )
    void method(){};

    @Before("method()")
    public void test(){

    }
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/pr114875/base/Base.java" revision="1.1" state="new">package com.aspectj.test;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public abstract class Base {

    @Pointcut //
    abstract void method();


    public static void main(String args[]){
    }
}
</file>
</fixedFiles>
</bug>
<bug id="115251" transactionid="69310">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-null O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>I get the same BCException when I build incrementally but not after cleaning the
project.  The code is correct (I think) and runs fine after clean-and-build.

AJDT Build id: 20051104134042
AspectJ version: 1.5.0.200510241400

(Sorry if this is another manifestation of a different bug or an AJDT bug.)

---------------------------------------------------------------
----------------- Singleton.java
package com.isberg.articles.aop7.patterns;

/**
 * CODE article singleton variant without eager/lazy
 */
public abstract aspect Singleton&lt;Target&gt; pertypewithin(Target) {
	private final Object lock = new Object();
	private Target singleton;

	/**
	 * Subaspects define this.  All join points must return type Target.
	 */
	abstract protected pointcut creation();

	pointcut creating() : cflow(within(Singleton+) &amp;&amp; adviceexecution());
	
    Target around() : creation() &amp;&amp; !creating(){
    	synchronized(lock) {
            if (singleton == null) {
                singleton = proceed();
            }
            return singleton;
    	}
    }
}

----------------- SingletonTest.java
package com.isberg.articles.aop7.patterns;

import junit.framework.TestCase;

public class SingletonTest extends TestCase {
	public void testSingleton() throws Exception {
		C[] cs = {C.create(), new C(), C.create()};
		for (int i = 1; i &lt; cs.length; i++) {
			assertEquals(cs[0], cs[i]);
		}
	}
	static class C {
		static C create() {return new C();}
		C() {}		
	}
	static aspect A extends Singleton&lt;C&gt; {
		protected pointcut creation() : execution(static C C.create())
			|| call(C.new());
	}
}
---------------------------------------------------------------

trouble in:public class com.isberg.articles.aop7.patterns.SingletonTest extends
junit.framework.TestCase:
public void &lt;init&gt;():
ALOAD_0     // com.isberg.articles.aop7.patterns.SingletonTest this   (line 5)
INVOKESPECIAL junit.framework.TestCase.&lt;init&gt; ()V
constructor-execution(void com.isberg.articles.aop7.patterns.SingletonTest.&lt;init&gt;())
|               RETURN
constructor-execution(void com.isberg.articles.aop7.patterns.SingletonTest.&lt;init&gt;())
end public void &lt;init&gt;()
public void testSingleton() throws java.lang.Exception   
org.aspectj.weaver.MethodDeclarationLineNumber: 6:142
:
method-execution(void
com.isberg.articles.aop7.patterns.SingletonTest.testSingleton())
|               ICONST_3   (line 7)
|               ANEWARRAY com.isberg.articles.aop7.patterns.SingletonTest$C
|               DUP
|               ICONST_0
| method-call(com.isberg.articles.aop7.patterns.SingletonTest$C
com.isberg.articles.aop7.patterns.SingletonTest$C.create())
| |             INVOKESTATIC
com.isberg.articles.aop7.patterns.SingletonTest$C.create
()Lcom/isberg/articles/aop7/patterns/SingletonTest$C;
| method-call(com.isberg.articles.aop7.patterns.SingletonTest$C
com.isberg.articles.aop7.patterns.SingletonTest$C.create())
|               AASTORE
|               DUP
|               ICONST_1
| constructor-call(void com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;())
| |             NEW com.isberg.articles.aop7.patterns.SingletonTest$C
| |             DUP
| |             INVOKESPECIAL
com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt; ()V
| constructor-call(void com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;())
|               AASTORE
|               DUP
|               ICONST_2
| method-call(com.isberg.articles.aop7.patterns.SingletonTest$C
com.isberg.articles.aop7.patterns.SingletonTest$C.create())
| |             INVOKESTATIC
com.isberg.articles.aop7.patterns.SingletonTest$C.create
()Lcom/isberg/articles/aop7/patterns/SingletonTest$C;
| method-call(com.isberg.articles.aop7.patterns.SingletonTest$C
com.isberg.articles.aop7.patterns.SingletonTest$C.create())
|               AASTORE
|               ASTORE_1
|               ICONST_1   (line 8)
|               ISTORE_2
|               GOTO L1
|           L0: ALOAD_1     //
com.isberg.articles.aop7.patterns.SingletonTest$C[] cs   (line 9)
|               ICONST_0
|               AALOAD
|               ALOAD_1     //
com.isberg.articles.aop7.patterns.SingletonTest$C[] cs
|               ILOAD_2     // int i
|               AALOAD
| method-call(void junit.framework.Assert.assertEquals(java.lang.Object,
java.lang.Object))
| |             INVOKESTATIC
com.isberg.articles.aop7.patterns.SingletonTest.assertEquals
(Ljava/lang/Object;Ljava/lang/Object;)V
| method-call(void junit.framework.Assert.assertEquals(java.lang.Object,
java.lang.Object))
|               IINC 2 1     // int i   (line 8)
|           L1: ILOAD_2     // int i
|               ALOAD_1     //
com.isberg.articles.aop7.patterns.SingletonTest$C[] cs
|               ARRAYLENGTH
|               IF_ICMPLT L0
|               RETURN   (line 11)
method-execution(void
com.isberg.articles.aop7.patterns.SingletonTest.testSingleton())
end public void testSingleton() throws java.lang.Exception
end public class com.isberg.articles.aop7.patterns.SingletonTest
when implementing on shadow constructor-call(void
com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;())
when weaving type com.isberg.articles.aop7.patterns.SingletonTest
when weaving classes
when weaving
when incrementally building
BuildConfig[c:\home\ws\main-31\.metadata\.plugins\org.eclipse.ajdt.core\devworks-fall.generated.lst]
#Files=90


org.aspectj.weaver.BCException: Class
com.isberg.articles.aop7.patterns.Singleton does not have a method
ajc$around$com_isberg_articles_aop7_patterns_Singleton$1$51e13820 with signature
(Lorg/aspectj/runtime/internal/AroundClosure;)Ljava/lang/Object;
when implementing on shadow constructor-call(void
com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;())
when weaving type com.isberg.articles.aop7.patterns.SingletonTest
when weaving classes
when weaving
when incrementally building
BuildConfig[c:\home\ws\main-31\.metadata\.plugins\org.eclipse.ajdt.core\devworks-fall.generated.lst]
#Files=90
at org.aspectj.weaver.bcel.LazyClassGen.getLazyMethodGen(LazyClassGen.java:1161)
at org.aspectj.weaver.bcel.LazyClassGen.getLazyMethodGen(LazyClassGen.java:1146)
at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:1973)
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:211)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:514)
at org.aspectj.weaver.Shadow.implement(Shadow.java:391)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1782)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:394)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:98)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1478)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1443)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1217)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1039)
at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at
org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:759)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:249)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:158)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</bugreport>
<pre-fix-testcases failing="182" file="output/115251/pre-fix/testresults.xml" passing="1603" size="1785"/>
<post-fix-testcases failing="180" file="output/115251/post-fix/testresults.xml" passing="1605" size="1785"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java" revision="1.46" state="changed">982c982
&lt; 	        	if (sourceSc.scope.referenceContext instanceof AspectDeclaration) {
---
&gt; 	        	if (sourceSc.scope != null &amp;&amp; sourceSc.scope.referenceContext instanceof AspectDeclaration) {
</file>
</fixedFiles>
</bug>
<bug id="115252" transactionid="69080">
<property name="files-churned" value="11"/>
<property name="java-files-churned" value="10"/>
<property name="classes-churned" value="10"/>
<property name="methods-churned" value="10"/>
<property name="hunks" value="27"/>
<property name="lines-added" value="365"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="367"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-case K-class K-else K-false K-for K-if K-import K-instanceof K-new K-null K-package K-return K-super K-switch K-this K-throw K-true M O-&lt; O-== O-&gt; O-|| O-- O-! O-!= O-() O-&amp; O-&amp;&amp; O-+ O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-switch Z-throw Z-vardecl</fullfingerprint>
<bugreport>When an annotation can only target one kind of thing (e.g., a type) but is used
to modify something else in a pointcut (e.g., a method), it would be nice if the
compiler emitted an error, since the two situations can be confusingly similar:

   call(@Nice * *(..))      // method
   call((@Nice *) *(..))    // return type


---------------------------------------------
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

public class AnnotationTypePatternMistakes {
	@Retention(RetentionPolicy.RUNTIME)
	@Target({ElementType.TYPE}) 
	@interface I{}
	@I()
	class C{}
	static aspect A {
		// would like a CE here - I only on types
		pointcut pc() : execution(@I * *(..));
		declare error : pc() : "hi";
	}
}</bugreport>
<testsforfix ID="115252" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testXlintMessageForImproperAnnotationType_pr115252_Exact"/>
      <test NAME="testXlintMessageForImproperAnnotationType_pr115252_OR"/>
      <test NAME="testXlintMessageForImproperAnnotationType_pr115252_AND"/>
      <test NAME="testXlintMessageForImproperAnnotationType_pr115252_Return"/>
      <test NAME="testXlintMessageForImproperAnnotationType_pr115252_Declaring"/>
      <test NAME="testXlintMessageForImproperAnnotationType_pr115252_Parameter"/>
      <test NAME="testXlintMessageForImproperAnnotationType_pr115252_Throws"/>
      <test NAME="testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="parameterized type and around advice"/>
      <test NAME="xlint message for improper exact annotation type"/>
      <test NAME="xlint message for improper annotation type inside OR"/>
      <test NAME="xlint message for improper annotation type inside AND"/>
      <test NAME="xlint message for improper annotated return type"/>
      <test NAME="xlint message for improper annotated declaring type"/>
      <test NAME="xlint message for improper annotated parameter type"/>
      <test NAME="xlint message for improper annotated throws pattern"/>
      <test NAME="xlint message for more than one improper annotated parameter type"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/115252/pre-fix/testresults.xml" passing="1603" size="1783"/>
<post-fix-testcases failing="180" file="output/115252/post-fix/testresults.xml" passing="1603" size="1783"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Lint.java" revision="1.27" state="changed">53a54,56
&gt; 	public final Kind unmatchedTargetKind = 
&gt; 		new Kind("unmatchedTargetKind", "does not match because annotation {0} has @Target{1}");
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ReferenceType.java" revision="1.33" state="changed">160a161,168
&gt;     
&gt;     public boolean canAnnotationTargetType() {
&gt;     	return delegate.canAnnotationTargetType();
&gt;     }
&gt;     
&gt;     public AnnotationTargetKind[] getAnnotationTargetKinds() {
&gt;     	return delegate.getAnnotationTargetKinds();
&gt;     }
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/XlintDefault.properties" revision="1.19" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java" revision="1.48" state="changed">35a36
&gt; import org.aspectj.weaver.AnnotationTargetKind;
90a92,93
&gt; 	private boolean discoveredAnnotationTargetKinds = false;
&gt; 	private AnnotationTargetKind[] annotationTargetKinds;
472a476,529
&gt; 	public boolean canAnnotationTargetType() {
&gt; 		AnnotationTargetKind[] targetKinds = getAnnotationTargetKinds();
&gt; 		if (targetKinds == null) return true;
&gt; 		for (int i = 0; i &lt; targetKinds.length; i++) {
&gt; 			if (targetKinds[i].equals(AnnotationTargetKind.TYPE)) {
&gt; 				return true;
&gt; 			}
&gt; 		}
&gt; 		return false;
&gt; 	}
&gt; 	
&gt; 	public AnnotationTargetKind[] getAnnotationTargetKinds() {
&gt; 		if (discoveredAnnotationTargetKinds) return annotationTargetKinds;
&gt; 		discoveredAnnotationTargetKinds = true;
&gt; 		annotationTargetKinds = null; // null means we have no idea or the @Target annotation hasn't been used
&gt; 		List targetKinds = new ArrayList();
&gt; 		if (isAnnotation()) {
&gt; 	        Annotation[] annotationsOnThisType = javaClass.getAnnotations();
&gt; 	        for (int i = 0; i &lt; annotationsOnThisType.length; i++) {
&gt; 	            Annotation a = annotationsOnThisType[i];
&gt; 	            if (a.getTypeName().equals(UnresolvedType.AT_TARGET.getName())) {
&gt; 	                List values = a.getValues();
&gt; 	                for (Iterator it = values.iterator(); it.hasNext();) {
&gt;                         ElementNameValuePair element = (ElementNameValuePair) it.next();
&gt;                         ElementValue v = element.getValue();
&gt;                         String targetKind = v.stringifyValue();
&gt;                         if (targetKind.equals("ANNOTATION_TYPE")) {
&gt; 							targetKinds.add(AnnotationTargetKind.ANNOTATION_TYPE);
&gt;                         } else if (targetKind.equals("CONSTRUCTOR")) {
&gt; 							targetKinds.add(AnnotationTargetKind.CONSTRUCTOR);
&gt; 						} else if (targetKind.equals("FIELD")) {
&gt; 							targetKinds.add(AnnotationTargetKind.FIELD);
&gt; 						} else if (targetKind.equals("LOCAL_VARIABLE")) {
&gt; 							targetKinds.add(AnnotationTargetKind.LOCAL_VARIABLE);
&gt; 						} else if (targetKind.equals("METHOD")) {
&gt; 							targetKinds.add(AnnotationTargetKind.METHOD);
&gt; 						} else if (targetKind.equals("PACKAGE")) {
&gt; 							targetKinds.add(AnnotationTargetKind.PACKAGE);
&gt; 						} else if (targetKind.equals("PARAMETER")) {
&gt; 							targetKinds.add(AnnotationTargetKind.PARAMETER);
&gt; 						} else if (targetKind.equals("TYPE")) {
&gt; 							targetKinds.add(AnnotationTargetKind.TYPE);
&gt; 						} 
&gt;                     }
&gt; 	            }
&gt; 	        }
&gt; 			if (!targetKinds.isEmpty()) {
&gt; 				annotationTargetKinds = new AnnotationTargetKind[targetKinds.size()];
&gt; 				return (AnnotationTargetKind[]) targetKinds.toArray(annotationTargetKinds);	
&gt; 			}
&gt; 		}
&gt; 		return annotationTargetKinds;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java" revision="1.7" state="changed">19a20
&gt; import org.aspectj.weaver.AnnotationTargetKind;
134a136,143
&gt; 	public boolean canAnnotationTargetType() {
&gt; 		return false;
&gt; 	}
&gt; 	
&gt; 	public AnnotationTargetKind[] getAnnotationTargetKinds() {
&gt; 		return null;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/BoundedReferenceType.java" revision="1.11" state="changed">187a188,195
&gt; 		public boolean canAnnotationTargetType() {
&gt; 			return resolvedTypeX.canAnnotationTargetType();
&gt; 		}
&gt; 		
&gt; 		public AnnotationTargetKind[] getAnnotationTargetKinds() {
&gt; 			return resolvedTypeX.getAnnotationTargetKinds();
&gt; 		}
&gt; 		
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java" revision="1.45" state="changed">46a47
&gt; import org.aspectj.weaver.AnnotationTargetKind;
80a82,84
&gt; 		
&gt; 	private boolean discoveredAnnotationTargetKinds = false;
&gt; 	private AnnotationTargetKind[] annotationTargetKinds;
338a343,394
&gt; 	public boolean canAnnotationTargetType() {
&gt; 		if (isAnnotation()) {
&gt; 			return ((binding.getAnnotationTagBits() &amp; TagBits.AnnotationForType) != 0 );
&gt; 		}
&gt; 		return false;
&gt; 	}
&gt; 	
&gt; 	public AnnotationTargetKind[] getAnnotationTargetKinds() {
&gt; 		if (discoveredAnnotationTargetKinds) return annotationTargetKinds;
&gt; 		discoveredAnnotationTargetKinds = true;
&gt; 		annotationTargetKinds = null; // null means we have no idea or the @Target annotation hasn't been used
&gt; //		if (isAnnotation()) {
&gt; //	        Annotation[] annotationsOnThisType = declaration.annotations;
&gt; //	        if (annotationsOnThisType != null) {
&gt; //		        for (int i = 0; i &lt; annotationsOnThisType.length; i++) {
&gt; //		            Annotation a = annotationsOnThisType[i];
&gt; //		            if (a.resolvedType != null) {
&gt; //		            	String packageName = new String(a.resolvedType.qualifiedPackageName()).concat(".");
&gt; //			            String sourceName = new String(a.resolvedType.qualifiedSourceName());
&gt; //			            if ((packageName + sourceName).equals(UnresolvedType.AT_TARGET.getName())) {
&gt; //			            	MemberValuePair[] pairs = a.memberValuePairs();
&gt; //			            	for (int j = 0; j &lt; pairs.length; j++) {
&gt; //								MemberValuePair pair = pairs[j];
&gt; //								targetKind = pair.value.toString();
&gt; //								return targetKind;
&gt; //							}
&gt; //			            }
&gt; //					}
&gt; //				}
&gt; //	        }
&gt; //		}
&gt; //	    return targetKind;
&gt; 		if (isAnnotation()) {
&gt; 			List targetKinds = new ArrayList();
&gt; 			
&gt; 			if ((binding.getAnnotationTagBits() &amp; TagBits.AnnotationForAnnotationType) != 0) targetKinds.add(AnnotationTargetKind.ANNOTATION_TYPE);
&gt; 			if ((binding.getAnnotationTagBits() &amp; TagBits.AnnotationForConstructor)    != 0) targetKinds.add(AnnotationTargetKind.CONSTRUCTOR);
&gt; 			if ((binding.getAnnotationTagBits() &amp; TagBits.AnnotationForField)          != 0) targetKinds.add(AnnotationTargetKind.FIELD);
&gt; 			if ((binding.getAnnotationTagBits() &amp; TagBits.AnnotationForLocalVariable)  != 0) targetKinds.add(AnnotationTargetKind.LOCAL_VARIABLE);
&gt; 			if ((binding.getAnnotationTagBits() &amp; TagBits.AnnotationForMethod)         != 0) targetKinds.add(AnnotationTargetKind.METHOD);
&gt; 			if ((binding.getAnnotationTagBits() &amp; TagBits.AnnotationForPackage)        != 0) targetKinds.add(AnnotationTargetKind.PACKAGE);
&gt; 			if ((binding.getAnnotationTagBits() &amp; TagBits.AnnotationForParameter)      != 0) targetKinds.add(AnnotationTargetKind.PARAMETER);
&gt; 			if ((binding.getAnnotationTagBits() &amp; TagBits.AnnotationForType)           != 0) targetKinds.add(AnnotationTargetKind.TYPE);
&gt; 			
&gt; 			if (!targetKinds.isEmpty()) {
&gt; 				annotationTargetKinds = new AnnotationTargetKind[targetKinds.size()];
&gt; 				return (AnnotationTargetKind[]) targetKinds.toArray(annotationTargetKinds);	
&gt; 			}
&gt; 		}
&gt; 		return annotationTargetKinds;
&gt; 	}
&gt; 	
555a612
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java" revision="1.44" state="changed">20a21
&gt; import java.util.HashMap;
23a25
&gt; import java.util.Set;
24a27
&gt; import org.aspectj.bridge.ISourceLocation;
30a34
&gt; import org.aspectj.weaver.AnnotationTargetKind;
73a78
&gt; 			checkForIncorrectTargetKind(returnType,scope,false);
76a82
&gt; 			checkForIncorrectTargetKind(declaringType,scope,false);
79a86
&gt; 			checkForIncorrectTargetKind(parameterTypes,scope,false);
82a90,93
&gt; 			if (throwsPattern.getForbidden().getTypePatterns().length &gt; 0 
&gt; 					|| throwsPattern.getRequired().getTypePatterns().length &gt; 0) {
&gt; 				checkForIncorrectTargetKind(throwsPattern,scope,false);				
&gt; 			}
85a97
&gt; 			checkForIncorrectTargetKind(annotationPattern,scope,true);
90a103,246
&gt;     // bug 115252 - adding an xlint warning if the annnotation target type is 
&gt;     // wrong. This logic, or similar, may have to be applied elsewhere in the case
&gt;     // of pointcuts which don't go through SignaturePattern.resolveBindings(..)
&gt;     private void checkForIncorrectTargetKind(PatternNode patternNode, IScope scope, boolean targetsOtherThanTypeAllowed) {
&gt;     	// return if we're not in java5 mode, if the unmatchedTargetKind Xlint
&gt;     	// warning has been turned off, or if the patternNode is *
&gt;     	if (!scope.getWorld().isInJava5Mode()
&gt;     			|| scope.getWorld().getLint().unmatchedTargetKind == null
&gt;     			|| (patternNode instanceof AnyTypePattern)) {
&gt; 			return;
&gt; 		}
&gt; 		if (patternNode instanceof ExactAnnotationTypePattern) {
&gt; 			ResolvedType resolvedType = ((ExactAnnotationTypePattern)patternNode).getAnnotationType().resolve(scope.getWorld());
&gt; 			if (targetsOtherThanTypeAllowed) {
&gt; 				AnnotationTargetKind[] targetKinds = resolvedType.getAnnotationTargetKinds();
&gt; 				if (targetKinds == null) return;
&gt; 				reportUnmatchedTargetKindMessage(targetKinds,patternNode,scope,true);
&gt; 			} else if (!targetsOtherThanTypeAllowed &amp;&amp; !resolvedType.canAnnotationTargetType()) {
&gt; 				// everything is incorrect since we've already checked whether we have the TYPE target annotation
&gt; 				AnnotationTargetKind[] targetKinds = resolvedType.getAnnotationTargetKinds();
&gt; 				if (targetKinds == null) return;
&gt; 				reportUnmatchedTargetKindMessage(targetKinds,patternNode,scope,false);
&gt; 			}
&gt; 		} else {
&gt; 			TypePatternVisitor visitor = new TypePatternVisitor(scope,targetsOtherThanTypeAllowed);
&gt; 			patternNode.traverse(visitor,null);
&gt; 			if (visitor.containedIncorrectTargetKind()) {
&gt; 				Set keys = visitor.getIncorrectTargetKinds().keySet();				
&gt; 				for (Iterator iter = keys.iterator(); iter.hasNext();) {
&gt; 					PatternNode node = (PatternNode)iter.next();
&gt; 					AnnotationTargetKind[] targetKinds =  (AnnotationTargetKind[]) visitor.getIncorrectTargetKinds().get(node);
&gt; 					reportUnmatchedTargetKindMessage(targetKinds,node,scope,false);
&gt; 				}
&gt; 			}
&gt; 		}
&gt;     }
&gt;     
&gt;     private void reportUnmatchedTargetKindMessage(
&gt;     		AnnotationTargetKind[] annotationTargetKinds,  
&gt;     		PatternNode node,
&gt;     		IScope scope,
&gt;     		boolean checkMatchesMemberKindName) {
&gt;     	StringBuffer targetNames = new StringBuffer("{");
&gt;     	for (int i = 0; i &lt; annotationTargetKinds.length; i++) {
&gt; 			AnnotationTargetKind targetKind = annotationTargetKinds[i];
&gt; 			if (checkMatchesMemberKindName &amp;&amp; kind.getName().equals(targetKind.getName())) {
&gt; 				return;
&gt; 			}
&gt; 			if (i &lt; (annotationTargetKinds.length - 1)) {
&gt; 				targetNames.append("ElementType." + targetKind.getName() + ",");
&gt; 			} else {
&gt; 				targetNames.append("ElementType." + targetKind.getName() + "}");
&gt; 			}
&gt; 		}
&gt; 		scope.getWorld().getLint().unmatchedTargetKind.signal(new String[] {node.toString(),targetNames.toString()}, getSourceLocation(), new ISourceLocation[0]);
&gt;     }
&gt;     
&gt;     /**
&gt;      * Class which visits the nodes in the TypePattern tree until an
&gt;      * ExactTypePattern is found. Once this is found it creates a new
&gt;      * ExactAnnotationTypePattern and checks whether the targetKind
&gt;      * (created via the @Target annotation) matches ElementType.TYPE if
&gt;      * this is the only target kind which is allowed, or matches the
&gt;      * signature pattern kind if there is no restriction.
&gt;      */
&gt;     private class TypePatternVisitor extends AbstractPatternNodeVisitor {
&gt; 
&gt;     	private IScope scope;
&gt;     	private Map incorrectTargetKinds /* PatternNode -&gt; AnnotationTargetKind[] */ = new HashMap();
&gt;     	private boolean targetsOtherThanTypeAllowed;
&gt; 
&gt;     	/**
&gt;     	 * @param requiredTarget - the signature pattern Kind
&gt;     	 * @param scope
&gt;     	 */
&gt;     	public TypePatternVisitor(IScope scope, boolean targetsOtherThanTypeAllowed) {
&gt;     		this.scope = scope;
&gt;     		this.targetsOtherThanTypeAllowed = targetsOtherThanTypeAllowed;
&gt;     	}
&gt;     	
&gt;     	public Object visit(WildAnnotationTypePattern node, Object data) {
&gt;     		node.getTypePattern().accept(this,data);
&gt;     		return node;
&gt;     	}
&gt;     	
&gt;     	/**
&gt;     	 * Do the ExactAnnotationTypePatterns have the incorrect target?
&gt;     	 */
&gt;     	public Object visit(ExactAnnotationTypePattern node, Object data) {
&gt;     		ResolvedType resolvedType = node.getAnnotationType().resolve(scope.getWorld());
&gt; 			if (targetsOtherThanTypeAllowed) {
&gt; 				AnnotationTargetKind[] targetKinds = resolvedType.getAnnotationTargetKinds();
&gt; 				if (targetKinds == null) return data;
&gt; 				List incorrectTargets = new ArrayList();
&gt; 				for (int i = 0; i &lt; targetKinds.length; i++) {
&gt; 					if (targetKinds[i].getName().equals(kind.getName())) {
&gt; 						return data;
&gt; 					}
&gt; 					incorrectTargets.add(targetKinds[i]);
&gt; 				}
&gt; 				if (incorrectTargets.isEmpty()) return data;
&gt; 				AnnotationTargetKind[] kinds = new AnnotationTargetKind[incorrectTargets.size()];
&gt; 				incorrectTargetKinds.put(node,(AnnotationTargetKind[]) incorrectTargets.toArray(kinds));	
&gt; 			} else if (!targetsOtherThanTypeAllowed &amp;&amp; !resolvedType.canAnnotationTargetType()) {
&gt; 				AnnotationTargetKind[] targetKinds = resolvedType.getAnnotationTargetKinds();
&gt; 				if (targetKinds == null) return data;
&gt; 				incorrectTargetKinds.put(node,targetKinds);
&gt; 			}
&gt;     		return data;
&gt;     	}
&gt;     	
&gt;     	public Object visit(ExactTypePattern node, Object data) {
&gt;     		ExactAnnotationTypePattern eatp =  new ExactAnnotationTypePattern(node.getExactType().resolve(scope.getWorld()));
&gt;     		eatp.accept(this,data);		
&gt;     		return data;
&gt;     	}
&gt;     	
&gt;     	public Object visit(AndTypePattern node, Object data) {
&gt;     		node.getLeft().accept(this,data);
&gt;     		node.getRight().accept(this,data);
&gt;     		return node;
&gt;     	}
&gt; 
&gt;     	public Object visit(OrTypePattern node, Object data) {
&gt;     		node.getLeft().accept(this,data);
&gt;     		node.getRight().accept(this,data);
&gt;     		return node;
&gt;     	}
&gt; 
&gt;     	public Object visit(AnyWithAnnotationTypePattern node, Object data) {
&gt;     		node.getAnnotationPattern().accept(this,data);
&gt;     		return node;
&gt;     	}
&gt;     	
&gt;     	public boolean containedIncorrectTargetKind() {
&gt;     		return (incorrectTargetKinds.size() != 0);
&gt;     	}
&gt;     	
&gt;     	public Map getIncorrectTargetKinds() {
&gt;     		return incorrectTargetKinds;
&gt;     	}
&gt;     }
&gt;     
&gt;     
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ReferenceTypeDelegate.java" revision="1.9" state="changed">28,29d27
&lt; 
&lt; 	
36a35,36
&gt;     public boolean canAnnotationTargetType();
&gt;     public AnnotationTargetKind[] getAnnotationTargetKinds();
63a64
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedType.java" revision="1.34" state="changed">636d635
&lt; 
637a637,650
&gt; 	/**
&gt; 	 * Note: Only overridden by ReferenceType subtype
&gt; 	 */
&gt; 	public boolean canAnnotationTargetType() {
&gt; 		return false;
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * Note: Only overridden by ReferenceType subtype
&gt; 	 */	
&gt; 	public AnnotationTargetKind[] getAnnotationTargetKinds() {
&gt; 		return null;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.214" state="changed">65c65,74
&lt;     
---
&gt;   
&gt;     &lt;ajc-test dir="bugs150" title="parameterized type and around advice"&gt;
&gt;         &lt;compile files="pr115250.aj" options="-1.5 -Xlint:ignore"/&gt;
&gt;         &lt;run class="pr115250"/&gt;
&gt;           &lt;!--stderr&gt;
&gt;             &lt;line text="Advice running"/&gt;
&gt;           &lt;/stderr&gt;
&gt;         &lt;/run--&gt;
&gt;     &lt;/ajc-test&gt;
&gt;       
1026a1036,1108
&gt; 	&lt;ajc-test dir="bugs150/pr115252" title="xlint message for improper exact annotation type"&gt;
&gt;         &lt;compile files="ExactAnnotationTypePattern.java" options="-1.5"&gt;
&gt; 			&lt;message kind="warning" line="20" text="field blah"/&gt;
&gt;         	&lt;message kind="warning" line="28" text="does not match because annotation @TypeAnnotation has @Target{ElementType.TYPE} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         	&lt;message kind="warning" line="37" text="does not match because annotation @FieldAnnotation has @Target{ElementType.FIELD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;             &lt;message kind="warning" line="46" text="does not match because annotation @MethodAnnotation has @Target{ElementType.METHOD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt; 	&lt;ajc-test dir="bugs150/pr115252" title="xlint message for improper annotation type inside OR"&gt;
&gt;         &lt;compile files="OrTypePattern.java" options="-1.5"&gt;
&gt;             &lt;message kind="warning" line="26" text="does not match because annotation @FieldAnnotation has @Target{ElementType.FIELD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         	&lt;message kind="warning" line="31" text="does not match because annotation @TypeAnnotation has @Target{ElementType.TYPE} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         	&lt;message kind="warning" line="31" text="does not match because annotation @FieldAnnotation has @Target{ElementType.FIELD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt; 	&lt;ajc-test dir="bugs150/pr115252" title="xlint message for improper annotation type inside AND"&gt;
&gt;         &lt;compile files="AndTypePattern.java" options="-1.5"&gt;
&gt;             &lt;message kind="warning" line="23" text="does not match because annotation @FieldAnnotation has @Target{ElementType.FIELD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt; 	&lt;ajc-test dir="bugs150/pr115252" title="xlint message for improper annotated return type"&gt;
&gt;         &lt;compile files="AnnotationReturnType.java" options="-1.5"&gt;
&gt;             &lt;!-- warnings coming from matching pointcuts and corresponding declare warnings --&gt;
&gt; 			&lt;message kind="warning" line="12" text="(@TypeAnnotation *) *(..)"/&gt;
&gt; 			&lt;message kind="warning" line="12" text="(@(TypeAnnotation || MethodAnnotation) *) *(..)"/&gt;
&gt;             &lt;!-- xlint warnings that were put in as part of fix for pr115252 --&gt;
&gt;         	&lt;message kind="warning" line="32" text="does not match because annotation @MethodAnnotation has @Target{ElementType.METHOD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         	&lt;message kind="warning" line="37" text="does not match because annotation @MethodAnnotation has @Target{ElementType.METHOD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt; 	&lt;ajc-test dir="bugs150/pr115252" title="xlint message for improper annotated declaring type"&gt;
&gt;         &lt;compile files="AnnotationDeclaringType.java" options="-1.5"&gt;
&gt;             &lt;!-- warning coming from matching pointcuts and corresponding declare warnings --&gt;
&gt; 			&lt;message kind="warning" line="13" text="* (@TypeAnnotation *).*(..)"/&gt;
&gt;             &lt;!-- xlint warning that was put in as part of fix for pr115252 --&gt;
&gt;         	&lt;message kind="warning" line="27" text="does not match because annotation @MethodAnnotation has @Target{ElementType.METHOD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt; 	&lt;ajc-test dir="bugs150/pr115252" title="xlint message for improper annotated parameter type"&gt;
&gt;         &lt;compile files="AnnotationParameterType.java" options="-1.5"&gt;
&gt;             &lt;!-- warning coming from matching pointcuts and corresponding declare warnings --&gt;
&gt; 			&lt;message kind="warning" line="12" text="* *(@TypeAnnotation *)"/&gt;
&gt;             &lt;!-- xlint warning that was put in as part of fix for pr115252 --&gt;
&gt;         	&lt;message kind="warning" line="31" text="does not match because annotation @MethodAnnotation has @Target{ElementType.METHOD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt; 	&lt;ajc-test dir="bugs150/pr115252" title="xlint message for improper annotated throws pattern"&gt;
&gt;         &lt;compile files="AnnotationThrowsPattern.java" options="-1.5"&gt;
&gt;             &lt;!-- warnings coming from matching pointcuts and corresponding declare warnings --&gt;
&gt; 			&lt;message kind="warning" line="12" text="(* *.*(..) throws (@TypeAnnotation *))"/&gt;
&gt; 			&lt;message kind="warning" line="12" text="* *.*(..) throws !(@MethodAnnotation *)"/&gt;
&gt; 			&lt;message kind="warning" line="14" text="(* *.*(..) throws !(@TypeAnnotation *))"/&gt;
&gt; 			&lt;message kind="warning" line="14" text="* *.*(..) throws !(@MethodAnnotation *)"/&gt;
&gt;             &lt;!-- xlint warnings that were put in as part of fix for pr115252 --&gt;
&gt;         	&lt;message kind="warning" line="40" text="does not match because annotation @MethodAnnotation has @Target{ElementType.METHOD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         	&lt;message kind="warning" line="46" text="does not match because annotation @MethodAnnotation has @Target{ElementType.METHOD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt; 	&lt;ajc-test dir="bugs150/pr115252" title="xlint message for more than one improper annotated parameter type"&gt;
&gt;         &lt;compile files="MoreThanOneTargetAnnotation.java" options="-1.5"&gt;
&gt;             &lt;!-- xlint warning that was put in as part of fix for pr115252 --&gt;
&gt;         	&lt;message kind="warning" line="28" text="does not match because annotation @MethodAndFieldAnnotation has @Target{ElementType.FIELD,ElementType.METHOD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         	&lt;message kind="warning" line="38" text="does not match because annotation @TypeAndMethodAnnotation has @Target{ElementType.METHOD,ElementType.TYPE} [Xlint:unmatchedTargetKind]"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
2873c2955,2958
&lt;         &lt;/compile&gt;
---
&gt;            &lt;!-- xlint warnings that were put in as part of fix for pr115252 --&gt;
&gt;            &lt;message kind="warning" line="13" text="does not match because annotation @MethodColoring has @Target{ElementType.METHOD} [Xlint:unmatchedTargetKind]"/&gt;
&gt;            &lt;message kind="warning" line="16" text="does not match because annotation @TypeColoring has @Target{ElementType.TYPE} [Xlint:unmatchedTargetKind]"/&gt;
&gt;   &lt;/compile&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.135" state="changed">720a721,729
&gt;   public void testXlintMessageForImproperAnnotationType_pr115252_Exact() {runTest("xlint message for improper exact annotation type");}
&gt;   public void testXlintMessageForImproperAnnotationType_pr115252_OR() {runTest("xlint message for improper annotation type inside OR");}
&gt;   public void testXlintMessageForImproperAnnotationType_pr115252_AND() {runTest("xlint message for improper annotation type inside AND");}
&gt;   public void testXlintMessageForImproperAnnotationType_pr115252_Return() {runTest("xlint message for improper annotated return type");}  
&gt;   public void testXlintMessageForImproperAnnotationType_pr115252_Declaring() {runTest("xlint message for improper annotated declaring type");}  
&gt;   public void testXlintMessageForImproperAnnotationType_pr115252_Parameter() {runTest("xlint message for improper annotated parameter type");}  
&gt;   public void testXlintMessageForImproperAnnotationType_pr115252_Throws() {runTest("xlint message for improper annotated throws pattern");}  
&gt;   public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}  
&gt;     
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AnnotationTargetKind.java" revision="1.1" state="new">/********************************************************************
 * Copyright (c) 2005 Contributors. All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *       Helen Hawkins - Initial implementation
 *******************************************************************/
package org.aspectj.weaver;

import java.io.DataInputStream;
import java.io.IOException;

import org.aspectj.util.TypeSafeEnum;

/**
 * A TypeSafeEnum similar to the Java5 ElementType Enum
 */
public class AnnotationTargetKind extends TypeSafeEnum {

	public AnnotationTargetKind(String name, int key) {
		super(name, key);
	}
	
    public static AnnotationTargetKind read(DataInputStream s) throws IOException {
        int key = s.readByte();
        switch(key) {
            case 1: return ANNOTATION_TYPE;
            case 2: return CONSTRUCTOR;
            case 3: return FIELD;
            case 4: return LOCAL_VARIABLE;
            case 5: return METHOD;
            case 6: return PACKAGE;
            case 7: return PARAMETER;
            case 8: return TYPE;
        }
        throw new BCException("weird annotation target kind " + key);
    }

	public static final AnnotationTargetKind ANNOTATION_TYPE = new AnnotationTargetKind("ANNOTATION_TYPE", 1);
	public static final AnnotationTargetKind CONSTRUCTOR = new AnnotationTargetKind("CONSTRUCTOR", 2);
	public static final AnnotationTargetKind FIELD = new AnnotationTargetKind("FIELD", 3);
	public static final AnnotationTargetKind LOCAL_VARIABLE = new AnnotationTargetKind("LOCAL_VARIABLE", 4);
	public static final AnnotationTargetKind METHOD = new AnnotationTargetKind("METHOD", 5);
	public static final AnnotationTargetKind PACKAGE = new AnnotationTargetKind("PACKAGE", 6);
	public static final AnnotationTargetKind PARAMETER = new AnnotationTargetKind("PARAMETER", 7);
	public static final AnnotationTargetKind TYPE = new AnnotationTargetKind("TYPE", 8);

}
</file>
</fixedFiles>
</bug>
<bug id="115275" transactionid="71715">
<property name="files-churned" value="5"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="13"/>
<property name="lines-added" value="40"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="12"/>
<property name="lines-churned" value="53"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-else K-for K-if K-new K-null K-return K-true M O-&lt; O-! O-!= O-&amp;&amp; O-++ O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>I have a question about load-time weaving in AspectJ.  According to the
AspectJ 5 Development Kit Developer's Notebook,  the &lt;aspects&gt; element
can have an &lt;include within="[pattern]"&gt; child element
(http://eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html).

However, when I include that element as a child to the &lt;aspects&gt; element
in my aop.xml file, I get a SAX exception:

org.xml.sax.SAXException: Unknown element while parsing &lt;aspectj&gt;
element: include


Is the &lt;include&gt; element currently supported within the &lt;aspects&gt;
element?  Or do I have to explicitly list every aspect I want woven at
load time using an &lt;aspect name="..."&gt; for each aspect?  Basically I do
not wish to explicitly ennumerate every aspect in the aop.xml file for
the load-time weaver.  Rather, I want to use a wildcard pattern to
capture them all.</bugreport>
<testsforfix ID="115275" type="changed">
    <file LOCATION="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.java"/>
    <file LOCATION="org.aspectj/modules/loadtime/testsrc/org/aspectj/weaver/loadtime/test/DocumentParserTest.java"/>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/115275/pre-fix/testresults.xml" passing="1589" size="1769"/>
<post-fix-testcases failing="179" file="output/115275/post-fix/testresults.xml" passing="1590" size="1769"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/definition/Definition.java" revision="1.7" state="changed"/>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.27" state="changed">61a62,63
&gt;     private List m_aspectIncludeTypePattern = new ArrayList();
&gt;     private List m_aspectIncludeStartsWith = new ArrayList();
69c71
&lt;     
---
&gt; 
91c93
&lt;         
---
&gt; 
145c147
&lt;             
---
&gt; 
166a169
&gt;                 registerAspectInclude(weaver, loader, definitions);
206d208
&lt;         //world.setBehaveInJava5Way(weaverOption.java5);//TODO should be autodetected ?
263a266,281
&gt;     private void registerAspectInclude(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
&gt;         String fastMatchInfo = null;
&gt;         for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
&gt;             Definition definition = (Definition) iterator.next();
&gt;             for (Iterator iterator1 = definition.getAspectIncludePatterns().iterator(); iterator1.hasNext();) {
&gt;                 String include = (String) iterator1.next();
&gt;                 TypePattern includePattern = new PatternParser(include).parseTypePattern();
&gt;                 m_aspectIncludeTypePattern.add(includePattern);
&gt;                 fastMatchInfo = looksLikeStartsWith(include);
&gt;                 if (fastMatchInfo != null) {
&gt;                     m_aspectIncludeStartsWith.add(fastMatchInfo);
&gt;                 }
&gt;             }
&gt;         }
&gt;     }
&gt; 
466a485,486
&gt;     //FIXME we don't use include/exclude of others aop.xml
&gt;     //this can be nice but very dangerous as well to change that
469c489
&lt;         if (m_aspectExcludeTypePattern.isEmpty()) {
---
&gt;         if (m_aspectExcludeTypePattern.isEmpty() &amp;&amp; m_aspectIncludeTypePattern.isEmpty()) {
473a494
&gt;         // EXCLUDE: if one match then reject
479a501,506
&gt;         //INCLUDE: if one match then accept
&gt;         for (int i = 0; i &lt; m_aspectIncludeStartsWith.size(); i++) {
&gt;             if (fastClassName.startsWith((String)m_aspectIncludeStartsWith.get(i))) {
&gt;                 return true;
&gt;             }
&gt;         }
491c518,528
&lt;         return true;
---
&gt;         //include are "OR"ed
&gt;         boolean accept = true;//defaults to true if no include
&gt;         for (Iterator iterator = m_aspectIncludeTypePattern.iterator(); iterator.hasNext();) {
&gt;             TypePattern typePattern = (TypePattern) iterator.next();
&gt;             accept = typePattern.matchesStatically(classInfo);
&gt;             if (accept) {
&gt;                 break;
&gt;             }
&gt;             // goes on if this include did not match ("OR"ed)
&gt;         }
&gt;         return accept;
511c548
&lt;     
---
&gt; 
515c552
&lt;     
---
&gt; 
535c572
&lt;     
---
&gt; 
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java" revision="1.9" state="changed">195a196,200
&gt;         } else if (INCLUDE_ELEMENT.equals(qName) &amp;&amp; m_inAspects) {
&gt;             String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
&gt;             if (!isNull(typePattern)) {
&gt;                 m_definition.getAspectIncludePatterns().add(typePattern);
&gt;             }
</file>
<file name="org.aspectj/modules/docs/devGuideDB/ltw.xml" revision="1.7" state="changed">170,171c170,171
&lt;               &lt;!-- Of the set of aspects known to the weaver, use aspects matching
&lt;                    the type pattern "com..*" for weaving. --&gt;
---
&gt;               &lt;!-- Of the set of aspects declared in this sole aop.xml,
&gt;                    use aspects matching the type pattern "com..*" for weaving. --&gt;
174c174,175
&lt;               &lt;!-- Do not use any aspects with the @CoolAspect annotation for weaving --&gt;
---
&gt;               &lt;!-- Of the set of aspects declared in this sole aop.xml,
&gt;                    do not use any aspects with the @CoolAspect annotation for weaving --&gt;
215,216c216,217
&lt;                 The aspects element may optionally contain one or more include and
&lt;                 exclude elements (by default, all defined aspects are used for weaving).
---
&gt;                 The &lt;literal&gt;aspects&lt;/literal&gt; element may optionally contain one or more &lt;literal&gt;include&lt;/literal&gt; and
&gt;                 &lt;literal&gt;exclude&lt;/literal&gt; elements (by default, all defined aspects are used for weaving).
219c220
&lt;                 pattern, but not by an exclude pattern. The 'within' attribute accepts
---
&gt;                 pattern, but not by an exclude pattern. The &lt;literal&gt;within&lt;/literal&gt; attribute accepts
222a224,229
&gt;             &lt;para&gt;
&gt;                 Note that &lt;literal&gt;include&lt;/literal&gt; and &lt;literal&gt;exclude&lt;/literal&gt; affects the declared list of aspects (or concrete-aspect) defined in this
&gt;                 sole aop.xml and has no side effect on other aop.xml files.
&gt;                 Also note it is required to use &lt;literal&gt;aspect&lt;/literal&gt; or &lt;literal&gt;concrete-aspect&lt;/literal&gt; elements and that include does not
&gt;                 mean "pick any aspect you 'll find" - as the aspect list must be known by the weaver.
&gt;             &lt;/para&gt;
520a528,532
&gt; 
&gt;         &lt;para&gt;
&gt;             Some lint options behave differently when used under load-time weaving. The &lt;literal&gt;adviceDidNotMatch&lt;/literal&gt;
&gt;             won't be handled as a warn (as during compile time) but as an info message.
&gt;         &lt;/para&gt;
</file>
<file name="org.aspectj/modules/loadtime/src/aspectj_1_5_0.dtd" revision="1.5" state="changed"/>
<file name="org.aspectj/modules/loadtime/testsrc/org/aspectj/weaver/loadtime/test/simpleWithDtd.xml" revision="1.4" state="changed">9a10
&gt;         &lt;include within="@Whoo"/&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.java" revision="1.4" state="changed">40c40
&lt;         @Pointcut()
---
&gt;         @Pointcut
</file>
<file name="org.aspectj/modules/loadtime/testsrc/org/aspectj/weaver/loadtime/test/DocumentParserTest.java" revision="1.4" state="changed">39a40
&gt;         assertEquals("@Whoo", def.getAspectIncludePatterns().get(0));
</file>
</fixedFiles>
</bug>
<bug id="115607" transactionid="68662">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-else K-if O-&lt; O-== O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>This program:
---8&lt;-----
@interface I {}

class Simple {}

public aspect C {
  declare @type: Simple : @I;
}
---8&lt;-----
(all in a file called C.java, open with the AJ editor) when built shows
incorrect gutter markers, it shows a double headed arrow on Simple implying that
it annotates itself - rather than something outgoing from the declare statement
and something incoming on the Simple type.</bugreport>
<testsforfix ID="115607" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testSelfBoundGenerics_pr117296"/>
      <test NAME="testDeclareAtTypeInStructureModel_pr115607"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="self bounding generic types"/>
      <test NAME="declare at type appears correctly in structure model"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="163" file="output/115607/pre-fix/testresults.xml" passing="1435" size="1598"/>
<post-fix-testcases failing="180" file="output/115607/post-fix/testresults.xml" passing="1605" size="1785"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java" revision="1.9" state="changed">90a91,92
&gt;             } else if (0 &lt; lineNumber &amp;&amp; lineNumber == result.lineSeparatorPositions.length) {
&gt;             	column = 0;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.137" state="changed">79a80
&gt;  // public void testSelfBoundGenerics_pr117296() { runTest("self bounding generic types");}
734c735,746
&lt;     
---
&gt;   
&gt;   public void testDeclareAtTypeInStructureModel_pr115607() {
&gt;       AsmManager.setReporting("c:/debug.txt",true,true,true,true);
&gt; 	  runTest("declare at type appears correctly in structure model");  
&gt;   	  IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt;   	  IProgramElement pe = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE,"declare @type: Simple : @I");  	 	 
&gt;   	  assertNotNull("Couldn't find 'declare @type: Simple : @I' element in the tree",pe);
&gt;   	  List l = AsmManager.getDefault().getRelationshipMap().get(pe);	
&gt; 	  assertNotNull("Should have some relationships but does not",l);
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.217" state="changed">54a55,58
&gt;     
&gt;     &lt;ajc-test dir="bugs150" pr="117296" title="self bounding generic types"&gt;
&gt;      &lt;compile files="PropertySupport.java" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt;
1125a1130,1134
&gt; 	&lt;ajc-test dir="bugs150" title="declare at type appears correctly in structure model"&gt;
&gt;         &lt;compile files="pr115607.java" options="-1.5,-emacssym"&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs150/pr115607.java" revision="1.1" state="new">@interface I {}

class Simple {}

public aspect pr115607 {
  declare @type: Simple : @I;
}</file>
</fixedFiles>
</bug>
<bug id="116626" transactionid="68405">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P2"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-null K-return K-this M O-!= T V Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>Hi again :-)

I'm trying to use loadtime weaving and getting an exception. Please look at the 
testcase:

Java code:
==========
public class Test&lt;T&gt; {

	Set&lt;T&gt; intsSet;

	public Test() {
		this.intsSet = new HashSet&lt;T&gt;();
	}

	public &lt;T&gt; T[] getObjs(T[] a) {
		return intsSet.toArray(a);
	}

	public static void main(String[] args) {
		System.out.println("AAA :-)");
		new TTT().foo();
	}
}

class TTT {
	public void foo() {
		Test&lt;Object&gt; mt = new Test&lt;Object&gt;();
		Object[] arr = mt.getObjs(new Object[]{});
	}
}

Aspect:
=======
public privileged aspect TestAspect {

      pointcut TestToArray(Test mt) :
                target(mt) &amp;&amp;
                !within(TestAspect);


    Object[] around(Test mt, Object[] objs) :
            TestToArray(mt) &amp;&amp;
            args(objs) &amp;&amp;
            execution(Object[] com.mprv.secsph.Test.getObjs(Object[])) {

        objs = proceed(mt, objs);
        System.out.println("GO Aspects!");
        return objs;
    }
}

aop.xml
=======
&lt;aspectj&gt;
	&lt;aspects&gt;
		&lt;aspect name="com.mprv.secsph.TestAspect"/&gt;
	&lt;/aspects&gt;

	&lt;weaver options="-verbose -XlazyTjp -showWeaveInfo"&gt;
		&lt;include within="com.mprv.*"/&gt;
	&lt;/weaver&gt;
&lt;/aspectj&gt;

Program output:
==============
AAA :-)
info weaving 'com/mprv/secsph/TestAspect'
java.lang.NullPointerException
	at 
org.aspectj.weaver.tools.WeavingAdaptor$WeavingClassFileProvider.getBytes
(WeavingAdaptor.java:390)
	at org.aspectj.weaver.tools.WeavingAdaptor.getAtAspectJAspectBytes
(WeavingAdaptor.java:259)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass
(WeavingAdaptor.java:181)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:66)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform
(ClassPreProcessorAgentAdapter.java:52)
	at sun.instrument.TransformerManager.transform
(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform
(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
	at java.security.SecureClassLoader.defineClass
(SecureClassLoader.java:124)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:56)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
	at com.mprv.secsph.Test.getObjs(Test.java:1)
	at com.mprv.secsph.TTT.foo(Test.java:34)
	at com.mprv.secsph.Test.main(Test.java:27)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:86)
GO Aspects!

====

This exception doesn't happen all the time ... but if you will try a few times, 
you will probably get it. May you can understand what is the problem event 
without running the test case. 

Anyway, I took a look at your code, and have a guess (but it's only the guess) -
My aspect is in the application classpath. Actually it's in the same package, 
so may be you are trying to weave the aspect with itself somehow ...

Thanks!
Misha.</bugreport>
<testsforfix ID="116626" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testNPEinWeavingAdaptor_pr116626"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="NPE in WeavingAdaptor"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="181" file="output/116626/pre-fix/testresults.xml" passing="1602" size="1783"/>
<post-fix-testcases failing="182" file="output/116626/post-fix/testresults.xml" passing="1601" size="1783"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.20" state="changed">389a390
&gt; 		private UnwovenClassFile unwovenClass;
395,397c396,398
&lt; 			UnwovenClassFile unwoven = new UnwovenClassFile(name,bytes);
&lt; 			unwovenClasses.add(unwoven);
&lt; 			bcelWorld.addSourceObjectType(unwoven.getJavaClass());
---
&gt; 			this.unwovenClass = new UnwovenClassFile(name,bytes);
&gt; 			this.unwovenClasses.add(unwovenClass);
&gt; 			bcelWorld.addSourceObjectType(unwovenClass.getJavaClass());
409c410,411
&lt; 			return wovenClass.getBytes();
---
&gt;         	if (wovenClass != null) return wovenClass.getBytes();
&gt;         	else return unwovenClass.getBytes();
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.213" state="changed">5561a5562,5568
&gt;    
&gt;    &lt;ajc-test dir="bugs150/pr116626" title="NPE in WeavingAdaptor"&gt;
&gt;      &lt;compile files="com/foo/bar/Test.java, TestAspect.aj" options="-1.5"/&gt;
&gt;      &lt;run class="com.foo.bar.Test" ltw="aop.xml"
&gt;      &gt;
&gt;      &lt;/run&gt;
&gt;    &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs150/pr116626/com/foo/bar/Test.java" revision="1.1" state="new">package com.foo.bar;

import java.util.*;

public class Test&lt;T&gt; {

	Set&lt;T&gt; intsSet;

	public Test() {
		this.intsSet = new HashSet&lt;T&gt;();
	}

	public &lt;T&gt; T[] getObjs(T[] a) {
		return intsSet.toArray(a);
	}

	public static void main(String[] args) {
		System.out.println("AAA :-)");
		new TTT().foo();
	}
}

class TTT {
	public void foo() {
		Test&lt;Object&gt; mt = new Test&lt;Object&gt;();
		Object[] arr = mt.getObjs(new Object[]{});
	}
}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.134" state="changed">714a715,719
&gt; 
&gt;   /*
&gt;    * Load-time weaving bugs
&gt;    */
&gt;   public void testNPEinWeavingAdaptor_pr116626() { runTest("NPE in WeavingAdaptor");}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr116626/TestAspect.aj" revision="1.1" state="new">package com.foo.bar;

public privileged aspect TestAspect {

      pointcut TestToArray(Test mt) :
                target(mt) &amp;&amp;
                !within(TestAspect);


    Object[] around(Test mt, Object[] objs) :
            TestToArray(mt) &amp;&amp;
            args(objs) &amp;&amp;
            execution(Object[] Test.getObjs(Object[])) {

        objs = proceed(mt, objs);
        System.out.println("GO Aspects!");
        return objs;
    }
}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr116626/aop.xml" revision="1.1" state="new">&lt;aspectj&gt;
	&lt;aspects&gt;
		&lt;aspect name="com.foo.bar.TestAspect"/&gt;
	&lt;/aspects&gt;

	&lt;weaver options="-verbose -XlazyTjp -showWeaveInfo"&gt;
		&lt;include within="com.foo.*"/&gt;
	&lt;/weaver&gt;
&lt;/aspectj&gt;
</file>
</fixedFiles>
</bug>
<bug id="116949" transactionid="69302">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-instanceof O-instanceof T V Z-cast Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>java.lang.ClassCastException
at org.aspectj.weaver.bcel.BcelClassWeaver.checkForOverride
(BcelClassWeaver.java:607)
at org.aspectj.weaver.bcel.BcelClassWeaver.calculateAnyRequiredBridgeMethods
(BcelClassWeaver.java:676)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1537)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1485)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1266)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1088)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
(AjCompilerAdapter.java:178)
at 
org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspect
j_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile
(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
(AjBuildManager.java:809)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:254)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild
(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run
(AspectJBuildManager.java:191)

trouble in: 
public class ts.simul.client.AbstractClient$OptionSetter extends 
ts.util.CmdLineProgram$OptionSetterBase:
  final ts.simul.client.AbstractClient this$0
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  public void &lt;init&gt;(ts.simul.client.AbstractClient)    
org.aspectj.weaver.MethodDeclarationLineNumber: 59:1411
:
                    ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 60)
                    ALOAD_1
                    PUTFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
                    ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 59)
                    ALOAD_1
                    INVOKESPECIAL 
ts.util.CmdLineProgram$OptionSetterBase.&lt;init&gt; (Lts/util/CmdLineProgram;)V
    constructor-execution(void 
ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt;
(ts.simul.client.AbstractClient))
    |               RETURN
    constructor-execution(void 
ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt;
(ts.simul.client.AbstractClient))
  end public void &lt;init&gt;(ts.simul.client.AbstractClient)

  public boolean setOption_file(String) throws 
ts.util.IllegalProgramArgumentException    
org.aspectj.weaver.MethodDeclarationLineNumber: 62:1469
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String))
    |               ALOAD_1     // java.lang.String optParam   (line 65)
    | method-call(int java.lang.String.length())
    | |             INVOKEVIRTUAL java.lang.String.length ()I
    | method-call(int java.lang.String.length())
    |               IFLE L1
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 66)
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               ALOAD_1     // java.lang.String optParam
    |               PUTFIELD ts.simul.client.AbstractClient.fileName 
Ljava/lang/String;
    |               NEW java.io.File   (line 67)
    |               DUP
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               GETFIELD ts.simul.client.AbstractClient.fileName 
Ljava/lang/String;
    | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String))
    | |             INVOKESPECIAL java.io.File.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String))
    |               ASTORE_2
    |               ALOAD_2     // java.io.File file   (line 68)
    | method-call(boolean java.io.File.exists())
    | |             INVOKEVIRTUAL java.io.File.exists ()Z
    | method-call(boolean java.io.File.exists())
    |               IFNE L0
    |               NEW ts.util.IllegalProgramArgumentException   (line 69)
    |               DUP
    |               NEW java.lang.StringBuilder
    |               DUP
    |               LDC "Cannot find file: ["
    | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String))
    | |             INVOKESPECIAL java.lang.StringBuilder.&lt;init&gt; 
(Ljava/lang/String;)V
    | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String))
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               GETFIELD ts.simul.client.AbstractClient.fileName 
Ljava/lang/String;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuilder.append 
(Ljava/lang/String;)Ljava/lang/StringBuilder;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    |               LDC "]"
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    | |             INVOKEVIRTUAL java.lang.StringBuilder.append 
(Ljava/lang/String;)Ljava/lang/StringBuilder;
    | method-call(java.lang.StringBuilder java.lang.StringBuilder.append
(java.lang.String))
    | method-call(java.lang.String java.lang.StringBuilder.toString())
    | |             INVOKEVIRTUAL java.lang.StringBuilder.toString ()
Ljava/lang/String;
    | method-call(java.lang.String java.lang.StringBuilder.toString())
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    | |             INVOKESPECIAL 
ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    |               ATHROW
    |           L0: ICONST_1   (line 70)
    |               IRETURN
    |           L1: ICONST_0   (line 73)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String))
  end public boolean setOption_file(String) throws 
ts.util.IllegalProgramArgumentException

  public boolean setOption_class(String) throws 
ts.util.IllegalProgramArgumentException    
org.aspectj.weaver.MethodDeclarationLineNumber: 76:1971
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String))
    |               ALOAD_1     // java.lang.String optParam   (line 79)
    | method-call(int java.lang.String.length())
    | |             INVOKEVIRTUAL java.lang.String.length ()I
    | method-call(int java.lang.String.length())
    |               IFLE L1
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 80)
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               ALOAD_1     // java.lang.String optParam
    |               PUTFIELD ts.simul.client.AbstractClient.className 
Ljava/lang/String;
    | catch ts.simul.SimulationException -&gt; E0
    | |             ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 82)
    | |             GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    | |             ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this
    | |             GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    | |             GETFIELD ts.simul.client.AbstractClient.className 
Ljava/lang/String;
    | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass
(java.lang.String))
    | | |           INVOKESTATIC ts.simul.SceneFactory.getSceneClass 
(Ljava/lang/String;)Ljava/lang/Class;
    | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass
(java.lang.String))
    | |             PUTFIELD ts.simul.client.AbstractClient.sceneClass 
Ljava/lang/Class;
    | |             ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 83)
    | |             GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath())
    | | |           INVOKESTATIC ts.simul.Architecture.aspectOf ()
Lts/simul/Architecture;
    | | |           GETSTATIC 
ts.simul.client.AbstractClient$OptionSetter.ajc$tjp_0 
Lorg/aspectj/lang/JoinPoint$StaticPart;
    | | |           INVOKEVIRTUAL 
ts.simul.Architecture.ajc$before$ts_simul_Architecture$1$ae285a4d 
(Lorg/aspectj/lang/JoinPoint$StaticPart;)V
    | | |           INVOKEVIRTUAL 
ts.simul.client.AbstractClient.setBeanInfoSearchPath ()V
    | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath())
    | |             GOTO L0
    | catch ts.simul.SimulationException -&gt; E0
    |           E0: ASTORE_2   (line 85)
    |               NEW ts.util.IllegalProgramArgumentException   (line 86)
    |               DUP
    |               ALOAD_2     // ts.simul.SimulationException e
    | method-call(java.lang.String ts.simul.SimulationException.getMessage())
    | |             INVOKEVIRTUAL ts.simul.SimulationException.getMessage ()
Ljava/lang/String;
    | method-call(java.lang.String ts.simul.SimulationException.getMessage())
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    | |             INVOKESPECIAL 
ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V
    | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt;
(java.lang.String))
    |               ATHROW
    |           L0: ICONST_1   (line 88)
    |               IRETURN
    |           L1: ICONST_0   (line 91)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String))
  end public boolean setOption_class(String) throws 
ts.util.IllegalProgramArgumentException

  public boolean setOption_name(String)    
org.aspectj.weaver.MethodDeclarationLineNumber: 94:2593
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String))
    |               ALOAD_0     // ts.simul.client.AbstractClient$OptionSetter 
this   (line 96)
    |               GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 
Lts/simul/client/AbstractClient;
    |               ALOAD_1     // java.lang.String optParam
    |               PUTFIELD ts.simul.client.AbstractClient.sceneName 
Ljava/lang/String;
    |               ICONST_1   (line 97)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String))
  end public boolean setOption_name(String)

  public boolean setOption_actors(String)    
org.aspectj.weaver.MethodDeclarationLineNumber: 100:2739
:
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String))
    | catch java.lang.NumberFormatException -&gt; E0
    | |             ALOAD_1     // java.lang.String optParam   (line 103)
    | | method-call(int java.lang.Integer.parseInt(java.lang.String))
    | | |           INVOKESTATIC java.lang.Integer.parseInt (Ljava/lang/String;)
I
    | | method-call(int java.lang.Integer.parseInt(java.lang.String))
    | |             ISTORE_2
    | |             GOTO L0
    | catch java.lang.NumberFormatException -&gt; E0
    |           E0: ASTORE_2     // int n   (line 105)
    |               ICONST_0   (line 106)
    |               IRETURN
    |           L0: ICONST_1   (line 108)
    |               IRETURN
    method-execution(boolean 
ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String))
  end public boolean setOption_actors(String)

end public class ts.simul.client.AbstractClient$OptionSetter

when weaving type ts.simul.client.AbstractClient$OptionSetter
when weaving classes 
when weaving 
when incrementally building BuildConfig
[c:\Projects\eclipse\.metadata\.plugins\org.eclipse.ajdt.core\TS.generated.lst] 
#Files=79</bugreport>
<pre-fix-testcases failing="180" file="output/116949/pre-fix/testresults.xml" passing="1603" size="1783"/>
<post-fix-testcases failing="181" file="output/116949/post-fix/testresults.xml" passing="1602" size="1783"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java" revision="1.64" state="changed">607,612c607,616
&lt; 			BcelTypeMunger element = (BcelTypeMunger) iterator.next();
&lt; 			if (element.getMunger() instanceof NewMethodTypeMunger) {
&lt; 				if (debug) System.err.println("Possible ITD candidate "+element);
&lt; 				ResolvedMember aMethod = element.getSignature();
&lt; 				ResolvedMember isOverriding = isOverriding(typeToCheck,aMethod,mname,mrettype,mmods,inSamePackage,methodParamsArray);
&lt; 				if (isOverriding!=null) return isOverriding;
---
&gt; 			Object o = iterator.next();
&gt; 			// FIXME asc if its not a BcelTypeMunger then its an EclipseTypeMunger ... do I need to worry about that?
&gt; 			if (o instanceof BcelTypeMunger) {
&gt; 				BcelTypeMunger element = (BcelTypeMunger)o;
&gt; 				if (element.getMunger() instanceof NewMethodTypeMunger) {
&gt; 					if (debug) System.err.println("Possible ITD candidate "+element);
&gt; 					ResolvedMember aMethod = element.getSignature();
&gt; 					ResolvedMember isOverriding = isOverriding(typeToCheck,aMethod,mname,mrettype,mmods,inSamePackage,methodParamsArray);
&gt; 					if (isOverriding!=null) return isOverriding;
&gt; 				}
</file>
</fixedFiles>
</bug>
<bug id="117189" transactionid="69698">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="24"/>
<property name="lines-added" value="33"/>
<property name="lines-deleted" value="26"/>
<property name="lines-modified" value="12"/>
<property name="lines-churned" value="71"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-else K-false K-if K-import K-return K-try M T V Y Z-if</fullfingerprint>
<bugreport>This patch to the ClassLoaderWeavingAdaptor adds two optimizations when enabled 
is false for the adaptor: it immediately returns false for accept and it also 
avoids the overhead of constructing a weaver or world.

It also contains commented out code that was letting me improve performance by 
loading reflective proxies instead of creating BCEL objects for a resolution 
loader (which is currently broken since reflective proxies now require a 
ReflectionWorld...)</bugreport>
<pre-fix-testcases failing="182" file="output/117189/pre-fix/testresults.xml" passing="1603" size="1785"/>
<post-fix-testcases failing="181" file="output/117189/post-fix/testresults.xml" passing="1604" size="1785"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.21" state="changed">189,197c189,198
&lt; 		if (shouldWeave(name, bytes)) {
&lt;             //System.out.println("WeavingAdaptor.weaveClass " + name);
&lt; 			info("weaving '" + name + "'");
&lt; 			bytes = getWovenBytes(name, bytes);
&lt; 		} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
&lt;             // an @AspectJ aspect needs to be at least munged by the aspectOf munger
&lt;             info("weaving '" + name + "'");
&lt;             bytes = getAtAspectJAspectBytes(name, bytes);
&lt;         }
---
&gt; 		if (enabled) {
&gt; 			if (shouldWeave(name, bytes)) {
&gt; 				info("weaving '" + name + "'");
&gt; 				bytes = getWovenBytes(name, bytes);
&gt; 			} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
&gt; 	            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
&gt; 	            info("weaving '" + name + "'");
&gt; 	            bytes = getAtAspectJAspectBytes(name, bytes);
&gt; 	        }
&gt; 		}
208c209
&lt; 		boolean b = enabled &amp;&amp; !generatedClasses.containsKey(name) &amp;&amp; shouldWeaveName(name);
---
&gt; 		boolean b = !generatedClasses.containsKey(name) &amp;&amp; shouldWeaveName(name);
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.30" state="changed">14a15,26
&gt; import java.io.File;
&gt; import java.io.IOException;
&gt; import java.io.InputStream;
&gt; import java.net.URL;
&gt; import java.util.ArrayList;
&gt; import java.util.Enumeration;
&gt; import java.util.HashMap;
&gt; import java.util.Iterator;
&gt; import java.util.List;
&gt; import java.util.Properties;
&gt; import java.util.StringTokenizer;
&gt; 
19d30
&lt; import org.aspectj.bridge.MessageUtil;
26a38
&gt; import org.aspectj.weaver.bcel.BcelObjectType;
30d41
&lt; import org.aspectj.weaver.bcel.BcelObjectType;
38,49d48
&lt; import java.io.File;
&lt; import java.io.InputStream;
&lt; import java.io.IOException;
&lt; import java.net.URL;
&lt; import java.util.ArrayList;
&lt; import java.util.Enumeration;
&lt; import java.util.HashMap;
&lt; import java.util.Iterator;
&lt; import java.util.List;
&lt; import java.util.Properties;
&lt; import java.util.StringTokenizer;
&lt; 
101a101,105
&gt;         List definitions = parseDefinitions(loader);
&gt;         if (!enabled) {
&gt;         	return;
&gt;         }
&gt;         
109d112
&lt; 
119c122,123
&lt;         registerDefinitions(weaver, loader);
---
&gt;         registerDefinitions(weaver, loader, definitions);
&gt;         messageHandler = bcelWorld.getMessageHandler();
121,126c125,128
&lt;         // AV - see #113511 - not sure it is good to skip message handler
&lt;         if (enabled) {
&lt;             messageHandler = bcelWorld.getMessageHandler();
&lt;             // after adding aspects
&lt;             weaver.prepareForWeave();
&lt;         }
---
&gt;         //bcelWorld.setResolutionLoader(loader.getParent());//(ClassLoader)null);//
&gt;         
&gt;         // after adding aspects
&gt;         weaver.prepareForWeave();
135,137c137,140
&lt;     private void registerDefinitions(final BcelWeaver weaver, final ClassLoader loader) {
&lt;         try {
&lt;             MessageUtil.info(messageHandler, "register classloader " + getClassLoaderName(loader));
---
&gt;     private List parseDefinitions(final ClassLoader loader) {
&gt;         List definitions = new ArrayList();
&gt;     	try {
&gt;             info("register classloader " + getClassLoaderName(loader));
139d141
&lt;             List definitions = new ArrayList();
145c147
&lt;                     MessageUtil.info(messageHandler, "using (-Daj5.def) " + file);
---
&gt;                     info("using (-Daj5.def) " + file);
159c161
&lt;     			    MessageUtil.info(messageHandler, "using " + xml.getFile());
---
&gt;     			    info("using " + xml.getFile());
163,175c165
&lt; 
&lt;             // still go thru if definitions is empty since we will configure
&lt;             // the default message handler in there
&lt;             registerOptions(weaver, loader, definitions);
&lt; 
&lt;             // AV - see #113511
&lt;             if (!definitions.isEmpty()) {
&lt;                 registerAspectExclude(weaver, loader, definitions);
&lt;                 registerAspectInclude(weaver, loader, definitions);
&lt;                 registerAspects(weaver, loader, definitions);
&lt;                 registerIncludeExclude(weaver, loader, definitions);
&lt;                 registerDump(weaver, loader, definitions);
&lt;             } else {
---
&gt;     		if (definitions.isEmpty()) {
178c168,183
&lt;             }
---
&gt;     		}
&gt;         } catch (Exception e) {
&gt;             enabled = false;// will allow very fast skip in shouldWeave()
&gt;             warn("parse definitions failed",e);
&gt;         }
&gt; 		return definitions;
&gt;     }
&gt;         
&gt;     private void registerDefinitions(final BcelWeaver weaver, final ClassLoader loader, List definitions) {
&gt;     	try {
&gt;             registerOptions(weaver, loader, definitions);
&gt;             registerAspectExclude(weaver, loader, definitions);
&gt;             registerAspectInclude(weaver, loader, definitions);
&gt;             registerAspects(weaver, loader, definitions);
&gt;             registerIncludeExclude(weaver, loader, definitions);
&gt;             registerDump(weaver, loader, definitions);
589d593
&lt;     
</file>
</fixedFiles>
</bug>
<bug id="117209" transactionid="69549">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-true M O-! O-&amp;&amp; T V Z-if</fullfingerprint>
<bugreport>AspectJ compiler version: 1.5M5
AJDT plugin version: 1.3.0

This is the same error as reported by Bug#69706, even the bug is resolved I'm 
still experiencing problem by using the classes attached at the bottom.

// RUNTIME ERROR MESSAGE
========================
Exception in thread "main" java.lang.VerifyError: (class: 
DefaultInterfaceImplementationRecipe, method: &lt;clinit&gt; signature: ()V) Stack 
size too large
	at MyClass_ch16.main(MyClass_ch16.java:15)


// MyClass_ch16.java
====================
public class MyClass_ch16
{
        public void foo(int number, String name)
	{
		System.out.println("Inside foo (int, String) with args: " + 
number + ":" + name);
	}

	public static void main(String[] args)
	{
		// Create an instance of MyClass
		MyInterface_ch16 myObject = (MyInterface_ch16)new MyClass_ch16
();
		
		// Make the call to foo
		myObject.bar("Russ");
	}
}

//MyInterface_ch16.java
=======================
public interface MyInterface_ch16
{
	public void bar(String name);
}

// DefaultInterfaceImplementationRecipe.aj
==========================================
public aspect DefaultInterfaceImplementationRecipe
{
	declare parents : MyClass_ch16 implements MyInterface_ch16;
	
	// Declare the default implementation of the bar method
	public void MyInterface_ch16.bar(String name)
	{
		System.out.println("bar(String) called on " + this);
	}
}</bugreport>
<testsforfix ID="117209" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr117209"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="182" file="output/117209/pre-fix/testresults.xml" passing="1602" size="1784"/>
<post-fix-testcases failing="182" file="output/117209/post-fix/testresults.xml" passing="1602" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java" revision="1.35" state="changed">377a378,381
&gt;         if (!getProceedOnError() &amp;&amp; global.getProceedOnError()) {
&gt;         	setProceedOnError(true);
&gt;         }
&gt;        	setTargetAspectjRuntimeLevel(global.getTargetAspectjRuntimeLevel());
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.16" state="changed">292a293,304
&gt; 	// If you fiddle with the compiler options - you must manually reset the options at the end of the test
&gt; 	public void testPr117209() {
&gt; 		try {
&gt; 			initialiseProject("PR117209");
&gt; 			configureNonStandardCompileOptions("-proceedOnError");
&gt; 			build("PR117209");
&gt; 			checkCompileWeaveCount(6,6);
&gt; 		} finally {
&gt; 			MyBuildOptionsAdapter.reset();
&gt; 		}
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java" revision="1.9" state="changed">67a68,71
&gt; 	
&gt; 	public static void configureNonStandardCompileOptions(String options) {
&gt; 		MyBuildOptionsAdapter.setNonStandardOptions(options);
&gt; 	}
119a124
&gt; 			// MyBuildOptionsAdapter.reset(); needs manually resetting in a test
622a628,637
&gt; 		public static void setNonStandardOptions(String options) {
&gt; 			_instance.nonstandardoptions = options;
&gt; 		}
&gt; 
&gt; 		private String nonstandardoptions=null;
&gt; 		
&gt; 		public static void reset() {
&gt; 			_instance.nonstandardoptions=null;
&gt; 		}
&gt; 		
669c684
&lt; 			return null;
---
&gt; 			return nonstandardoptions;
</file>
<file name="org.aspectj/modules/tests/multiIncremental/pr117209/base/src/DefaultInterfaceImplementationRecipe.java" revision="1.1" state="new">public aspect DefaultInterfaceImplementationRecipe
{
	declare parents : MyClass_ch16 implements MyInterface_ch16;
	
	// Declare the default implementation of the bar method
	public void MyInterface_ch16.bar(String name)
	{
		System.out.println("bar(String) called on " + this);
	}
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/pr117209/base/src/MyInterface_ch16.java" revision="1.1" state="new">public interface MyInterface_ch16
{
	public void bar(String name);
}

</file>
<file name="org.aspectj/modules/tests/multiIncremental/pr117209/base/src/P.java" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/multiIncremental/pr117209/base/src/Aspect.java" revision="1.1" state="new">public class Aspect {
  public static void main(String []argv) {
    new Aspect().m();
  }

  public void m() {
  }
}

aspect Y {

  public int Aspect.x = 5;
  public void Aspect.foo() {
  }
  before():execution(* m()) {
  }

  before(): staticinitialization(*) {

  }
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/pr117209/base/src/Broken.java" revision="1.1" state="new">public class Broken {

</file>
<file name="org.aspectj/modules/tests/multiIncremental/pr117209/base/src/MyClass_ch16.java" revision="1.1" state="new">public class MyClass_ch16
{
        public void foo(int number, String name)
	{
		System.out.println("Inside foo (int, String) with args: " + 
number + ":" + name);
	}

	public static void main(String[] args)
	{
		// Create an instance of MyClass
		MyInterface_ch16 myObject = (MyInterface_ch16)new MyClass_ch16
();
		
		// Make the call to foo
		myObject.bar("Russ");
	}
}
</file>
</fixedFiles>
</bug>
<bug id="117296" transactionid="69729">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P1"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-new M O-() O-cast T V Z-cast</fullfingerprint>
<bugreport>Hi,

This code is a form of "Curiously Recurring Template Pattern"

public class PropertySupport&lt;T extends PropertySupport&lt;T&gt;&gt; {

}
My AJDT project does not accept this though my JDK 5.0 ECLIPSE project does.

java.lang.StackOverflowError
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:197)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:281)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:281)

Thanks,
Mohan</bugreport>
<testsforfix ID="117296" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java">
      <test NAME="testSelfBoundGenerics_pr117296"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="self bounding generic types"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="181" file="output/117296/pre-fix/testresults.xml" passing="1604" size="1785"/>
<post-fix-testcases failing="180" file="output/117296/post-fix/testresults.xml" passing="1605" size="1785"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java" revision="1.62" state="changed">280,281c280
&lt; 				String name = CharOperation.charToString(eclipseV.sourceName); 
&lt; 				tVars[i] = new TypeVariable(name,fromBinding(eclipseV.superclass()),fromBindings(eclipseV.superInterfaces()));
---
&gt; 				tVars[i] = ((TypeVariableReference)fromTypeVariableBinding(eclipseV)).getTypeVariable();				
341a341,342
&gt; 		TypeVariable tv = new TypeVariable(name);
&gt; 		ret.setTypeVariable(tv);
349d349
&lt; 		TypeVariable tv = new TypeVariable(name,superclassType,superinterfaces);
360d359
&lt; 		ret.setTypeVariable(tv);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.222" state="changed">55,56c55,56
&lt; 
&lt;     &lt;ajc-test dir="bugs150" pr="117296" title="self bounding generic types"&gt;
---
&gt;     
&gt;     &lt;ajc-test dir="bugs150/pr117296" pr="117296" title="self bounding generic types"&gt;
57a58
&gt;      &lt;run class="PropertySupport"/&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java" revision="1.71" state="changed">223a224,228
&gt; 
&gt;     public void testSelfBoundGenerics_pr117296() { 
&gt; 	    runTest("self bounding generic types");
&gt;     }
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.142" state="changed">80d79
&lt;  // public void testSelfBoundGenerics_pr117296() { runTest("self bounding generic types");}
</file>
</fixedFiles>
</bug>
<bug id="117681" transactionid="69279">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if M O-! O-++ T V Z-if</fullfingerprint>
<bugreport>Using Sun JDK1.5.0_04

Audit.java
public interface Audit {
   public String getLastUpdatedBy();
   public void   setLastUpdatedBy(String un);
}

AuditImpl.java
public class AuditImpl implements Audit {
   private String lastUpdatedBy;
   public String getLastUpdatedBy() {
       return lastUpdatedBy;
   }
   public void setLastUpdatedBy(String un) {
       lastUpdatedBy = un;
   }
}

TestAspect.java
import org.aspectj.lang.annotation.*;

Test.java
@Aspect
public class TestAspect {
      @DeclareParents("Test")
      public static Audit introduced = new AuditImpl();
}
public class Test {
    public static void main(String[] args) {
        Test t = new Test();
        Audit a = (Audit)t;
	    a.setLastUpdatedBy("username");
		System.out.println("Username ="+a.getLastUpdatedBy());
    }
}

files.lst
Audit.java
AuditImpl.java
TestAspect.java
Test.java

Compiled using the following command
d:\aspectj1.5\bin\ajc -classpath "d:\aspectj1.5\lib\aspectjrt.jar" -argfi
le files.lst -1.5

d:\aspectj1.5\bin\aj5 Test
Exception in thread "main" java.lang.VerifyError: (class: Test, method: setLastUpdatedBy signature: (Ljava/lang/String;)V) Incompatible argument to function

d:\aspectj1.5\bin\aj5 -noverify Test
Username=</bugreport>
<testsforfix ID="117681" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testAtDeclareParents_pr117681"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="at declare parents"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="182" file="output/117681/pre-fix/testresults.xml" passing="1603" size="1785"/>
<post-fix-testcases failing="181" file="output/117681/post-fix/testresults.xml" passing="1604" size="1785"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.68" state="changed">1109a1110,1113
&gt;     		if (!introduced.isStatic()) { // skip 'this'
&gt;     		  //body.append(InstructionFactory.createThis());
&gt;     		  pos++;
&gt;     		}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.225" state="changed">55a56,60
&gt;     &lt;ajc-test dir="bugs150/pr117681" pr="117681" title="at declare parents"&gt;
&gt;      &lt;compile files="Test.java,TestAspect.java,Audit.java,AuditImpl.java" options="-1.5"/&gt;
&gt;      &lt;run class="Test"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs150/pr117681/Test.java" revision="1.1" state="new">public class Test {
    public static void main(String[] args) {
        Audit a = (Audit)new Test();
        a.setLastUpdatedBy("username");
        System.out.println("Username ="+a.getLastUpdatedBy());
    }
}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.145" state="changed">51a52
&gt;   public void testAtDeclareParents_pr117681() { runTest("at declare parents");}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr117681/MoodIndicator.java" revision="1.1" state="new">import org.aspectj.lang.annotation.*;

class Mood {
  public final static Mood HAPPY=new Mood();
}
   // this interface can be outside of the aspect
    interface Moody {
     Mood getMood(int i);
   };

   // this implementation can be outside of the aspect
    class MoodyImpl implements Moody {
      private Mood mood = Mood.HAPPY;

      public Mood getMood(int i) {
        return mood;
      }
   }
@Aspect
public class MoodIndicator {


   // here is the actual ITD syntax when using @AspectJ
   // public static is mandatory
   // the field type must be the introduced interface. It can't be a class.
   @DeclareParents("C")
   public static Moody introduced = new MoodyImpl();

//   @Before("execution(* *.*(..)) &amp;&amp; this(m)")
//   public void feelingMoody(Moody m) {
//      System.out.println("I'm feeling " + m.getMood());
//   }

  public static void main(String []argv) {
    ((Moody)new C()).getMood(7);
  }
}


class C {
  
}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr117681/Audit.java" revision="1.1" state="new">public interface Audit {
   public String getLastUpdatedBy();
   public void   setLastUpdatedBy(String un);
}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr117681/TestAspect.java" revision="1.1" state="new">import org.aspectj.lang.annotation.*;

@Aspect
public class TestAspect {
  @DeclareParents("Test")
  public static Audit introduced = new AuditImpl();
}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr117681/AuditImpl.java" revision="1.1" state="new">public class AuditImpl implements Audit {
   private String lastUpdatedBy;
   public String getLastUpdatedBy() {
       return lastUpdatedBy;
   }
   public void setLastUpdatedBy(String un) {
       lastUpdatedBy = un;
   }
}

</file>
</fixedFiles>
</bug>
<bug id="117882" transactionid="68839">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="138"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="138"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-else K-false K-if K-import K-instanceof K-new K-null K-package K-return K-super K-this K-true M O-== O-| O-|| O-! O-!= O-() O-&amp; O-&amp;&amp; O-+ O-instanceof T V Y Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Test program included and stack trace shown below:

java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:742)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:556)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:483)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doPendingWeaves(AjLookupEnvironment.java:350)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:177)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:809)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</bugreport>
<pre-fix-testcases failing="183" file="output/117882/pre-fix/testresults.xml" passing="1599" size="1782"/>
<post-fix-testcases failing="180" file="output/117882/post-fix/testresults.xml" passing="1604" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.54" state="changed">56a57
&gt; import org.aspectj.weaver.AnnotationX;
58a60
&gt; import org.aspectj.weaver.FakeAnnotation;
728a731,733
&gt; 		
&gt; 		
&gt; 		
741a747,794
&gt; 		if (sourceType instanceof BinaryTypeBinding) {
&gt; 			// In this case we can't access the source type binding to add a new annotation, so let's put something
&gt; 			// on the weaver type temporarily
&gt; 			ResolvedType theTargetType = factory.fromEclipse(sourceType);
&gt; 			TypeBinding theAnnotationType = toAdd[0].resolvedType;
&gt; 			String name = new String(theAnnotationType.qualifiedPackageName())+"."+new String(theAnnotationType.sourceName());
&gt; 			String sig = new String(theAnnotationType.signature());
&gt; 			if (theTargetType.hasAnnotation(UnresolvedType.forSignature(sig))) {
&gt; 				CompilationAndWeavingContext.leavingPhase(tok);
&gt; 				return false;
&gt; 			}
&gt; 			
&gt; 			// FIXME asc tidy up this code that duplicates whats below!
&gt; 			// Simple checks on the bits
&gt; 			boolean giveupnow = false;
&gt; 			if (((abits &amp; TagBits.AnnotationTargetMASK)!=0)) {
&gt; 				if ( isAnnotationTargettingSomethingOtherThanAnnotationOrNormal(abits)) {
&gt; 					// error will have been already reported
&gt; 					giveupnow = true;
&gt; 				} else if (  (sourceType.isAnnotationType() &amp;&amp; (abits &amp; TagBits.AnnotationForAnnotationType)==0) ||
&gt; 				      (!sourceType.isAnnotationType() &amp;&amp; (abits &amp; TagBits.AnnotationForType)==0) ) {
&gt; 				
&gt; 				  if (reportProblems) {
&gt; 				    if (decA.isExactPattern()) {
&gt; 				      factory.showMessage(IMessage.ERROR,
&gt; 						WeaverMessages.format(WeaverMessages.INCORRECT_TARGET_FOR_DECLARE_ANNOTATION,rtx.getName(),toAdd[0].type,stringifyTargets(abits)),
&gt; 						decA.getSourceLocation(), null);
&gt; 				    } 
&gt; 				    // dont put out the lint - the weaving process will do that
&gt; //				    else {
&gt; //					  if (factory.getWorld().getLint().invalidTargetForAnnotation.isEnabled()) {
&gt; //						  factory.getWorld().getLint().invalidTargetForAnnotation.signal(new String[]{rtx.getName(),toAdd[0].type.toString(),stringifyTargets(abits)},decA.getSourceLocation(),null);
&gt; //					  }
&gt; //				    }
&gt; 				  }
&gt; 				  giveupnow=true;
&gt; 			    }
&gt; 			}
&gt; 			if (giveupnow) { 
&gt; 				CompilationAndWeavingContext.leavingPhase(tok);
&gt; 				return false;
&gt; 			}
&gt; 			
&gt; 			theTargetType.addAnnotation(new AnnotationX(new FakeAnnotation(name,sig,(abits &amp; TagBits.AnnotationRuntimeRetention)!=0),factory.getWorld()));
&gt; 			CompilationAndWeavingContext.leavingPhase(tok);
&gt; 			return true;
&gt; 		}
&gt; 		
799a853,856
&gt; 
&gt; 	private boolean isAnnotationTargettingSomethingOtherThanAnnotationOrNormal(long abits) {
&gt; 		return (abits &amp; (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType))==0;
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/FakeAnnotation.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * initial implementation              Andy Clement
 *******************************************************************************/
package org.aspectj.weaver;

import java.io.DataOutputStream;
import java.io.IOException;
import java.util.List;

import org.aspectj.apache.bcel.classfile.annotation.Annotation;
import org.aspectj.apache.bcel.classfile.annotation.ElementNameValuePair;

/**
 * For implementing declare @type interacting with declare @parents during compilation - we need to be 
 * able to add an annotation to 'binary type binding' (this is how types are seen during incremental compilation).
 * Unlike a SourceTypeBinding - a BinaryTypeBinding does not allow easy interaction with its annotations - 
 * so what we do is take the eclipse annotation, suck out the name/signature and visibility and put that information
 * in a 'FakeAnnotation'.  The FakeAnnotation is attached to the BCEL delegate for the binary type binding -
 * this will allow type resolution to succeed correctly.  The FakeAnnotation never makes it to disk, since the weaver
 * does the job properly, attaching a real annotation.
 */
public class FakeAnnotation extends Annotation {

	private String name;
	private String sig;
	private boolean isRuntimeVisible;
	
	public FakeAnnotation(String name,String sig,boolean isRuntimeVisible) {
		super(0,null,true);
		this.name = name;
		this.sig = sig;
		this.isRuntimeVisible = isRuntimeVisible;
	}

	public String getTypeName() {
		return name;
	}

	public String getTypeSignature() {
		return sig;
	}

	public void addElementNameValuePair(ElementNameValuePair evp) {
		// doesnt need to know about name/value pairs
	}

	protected void dump(DataOutputStream dos) throws IOException {
		// should be serialized
	}

	public int getTypeIndex() {
		return 0;
	}

	public List getValues() {
		return null;
	}

	public boolean isRuntimeVisible() {
		return isRuntimeVisible;
	}

	protected void isRuntimeVisible(boolean b) {
	}

	public String toShortString() {
		return "@"+this.name;
	}

	public String toString() {
		return this.name;
	}
}
</file>
</fixedFiles>
</bug>
<bug id="118141" transactionid="74675">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="59"/>
<property name="lines-added" value="99"/>
<property name="lines-deleted" value="22"/>
<property name="lines-modified" value="295"/>
<property name="lines-churned" value="416"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-class K-do K-false K-for K-if K-import K-new K-return K-super K-true K-while M O-&lt; O-&lt;= O-== O-&gt; O-|| O--- O-! O-!= O-&amp;&amp; O-++ O-cast T V Y Z-cast Z-for Z-if Z-vardecl Z-while</fullfingerprint>
<bugreport>Open a .java/.aj file with the AspectJ editor, and type the following:

    public enum CallbackMode {
        
    }

The "enum" keyword does not highlight as expected.</bugreport>
<pre-fix-testcases failing="182" file="output/118141/pre-fix/testresults.xml" passing="1602" size="1784"/>
<post-fix-testcases failing="182" file="output/118141/post-fix/testresults.xml" passing="1602" size="1784"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJCodeScanner.java" revision="1.8" state="changed">2,3c2,3
&lt;  * Copyright (c) 2000, 2003 IBM Corporation and others.
&lt;  * All rights reserved. This program and the accompanying materials 
---
&gt;  * Copyright (c) 2000, 2005 IBM Corporation and others.
&gt;  * All rights reserved. This program and the accompanying materials
15a16
&gt; import java.util.Iterator;
17a19
&gt; import org.eclipse.jdt.core.JavaCore;
18a21,22
&gt; import org.eclipse.jdt.internal.ui.text.CombinedWordRule;
&gt; import org.eclipse.jdt.internal.ui.text.ISourceVersionDependent;
23a28
&gt; import org.eclipse.jface.text.Assert;
26a32
&gt; import org.eclipse.jface.text.rules.IWhitespaceDetector;
35,38c41,42
&lt;  * An AspectJ code scanner - identical to the Java one except that we
&lt;  * add in the AspectJ keywords.
&lt;  * Better would be a proper extension mechanism in JDT that lets us do this
&lt;  * cleanly!
---
&gt;  * An AspectJ code scanner - copied from JavaCodeScanner so we can
&gt;  * add in the AspectJ keywords.  Changes marked // AspectJ Change
42c46,51
&lt; 	private static class VersionedWordRule extends WordRule {
---
&gt; 	/**
&gt; 	 * Rule to detect java operators.
&gt; 	 *
&gt; 	 * @since 3.0
&gt; 	 */
&gt; 	protected class OperatorRule implements IRule {
44,45c53,84
&lt; 		private final String fVersion;
&lt; 		private final boolean fEnable;
---
&gt; 		/** Java operators */
&gt; 		private final char[] JAVA_OPERATORS= { ';', '(', ')', '{', '}', '.', '=', '/', '\\', '+', '-', '*', '[', ']', '&lt;', '&gt;', ':', '?', '!', ',', '|', '&amp;', '^', '%', '~'};
&gt; 		/** Token to return for this rule */
&gt; 		private final IToken fToken;
&gt; 
&gt; 		/**
&gt; 		 * Creates a new operator rule.
&gt; 		 *
&gt; 		 * @param token Token to use for this rule
&gt; 		 */
&gt; 		public OperatorRule(IToken token) {
&gt; 			fToken= token;
&gt; 		}
&gt; 
&gt; 		/**
&gt; 		 * Is this character an operator character?
&gt; 		 *
&gt; 		 * @param character Character to determine whether it is an operator character
&gt; 		 * @return &lt;code&gt;true&lt;/code&gt; iff the character is an operator, &lt;code&gt;false&lt;/code&gt; otherwise.
&gt; 		 */
&gt; 		public boolean isOperator(char character) {
&gt; 			for (int index= 0; index &lt; JAVA_OPERATORS.length; index++) {
&gt; 				if (JAVA_OPERATORS[index] == character)
&gt; 					return true;
&gt; 			}
&gt; 			return false;
&gt; 		}
&gt; 
&gt; 		/*
&gt; 		 * @see org.eclipse.jface.text.rules.IRule#evaluate(org.eclipse.jface.text.rules.ICharacterScanner)
&gt; 		 */
&gt; 		public IToken evaluate(ICharacterScanner scanner) {
47c86,100
&lt; 		private String fCurrentVersion;
---
&gt; 			int character= scanner.read();
&gt; 			if (isOperator((char) character)) {
&gt; 				do {
&gt; 					character= scanner.read();
&gt; 				} while (isOperator((char) character));
&gt; 				scanner.unread();
&gt; 				return fToken;
&gt; 			} else {
&gt; 				scanner.unread();
&gt; 				return Token.UNDEFINED;
&gt; 			}
&gt; 		}
&gt; 	}
&gt; 
&gt; 	private static class VersionedWordMatcher extends CombinedWordRule.WordMatcher implements ISourceVersionDependent {
49,54c102,104
&lt; 		public VersionedWordRule(
&lt; 			IWordDetector detector,
&lt; 			String version,
&lt; 			boolean enable,
&lt; 			String currentVersion) {
&lt; 			super(detector);
---
&gt; 		private final IToken fDefaultToken;
&gt; 		private final String fVersion;
&gt; 		private boolean fIsVersionMatch;
56,58c106,109
&lt; 			fVersion = version;
&lt; 			fEnable = enable;
&lt; 			fCurrentVersion = currentVersion;
---
&gt; 		public VersionedWordMatcher(IToken defaultToken, String version, String currentVersion) {
&gt; 			fDefaultToken= defaultToken;
&gt; 			fVersion= version;
&gt; 			setSourceVersion(currentVersion);
61,62c112,116
&lt; 		public void setCurrentVersion(String version) {
&lt; 			fCurrentVersion = version;
---
&gt; 		/*
&gt; 		 * @see org.eclipse.jdt.internal.ui.text.ISourceVersionDependent#setSourceVersion(java.lang.String)
&gt; 		 */
&gt; 		public void setSourceVersion(String version) {
&gt; 			fIsVersionMatch= fVersion.compareTo(version) &lt;= 0;
66c120,231
&lt; 		 * @see IRule#evaluate
---
&gt; 		 * @see org.eclipse.jdt.internal.ui.text.CombinedWordRule.WordMatcher#evaluate(org.eclipse.jface.text.rules.ICharacterScanner, org.eclipse.jdt.internal.ui.text.CombinedWordRule.CharacterBuffer)
&gt; 		 */
&gt; 		public IToken evaluate(ICharacterScanner scanner, CombinedWordRule.CharacterBuffer word) {
&gt; 			IToken token= super.evaluate(scanner, word);
&gt; 
&gt; 			if (fIsVersionMatch || token.isUndefined())
&gt; 				return token;
&gt; 
&gt; 			return fDefaultToken;
&gt; 		}
&gt; 	}
&gt; 
&gt; 	/**
&gt; 	 * An annotation rule matches the '@' symbol, any following whitespace and
&gt; 	 * a following java identifier or the &lt;code&gt;interface&lt;/code&gt; keyword.
&gt; 	 *
&gt; 	 * It does not match if there is a comment between the '@' symbol and
&gt; 	 * the identifier. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=82452
&gt; 	 *
&gt; 	 * @since 3.1
&gt; 	 */
&gt; 	private static class AnnotationRule implements IRule, ISourceVersionDependent {
&gt; 		/**
&gt; 		 * A resettable scanner supports marking a position in a scanner and
&gt; 		 * unreading back to the marked position.
&gt; 		 */
&gt; 		private static final class ResettableScanner implements ICharacterScanner {
&gt; 			private final ICharacterScanner fDelegate;
&gt; 			private int fReadCount;
&gt; 
&gt; 			/**
&gt; 			 * Creates a new resettable scanner that will forward calls
&gt; 			 * to &lt;code&gt;scanner&lt;/code&gt;, but store a marked position.
&gt; 			 *
&gt; 			 * @param scanner the delegate scanner
&gt; 			 */
&gt; 			public ResettableScanner(final ICharacterScanner scanner) {
&gt; 				Assert.isNotNull(scanner);
&gt; 				fDelegate= scanner;
&gt; 				mark();
&gt; 			}
&gt; 
&gt; 			/*
&gt; 			 * @see org.eclipse.jface.text.rules.ICharacterScanner#getColumn()
&gt; 			 */
&gt; 			public int getColumn() {
&gt; 				return fDelegate.getColumn();
&gt; 			}
&gt; 
&gt; 			/*
&gt; 			 * @see org.eclipse.jface.text.rules.ICharacterScanner#getLegalLineDelimiters()
&gt; 			 */
&gt; 			public char[][] getLegalLineDelimiters() {
&gt; 				return fDelegate.getLegalLineDelimiters();
&gt; 			}
&gt; 
&gt; 			/*
&gt; 			 * @see org.eclipse.jface.text.rules.ICharacterScanner#read()
&gt; 			 */
&gt; 			public int read() {
&gt; 				int ch= fDelegate.read();
&gt; 				if (ch != ICharacterScanner.EOF)
&gt; 					fReadCount++;
&gt; 				return ch;
&gt; 			}
&gt; 
&gt; 			/*
&gt; 			 * @see org.eclipse.jface.text.rules.ICharacterScanner#unread()
&gt; 			 */
&gt; 			public void unread() {
&gt; 				if (fReadCount &gt; 0)
&gt; 					fReadCount--;
&gt; 				fDelegate.unread();
&gt; 			}
&gt; 
&gt; 			/**
&gt; 			 * Marks an offset in the scanned content.
&gt; 			 */
&gt; 			public void mark() {
&gt; 				fReadCount= 0;
&gt; 			}
&gt; 
&gt; 			/**
&gt; 			 * Resets the scanner to the marked position.
&gt; 			 */
&gt; 			public void reset() {
&gt; 				while (fReadCount &gt; 0)
&gt; 					unread();
&gt; 
&gt; 				while (fReadCount &lt; 0)
&gt; 					read();
&gt; 			}
&gt; 		}
&gt; 
&gt; 		private final IWhitespaceDetector fWhitespaceDetector= new JavaWhitespaceDetector();
&gt; 		private final IWordDetector fWordDetector= new JavaWordDetector();
&gt; 		private final IToken fInterfaceToken;
&gt; 		private final IToken fAnnotationToken;
&gt; 		private final String fVersion;
&gt; 		private boolean fIsVersionMatch;
&gt; 
&gt; 		/**
&gt; 		 * Creates a new rule.
&gt; 		 *
&gt; 		 * @param interfaceToken the token to return if
&gt; 		 *        &lt;code&gt;'@\s*interface'&lt;/code&gt; is matched
&gt; 		 * @param annotationToken the token to return if &lt;code&gt;'@\s*\w+'&lt;/code&gt;
&gt; 		 *        is matched, but not &lt;code&gt;'@\s*interface'&lt;/code&gt;
&gt; 		 * @param version the lowest &lt;code&gt;JavaCore.COMPILER_SOURCE&lt;/code&gt;
&gt; 		 *        version that this rule is enabled
&gt; 		 * @param currentVersion the current
&gt; 		 *        &lt;code&gt;JavaCore.COMPILER_SOURCE&lt;/code&gt; version
67a233,238
&gt; 		public AnnotationRule(IToken interfaceToken, Token annotationToken, String version, String currentVersion) {
&gt; 			fInterfaceToken= interfaceToken;
&gt; 			fAnnotationToken= annotationToken;
&gt; 			fVersion= version;
&gt; 			setSourceVersion(currentVersion);
&gt; 		}
68a240,242
&gt; 		/*
&gt; 		 * @see org.eclipse.jface.text.rules.IRule#evaluate(org.eclipse.jface.text.rules.ICharacterScanner)
&gt; 		 */
70c244,245
&lt; 			IToken token = super.evaluate(scanner);
---
&gt; 			if (!fIsVersionMatch)
&gt; 				return Token.UNDEFINED;
72,74c247,254
&lt; 			if (fEnable) {
&lt; 				if (fCurrentVersion.equals(fVersion))
&lt; 					return token;
---
&gt; 			ResettableScanner resettable= new ResettableScanner(scanner);
&gt; 			if (resettable.read() == '@')
&gt; 				if (skipWhitespace(resettable))
&gt; 					return readAnnotation(resettable);
&gt; 
&gt; 			resettable.reset();
&gt; 			return Token.UNDEFINED;
&gt; 		}
75a256,260
&gt; 		private IToken readAnnotation(ResettableScanner scanner) {
&gt; 			StringBuffer buffer= new StringBuffer();
&gt; 
&gt; 			if (!readIdentifier(scanner, buffer)) {
&gt; 				scanner.reset();
76a262
&gt; 			}
78,80c264,265
&lt; 			} else {
&lt; 				if (fCurrentVersion.equals(fVersion))
&lt; 					return Token.UNDEFINED;
---
&gt; 			if ("interface".equals(buffer.toString())) //$NON-NLS-1$
&gt; 				return fInterfaceToken;
82c267,298
&lt; 				return token;
---
&gt; 			while (readSegment(new ResettableScanner(scanner))) {
&gt; 				// do nothing
&gt; 			}
&gt; 			return fAnnotationToken;
&gt; 		}
&gt; 
&gt; 		private boolean readSegment(ResettableScanner scanner) {
&gt; 			scanner.mark();
&gt; 			if (skipWhitespace(scanner) &amp;&amp; skipDot(scanner) &amp;&amp; skipWhitespace(scanner) &amp;&amp; readIdentifier(scanner, null))
&gt; 				return true;
&gt; 
&gt; 			scanner.reset();
&gt; 			return false;
&gt; 		}
&gt; 
&gt; 		private boolean skipDot(ICharacterScanner scanner) {
&gt; 			int ch= scanner.read();
&gt; 			if (ch == '.')
&gt; 				return true;
&gt; 
&gt; 			scanner.unread();
&gt; 			return false;
&gt; 		}
&gt; 
&gt; 		private boolean readIdentifier(ICharacterScanner scanner, StringBuffer buffer) {
&gt; 			int ch= scanner.read();
&gt; 			boolean read= false;
&gt; 			while (fWordDetector.isWordPart((char) ch)) {
&gt; 				if (buffer != null)
&gt; 					buffer.append((char) ch);
&gt; 				ch= scanner.read();
&gt; 				read= true;
83a300,313
&gt; 
&gt; 			if (ch != ICharacterScanner.EOF)
&gt; 				scanner.unread();
&gt; 
&gt; 			return read;
&gt; 		}
&gt; 
&gt; 		private boolean skipWhitespace(ICharacterScanner scanner) {
&gt; 			while (fWhitespaceDetector.isWhitespace((char) scanner.read())) {
&gt; 				// do nothing
&gt; 			}
&gt; 
&gt; 			scanner.unread();
&gt; 			return true;
84a315,322
&gt; 
&gt; 		/*
&gt; 		 * @see org.eclipse.jdt.internal.ui.text.ISourceVersionDependent#setSourceVersion(java.lang.String)
&gt; 		 */
&gt; 		public void setSourceVersion(String version) {
&gt; 			fIsVersionMatch= fVersion.compareTo(version) &lt;= 0; //$NON-NLS-1$
&gt; 		}
&gt; 
87,88c325
&lt; 	private static final String SOURCE_VERSION =
&lt; 		"org.eclipse.jdt.core.compiler.source"; //$NON-NLS-1$
---
&gt; 	private static final String SOURCE_VERSION= JavaCore.COMPILER_SOURCE;
90c327,328
&lt; 	private static String[] fgKeywords = { "abstract", //$NON-NLS-1$
---
&gt; 	static String[] fgKeywords= {
&gt; 		"abstract", //$NON-NLS-1$
92,96c330
&lt; 		"case", //$NON-NLS-1$
&lt; 			"catch", //$NON-NLS-1$
&lt; 			"class", //$NON-NLS-1$
&lt; 			"const", //$NON-NLS-1$
&lt; 			"continue", //$NON-NLS-1$
---
&gt; 		"case", "catch", "class", "const", "continue", //$NON-NLS-5$ //$NON-NLS-4$ //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$
101,105c335
&lt; 		"if", //$NON-NLS-1$
&lt; 			"implements", //$NON-NLS-1$
&lt; 			"import", //$NON-NLS-1$
&lt; 			"instanceof", //$NON-NLS-1$
&lt; 			"interface", //$NON-NLS-1$
---
&gt; 		"if", "implements", "import", "instanceof", "interface", //$NON-NLS-5$ //$NON-NLS-4$ //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$
107,120c337,339
&lt; 		"package", //$NON-NLS-1$
&lt; 			"private", //$NON-NLS-1$
&lt; 			"protected", //$NON-NLS-1$
&lt; 			"public", //$NON-NLS-1$
&lt; 		"return", //$NON-NLS-1$
&lt; 		"static", //$NON-NLS-1$
&lt; 			"super", //$NON-NLS-1$
&lt; 			"switch", //$NON-NLS-1$
&lt; 			"synchronized", //$NON-NLS-1$
&lt; 		"this", //$NON-NLS-1$
&lt; 			"throw", //$NON-NLS-1$
&lt; 			"throws", //$NON-NLS-1$
&lt; 			"transient", //$NON-NLS-1$
&lt; 			"try", //$NON-NLS-1$
---
&gt; 		"package", "private", "protected", "public", //$NON-NLS-4$ //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$
&gt; 		"static", "super", "switch", "synchronized", //$NON-NLS-4$ //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$
&gt; 		"this", "throw", "throws", "transient", "try", //$NON-NLS-5$ //$NON-NLS-4$ //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$
125c344,348
&lt; 	// AspectJ keywords
---
&gt; 	private static final String RETURN= "return"; //$NON-NLS-1$
&gt; 	private static String[] fgJava14Keywords= { "assert" }; //$NON-NLS-1$
&gt; 	private static String[] fgJava15Keywords= { "enum" }; //$NON-NLS-1$
&gt; 
&gt; 	// AspectJ change begin - AspectJ keywords
152a376,380
&gt;     // AspectJ Change End
&gt;     
&gt; 	private static String[] fgTypes= { "void", "boolean", "char", "byte", "short", "strictfp", "int", "long", "float", "double" }; //$NON-NLS-1$ //$NON-NLS-5$ //$NON-NLS-7$ //$NON-NLS-6$ //$NON-NLS-8$ //$NON-NLS-9$  //$NON-NLS-10$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-2$
&gt; 
&gt; 	private static String[] fgConstants= { "false", "null", "true" }; //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$
154d381
&lt; 	private static String[] fgNewKeywords = { "assert" }; //$NON-NLS-1$
156,175c383,390
&lt; 	private static String[] fgTypes =
&lt; 		{
&lt; 			"void", //$NON-NLS-1$
&lt; 			"boolean", //$NON-NLS-1$
&lt; 			"char", //$NON-NLS-1$
&lt; 			"byte", //$NON-NLS-1$
&lt; 			"short", //$NON-NLS-1$
&lt; 			"strictfp", //$NON-NLS-1$
&lt; 			"int", //$NON-NLS-1$
&lt; 			"long", //$NON-NLS-1$
&lt; 			"float", //$NON-NLS-1$
&lt; 			"double" }; //$NON-NLS-1$
&lt; 	
&lt; 	private static String[] fgConstants = { "false", "null", "true" }; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
&lt; 
&lt; 	private static String[] fgTokenProperties =
&lt; 		{
&lt; 			IJavaColorConstants.JAVA_KEYWORD,
&lt; 			IJavaColorConstants.JAVA_STRING,
&lt; 			IJavaColorConstants.JAVA_DEFAULT };
---
&gt; 	private static String[] fgTokenProperties= {
&gt; 		IJavaColorConstants.JAVA_KEYWORD,
&gt; 		IJavaColorConstants.JAVA_STRING,
&gt; 		IJavaColorConstants.JAVA_DEFAULT,
&gt; 		IJavaColorConstants.JAVA_KEYWORD_RETURN,
&gt; 		IJavaColorConstants.JAVA_OPERATOR,
&gt; 		IJavaColorConstants.JAVA_ANNOTATION,
&gt; 	};
177c392
&lt; 	private VersionedWordRule fVersionedWordRule;
---
&gt; 	private List fVersionDependentRules= new ArrayList(3);
180a396,398
&gt; 	 *
&gt; 	 * @param manager	the color manager
&gt; 	 * @param store		the preference store
184d401
&lt; 
200,201c417,422
&lt; 		//		System.err.println("AJCodeScanner.createRules() called");
&lt; 		List rules = new ArrayList();
---
&gt; 		List rules= new ArrayList();
&gt; 
&gt; 		// Add rule for character constants.
&gt; 		Token token= getToken(IJavaColorConstants.JAVA_STRING);
&gt; 		rules.add(new SingleLineRule("'", "'", token, '\\')); //$NON-NLS-2$ //$NON-NLS-1$
&gt; 
203,207d423
&lt; 		// Add rule for strings and character constants.
&lt; 		Token token = getToken(IJavaColorConstants.JAVA_STRING);
&lt; 		rules.add(new SingleLineRule("\"", "\"", token, '\\')); //$NON-NLS-1$ //$NON-NLS-2$
&lt; 		rules.add(new SingleLineRule("'", "'", token, '\\')); //$NON-NLS-1$ //$NON-NLS-2$
&lt; 	
210a427,433
&gt; 		String version= getPreferenceStore().getString(SOURCE_VERSION);
&gt; 
&gt; 		// Add JLS3 rule for /@\s*interface/
&gt; 		AnnotationRule atInterfaceRule= new AnnotationRule(getToken(IJavaColorConstants.JAVA_KEYWORD), getToken(IJavaColorConstants.JAVA_ANNOTATION), "1.5", version); //$NON-NLS-1$
&gt; 		rules.add(atInterfaceRule);
&gt; 		fVersionDependentRules.add(atInterfaceRule);
&gt; 
212,221c435,466
&lt; 		String version = getPreferenceStore().getString(SOURCE_VERSION);//JavaCore.getOptions().get(SOURCE_VERSION);
&lt; 		//if (version instanceof String) {
&lt; 		fVersionedWordRule =
&lt; 			new VersionedWordRule(new JavaWordDetector(), "1.4", true, version); //$NON-NLS-1$
&lt; 
&lt; 		token = getToken(IJavaColorConstants.JAVA_KEYWORD);
&lt; 		for (int i = 0; i &lt; fgNewKeywords.length; i++)
&lt; 			fVersionedWordRule.addWord(fgNewKeywords[i], token);
&lt; 		rules.add(fVersionedWordRule);
&lt; //		}
---
&gt; 		JavaWordDetector wordDetector= new JavaWordDetector();
&gt; 		token= getToken(IJavaColorConstants.JAVA_DEFAULT);
&gt; 		CombinedWordRule combinedWordRule= new CombinedWordRule(wordDetector, token);
&gt; 
&gt; 		token= getToken(IJavaColorConstants.JAVA_DEFAULT);
&gt; 		VersionedWordMatcher j14Matcher= new VersionedWordMatcher(token, "1.4", version); //$NON-NLS-1$
&gt; 
&gt; 		token= getToken(IJavaColorConstants.JAVA_KEYWORD);
&gt; 		for (int i=0; i&lt;fgJava14Keywords.length; i++)
&gt; 			j14Matcher.addWord(fgJava14Keywords[i], token);
&gt; 
&gt; 		combinedWordRule.addWordMatcher(j14Matcher);
&gt; 		fVersionDependentRules.add(j14Matcher);
&gt; 
&gt; 		token= getToken(IJavaColorConstants.JAVA_DEFAULT);
&gt; 		VersionedWordMatcher j15Matcher= new VersionedWordMatcher(token, "1.5", version); //$NON-NLS-1$
&gt; 		token= getToken(IJavaColorConstants.JAVA_KEYWORD);
&gt; 		for (int i=0; i&lt;fgJava15Keywords.length; i++)
&gt; 			j15Matcher.addWord(fgJava15Keywords[i], token);
&gt; 
&gt; 		combinedWordRule.addWordMatcher(j15Matcher);
&gt; 		fVersionDependentRules.add(j15Matcher);
&gt; 
&gt; 		// Add rule for operators and brackets
&gt; 		token= getToken(IJavaColorConstants.JAVA_OPERATOR);
&gt; 		rules.add(new OperatorRule(token));
&gt; 
&gt; 		// Add word rule for keyword 'return'.
&gt; 		CombinedWordRule.WordMatcher returnWordRule= new CombinedWordRule.WordMatcher();
&gt; 		token= getToken(IJavaColorConstants.JAVA_KEYWORD_RETURN);
&gt; 		returnWordRule.addWord(RETURN, token);  //$NON-NLS-1$
&gt; 		combinedWordRule.addWordMatcher(returnWordRule);
224,229c469,471
&lt; 		token = getToken(IJavaColorConstants.JAVA_DEFAULT);
&lt; 		WordRule wordRule = new WordRule(new JavaWordDetector(), token);
&lt; 		WordRule ajKeywordRule = new DotWordRule(new JavaWordDetector());
&lt; 		token = getToken(IJavaColorConstants.JAVA_KEYWORD);
&lt; 
&lt; 		for (int i = 0; i &lt; fgKeywords.length; i++)
---
&gt; 		CombinedWordRule.WordMatcher wordRule= new CombinedWordRule.WordMatcher();
&gt; 		token= getToken(IJavaColorConstants.JAVA_KEYWORD);
&gt; 		for (int i=0; i&lt;fgKeywords.length; i++)
231,232c473
&lt; 
&lt; 		for (int i = 0; i &lt; fgTypes.length; i++)
---
&gt; 		for (int i=0; i&lt;fgTypes.length; i++)
234,235c475
&lt; 
&lt; 		for (int i = 0; i &lt; fgConstants.length; i++)
---
&gt; 		for (int i=0; i&lt;fgConstants.length; i++)
237a478,479
&gt; 		// AspectJ Change begin - add AJ keywords
&gt; 		WordRule ajKeywordRule = new DotWordRule(new JavaWordDetector());
240c482
&lt; 
---
&gt; 		
243c485,488
&lt; 		rules.add(wordRule);
---
&gt; 		// AspectJ Change enf
&gt; 		
&gt; 		combinedWordRule.addWordMatcher(wordRule);
&gt; 		rules.add(combinedWordRule);
250,265d494
&lt; 	 * @see RuleBasedScanner#setRules(IRule[])
&lt; 	 */
&lt; 	public void setRules(IRule[] rules) {
&lt; 		int i;
&lt; 		for (i = 0; i &lt; rules.length; i++)
&lt; 			if (rules[i].equals(fVersionedWordRule))
&lt; 				break;
&lt; 
&lt; 		// not found - invalidate fVersionedWordRule
&lt; 		if (i == rules.length)
&lt; 			fVersionedWordRule = null;
&lt; 
&lt; 		super.setRules(rules);
&lt; 	}
&lt; 
&lt; 	/*
269,270c498
&lt; 		return event.getProperty().equals(SOURCE_VERSION)
&lt; 			|| super.affectsBehavior(event);
---
&gt; 		return event.getProperty().equals(SOURCE_VERSION) || super.affectsBehavior(event);
279c507
&lt; 			Object value = event.getNewValue();
---
&gt; 			Object value= event.getNewValue();
282c510
&lt; 				String s = (String) value;
---
&gt; 				String s= (String) value;
284,285c512,515
&lt; 				if (fVersionedWordRule != null)
&lt; 					fVersionedWordRule.setCurrentVersion(s);
---
&gt; 				for (Iterator it= fVersionDependentRules.iterator(); it.hasNext();) {
&gt; 					ISourceVersionDependent dependent= (ISourceVersionDependent) it.next();
&gt; 					dependent.setSourceVersion(s);
&gt; 				}
292a523
&gt; 	// AspectJ Change Begin
314a546
&gt; 	// AspectJ Change End
</file>
</fixedFiles>
</bug>
<bug id="118192" transactionid="68432">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null K-return M O-== O-!= T V Z-if</fullfingerprint>
<bugreport>See attached patch for a failing junit test case.</bugreport>
<testsforfix ID="118192" type="new">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java">
      <test NAME="testSerializableSuperclass"/>
      <test NAME="testSubinterfaceSuperclass"/>
      <test NAME="testVoidSuperclass"/>
      <test NAME="testIntSuperclass"/>
      <test NAME="testGenericInterfaceSuperclass_BcelWorldResolution"/>
      <test NAME="testGenericInterfaceSuperclass_ReflectionWorldResolution"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="182" file="output/118192/pre-fix/testresults.xml" passing="1602" size="1784"/>
<post-fix-testcases failing="182" file="output/118192/post-fix/testresults.xml" passing="1602" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/UnresolvedType.java" revision="1.21" state="changed">189a190
&gt;     public TypeKind getTypekind() { return typeKind;}
</file>
<file name="org.aspectj/modules/weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java" revision="1.8" state="changed">131a132
&gt; 	// If the superclass is null, return Object - same as bcel does
133,134c134,138
&lt; 		if (superclass == null &amp;&amp; getBaseClass()!=Object.class) // superclass of Object is null
&lt; 		  superclass = fromType(this.getBaseClass().getGenericSuperclass());
---
&gt; 		if (superclass == null &amp;&amp; getBaseClass()!=Object.class) {// superclass of Object is null
&gt; 		  Type t = this.getBaseClass().getGenericSuperclass();
&gt; 		  if (t!=null) superclass = fromType(t);
&gt; 		  if (t==null) superclass = getWorld().resolve(UnresolvedType.OBJECT);
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java" revision="1.4" state="changed">16a17
&gt; import org.aspectj.weaver.ReferenceType;
19a21
&gt; import org.aspectj.weaver.bcel.BcelWorld;
26,27d27
&lt; 	private ResolvedType enumType;
&lt; 
175a176,259
&gt; 	
&gt; 	
&gt; 	public void testSerializableSuperclass() {
&gt; 		ResolvedType serializableType = world.resolve("java.io.Serializable");
&gt; 		ResolvedType superType = serializableType.getSuperclass();
&gt;         assertTrue("Superclass of serializable should be Object but was "+superType,superType.equals(UnresolvedType.OBJECT));    
&gt; 
&gt;         BcelWorld bcelworld = new BcelWorld();
&gt;         bcelworld.setBehaveInJava5Way(true);
&gt;         ResolvedType bcelSupertype = bcelworld.resolve(UnresolvedType.SERIALIZABLE).getSuperclass();
&gt;         assertTrue("Should be null but is "+bcelSupertype,bcelSupertype.equals(UnresolvedType.OBJECT));
&gt; 	}
&gt; 	
&gt; 	public void testSubinterfaceSuperclass() {		
&gt; 		ResolvedType ifaceType = world.resolve("java.security.Key");
&gt; 		ResolvedType superType = ifaceType.getSuperclass();
&gt; 		assertTrue("Superclass should be Object but was "+superType,superType.equals(UnresolvedType.OBJECT));  
&gt; 
&gt;         BcelWorld bcelworld = new BcelWorld();
&gt;         bcelworld.setBehaveInJava5Way(true);
&gt;         ResolvedType bcelSupertype = bcelworld.resolve("java.security.Key").getSuperclass();
&gt;         assertTrue("Should be null but is "+bcelSupertype,bcelSupertype.equals(UnresolvedType.OBJECT));
&gt; 	}
&gt; 	
&gt; 	public void testVoidSuperclass() {
&gt; 		ResolvedType voidType = world.resolve(Void.TYPE);
&gt; 		ResolvedType superType = voidType.getSuperclass();
&gt; 		assertNull(superType);
&gt; 		   
&gt;         BcelWorld bcelworld = new BcelWorld();
&gt;         bcelworld.setBehaveInJava5Way(true);
&gt;         ResolvedType bcelSupertype = bcelworld.resolve("void").getSuperclass();
&gt;         assertTrue("Should be null but is "+bcelSupertype,bcelSupertype==null);
&gt; 	}
&gt; 
&gt; 	public void testIntSuperclass() {
&gt; 		ResolvedType voidType = world.resolve(Integer.TYPE);
&gt; 		ResolvedType superType = voidType.getSuperclass();
&gt; 		assertNull(superType);
&gt; 
&gt;         BcelWorld bcelworld = new BcelWorld();
&gt;         bcelworld.setBehaveInJava5Way(true);
&gt;         ResolvedType bcelSupertype = bcelworld.resolve("int").getSuperclass();
&gt;         assertTrue("Should be null but is "+bcelSupertype,bcelSupertype==null);
&gt; 	}
&gt; 	
&gt;     public void testGenericInterfaceSuperclass_BcelWorldResolution() {
&gt;         BcelWorld bcelworld = new BcelWorld();
&gt;         bcelworld.setBehaveInJava5Way(true);
&gt;         
&gt;         UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
&gt;         
&gt;         ReferenceType rawType = (ReferenceType) bcelworld.resolve(javaUtilMap);
&gt;         assertTrue("Should be the raw type ?!? "+rawType.getTypekind(),rawType.isRawType());
&gt;         
&gt;         ReferenceType genericType = (ReferenceType)rawType.getGenericType();
&gt;         assertTrue("Should be the generic type ?!? "+genericType.getTypekind(),genericType.isGenericType());
&gt;         
&gt;         ResolvedType rt = rawType.getSuperclass();
&gt;         assertTrue("Superclass for Map raw type should be Object but was "+rt,rt.equals(UnresolvedType.OBJECT));         
&gt;         
&gt;         ResolvedType rt2 = genericType.getSuperclass();
&gt;         assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT));         
&gt;     }
&gt;     
&gt;     public void testGenericInterfaceSuperclass_ReflectionWorldResolution() {
&gt;         
&gt;         UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
&gt;         
&gt;         ReferenceType rawType = (ReferenceType) world.resolve(javaUtilMap);
&gt;         assertTrue("Should be the raw type ?!? "+rawType.getTypekind(),rawType.isRawType());
&gt;         
&gt;         ReferenceType genericType = (ReferenceType)rawType.getGenericType();
&gt;         assertTrue("Should be the generic type ?!? "+genericType.getTypekind(),genericType.isGenericType());
&gt;         
&gt;         ResolvedType rt = rawType.getSuperclass();
&gt;         assertTrue("Superclass for Map raw type should be Object but was "+rt,rt.equals(UnresolvedType.OBJECT));     
&gt;         
&gt;         ResolvedType rt2 = genericType.getSuperclass();
&gt;         assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT));       
&gt;     }
&gt; 
&gt; 	// todo: array of int	
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="118599" transactionid="69256">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V</fullfingerprint>
<bugreport>Configuration:
  - Eclipse 3.1.1
  - AJDT 1.3.0.20051129155513


Problem Description:

Project A defines an interface with static aspect to provide a default implementation:


public interface Attributable {

  void setAttribute(String name, Object attribute);
  Object getAttribute(String name);

  static aspect DefImpl {

    private Map&lt;String,Object&gt; Attributable.attributes =
      new HashMap&lt;String,Object&gt;();

    public void Attributable.setAttribute(String name, Object attribute) {
      this.attributes.put(name, attribute);
    }

    public Object Attributable.getAttribute(String name) {
      return this.attributes.get(name);
    }
  }
}


Project A generates a JAR that gets used in Project B on both the Java Build Path and the AspectJ Aspect Path. Project B contains the following implementing class:


public class AnAttributedClass implements Attributable {

  public void doSomething() {
    this.setAttribute("foo", "bar");
  }
}


This results in the compile error "The method setAttribute(String,Object) is ambiguous for the type AnAttributedClass".

Please note that using the aspected interface within Project A when implementing classes does not cause said compiler error.

With best regards,
Christoph Cenowa</bugreport>
<pre-fix-testcases failing="181" file="output/118599/pre-fix/testresults.xml" passing="1603" size="1784"/>
<post-fix-testcases failing="180" file="output/118599/post-fix/testresults.xml" passing="1604" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java" revision="1.17" state="changed">45c45
&lt; 
---
&gt; 	
437a438
&gt; 				sourceTypeBinding.resolveTypesFor(b); // this will return fast if its already been done.
</file>
</fixedFiles>
</bug>
<bug id="118715" transactionid="70200">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="11"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="9"/>
<property name="lines-modified" value="19"/>
<property name="lines-churned" value="28"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-import K-new M O-== O-!= T V Y Z-if</fullfingerprint>
<bugreport>In ClassLoaderWeavingAdaptor if weaverOption.lint is null, then a loaded Xlint properties file gets overwritten by the default Xlint properties. See attached patch to fix this problem.</bugreport>
<testsforfix ID="118715" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java">
      <test NAME="testXlintfileEmpty"/>
      <test NAME="testXlintfileMissing"/>
      <test NAME="testXlintWarningAdviceDidNotMatchSuppressed"/>
      <test NAME="testXlintfile"/>
      <test NAME="testXlintDefault"/>
      <test NAME="testXlintWarning"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/ltw-tests.xml">
      <test NAME="Empty Xlint.properties file"/>
      <test NAME="Warning with missing Xlint.properties file"/>
      <test NAME="Warning when advice doesn't match suppressed for LTW"/>
      <test NAME="Override suppressing of warning when advice doesn't match using -Xlintfile"/>
      <test NAME="Warning when advice doesn't match using -Xlint:default"/>
      <test NAME="Override suppressing of warning when advice doesn't match using -Xlint:warning"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="181" file="output/118715/pre-fix/testresults.xml" passing="1603" size="1784"/>
<post-fix-testcases failing="180" file="output/118715/post-fix/testresults.xml" passing="1604" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.33" state="changed">28d27
&lt; import org.aspectj.bridge.IMessage;
30d28
&lt; import org.aspectj.bridge.Message;
223c221,228
&lt;         //-Xlintfile: first so that lint wins
---
&gt; 
&gt;         /* First load defaults */
&gt; 		bcelWorld.getLint().loadDefaultProperties();
&gt; 		
&gt; 		/* Second overlay LTW defaults */
&gt; 		bcelWorld.getLint().adviceDidNotMatch.setKind(null);
&gt;         
&gt;         /* Third load user file using -Xlintfile so that -Xlint wins */
239,243c244,249
&lt;                     world.getMessageHandler().handleMessage(new Message(
&lt;                             "Cannot access resource for -Xlintfile:"+weaverOption.lintFile,
&lt;                             IMessage.WARNING,
&lt;                             failure,
&lt;                             null));
---
&gt;                 	warn("Cannot access resource for -Xlintfile:"+weaverOption.lintFile,failure);
&gt; //                    world.getMessageHandler().handleMessage(new Message(
&gt; //                            "Cannot access resource for -Xlintfile:"+weaverOption.lintFile,
&gt; //                            IMessage.WARNING,
&gt; //                            failure,
&gt; //                            null));
248,252c254,257
&lt;         }
&lt;         if (weaverOption.lint == null) {
&lt;         		bcelWorld.getLint().loadDefaultProperties();
&lt;         		bcelWorld.getLint().adviceDidNotMatch.setKind(IMessage.INFO);
&lt;         } else {
---
&gt;        } 
&gt;         
&gt;        /* Fourth override with -Xlint */
&gt;        if (weaverOption.lint != null) {
</file>
<file name="org.aspectj/modules/testing/newsrc/org/aspectj/testing/OutputSpec.java" revision="1.3" state="changed">38c38,39
&lt; 				if (!line.equals(outputLine)) {
---
&gt; 				/* Avoid trying to match on ajSandbox source names that appear in messages */
&gt; 				if (outputLine.indexOf(line) == -1) {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.23" state="changed">335c335
&lt;         return messageHandler.handleMessage(new Message("Register definition failed", IMessage.WARNING, th, null));
---
&gt;         return messageHandler.handleMessage(new Message(message, IMessage.WARNING, th, null));
</file>
<file name="org.aspectj/modules/testing/newsrc/org/aspectj/testing/RunSpec.java" revision="1.8" state="changed">39a40
&gt; 	private String xlintFile;
53a55
&gt; 		copyXlintFile(inTestCase.getSandboxDirectory());
149a152,172
&gt; 
&gt; 	public String getXlintFile() {
&gt; 		return xlintFile;
&gt; 	}
&gt; 
&gt; 	public void setXlintFile(String xlintFile) {
&gt; 		this.xlintFile = xlintFile;
&gt; 	}
&gt; 
&gt; 	private void copyXlintFile (File sandboxDirectory) {
&gt; 		if (xlintFile != null) {
&gt; 			File from = new File(baseDir,xlintFile);
&gt; 			File to = new File(sandboxDirectory, File.separator + xlintFile);
&gt; 			try {
&gt; 				FileUtil.copyFile(from,to);
&gt; 			}
&gt; 			catch (IOException ex) {
&gt; 				AjcTestCase.fail(ex.toString());
&gt; 			}
&gt; 		}
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java" revision="1.10" state="changed">18d17
&lt; import java.lang.reflect.GenericArrayType;
20d18
&lt; import java.lang.reflect.ParameterizedType;
22,24d19
&lt; import java.lang.reflect.WildcardType;
&lt; import java.util.HashMap;
&lt; import java.util.Map;
31d25
&lt; import org.aspectj.weaver.BoundedReferenceType;
36d29
&lt; import org.aspectj.weaver.TypeFactory;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/ltw-tests.xml" revision="1.5" state="changed">0a1
&gt; 
217a219,324
&gt; 	&lt;ajc-test dir="ltw"
&gt;       title="Empty Xlint.properties file"
&gt;       keywords="xlint, ltw"&gt;
&gt;         &lt;compile
&gt;         	files="Main.java"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;run class="Main" ltw="aop-xlintfile.xml" xlintfile="Xlint-empty.properties"&gt;
&gt;         	&lt;stderr&gt;
&gt;         	&lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt; 	&lt;ajc-test dir="ltw"
&gt;       title="Warning with missing Xlint.properties file"
&gt;       keywords="xlint, ltw"&gt;
&gt;         &lt;compile
&gt;         	files="Main.java"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;run class="Main" ltw="aop-xlintfile.xml"&gt;
&gt;         	&lt;stderr&gt;
&gt;         		&lt;line text="warning Cannot access resource for -Xlintfile:Xlint-empty.properties"/&gt;
&gt;         	&lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt; 	&lt;ajc-test dir="ltw"
&gt;       title="Warning when advice doesn't match suppressed for LTW"
&gt;       keywords="xlint, ltw"&gt;
&gt;         &lt;compile
&gt;         	files="Main.java"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;compile
&gt;         	files="Aspect3.aj"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;run class="Main" ltw="aop-nomatch.xml"&gt;
&gt;         	&lt;stderr&gt;
&gt; 	        	&lt;line text="info register aspect Aspect3"/&gt;
&gt; 	        	&lt;line text="info weaving 'Main'"/&gt;
&gt;         	&lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt; 	&lt;ajc-test dir="ltw"
&gt;       title="Override suppressing of warning when advice doesn't match using -Xlintfile"
&gt;       keywords="xlint, ltw"&gt;
&gt;         &lt;compile
&gt;         	files="Main.java"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;compile
&gt;         	files="Aspect3.aj"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;run class="Main" ltw="aop-nomatchxlintfile.xml" xlintfile="Xlint-nomatch.properties"&gt;
&gt;         	&lt;stderr&gt;
&gt; 	        	&lt;line text="info register aspect Aspect3"/&gt;
&gt; 	        	&lt;line text="info weaving 'Main'"/&gt;
&gt;         		&lt;line text="advice defined in Aspect3 has not been applied [Xlint:adviceDidNotMatch]"/&gt;
&gt;         	&lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt; 	&lt;ajc-test dir="ltw"
&gt;       title="Warning when advice doesn't match using -Xlint:default"
&gt;       keywords="xlint, ltw"&gt;
&gt;         &lt;compile
&gt;         	files="Main.java"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;compile
&gt;         	files="Aspect3.aj"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;run class="Main" ltw="aop-nomatchxlint.xml"&gt;
&gt;         	&lt;stderr&gt;
&gt; 	        	&lt;line text="info register aspect Aspect3"/&gt;
&gt; 	        	&lt;line text="info weaving 'Main'"/&gt;
&gt;         		&lt;line text="advice defined in Aspect3 has not been applied [Xlint:adviceDidNotMatch]"/&gt;
&gt;         	&lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt; 	&lt;ajc-test dir="ltw"
&gt;       title="Override suppressing of warning when advice doesn't match using -Xlint:warning"
&gt;       keywords="xlint, ltw"&gt;
&gt;         &lt;compile
&gt;         	files="Main.java"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;compile
&gt;         	files="Aspect3.aj"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;run class="Main" ltw="aop-nomatchxlint.xml"&gt;
&gt;         	&lt;stderr&gt;
&gt; 	        	&lt;line text="info register aspect Aspect3"/&gt;
&gt; 	        	&lt;line text="info weaving 'Main'"/&gt;
&gt;         		&lt;line text="advice defined in Aspect3 has not been applied [Xlint:adviceDidNotMatch]"/&gt;
&gt;         	&lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java" revision="1.5" state="changed">67a68,91
&gt;   	public void testXlintfileEmpty () {
&gt;   		runTest("Empty Xlint.properties file");
&gt;   	}
&gt; 
&gt;   	public void testXlintfileMissing () {
&gt;   		runTest("Warning with missing Xlint.properties file");
&gt;   	}
&gt; 
&gt;   	public void testXlintWarningAdviceDidNotMatchSuppressed () {
&gt;   		runTest("Warning when advice doesn't match suppressed for LTW");
&gt;   	}
&gt; 
&gt;   	public void testXlintfile () {
&gt;   		runTest("Override suppressing of warning when advice doesn't match using -Xlintfile");
&gt;   	}
&gt; 
&gt;   	public void testXlintDefault () {
&gt;   		runTest("Warning when advice doesn't match using -Xlint:default");
&gt;   	}
&gt; 
&gt;   	public void testXlintWarning () {
&gt;   		runTest("Override suppressing of warning when advice doesn't match using -Xlint:warning");
&gt;   	}
&gt;   	
</file>
<file name="org.aspectj/modules/testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java" revision="1.9" state="changed">169a170
&gt; 		digester.addSetProperties("suite/ajc-test/run","xlintfile","xlintFile");
</file>
<file name="org.aspectj/modules/tests/ltw/aop-nomatch.xml" revision="1.1" state="new">&lt;aspectj&gt;
	&lt;aspects&gt;
	    &lt;aspect name="Aspect3"/&gt;
	&lt;/aspects&gt;
    
    &lt;weaver options="-verbose -showWeaveInfo"/&gt;
&lt;/aspectj&gt;
</file>
<file name="org.aspectj/modules/tests/ltw/aop-nomatchxlintfile.xml" revision="1.1" state="new">&lt;aspectj&gt;
	&lt;aspects&gt;
	    &lt;aspect name="Aspect3"/&gt;
	&lt;/aspects&gt;
    
    &lt;weaver options="-verbose -showWeaveInfo -Xlintfile:Xlint-nomatch.properties"/&gt;
&lt;/aspectj&gt;
</file>
<file name="org.aspectj/modules/tests/ltw/aop-nomatchxlint.xml" revision="1.1" state="new">&lt;aspectj&gt;
	&lt;aspects&gt;
	    &lt;aspect name="Aspect3"/&gt;
	&lt;/aspects&gt;
    
    &lt;weaver options="-verbose -showWeaveInfo -Xlint:warning"/&gt;
&lt;/aspectj&gt;
</file>
<file name="org.aspectj/modules/tests/ltw/Xlint-nomatch.properties" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/ltw/Aspect3.aj" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Matthew Webster         initial implementation
 *******************************************************************************/
import org.aspectj.lang.JoinPoint;

public aspect Aspect3 {
	
	before () : execution(void Main.test999()) {
		System.err.println("Aspect1.before_" + thisJoinPoint.getSignature().getName());
	}
}
</file>
<file name="org.aspectj/modules/tests/ltw/Xlint-empty.properties" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/ltw/aop-xlintfile.xml" revision="1.1" state="new">&lt;aspectj&gt;
	&lt;weaver options="-Xlintfile:Xlint-empty.properties"/&gt;
&lt;/aspectj&gt;
</file>
</fixedFiles>
</bug>
<bug id="118781" transactionid="68676">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if M O-- O-!= O-+ T V Y Z-if</fullfingerprint>
<bugreport>I'm fairly new to AspectJ, so this is probably not going to be well explained. I've started working on a project that was working fine. Then I added methods to classes that take a 2-dimensional string array parameter and suddenly I'm getting a VerifyError exception.

java.lang.VerifyError: (class: com/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00, method: searchForObligorSummariesByGroup_aroundBody24 signature: (Lcom/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00;[[[Ljava/lang/String;Ljava/lang/String;Ljava(&amp;#130;
	at com.drkw.cpds.obligor.facades.version_1_00.obligor.ObligorManager.&lt;clinit&gt;(ObligorManager.java:48)
	at com.drkw.cpds.obligor.integration.version_1_00.obligor.GetObligorDetailsGroupingTest.testGetObligorDetailsUsingGroups(GetObligorDetailsGroupingTest.java:45)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</bugreport>
<testsforfix ID="118781" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testAroundAdviceArrayAdviceSigs_pr118781"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="verify error with around advice array sigs"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="181" file="output/118781/pre-fix/testresults.xml" passing="1603" size="1784"/>
<post-fix-testcases failing="180" file="output/118781/post-fix/testresults.xml" passing="1604" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.66" state="changed">212,213c212,213
&lt;         	String brackets = signature.substring(0,signature.lastIndexOf("[")+1);
&lt;             ret = new ResolvedType.Array(signature, brackets+componentType.getErasureSignature(),
---
&gt;         	//String brackets = signature.substring(0,signature.lastIndexOf("[")+1);
&gt;             ret = new ResolvedType.Array(signature, "["+componentType.getErasureSignature(),
692a693,695
&gt; 			if (key.indexOf("String")!=-1) {
&gt; 				int stop=1;
&gt; 			}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.154" state="changed">53d52
&lt;   
55a55
&gt;   public void testAroundAdviceArrayAdviceSigs_pr118781()     { runTest("verify error with around advice array sigs");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.235" state="changed">94a95,99
&gt;     &lt;ajc-test dir="bugs150/pr118781" pr="118781" title="verify error with around advice array sigs"&gt;
&gt;      &lt;compile files="MyMain.java,MyAspect.java,MyClass.java" options="-XnoInline"/&gt;
&gt;      &lt;run class="blah.MyMain"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs150/pr118781/MyClass.java" revision="1.1" state="new">package blah;

import java.util.Random;

public class MyClass {
       public Integer[] getRandomInt(String[][] param)
       {
               for (int i = 0; i &lt; param.length; i++)
               {
                       System.out.print("[" + i + "] = [");
                       for (int j = 0; j &lt; param[i].length; j++)
                       {
                               System.out.print(param[i][j]);
                               if (j != param[i].length-1)
                                       System.out.print(',');
                       }
                       System.out.println(']');
               }
               return new Integer[] { new Integer(new Random().nextInt())};
       }
}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr118781/MyMain.java" revision="1.1" state="new">package blah;

/** */
public class MyMain {

       /**
        * @param args
        */
       public static void main(String[] args)
       {
               MyClass mc = new MyClass();
               mc.getRandomInt(new String[][]{{ "a", "b",
"c"},{"x","y","z"}});
       }
}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr118781/MyAspect.java" revision="1.1" state="new">package blah;

public aspect MyAspect {

       pointcut callPointCut(): call(public * blah.MyClass+.*(..));

       Object around() : callPointCut() {
               System.out.println("start of around");
               Object result = proceed();
               System.out.println("end of around");
               return result;
       }
}
</file>
</fixedFiles>
</bug>
<bug id="119210" transactionid="69473">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="32"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="36"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-instanceof K-new K-return M O-&amp;&amp; O-+ O-instanceof T V Y Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I met NullPointerException when weaving. Doesn't Aj support this situations?

public class TestLib {

	  private static int myInt;
	  static {
		  myInt = 1;
	  }
	  public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("myInt="+myInt);
	  }
}

public aspect ThreadAspectLib {
	pointcut setThreadLocalsField():set(private int TestLib.myInt);
	
	Integer around():setThreadLocalsField()
	{
		try{
			return new Integer(2);
		}
		catch(Exception e)
		{
			e.printStackTrace();
			return null;
		}
	}
}

---- AspectJ Properties ---
AspectJ Compiler DEVELOPMENT built on Tuesday Jun 14, 2005 at 15:41:05 GMT
---- Dump Properties ---
Dump file: ajcore.20051205.145247.250.txt
Dump reason: java.lang.NullPointerException
Dump on exception: true
Dump at exit condition: abort
---- Exception Information ---
java.lang.NullPointerException
	at org.aspectj.weaver.ResolvedTypeX$Primitive.isAssignableFrom(ResolvedTypeX.java:985)
	at org.aspectj.weaver.ResolvedTypeX.isAssignableFrom(ResolvedTypeX.java:96)
	at org.aspectj.weaver.Advice.match(Advice.java:143)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1673)
	at org.aspectj.weaver.bcel.BcelClassWeaver.matchSetInstruction(BcelClassWeaver.java:1543)
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java(Compiled Code))
	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java(Compiled Code))
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:377)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:94)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1362)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1327)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1106)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:993)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:368)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:727)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:318)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:228)
	at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1194)
	at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:985)
	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
	at org.apache.tools.ant.Task.perform(Task.java:364)
	at org.apache.tools.ant.Target.execute(Target.java:341)
	at org.apache.tools.ant.Target.performTasks(Target.java:369)
	at org.apache.tools.ant.Project.executeTarget(Project.java:1214)
	at org.apache.tools.ant.Project.executeTargets(Project.java:1062)
	at org.apache.tools.ant.Main.runBuild(Main.java:690)
	at org.apache.tools.ant.Main.startAnt(Main.java:200)
	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)
---- System Properties ---
java.assistive=ON
java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition
sun.boot.library.path=C:\Program Files\IBM\Java141\jre\bin
java.vm.version=1.4.1
java.vm.vendor=IBM Corporation
java.vendor.url=http://www.ibm.com/
path.separator=;
java.vm.name=Classic VM
file.encoding.pkg=sun.io</bugreport>
<pre-fix-testcases failing="182" file="output/119210/pre-fix/testresults.xml" passing="1602" size="1784"/>
<post-fix-testcases failing="183" file="output/119210/post-fix/testresults.xml" passing="1601" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/Utility.java" revision="1.26" state="changed">396a397,399
&gt;     public static InstructionList createConversion(InstructionFactory factory,Type fromType,Type toType) {
&gt;     	return createConversion(factory,fromType,toType,false);
&gt;     }
401c404,405
&lt;             Type toType) {
---
&gt;             Type toType,
&gt;             boolean allowAutoboxing) {
461a466,494
&gt;         
&gt;         if (allowAutoboxing) {
&gt; 	        if (toType instanceof BasicType &amp;&amp; fromType instanceof ReferenceType) {
&gt; 	        	// unboxing
&gt; 	        	String name = toType.toString() + "Value";
&gt; 	            il.append(
&gt; 	                fact.createInvoke(
&gt; 	                    "org.aspectj.runtime.internal.Conversions",
&gt; 	                    name,
&gt; 	                    toType,
&gt; 	                    new Type[] { Type.OBJECT },
&gt; 	                    Constants.INVOKESTATIC));
&gt; 	            return il;
&gt; 	        }
&gt; 	        
&gt; 	        if (fromType instanceof BasicType &amp;&amp; toType instanceof ReferenceType) {
&gt; 	        	// boxing
&gt; 	        	String name = fromType.toString() + "Object";
&gt; 	            il.append(
&gt; 	                fact.createInvoke(
&gt; 	                    "org.aspectj.runtime.internal.Conversions",
&gt; 	                    name,
&gt; 	                    Type.OBJECT,
&gt; 	                    new Type[] { fromType },
&gt; 	                    Constants.INVOKESTATIC));
&gt; 	            il.append(fact.createCast(Type.OBJECT, toType));
&gt; 	            return il;
&gt; 	        }
&gt;         }
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.84" state="changed">2234c2234
&lt; 		            extractedMethod.getReturnType()));
---
&gt; 		            extractedMethod.getReturnType(),world.isInJava5Mode()));
2662c2662
&lt; 	                callbackMethod.getReturnType());
---
&gt; 	                callbackMethod.getReturnType(),world.isInJava5Mode());
</file>
</fixedFiles>
</bug>
<bug id="119353" transactionid="68957">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-cast T V Y Z-cast</fullfingerprint>
<bugreport>I am running into a problem in load-time weaving when I use reflection delegates because the weaver is generating an incorrect bridge method when I perform an inter-type declaration on Struts.ActionServlet for the init method. On investigation, the BCEL world is recognizing this as an overriding method, because its version of getDeclaredMethods is returning the declared methods for all ancestor superclasses. However, the reflection world is returning only the declared methods for this one class. It therefore appears that the weaver expects getDeclaredMethods to return all of them (making the name quite misleading). I think previously the method was being implemented inconsistently between 1.5 reflection and &lt;1.5 reflection delegates. But it looks like it needs to be handled consistently to include all superclass methods.

However, I dont know what other places (e.g., the MAP) are really expecting getDeclaredMethods and its siblings to behave like Java reflection's version

I started work on adding a getAllDeclaredMethods method to ReferenceType and delegates, as an alternative to provide the weaver the ability to check method overriding as in this case, but it's a little bit involved and I wanted to flag the issue first.

Here's a test that fails and illustrates the issue:
Index: ReflectionBasedReferenceTypeDelegateTest.java
===================================================================
RCS file: /home/technology/org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java,v
retrieving revision 1.5
diff -u -r1.5 ReflectionBasedReferenceTypeDelegateTest.java
--- ReflectionBasedReferenceTypeDelegateTest.java	28 Nov 2005 17:44:40 -0000	1.5
+++ ReflectionBasedReferenceTypeDelegateTest.java	6 Dec 2005 04:11:41 -0000
@@ -238,6 +238,18 @@
         assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT));         
     }
     
+    public void testCompareSubclassDelegates() {
+        world.setBehaveInJava5Way(true);
+        
+        BcelWorld bcelWorld = new BcelWorld();
+        bcelWorld.setBehaveInJava5Way(true);
+        UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
+        ReferenceType rawType = (ReferenceType)bcelWorld.resolve(javaUtilHashMap );
+        
+        ReferenceType rawReflectType = (ReferenceType)world.resolve(javaUtilHashMap );
+        assertEquals(rawType.getDelegate().getDeclaredMethods().length, rawReflectType.getDelegate().getDeclaredMethods().length);
+    }
+    
 	// todo: array of int	
 
 	protected void setUp() throws Exception {


This results in:
junit.framework.AssertionFailedError: expected:&lt;41&gt; but was:&lt;29&gt;
	at junit.framework.Assert.fail(Assert.java:47)
	at junit.framework.Assert.failNotEquals(Assert.java:282)
	at junit.framework.Assert.assertEquals(Assert.java:64)
	at junit.framework.Assert.assertEquals(Assert.java:201)
	at junit.framework.Assert.assertEquals(Assert.java:207)
	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:250)
	at java.lang.reflect.Method.invoke(Native Method)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</bugreport>
<testsforfix ID="119353" type="new">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java">
      <test NAME="testCompareSubclassDelegates"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/119353/pre-fix/testresults.xml" passing="1604" size="1784"/>
<post-fix-testcases failing="180" file="output/119353/post-fix/testresults.xml" passing="1604" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java" revision="1.11" state="changed">216,217c216,218
&lt; 			getGenericResolvedType(),
&lt; 			"init",
---
&gt; 			// to return what BCEL returns the return type is void
&gt; 			ResolvedType.VOID,//getGenericResolvedType(),
&gt; 			"&lt;init&gt;",
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java" revision="1.10" state="changed">156,157c156,158
&lt; 				toResolvedType(aConstructor.getDeclaringClass(),(ReflectionWorld)inWorld),
&lt; 				"init",
---
&gt; 				// to return what BCEL returns, the return type for ctor is void
&gt; 				ResolvedType.VOID,//toResolvedType(aConstructor.getDeclaringClass(),(ReflectionWorld)inWorld),
&gt; 				"&lt;init&gt;",
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java" revision="1.6" state="changed">14a15,17
&gt; import java.util.HashSet;
&gt; import java.util.Set;
&gt; 
133c136
&lt; 		int initidx = findMethod("init", methods);
---
&gt; 		int initidx = findMethod("&lt;init&gt;", methods);
240a244,288
&gt;     // FIXME asc maybe.  The reflection list of methods returned doesn't include &lt;clinit&gt; (the static initializer) ... is that really a problem.
&gt;     public void testCompareSubclassDelegates() {
&gt;     	
&gt;     	boolean barfIfClinitMissing = false;
&gt;         world.setBehaveInJava5Way(true);
&gt;         
&gt;         BcelWorld bcelWorld = new BcelWorld();
&gt;         bcelWorld.setBehaveInJava5Way(true);
&gt;         UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
&gt;         ReferenceType rawType =(ReferenceType)bcelWorld.resolve(javaUtilHashMap );
&gt;         
&gt;         ReferenceType rawReflectType =(ReferenceType)world.resolve(javaUtilHashMap );
&gt;         ResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();
&gt;         ResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();
&gt;         StringBuffer errors = new StringBuffer();
&gt;         Set one = new HashSet();
&gt;         for (int i = 0; i &lt; rms1.length; i++) {
&gt; 			one.add(rms1[i].toString());
&gt; 		}
&gt;         Set two = new HashSet();
&gt;         for (int i = 0; i &lt; rms2.length; i++) {
&gt; 			two.add(rms2[i].toString());
&gt; 		}
&gt;         for (int i = 0;i&lt;rms2.length;i++) {
&gt;         	if (!one.contains(rms2[i].toString())) {
&gt;         		errors.append("Couldn't find "+rms2[i].toString()+" in the bcel set\n");
&gt;         	}
&gt;         }
&gt;         for (int i = 0;i&lt;rms1.length;i++) {
&gt;         	if (!two.contains(rms1[i].toString())) {
&gt;         		if (!barfIfClinitMissing &amp;&amp; rms1[i].getName().equals("&lt;clinit&gt;")) continue;
&gt;         		errors.append("Couldn't find "+rms1[i].toString()+" in the reflection set\n");
&gt;         	}
&gt;         }
&gt;         assertTrue("Errors:"+errors.toString(),errors.length()==0);
&gt;         
&gt;         if (barfIfClinitMissing) {
&gt;         	// the numbers must be exact
&gt;             assertEquals(rms1.length,rms2.length);        	
&gt;         } else {
&gt;         	// the numbers can be out by one in favour of bcel
&gt;         	assertTrue("Should be one extra (clinit) in BCEL case, but bcel="+rms1.length+" reflect="+rms2.length,rms1.length==rms2.length+1);
&gt;         }
&gt;     }
&gt;     	    
</file>
</fixedFiles>
</bug>
<bug id="119451" transactionid="68463">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>Z</concisefingerprint>
<fullfingerprint>O-== O-|| O-() T V Y Z-if</fullfingerprint>
<bugreport>// Main.java
package bug;

public class Main {
}

aspect LogMain {
	
}

Generating ajdoc through Eclipse (AJDT 1.3.0.20051206092602, AspectJ 1.5.0.20051206103951) generate incorrect warning for the LogMain aspect:

&gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc...
Loading source file C:\work\aop\src\ajdocworkingdir\bug\Main.java...
Constructing Javadoc information...
C:\work\aop\src\ajdocworkingdir\bug\Main.java:11: class LogMain is public, should be declared in a file named LogMain.java
public class  LogMain {
       ^
Standard Doclet version 1.5.0_04
Building tree for all the packages and classes...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\LogMain.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\Main.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-frame.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-summary.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-tree.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\constant-values.html...
Building index for all the packages and classes...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\overview-tree.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index-all.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\deprecated-list.html...
Building index for all classes...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-frame.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-noframe.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\help-doc.html...
Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\stylesheet.css...
1 warning
&gt; Decorating html files...
&gt; Decorating C:\work\aop\src\workspace\AJDocPackageAspect\doc\bug\Main.html...
&gt; Removing generated tags (this may take a while)...
&gt; Finished.</bugreport>
<testsforfix ID="119451" type="changed">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java">
      <test NAME="testAspectAccessibility"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="181" file="output/119451/pre-fix/testresults.xml" passing="1603" size="1784"/>
<post-fix-testcases failing="180" file="output/119451/post-fix/testresults.xml" passing="1604" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java" revision="1.47" state="changed">1116c1116,1118
&lt; 		printModifiers(this.modifiers, output);
---
&gt; 		// since all aspects are made public we want to print the
&gt; 		// modifiers that were supplied in the original source code
&gt; 		printModifiers(this.declaredModifiers,output);
</file>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java" revision="1.11" state="changed">168c168
&lt; 			if (index != -1 &amp;&amp; signature.charAt(index-1) != '.') {
---
&gt; 			if (index == 0 || (index != -1 &amp;&amp; signature.charAt(index-1) != '.') ) {
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java" revision="1.14" state="changed">37a38
&gt; 		assertEquals("aspect should not have public in it's signature","aspect AdviceNamingCoverage",packageAspect.getSourceSignature());
</file>
</fixedFiles>
</bug>
<bug id="119539" transactionid="68481">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="29"/>
<property name="lines-added" value="33"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="48"/>
<property name="lines-churned" value="81"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-if K-import K-instanceof K-new K-null K-return K-while M O-== O-|| O-!= O-?: O-() O-+ O-cast O-instanceof T V Y Z-cast Z-cond Z-for Z-if Z-throw Z-vardecl Z-while</fullfingerprint>
<bugreport>Get compiler xlint adviceDidNotMatch when using parameterized type to specify type pattern for pertypewithin clause.  Parameterized type works in pointcuts, and the pointcut matches staticly (with deow).  Same result for before or around advice.

Also, the permitted uses for the type parameter of a parameterized aspect in the adk15notebook section on point.

Resolutions could be:
- not a bug b/c the code below is wrong
- not permitted to use type parameter in pertypewithin; doc updated
- permitted, fixed
...

AspectJ version 1.5.0.20051206103951, via AJDT

----------------------------------------- sample
package bugs;

public class GenericPerTypeWithin {

    public static void main(String[] args) {
        new C(); // fyi, compiler does nothing absent this call?
    }
    public static abstract aspect Singleton&lt;Target&gt; pertypewithin(Target) {
        pointcut creation() : execution(Target+.new()) ;
        // adviceDoesNotMatch - same for before advice
        Target around() : creation() { return proceed(); }
        // picks out constructor-execution below
        declare warning : creation() : "Singleton.creation()";
    }
    static class C {
        C(){}
    }
    static aspect A extends Singleton&lt;C&gt; {}
}</bugreport>
<testsforfix ID="119539" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testGenericPTW_pr119539_1"/>
      <test NAME="testGenericPTW_pr119539_2"/>
      <test NAME="testGenericPTW_pr119539_3"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="183" file="output/119539/pre-fix/testresults.xml" passing="1601" size="1784"/>
<post-fix-testcases failing="181" file="output/119539/post-fix/testresults.xml" passing="1603" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java" revision="1.48" state="changed">454,457c454,457
&lt; //        	   if(declaration instanceof AspectDeclaration) {
&lt; //        		   PerClause pc = ((AspectDeclaration)declaration).perClause;
&lt; //        		   if (pc != null) return pc;
&lt; //        	   }
---
&gt;         	   if(declaration instanceof AspectDeclaration) {
&gt;         		   PerClause pc = ((AspectDeclaration)declaration).perClause;
&gt;         		   if (pc != null) return pc;
&gt;         	   }
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java" revision="1.32" state="changed">20a21
&gt; import java.util.Enumeration;
21a23
&gt; import java.util.Iterator;
152c154
&lt; 		throw new RuntimeException("unimplemented");
---
&gt; 		throw new RuntimeException("unimplemented - did concretization fail?");
156a159,160
&gt; 		// the pointcut is marked as CONCRETE after returning from this 
&gt; 		// call - so we can't skip concretization
172c176,177
&lt; 		for (int i=0, len=freeVars.length; i &lt; len; i++) {
---
&gt; 		if (freeVars!=null) {
&gt; 		  for (int i=0, len=freeVars.length; i &lt; len; i++) {
175a181
&gt; 		  }
201,202c207
&lt; 		  
&lt; 		Object field = getCflowfield(concreteEntry);
---
&gt; 		Object field = getCflowfield(concreteEntry,concreteAspect);
214c219
&lt; 		if (freeVars.length == 0) { // No state, so don't use a stack, use a counter.
---
&gt; 		if (freeVars==null || freeVars.length == 0) { // No state, so don't use a stack, use a counter.
232c237
&lt; 		    Advice.makeCflowEntry(world,concreteEntry,isBelow,localCflowField,freeVars.length,innerCflowEntries,inAspect));
---
&gt; 		    Advice.makeCflowEntry(world,concreteEntry,isBelow,localCflowField,freeVars==null?0:freeVars.length,innerCflowEntries,inAspect));
234c239
&lt; 			putCflowfield(concreteEntry,localCflowField); // Remember it
---
&gt; 			putCflowfield(concreteEntry,concreteAspect,localCflowField); // Remember it
292c297
&lt; 			  putCflowfield(concreteEntry,localCflowField);
---
&gt; 			  putCflowfield(concreteEntry,concreteAspect,localCflowField);
306c311,321
&lt; 	private Object getCflowfield(Pointcut pcutkey) {
---
&gt; 	private String getKey(Pointcut p,ResolvedType a) {
&gt; 	  StringBuffer sb = new StringBuffer();
&gt; 	  sb.append(a.getName());
&gt; 	  sb.append("::");
&gt; 	  sb.append(p.toString());
&gt; 	  return sb.toString();
&gt; 	}
&gt; 	
&gt; 	private Object getCflowfield(Pointcut pcutkey, ResolvedType concreteAspect) {
&gt; 		String key = getKey(pcutkey,concreteAspect);
&gt; 		Object o =null;
308c323
&lt; 			return cflowBelowFields.get(pcutkey);
---
&gt; 			o = cflowBelowFields.get(key);
310c325
&lt; 			return cflowFields.get(pcutkey);
---
&gt; 			o = cflowFields.get(key);
311a327,328
&gt; 		//System.err.println("Retrieving for key "+key+" returning "+o);
&gt; 		return o;
314c331,333
&lt; 	private void putCflowfield(Pointcut pcutkey,Object o) {
---
&gt; 	private void putCflowfield(Pointcut pcutkey,ResolvedType concreteAspect,Object o) {
&gt; 		String key = getKey(pcutkey,concreteAspect);
&gt; 		//System.err.println("Storing cflow field for key"+key);
316c335
&lt; 			cflowBelowFields.put(pcutkey,o);
---
&gt; 			cflowBelowFields.put(key,o);
318c337
&lt; 			cflowFields.put(pcutkey,o);
---
&gt; 			cflowFields.put(key,o);
324a344,363
&gt; 
&gt; 	public static void clearCaches(ResolvedType aspectType) {
&gt; 		//System.err.println("Wiping entries starting "+aspectType.getName());
&gt; 		String key = aspectType.getName()+"::";
&gt; 		wipeKeys(key,cflowFields);
&gt; 		wipeKeys(key,cflowBelowFields);
&gt; 	}
&gt; 	
&gt; 	private static void wipeKeys(String keyPrefix,Hashtable ht) {
&gt; 		Enumeration keys = ht.keys();
&gt; 		List forRemoval = new ArrayList();
&gt; 		while (keys.hasMoreElements()) {
&gt; 			String s = (String)keys.nextElement();
&gt; 			if (s.startsWith(keyPrefix)) forRemoval.add(s);
&gt; 		}
&gt; 		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
&gt; 			String element = (String) iter.next();
&gt; 			ht.remove(element);
&gt; 		}
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ReferenceType.java" revision="1.37" state="changed">472c472,479
&lt; 	public PerClause getPerClause() { return delegate.getPerClause(); }
---
&gt; 	public PerClause getPerClause() { 
&gt; 		PerClause pclause = delegate.getPerClause();
&gt; 		if (isParameterizedType()) { // could cache the result here...
&gt; 			Map parameterizationMap = getAjMemberParameterizationMap();
&gt; 			pclause = (PerClause)pclause.parameterizeWith(parameterizationMap);
&gt; 		}
&gt; 		return pclause;
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java" revision="1.16" state="changed">23a24
&gt; import org.aspectj.weaver.patterns.CflowPointcut;
35c36
&lt;     private Map members = new HashMap();
---
&gt;     private Map /* ResolvedType (the aspect) &gt; CrosscuttingMembers */members = new HashMap();
37,42c38,43
&lt; 	private List shadowMungers = null;
&lt; 	private List typeMungers = null;
&lt;     private List lateTypeMungers = null;
&lt; 	private List declareSofts = null;
&lt; 	private List declareParents = null;
&lt; 	private List declareAnnotationOnTypes   = null;
---
&gt; 	private List shadowMungers             = null;
&gt; 	private List typeMungers               = null;
&gt;     private List lateTypeMungers           = null;
&gt; 	private List declareSofts              = null;
&gt; 	private List declareParents            = null;
&gt; 	private List declareAnnotationOnTypes  = null;
45c46
&lt; 	private List declareDominates = null;
---
&gt; 	private List declareDominates          = null;
61a63
&gt; 			CflowPointcut.clearCaches(aspectType);
65a68,69
&gt; 
&gt; 				CflowPointcut.clearCaches(aspectType);
71,75c75,79
&lt; //		if (aspectType.isAbstract()) {
&lt; //			// we might have sub-aspects that need to re-collect their crosscutting members from us
&lt; //			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType); 
&lt; //			change = change || ancestorChange;
&lt; //		}
---
&gt; 		if (aspectType.isAbstract()) {
&gt; 			// we might have sub-aspects that need to re-collect their crosscutting members from us
&gt; 			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType); 
&gt; 			change = change || ancestorChange;
&gt; 		}
79a84
&gt; 		//System.err.println("Looking at descendants of "+aspectType.getName());
83,85c88,90
&lt; 			ResolvedType candidateAncestor = (ResolvedType)it.next();
&lt; 			if ((candidateAncestor != aspectType) &amp;&amp; (aspectType.isAssignableFrom(candidateAncestor))) {
&lt; 				toBeReplaced.add(candidateAncestor);
---
&gt; 			ResolvedType candidateDescendant = (ResolvedType)it.next();
&gt; 			if ((candidateDescendant != aspectType) &amp;&amp; (aspectType.isAssignableFrom(candidateDescendant))) {
&gt; 				toBeReplaced.add(candidateDescendant);
90c95,96
&lt; 			boolean thisChange = addOrReplaceAspect((ResolvedType)it.next());
---
&gt; 			ResolvedType next = (ResolvedType)it.next();
&gt; 			boolean thisChange = addOrReplaceAspect(next);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.164" state="changed">45,47c45,47
&lt;   //public void testGenericPTW_pr119539_1() { runTest("generic pertypewithin aspect - 1");}
&lt;   //public void testGenericPTW_pr119539_2() { runTest("generic pertypewithin aspect - 2");}
&lt;   //public void testGenericPTW_pr119539_3() { runTest("generic pertypewithin aspect - 3");}
---
&gt;   public void testGenericPTW_pr119539_1() { runTest("generic pertypewithin aspect - 1");}
&gt;   public void testGenericPTW_pr119539_2() { runTest("generic pertypewithin aspect - 2");}
&gt;   public void testGenericPTW_pr119539_3() { runTest("generic pertypewithin aspect - 3");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.20" state="changed">352c352
&lt; //		checkCompileWeaveCount(1,4);
---
&gt; 		checkCompileWeaveCount(1,4);
</file>
</fixedFiles>
</bug>
<bug id="119543" transactionid="69401">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M</fullfingerprint>
<tag>exception</tag>
<bugreport>Code and exception below.  

Same result for HEAD and AspectJ 1.5.0.20051206103951 via AJDT.

------------------------------- bugs/CachedToString.java

package bugs;

import java.lang.ref.SoftReference;

import junit.framework.TestCase;

public class CachedToString {

    /**
     * @param args
     */
    public static void main(String[] args) {
        new CacheGetterTest().testToString();
    }
    public static class CacheGetterTest extends TestCase {
        static boolean runAdvice;
        public void testToString() {
            RandomToString me = new RandomToString ();
            runAdvice = false;
            String one = me.toString();
            String two = me.toString();
            assertFalse(one.equals(two));
            runAdvice = true;
            one = me.toString();
            two = me.toString();
            assertTrue(one.equals(two));
        }
        static class RandomToString {
            static aspect CacheToString extends CachedItem&lt;String&gt; {
                public pointcut context() : if(runAdvice);
                public pointcut caching() :  
                    execution(String RandomToString.toString());
            }
            Random random = new Random(-1);
            public String toString() {
                return "" + random.nextFloat();
            }
        }
    }

    public abstract static aspect CachedItem&lt;Result&gt; pertarget(results()){
        SoftReference&lt;Result&gt; cache;

        boolean nullCache;

        // CODE writing pointcut trifecta separate context if extended and errors
        // getcode declaring-pointcuts-to-extend-with-caching START
        /**
         * Define join points to cache.
         * Must override, with staticly-determinable pointcuts 
         * that pick out join points that are permitted.
         */
        protected abstract pointcut caching();
            
        /** ok to use Result field-get or return value */
        private pointcut permitted() : get(Result *) || execution(Result *())
            || call(Result *()) || call(Result.new(..));

        /** Subaspects may add dynamic tests for the join points. */
        pointcut context() : !disabled();

        private pointcut disabled(); // fyi, undefined == none

        // getcode results START
        /** the pointcut composed from the user, as permitted, with context */
        pointcut results() : caching() &amp;&amp; permitted() &amp;&amp; context();
        // getcode results END

        Result around() :  results() {
            // ... }
            // getcode declaring-pointcuts-to-extend-with-caching END
            Result result;
            if (nullCache) {
                result = null;
            } else if ((null == cache) 
                    || (null == (result = cache.get()))){
                result = proceed();
                if (null == result) {
                    nullCache = true;
                } else {
                    cache = new SoftReference(result);
                }
            }
            return result;
        }

    }

}


------------------------------- exception
C:\home\ws\main-31\my-ajbugs\aspectj-src\bugs\CachedToString.java [error] Internal compiler error
java.lang.StringIndexOutOfBoundsException: String index out of range: -2
	at java.lang.String.substring(String.java:1768)
	at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:86)
	at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:426)
	at org.aspectj.weaver.UnresolvedType.getOutermostType(UnresolvedType.java:601)
	at org.aspectj.weaver.ResolvedType.isVisible(ResolvedType.java:1259)
	at org.aspectj.weaver.ResolvedType.addPointcutsResolvingConflicts(ResolvedType.java:1743)
	at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1716)
	at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1710)
	at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.checkPointcutDeclarations(EclipseSourceType.java:293)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:414)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:231)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)

(no source information available)
ABORT
	
Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
String index out of range: -2

when resolving pointcut declarations CachedToString
when completing type bindings 
when batch building with classpath: c:\home\apps\jdk15\jre\lib\ext\dnsns.jar;c:\home\apps\jdk15\jre\lib\ext\localedata.jar;c:\home\apps\jdk15\jre\lib\ext\sunjce_provider.jar;c:\home\apps\jdk15\jre\lib\ext\sunpkcs11.jar;C:\home\ws\main-31\lib\junit\junit.jar;C:\home\wes\dev\tools\aspectj-1.5\lib\aspectjrt.jar;
String index out of range: -2
java.lang.StringIndexOutOfBoundsException: String index out of range: -2
	at java.lang.String.substring(String.java:1768)
	at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:86)
	at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:426)
	at org.aspectj.weaver.UnresolvedType.getOutermostType(UnresolvedType.java:601)
	at org.aspectj.weaver.ResolvedType.isVisible(ResolvedType.java:1259)
	at org.aspectj.weaver.ResolvedType.addPointcutsResolvingConflicts(ResolvedType.java:1743)
	at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1716)
	at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1710)
	at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.checkPointcutDeclarations(EclipseSourceType.java:293)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:414)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:231)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)


1 fail|abort, 1 error
Signal 127</bugreport>
<pre-fix-testcases failing="180" file="output/119543/pre-fix/testresults.xml" passing="1604" size="1784"/>
<post-fix-testcases failing="180" file="output/119543/post-fix/testresults.xml" passing="1604" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/UnresolvedType.java" revision="1.22" state="changed">598c598
&lt; 		String sig = getSignature();
---
&gt; 		String sig = getErasureSignature();
</file>
</fixedFiles>
</bug>
<bug id="119749" transactionid="69322">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="26"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="26"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-for K-if K-return K-this K-true M O-&lt; O-== O-! O-() O-&amp;&amp; O-++ T V Y Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>Per user email "after() throwing matching on interface" and the code below, the execution PCD is matching based on a throws clause declared in the overridden method of a supertype.  While this tracks the multiple-signature model for the execution join point, it's not correct to say that the method will throw the exceptions declared by the method it overrides, unless it explicitly declares them, so it seems like a bug.  (We should also document the difference between call and execution in this respect.)

In the code below, all warnings are matched by all method implementations because they implement MyInterface.

-------------------- bugs/InheritedThrows.java
package bugs;

public class InheritedThrows {

    static aspect A {
        declare warning : execution (* *.*(..) throws Ex1) : "one";
        declare warning : execution (* *.*(..) throws Ex2) : "two";
        declare warning : execution (* *.*(..) throws !(Ex1||Ex2)) : "neither";
        declare warning : execution (* *.*(..) throws Ex1, Ex2) : "both";
    }

    public static class Ex1 extends Exception {}

    public static class Ex2 extends Exception {}

    public interface MyInterface {
        public void m() throws Ex1, Ex2;
    }

    private static class NestedClass1 implements MyInterface {
        public void m() throws Ex1 {}
    }

    private static class NestedClass2 implements MyInterface {
        public void m() throws Ex2 {}
    }

    private static class NestedClassBoth implements MyInterface {
        public void m() throws Ex1, Ex2 {}
    }

    private static class NestedClassNeither implements MyInterface {
        public void m() {}
    }
}</bugreport>
<testsforfix ID="119749" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testIncorrectSignatureMatchingWithExceptions_pr119749"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="182" file="output/119749/pre-fix/testresults.xml" passing="1604" size="1786"/>
<post-fix-testcases failing="183" file="output/119749/post-fix/testresults.xml" passing="1603" size="1786"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Advice.java" revision="1.30" state="changed">119,120c119,120
&lt; 			
&lt;     		if (hasExtraParameter() &amp;&amp; kind == AdviceKind.AfterReturning) {
---
&gt; 
&gt; 			if (hasExtraParameter() &amp;&amp; kind == AdviceKind.AfterReturning) {
129a130,139
&gt; 			} else if (hasExtraParameter() &amp;&amp; kind==AdviceKind.AfterThrowing) { // pr119749
&gt; 	    			ResolvedType exceptionType = getExtraParameterType().resolve(world);
&gt; 	    			if (!exceptionType.isCheckedException()) return true;
&gt; 	    			UnresolvedType[] shadowThrows = shadow.getSignature().getExceptions(world);
&gt; 	    			boolean matches = false;
&gt; 	    			for (int i = 0; i &lt; shadowThrows.length &amp;&amp; !matches; i++) {
&gt; 						ResolvedType type = shadowThrows[i].resolve(world);
&gt; 						if (exceptionType.isAssignableFrom(type)) matches=true;
&gt; 					}
&gt; 	    			return matches;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedType.java" revision="1.41" state="changed">1885a1886,1901
&gt; 	
&gt; 	/**
&gt; 	 * @return true if assignable to java.lang.Exception
&gt; 	 */
&gt; 	public boolean isException() {
&gt; 		return (world.getCoreType(UnresolvedType.JAVA_LANG_EXCEPTION).isAssignableFrom(this));
&gt; 	}
&gt; 	
&gt; 	/**
&gt; 	 * @return true if it is an exception and it is a checked one, false otherwise.
&gt; 	 */
&gt; 	public boolean isCheckedException() {
&gt; 		if (!isException()) return false;
&gt; 		if (world.getCoreType(UnresolvedType.RUNTIME_EXCEPTION).isAssignableFrom(this)) return false;
&gt; 		return true;
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.169" state="changed">55c55
&lt;   //public void testIncorrectSignatureMatchingWithExceptions_pr119749() { runTest("incorrect exception signature matching");}
---
&gt;   public void testIncorrectSignatureMatchingWithExceptions_pr119749() { runTest("incorrect exception signature matching");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.248" state="changed">139,141c139,141
&lt;      &lt;compile files="InheritedThrows.java" options=""&gt;  
&lt;      	&lt;message kind="warning" line="19" text="one"/&gt;
&lt;      	&lt;message kind="warning" line="27" text="one"/&gt;
---
&gt;      &lt;compile files="InheritedThrows.java" options="-showWeaveInfo"&gt;  
&gt;      	&lt;message kind="weave" text="Join point 'method-execution(void InheritedThrows$NestedClassBoth.m())' in Type 'InheritedThrows$NestedClassBoth' (InheritedThrows.java:24) advised by afterThrowing advice from 'InheritedThrows$A' (InheritedThrows.java:4)"/&gt;
&gt;      	&lt;message kind="weave" text="Join point 'method-execution(void InheritedThrows$NestedClass1.m())' in Type 'InheritedThrows$NestedClass1' (InheritedThrows.java:16) advised by afterThrowing advice from 'InheritedThrows$A' (InheritedThrows.java:4)"/&gt;
</file>
<file name="org.aspectj/modules/tests/bugs150/pr119749/InheritedThrows.java" revision="1.2" state="changed">4,7c4
&lt;         declare warning : execution (* *.*(..) throws Ex1) : "one";
&lt; //        declare warning : execution (* *.*(..) throws Ex2) : "two";
&lt; //        declare warning : execution (* *.*(..) throws !(Ex1||Ex2)) : "neither";
&lt; //        declare warning : execution (* *.*(..) throws Ex1, Ex2) : "both";
---
&gt;         after() throwing(Ex1 a): execution(* *.*(..) throws Ex1) {}
19c16
&lt;         public void m() throws Ex1 {}
---
&gt;         public void m() throws Ex1 {} // MATCHES HERE
27c24
&lt;         public void m() throws Ex1, Ex2 {}
---
&gt;         public void m() throws Ex1, Ex2 {}  // MATCHES HERE
</file>
</fixedFiles>
</bug>
<bug id="120351" transactionid="71630">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-true M T V Z-if</fullfingerprint>
<bugreport>Sam wrote:

&gt; I'm trying something and it works from .aj but not from .java.  When
&gt; I try it with annotation based stuff I get a nasty exception:
&gt;
&gt;       [iajc] trouble in:
&gt;       [iajc] public class gsc.repository.IdentifierTest extends
&gt; junit.framework.TestCase:
&gt;       [iajc]   private static final org.aspectj.lang.JoinPoint
&gt; $StaticPart ajc$tjp_0
&gt;       [iajc]   public void &lt;init&gt;():
&gt;       [iajc]                     ALOAD_0
&gt;       [iajc]                     INVOKESPECIAL
&gt; junit.framework.TestCase.&lt;init&gt; ()V
&gt;       [iajc]     constructor-execution(void
&gt; gsc.repository.IdentifierTest.&lt;init&gt;())
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     constructor-execution(void
&gt; gsc.repository.IdentifierTest.&lt;init&gt;())
&gt;       [iajc]   end public void &lt;init&gt;()
&gt;
&gt;       [iajc]   public void testIdentifierExactMatch() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException:
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactMatch())
&gt;       [iajc]     |               NEW java.io.File
&gt;       [iajc]     |               DUP
&gt;       [iajc]     |               LDC "test-repository/ant-test/jars/
&gt; ant-1.6.2.jar"
&gt;       [iajc]     |               INVOKESPECIAL java.io.File.&lt;init&gt;
&gt; (Ljava/lang/String;)V
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List;
&gt;       [iajc]     |               ASTORE_1
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               ICONST_0
&gt;       [iajc]     |               INVOKEINTERFACE java.util.List.get
&gt; (I)Ljava/lang/Object;
&gt;       [iajc]     |               CHECKCAST gsc.repository.ejb.Jar
&gt;       [iajc]     |               ASTORE_2
&gt;       [iajc]     |               ALOAD_2
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.6.2"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactMatch())
&gt;       [iajc]   end public void testIdentifierExactMatch() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException
&gt;
&gt;       [iajc]   public void testIdentifierExactSameClasses() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException:
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactSameClasses())
&gt;       [iajc]     |               NEW java.io.File
&gt;       [iajc]     |               DUP
&gt;       [iajc]     |               LDC "test-jars/ant-1.6.2-test.jar"
&gt;       [iajc]     |               INVOKESPECIAL java.io.File.&lt;init&gt;
&gt; (Ljava/lang/String;)V
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List;
&gt;       [iajc]     |               ASTORE_1
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               ICONST_0
&gt;       [iajc]     |               INVOKEINTERFACE java.util.List.get
&gt; (I)Ljava/lang/Object;
&gt;       [iajc]     |               CHECKCAST gsc.repository.ejb.Jar
&gt;       [iajc]     |               ASTORE_2
&gt;       [iajc]     |               ALOAD_2
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.6.2"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactSameClasses())
&gt;       [iajc]   end public void testIdentifierExactSameClasses()
&gt; throws java.security.NoSuchAlgorithmException, java.io.IOException
&gt;
&gt;       [iajc]   public void testIdentifierMixedUp() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException:
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierMixedUp())
&gt;       [iajc]     |               NEW java.io.File
&gt;       [iajc]     |               DUP
&gt;       [iajc]     |               LDC "test-jars/groovy-1.0-beta-4-and-
&gt; commons-logging-1.0.2.jar"
&gt;       [iajc]     |               INVOKESPECIAL java.io.File.&lt;init&gt;
&gt; (Ljava/lang/String;)V
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List;
&gt;       [iajc]     |               ASTORE_1
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               INVOKEINTERFACE java.util.List.size ()I
&gt;       [iajc]     |               ICONST_2
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (II)V
&gt;       [iajc]     |               ICONST_2
&gt;       [iajc]     |               ISTORE_2
&gt;       [iajc]     |               ALOAD_1
&gt;       [iajc]     |               INVOKEINTERFACE
&gt; java.util.List.iterator ()Ljava/util/Iterator;
&gt;       [iajc]     |               ASTORE_3
&gt;       [iajc]     |           L0: ALOAD_3
&gt;       [iajc]     |               INVOKEINTERFACE
&gt; java.util.Iterator.hasNext ()Z
&gt;       [iajc]     |               IFEQ L3
&gt;       [iajc]     |               ALOAD_3
&gt;       [iajc]     |               INVOKEINTERFACE
&gt; java.util.Iterator.next ()Ljava/lang/Object;
&gt;       [iajc]     |               CHECKCAST gsc.repository.ejb.Jar
&gt;       [iajc]     |               ASTORE 4
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "groovy"
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; java.lang.String.equals (Ljava/lang/Object;)Z
&gt;       [iajc]     |               IFEQ L1
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "groovy"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getArtifactid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "groovy"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.0-beta-4"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               IINC 2 -1
&gt;       [iajc]     |               GOTO L2
&gt;       [iajc]     |           L1: ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "commons-logging"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getArtifactid ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "commons-logging"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               ALOAD 4
&gt;       [iajc]     |               INVOKEVIRTUAL
&gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String;
&gt;       [iajc]     |               LDC "1.0.2"
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/
&gt; lang/String;)V
&gt;       [iajc]     |               IINC 2 -1
&gt;       [iajc]     |           L2: GOTO L0
&gt;       [iajc]     |           L3: ILOAD_2
&gt;       [iajc]     |               ICONST_0
&gt;       [iajc]     |               INVOKESTATIC
&gt; gsc.repository.IdentifierTest.assertEquals (II)V
&gt;       [iajc]     |               RETURN
&gt;       [iajc]     method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierMixedUp())
&gt;       [iajc]   end public void testIdentifierMixedUp() throws
&gt; java.security.NoSuchAlgorithmException, java.io.IOException
&gt;
&gt;       [iajc] end public class gsc.repository.IdentifierTest
&gt;
&gt;       [iajc]
&gt;       [iajc] Exception thrown from AspectJ 1.5.0M5
&gt;
&gt;       [iajc] This might be logged as a bug already -- find current
&gt; bugs at
&gt;       [iajc]   http://bugs.eclipse.org/bugs/buglist.cgi?
&gt; product=AspectJ&amp;component=Compiler
&gt;
&gt;       [iajc] Bugs for exceptions thrown have titles File:line from
&gt; the top stack,
&gt;       [iajc] e.g., "SomeFile.java:243"
&gt;
&gt;       [iajc] If you don't find the exception below in a bug, please
&gt; add a new bug
&gt;       [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?
&gt; product=AspectJ
&gt;       [iajc] To make the bug a priority, please include a test program
&gt;       [iajc] that can reproduce this exception.
&gt;       [iajc] Incorrectly attempting counter operation on stacked cflow
&gt;
&gt;       [iajc] when implementing on shadow method-execution(void
&gt; gsc.repository.IdentifierTest.testIdentifierExactMatch())
&gt;       [iajc] when weaving type gsc.repository.IdentifierTest
&gt;       [iajc] when weaving classes
&gt;       [iajc] when weaving
&gt;       [iajc] when batch building with classpath: /Users/sam/Library/
&gt; Java/Extensions/jsk-policy.jar:/System/Library/Java/Extensions/
&gt; CoreAudio.jar:/System/Library/Java/Extensions/dns_sd.jar:/System/
&gt; Library/Java/Extensions/j3daudio.jar:/System/Library/Java/Extensions/
&gt; j3dcore.jar:/System/Library/Java/Extensions/j3dutils.jar:/System/
&gt; Library/Java/Extensions/jai_codec.jar:/System/Library/Java/Extensions/
&gt; jai_core.jar:/System/Library/Java/Extensions/mlibwrapper_jai.jar:/
&gt; System/Library/Java/Extensions/MRJToolkit.jar:/System/Library/Java/
&gt; Extensions/QTJava.zip:/System/Library/Java/Extensions/QTJSupport.jar:/
&gt; System/Library/Java/Extensions/vecmath.jar:/System/Library/Frameworks/
&gt; JavaVM.framework/Versions/1.5.0/Home/lib/ext/apple_provider.jar:/
&gt; System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/
&gt; ext/dnsns.jar:/System/Library/Frameworks/JavaVM.framework/Versions/
&gt; 1.5.0/Home/lib/ext/localedata.jar:/System/Library/Frameworks/
&gt; JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunjce_provider.jar:/
&gt; Users/sam/gs/squire/jardb/.aspectj-lib/aspectjrt-1.5.0_M5.jar:/Users/
&gt; sam/gs/squire/jardb/.aspectj-lib/aspectjtools-1.5.0_M5.jar:/Users/sam/
&gt; gs/squire/jardb/target/classes:/Users/sam/gs/squire/jardb/target/test-
&gt; classes:/Users/sam/gs/squire/jardb/.lib/antlr-2.7.5.jar:/Users/sam/gs/
&gt; squire/jardb/.lib/asm-1.5.3.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; cglib-2.1_2.jar:/Users/sam/gs/squire/jardb/.lib/commons-
&gt; collections-2.1.1.jar:/Users/sam/gs/squire/jardb/.lib/commons-
&gt; logging-1.0.4.jar:/Users/sam/gs/squire/jardb/.lib/dom4j-1.6.jar:/
&gt; Users/sam/gs/squire/jardb/.lib/ehcache-1.1.jar:/Users/sam/gs/squire/
&gt; jardb/.lib/ejb3-persistence-pr.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; emma-2.0.latest.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; emma_ant-2.0.latest.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; hibernate-3.1alpha1.jar:/Users/sam/gs/squire/jardb/.lib/hibernate-
&gt; annotations-3.1beta3.jar:/Users/sam/gs/squire/jardb/.lib/hibernate-
&gt; entitymanager-3.1beta1.jar:/Users/sam/gs/squire/jardb/.lib/
&gt; jta-1.0.jar:/Users/sam/gs/squire/jardb/.lib/junit-3.8.1.jar:/Users/
&gt; sam/gs/squire/jardb/.lib/postgresql-7.4.1-jdbc3.jar:/Users/sam/gs/
&gt; squire/jardb/.lib/svn-javahl-1.2.0.jar:/Users/sam/gs/squire/jardb/lib/
&gt; testng-4.2-jdk15.jar:/Users/sam/gs/squire/jardb/target/aspects.jar:
&gt;       [iajc] Incorrectly attempting counter operation on stacked cflow
&gt;       [iajc] java.lang.RuntimeException: Incorrectly attempting
&gt; counter operation on stacked cflow
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelShadow.weaveCflowEntry
&gt; (BcelShadow.java:1890)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelAdvice.implementOn
&gt; (BcelAdvice.java:231)
&gt;       [iajc]     at org.aspectj.weaver.Shadow.implementMungers
&gt; (Shadow.java:514)
&gt;       [iajc]     at org.aspectj.weaver.Shadow.implement(Shadow.java:391)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelClassWeaver.implement
&gt; (BcelClassWeaver.java:2142)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave
&gt; (BcelClassWeaver.java:467)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelClassWeaver.weave
&gt; (BcelClassWeaver.java:102)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave
&gt; (BcelWeaver.java:1534)
&gt;       [iajc]     at
&gt; org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:
&gt; 1485)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify
&gt; (BcelWeaver.java:1266)
&gt;       [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave
&gt; (BcelWeaver.java:1088)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave
&gt; (AjCompilerAdapter.java:300)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling
&gt; (AjCompilerAdapter.java:178)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning
&gt; $org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0
&gt; (CompilerAdapter.aj:70)
&gt;       [iajc]     at
&gt; org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile
&gt; (Compiler.java:367)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation
&gt; (AjBuildManager.java:809)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
&gt; (AjBuildManager.java:230)
&gt;       [iajc]     at
&gt; org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild
&gt; (AjBuildManager.java:156)
&gt;       [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand
&gt; (AjdtCommand.java:112)
&gt;       [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand
&gt; (AjdtCommand.java:60)
&gt;       [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:326)
&gt;       [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
&gt;       [iajc]     at
&gt; org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:
&gt; 1210)
&gt;       [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute
&gt; (AjcTask.java:1001)
&gt;       [iajc]     at org.apache.tools.ant.UnknownElement.execute
&gt; (UnknownElement.java:275)
&gt;       [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
&gt;       [iajc]     at org.apache.tools.ant.taskdefs.Sequential.execute
&gt; (Sequential.java:64)
&gt;       [iajc]     at org.apache.tools.ant.UnknownElement.execute
&gt; (UnknownElement.java:275)
&gt;       [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
&gt;       [iajc]     at
&gt; org.apache.tools.ant.taskdefs.MacroInstance.execute
&gt; (MacroInstance.java:378)
&gt;       [iajc]     at org.apache.tools.ant.UnknownElement.execute
&gt; (UnknownElement.java:275)
&gt;       [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
&gt;       [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
&gt;       [iajc]     at org.apache.tools.ant.Target.performTasks
&gt; (Target.java:369)
&gt;       [iajc]     at org.apache.tools.ant.Project.executeSortedTargets
&gt; (Project.java:1216)
&gt;       [iajc]     at org.apache.tools.ant.Project.executeTarget
&gt; (Project.java:1185)
&gt;       [iajc]     at
&gt; org.apache.tools.ant.helper.DefaultExecutor.executeTargets
&gt; (DefaultExecutor.java:40)
&gt;       [iajc]     at org.apache.tools.ant.Project.executeTargets
&gt; (Project.java:1068)
&gt;       [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:668)
&gt;       [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:187)
&gt;       [iajc]     at org.apache.tools.ant.launch.Launcher.run
&gt; (Launcher.java:246)
&gt;       [iajc]     at org.apache.tools.ant.launch.Launcher.main
&gt; (Launcher.java:67)
&gt;
&gt;
&gt; package gsc.aspects.testing;
&gt;
&gt; import junit.framework.*;
&gt; import java.io.*;
&gt; import java.util.*;
&gt;
&gt; import org.aspectj.lang.annotation.Pointcut;
&gt; import org.aspectj.lang.annotation.Before;
&gt; import org.aspectj.lang.annotation.Aspect;
&gt; import org.aspectj.lang.annotation.After;
&gt; import org.aspectj.lang.JoinPoint;
&gt;
&gt; @Aspect
&gt; public class TestMethodMapperAnnotations {
&gt;
&gt;      @Pointcut("this(testCase) &amp;&amp; this(TestCase) &amp;&amp; execution(void
&gt; test*())")
&gt;      public void inTestClass(TestCase testCase) {
&gt;      }
&gt;
&gt;      private Map&lt;String, Map&lt;String, Integer&gt;&gt; coverage;
&gt;
&gt;      @Before("cflowbelow(inTestClass(testCase)) &amp;&amp; execution(* *(..))")
&gt;      public void beforeMethodExecution(JoinPoint thisJoinPoint,
&gt; TestCase testCase) {
&gt;          String testname = testCase.getClass().getName();
&gt;          String methodSignature = thisJoinPoint.getStaticPart
&gt; ().getSignature().toString();
&gt;          Map&lt;String, Integer&gt; tests = coverage.get(methodSignature);
&gt;          if (tests == null) {
&gt;              tests = new HashMap&lt;String, Integer&gt;();
&gt;              coverage.put(methodSignature, tests);
&gt;          }
&gt;          Integer count = tests.get(testname);
&gt;          if (count == null) {
&gt;              count = 1;
&gt;          } else {
&gt;              count++;
&gt;          }
&gt;          tests.put(testname, count);
&gt;      }
&gt;
&gt;      @Before("inTestClass(testCase)")
&gt;      public void beforeExecutingTestMethod(TestCase testCase) {
&gt;          try {
&gt;              File file = new File("results.ser");
&gt;              if (file.exists()) {
&gt;                  ObjectInputStream ois = new ObjectInputStream(new
&gt; FileInputStream(file));
&gt;                  coverage = (Map&lt;String, Map&lt;String, Integer&gt;&gt;)
&gt; ois.readObject();
&gt;                  ois.close();
&gt;              } else {
&gt;                  coverage = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();
&gt;              }
&gt;          } catch (Exception e) {
&gt;              e.printStackTrace();
&gt;          }
&gt;      }
&gt;
&gt;      @After("inTestClass(testCase)")
&gt;      public void afterExecutingTestMethod(TestCase testCase) {
&gt;          try {
&gt;              File file = new File("results.ser");
&gt;              ObjectOutputStream oos = new ObjectOutputStream(new
&gt; FileOutputStream(file));
&gt;              oos.writeObject(coverage);
&gt;              oos.close();
&gt;          } catch (Exception e) {
&gt;              e.printStackTrace();
&gt;          }
&gt;      }
&gt;
&gt; }
&gt;
&gt; vs.
&gt;
&gt; package gsc.aspects.testing;
&gt;
&gt; import junit.framework.*;
&gt; import java.io.*;
&gt; import java.util.*;
&gt;
&gt; public aspect TestMethodMapper {
&gt;
&gt;      pointcut inTestClass(TestCase testCase) : this(testCase) &amp;&amp; this
&gt; (TestCase) &amp;&amp; execution(void test*());
&gt;      private Map&lt;String, Map&lt;String, Integer&gt;&gt; coverage;
&gt;
&gt;      before(TestCase testCase) : cflowbelow(inTestClass(testCase)) &amp;&amp;
&gt; execution(* *(..)) {
&gt;         String testname = testCase.getClass().getName();
&gt;         String methodSignature = thisJoinPointStaticPart.getSignature
&gt; ().toString();
&gt;         Map&lt;String, Integer&gt; tests = coverage.get(methodSignature);
&gt;         if (tests == null) {
&gt;             tests = new HashMap&lt;String, Integer&gt;();
&gt;             coverage.put(methodSignature, tests);
&gt;         }
&gt;         Integer count = tests.get(testname);
&gt;         if (count == null) {
&gt;             count = 1;
&gt;         } else {
&gt;              count++;
&gt;         }
&gt;         tests.put(testname, count);
&gt;      }
&gt;
&gt;      before(TestCase testCase) : inTestClass(testCase) {
&gt;         try {
&gt;             File file = new File("results.ser");
&gt;             if (file.exists()) {
&gt;                 ObjectInputStream ois = new ObjectInputStream(new FileInputStream
&gt; (file));
&gt;                 coverage = (Map&lt;String, Map&lt;String, Integer&gt;&gt;) ois.readObject();
&gt;                 ois.close();
&gt;             } else {
&gt;                 coverage = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();
&gt;             }
&gt;         } catch (Exception e) {
&gt;             e.printStackTrace();
&gt;         }
&gt;      }
&gt;
&gt;      after(TestCase testCase) : inTestClass(testCase) {
&gt;         try {
&gt;             File file = new File("results.ser");
&gt;             ObjectOutputStream oos = new ObjectOutputStream(new
&gt; FileOutputStream(file));
&gt;             oos.writeObject(coverage);
&gt;             oos.close();
&gt;         } catch (Exception e) {
&gt;             e.printStackTrace();
&gt;         }
&gt;      }
&gt;
&gt; }
&gt;
&gt;
&gt;</bugreport>
<testsforfix ID="120351" type="new">
    <file LOCATION="org.aspectj/modules/tests/java5/ataspectj/ataspectj/bugs/CflowBelowStackTest.java">
      <test NAME="testMe"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
      <test NAME="testCflowBelowStack"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml">
      <test NAME="CflowBelowStack"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="183" file="output/120351/pre-fix/testresults.xml" passing="1601" size="1784"/>
<post-fix-testcases failing="180" file="output/120351/post-fix/testresults.xml" passing="1604" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java" revision="1.41" state="changed">598c598
&lt; 	public BcelVar[] getExposedStateAsBcelVars() {
---
&gt; 	public BcelVar[] getExposedStateAsBcelVars(boolean isAround) {
600,602c600,604
&lt;         // the closure instantiation has the same mapping as the extracted method from wich it is called
&lt;         if (getConcreteAspect()!= null &amp;&amp; getConcreteAspect().isAnnotationStyleAspect()) {
&lt;             return BcelVar.NONE;
---
&gt;         if (isAround) {
&gt;             // the closure instantiation has the same mapping as the extracted method from wich it is called
&gt;             if (getConcreteAspect()!= null &amp;&amp; getConcreteAspect().isAnnotationStyleAspect()) {
&gt;                 return BcelVar.NONE;
&gt;             }
605c607
&lt; 		//System.out.println("vars: " + Arrays.asList(exposedState.vars));
---
&gt;         //System.out.println("vars: " + Arrays.asList(exposedState.vars));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.86" state="changed">1897c1897
&lt; 				BcelVar[] cflowStateVars = munger.getExposedStateAsBcelVars();
---
&gt; 				BcelVar[] cflowStateVars = munger.getExposedStateAsBcelVars(false);
1961c1961
&lt; 					munger.getExposedStateAsBcelVars().length==0) {
---
&gt; 					munger.getExposedStateAsBcelVars(false).length==0) {
2345c2345
&lt; 		BcelVar[] adviceVars = munger.getExposedStateAsBcelVars();		
---
&gt; 		BcelVar[] adviceVars = munger.getExposedStateAsBcelVars(true);
2590c2590
&lt;     	BcelVar[] adviceVars = munger.getExposedStateAsBcelVars();
---
&gt;     	BcelVar[] adviceVars = munger.getExposedStateAsBcelVars(true);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java" revision="1.23" state="changed">202a203,206
&gt;     public void testCflowBelowStack() {
&gt;         runTest("CflowBelowStack");
&gt;     }
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml" revision="1.20" state="changed">279a280,288
&gt; 
&gt;     &lt;ajc-test dir="java5/ataspectj" title="CflowBelowStack"&gt;
&gt;         &lt;compile
&gt;             files="ataspectj/bugs/CflowBelowStackTest.java,ataspectj/TestHelper.java"
&gt;             options="-1.5 -verbose "/&gt;
&gt;         &lt;run class="ataspectj.bugs.CflowBelowStackTest" ltw="ataspectj/bugs/aop-cflowbelowstacktest.xml"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt; 
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/bugs/CflowBelowStackTest.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
package ataspectj.bugs;

import ataspectj.TestHelper;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.HashMap;
import java.util.Map;

/**
 * @author &lt;a href="mailto:alex AT gnilux DOT com"&gt;Alexandre Vasseur&lt;/a&gt;
 */
public class CflowBelowStackTest extends TestCase {

    public void testMe() {
        assertTrue(true);
    }

    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }

    public static Test suite() {
        return new TestSuite(CflowBelowStackTest.class);
    }


    @Aspect
    public static class TestAspect {

        @Pointcut("this(testCase) &amp;&amp; execution(void test*())")
        public void inTestClass(TestCase testCase) {
        }

        private Map&lt;String, Map&lt;String, Integer&gt;&gt; coverage;

        @Before("cflowbelow(inTestClass(testCase)) &amp;&amp; execution(* *(..))")
        public void beforeMethodExecution(JoinPoint thisJoinPoint, TestCase testCase) {
            String testname = testCase.getClass().getName();
            String methodSignature = thisJoinPoint.getStaticPart().getSignature().toString();
            Map&lt;String, Integer&gt; tests = coverage.get(methodSignature);
            if (tests == null) {
                tests = new HashMap&lt;String, Integer&gt;();
                coverage.put(methodSignature, tests);
            }
            Integer count = tests.get(testname);
            if (count == null) {
                count = 1;
            } else {
                count++;
            }
            tests.put(testname, count);
        }

        @Before("inTestClass(testCase)")
        public void beforeExecutingTestMethod(TestCase testCase) {
            try {
                File file = new File("results.ser");
                if (file.exists()) {
                    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
                    coverage = (Map&lt;String, Map&lt;String, Integer&gt;&gt;) ois.readObject();
                    ois.close();
                } else {
                    coverage = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        @After("inTestClass(testCase)")
        public void afterExecutingTestMethod(TestCase testCase) {
            try {
                File file = new File("results.ser");
                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
                oos.writeObject(coverage);
                oos.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/bugs/aop-cflowbelowstacktest.xml" revision="1.1" state="new">&lt;aspectj&gt;
    &lt;weaver options="-1.5 -showWeaveInfo"&gt;
    &lt;/weaver&gt;
    &lt;aspects&gt;
        &lt;aspect name="ataspectj.bugs.CflowBelowStackTest.TestAspect"/&gt;
    &lt;/aspects&gt;
&lt;/aspectj&gt;</file>
</fixedFiles>
</bug>
<bug id="120356" transactionid="69749">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="37"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="39"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-null K-return M O-- O-!= O-&amp;&amp; O-+ T V Y Z-if</fullfingerprint>
<bugreport>Perhaps an issue in the ASM struct for DEOW
since cross struct. is empty in AJDT , despite error / warning gutter and message is ok.</bugreport>
<testsforfix ID="120356" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testAtAspectDEOWInStructureModel_pr120356"/>
      <test NAME="testAtAspectNoNPEWithDEOWWithoutStructureModel_pr120356"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="@AJ deow appear correctly when structure model is generated"/>
      <test NAME="@AJ no NPE with deow when structure model isn't generated"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="182" file="output/120356/pre-fix/testresults.xml" passing="1802" size="1984"/>
<post-fix-testcases failing="180" file="output/120356/post-fix/testresults.xml" passing="1804" size="1984"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java" revision="1.32" state="changed">35a36,38
&gt; import org.aspectj.asm.AsmManager;
&gt; import org.aspectj.asm.IHierarchy;
&gt; import org.aspectj.asm.IProgramElement;
1250c1253
&lt;                     deow.setLocation(struct.context, -1, -1);
---
&gt;                     setDeclareErrorOrWarningLocation(deow,struct);
1277c1280
&lt;                     deow.setLocation(struct.context, -1, -1);
---
&gt;                     setDeclareErrorOrWarningLocation(deow,struct);
1286a1290,1323
&gt;      * Sets the location for the declare error / warning using the corresponding 
&gt;      * IProgramElement in the structure model. This will only fix bug 120356 if
&gt;      * compiled with -emacssym, however, it does mean that the cross references 
&gt;      * view in AJDT will show the correct information.
&gt;      * 
&gt;      * Other possibilities for fix: 
&gt;      *  1. using the information in ajcDeclareSoft (if this is set correctly) 
&gt;      *     which will fix the problem if compiled with ajc but not if compiled 
&gt;      *     with javac.
&gt;      *  2. creating an AjAttribute called FieldDeclarationLineNumberAttribute 
&gt;      *     (much like MethodDeclarationLineNumberAttribute) which we can ask 
&gt;      *     for the offset. This will fix bug 120356 both when compiled with ajc 
&gt;      *     and javac.
&gt;      * 
&gt;      * @param deow
&gt;      * @param struct
&gt;      */
&gt;     private static void setDeclareErrorOrWarningLocation(DeclareErrorOrWarning deow, AjAttributeFieldStruct struct) {
&gt;         IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt;         if (top.getRoot() != null) {
&gt;         	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
&gt;       			  IProgramElement.Kind.FIELD,struct.field.getName());
&gt;         	if (ipe != null &amp;&amp; ipe.getSourceLocation() != null) {
&gt;     			ISourceLocation sourceLocation = ipe.getSourceLocation();
&gt;     			int start = sourceLocation.getOffset();
&gt;     			int end = start + struct.field.getName().length();
&gt;     			deow.setLocation(struct.context,start,end);
&gt;     			return;
&gt;     		}
&gt; 		}
&gt;         deow.setLocation(struct.context, -1, -1);												
&gt;     }
&gt;     
&gt;     /**
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.18" state="changed">13a14
&gt; import java.util.List;
19a21
&gt; import org.aspectj.asm.internal.Relationship;
88a91,151
&gt;   public void testAtAspectDEOWInStructureModel_pr120356() {
&gt; 	  //AsmManager.setReporting("c:/debug.txt",true,true,true,true);
&gt; 	  runTest("@AJ deow appear correctly when structure model is generated");  
&gt;   	  IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt;   	   
&gt;   	  // get the IProgramElements corresponding to the @DeclareWarning statement
&gt;   	  // and the method it matches.
&gt;   	  IProgramElement warningMethodIPE = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.METHOD,"warningMethod()");  	   	 
&gt;   	  assertNotNull("Couldn't find 'warningMethod()' element in the tree",warningMethodIPE);
&gt;   	  IProgramElement atDeclareWarningIPE = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.FIELD,"warning");
&gt;   	  assertNotNull("Couldn't find @DeclareWarning element in the tree",atDeclareWarningIPE);
&gt; 
&gt;   	  // check that the method has a matches declare relationship with @DeclareWarning
&gt;   	  List matches = AsmManager.getDefault().getRelationshipMap().get(warningMethodIPE);	
&gt;   	  assertNotNull("warningMethod should have some relationships but does not",matches);
&gt;   	  assertTrue("warningMethod should have one relationships but has " + matches.size(),matches.size()==1);
&gt;   	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("warningMethod should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
&gt;   	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the @DeclareWarning 'warning' but is IPE with label "
&gt;   			  + target.toLabelString(),atDeclareWarningIPE,target);
&gt;   	  
&gt;   	  // check that the @DeclareWarning has a matches relationship with the warningMethod
&gt;   	  List matchedBy = AsmManager.getDefault().getRelationshipMap().get(atDeclareWarningIPE);
&gt;   	  assertNotNull("@DeclareWarning should have some relationships but does not",matchedBy);
&gt;   	  assertTrue("@DeclareWarning should have one relationship but has " + matchedBy.size(), matchedBy.size() == 1);
&gt;   	  List matchedByTargets = ((Relationship)matchedBy.get(0)).getTargets();
&gt;   	  assertTrue("@DeclareWarning 'matched by' relationship should have one target " +
&gt;   	  		"but has " + matchedByTargets.size(), matchedByTargets.size() == 1);
&gt;   	  IProgramElement matchedByTarget = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchedByTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the warningMethod but is IPE with label "
&gt;   			  + matchedByTarget.toLabelString(),warningMethodIPE,matchedByTarget);
&gt;   	  
&gt;   	  // get the IProgramElements corresponding to the @DeclareError statement
&gt;   	  // and the method it matches.
&gt;   	  IProgramElement errorMethodIPE = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.METHOD,"badMethod()");  	   	 
&gt;   	  assertNotNull("Couldn't find 'badMethod()' element in the tree",errorMethodIPE);
&gt;   	  IProgramElement atDeclarErrorIPE = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.FIELD,"error");
&gt;   	  assertNotNull("Couldn't find @DeclareError element in the tree",atDeclarErrorIPE);
&gt; 
&gt;   	  // check that the @DeclareError has a matches relationship with the badMethod
&gt;   	  List matchedByE = AsmManager.getDefault().getRelationshipMap().get(atDeclarErrorIPE);
&gt;   	  assertNotNull("@DeclareError should have some relationships but does not",matchedByE);
&gt;   	  assertTrue("@DeclareError should have one relationship but has " + matchedByE.size(), matchedByE.size() == 1);
&gt;   	  List matchedByTargetsE = ((Relationship)matchedByE.get(0)).getTargets();
&gt;   	  assertTrue("@DeclareError 'matched by' relationship should have one target " +
&gt;   	  		"but has " + matchedByTargetsE.size(), matchedByTargetsE.size() == 1);
&gt;   	  IProgramElement matchedByTargetE = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchedByTargetsE.get(0));
&gt;   	  assertEquals("target of relationship should be the badMethod but is IPE with label "
&gt;   			  + matchedByTargetE.toLabelString(),errorMethodIPE,matchedByTargetE);
&gt; 
&gt;   }
&gt;   
&gt;   public void testAtAspectNoNPEWithDEOWWithoutStructureModel_pr120356() {
&gt; 	  runTest("@AJ no NPE with deow when structure model isn't generated"); 
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.16" state="changed">144a145,158
&gt;     &lt;ajc-test dir="bugs151/pr120356" title="@AJ deow appear correctly when structure model is generated"&gt;
&gt;         &lt;compile files="C.java, A.java" options="-1.5, -emacssym"&gt;
&gt;          &lt;message kind="error" line="8" text="error"/&gt;
&gt;           &lt;message kind="warning" line="5" text="warning"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt; 
&gt; 
&gt;     &lt;ajc-test dir="bugs151/pr120356" title="@AJ no NPE with deow when structure model isn't generated"&gt;
&gt;         &lt;compile files="C.java, A.java" options="-1.5"&gt;
&gt;          &lt;message kind="error" line="8" text="error"/&gt;
&gt;           &lt;message kind="warning" line="5" text="warning"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs151/pr120356/C.java" revision="1.1" state="new">

public class C {

	public void warningMethod() {
	}
	
	public void badMethod() {
	}
	
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr120356/A.java" revision="1.1" state="new">
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareWarning;
import org.aspectj.lang.annotation.DeclareError;

@Aspect
public class A {

	@DeclareWarning("execution(* C.warningMethod())")
    static final String warning = "warning";

    @DeclareError("execution(* C.badMethod())")
    static final String error = "error";
	
}
</file>
</fixedFiles>
</bug>
<bug id="120363" transactionid="70005">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="9"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-return K-true M T V Z-if</fullfingerprint>
<bugreport>According to the specification (http://www.eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html) "The set of types to be woven are those types matched by at least one weaver include element and not matched by any weaver exclude element." However if an includ elemement can be fast matched e.g. "com.foo..*" any exclude elements are ignored (see bug 117854). There is no explicit test in the harness for this feature.</bugreport>
<pre-fix-testcases failing="183" file="output/120363/pre-fix/testresults.xml" passing="1601" size="1784"/>
<post-fix-testcases failing="181" file="output/120363/post-fix/testresults.xml" passing="1603" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.35" state="changed">468,472c468,480
&lt;         boolean fastAccept = false;//defaults to false if no fast include
&lt;         for (int i = 0; i &lt; m_includeStartsWith.size(); i++) {
&lt;             fastAccept = fastClassName.startsWith((String)m_includeStartsWith.get(i));
&lt;             if (fastAccept) {
&lt;                 break;
---
&gt;         
&gt;         /* 
&gt;          * Bug 120363
&gt;          * If we have an exclude pattern that cannot be matched using "starts with"
&gt;          * then we cannot fast accept
&gt;          */ 
&gt;         if (m_excludeTypePattern.isEmpty()) {
&gt;             boolean fastAccept = false;//defaults to false if no fast include
&gt;             for (int i = 0; i &lt; m_includeStartsWith.size(); i++) {
&gt;                 fastAccept = fastClassName.startsWith((String)m_includeStartsWith.get(i));
&gt;                 if (fastAccept) {
&gt;                     break;
&gt;                 }
475,477d482
&lt;         if (fastAccept) {
&lt;             return true;
&lt;         }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml" revision="1.21" state="changed">95c95
&lt; 
---
&gt;     
98c98
&lt;                 files="ataspectj/Test$$EnhancerByCGLIB$$12345.java"
---
&gt;                 files="com/foo/bar/Test.java, com/foo/bar/Test$$EnhancerByCGLIB$$12345.java"
100c100,108
&lt;         &lt;run class="ataspectj.Test$$EnhancerByCGLIB$$12345" ltw="ataspectj/aop-dumpbeforeandafter.xml"/&gt;
---
&gt;         &lt;run class="com.foo.bar.Test$$EnhancerByCGLIB$$12345" ltw="ataspectj/aop-dumpbeforeandafter.xml"&gt;
&gt;         	&lt;stdout&gt;
&gt;         		&lt;line text="Test$$EnhancerByCGLIB$$12345.main()"/&gt;
&gt;         		&lt;line text="Test.main()"/&gt;
&gt;             &lt;/stdout&gt;
&gt;         	&lt;stderr&gt;
&gt;         		&lt;line text="info weaving 'com.foo.bar.Test'"/&gt;
&gt;             &lt;/stderr&gt;
&gt;         &lt;/run&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/com/foo/bar/Test.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package com.foo.bar;

public class Test {

	public static void main(String[] args) {
		System.out.println("Test.main()");
	}

}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java" revision="1.24" state="changed">99a100,105
&gt;         
&gt;         // before
&gt;         File f = new File("_ajdump/_before/com/foo/bar");
&gt;         CountingFilenameFilter cff = new CountingFilenameFilter();
&gt;         f.listFiles(cff);
&gt;         assertEquals("Expected dump file in " + f.getAbsolutePath(),1,cff.getCount());
101,104c107,111
&lt;         File f = new File("_ajdump/_before/ataspectj/Test$$EnhancerByCGLIB$$12345.class");
&lt;         assertTrue(f.exists());
&lt;         f = new File("_ajdump/ataspectj/Test$$EnhancerByCGLIB$$12345.class");
&lt;         assertTrue(f.exists());
---
&gt;         // after
&gt;         f = new File("_ajdump/com/foo/bar");
&gt;         cff = new CountingFilenameFilter();
&gt;         f.listFiles(cff);
&gt;         assertEquals("Expected dump file in " + f.getAbsolutePath(),1,cff.getCount());
130d136
&lt;         System.out.println("AtAjLTWTests.testLTWDumpProxy() f=" + f.getAbsolutePath());
135d140
&lt;         System.out.println("AtAjLTWTests.testLTWDumpProxy() f=" + f.getAbsolutePath());
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/aop-dumpbeforeandafter.xml" revision="1.3" state="changed">3,5c3,7
&lt;     &lt;weaver options="-verbose"&gt;
&lt;         &lt;dump within="ataspectj..*" beforeandafter="true"/&gt; 
&lt;     &lt;/weaver&gt;
---
&gt;     &lt;weaver options="-XlazyTjp -verbose"&gt;
&gt;         &lt;dump within="com.foo.bar..*" beforeandafter="true"/&gt; 
&gt;         &lt;include within="com.foo..*"/&gt;
&gt;         &lt;exclude within="com.foo.bar..*CGLIB*"/&gt;
&gt; 	&lt;/weaver&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/com/foo/bar/Test$$EnhancerByCGLIB$$12345.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package com.foo.bar;

public class Test$$EnhancerByCGLIB$$12345 {

	public static void main(String[] args) {
		System.out.println("Test$$EnhancerByCGLIB$$12345.main()");
		Test.main(args);
	}

}
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/Test$$EnhancerByCGLIB$$12345.java" revision="1.2" state="deleted"/>
</fixedFiles>
</bug>
<bug id="120401" transactionid="75735">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>Z</concisefingerprint>
<fullfingerprint>O-+ T V Y Z-throw</fullfingerprint>
<tag>exception</tag>
<bugreport>I keep getting UnresolvedType UnsupportedOperationException unhelpful message "resolve this type first," so I'm adding the signature to the message (without permission, hence the bug as notice).

throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);


-------------------------------
java.lang.UnsupportedOperationException
at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:218)
at org.aspectj.weaver.patterns.ExactTypePattern.parameterizeWith(ExactTypePattern.java:242)
at org.aspectj.weaver.patterns.TypePatternList.parameterizeWith(TypePatternList.java:195)
at org.aspectj.weaver.patterns.DeclareParents.parameterizeWith(DeclareParents.java:77)
at org.aspectj.weaver.ReferenceType.getDeclares(ReferenceType.java:484)
at org.aspectj.weaver.ResolvedType.collectDeclares(ResolvedType.java:523)
at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:488)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:60)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:378)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:388)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:314)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

UnsupportedOperationException thrown: resolve this type first</bugreport>
<pre-fix-testcases failing="180" file="output/120401/pre-fix/testresults.xml" passing="1604" size="1784"/>
<post-fix-testcases failing="182" file="output/120401/post-fix/testresults.xml" passing="1602" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/UnresolvedType.java" revision="1.23" state="changed">218c218
&lt;     	throw new UnsupportedOperationException("resolve this type first");
---
&gt;     	throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);
</file>
</fixedFiles>
</bug>
<bug id="120474" transactionid="68341">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>Z</concisefingerprint>
<fullfingerprint>O-&gt; O-- O-!= Y Z-while</fullfingerprint>
<bugreport>I am seeing a BCException that gets caught and prints a stack trace in Aj.preProcess when loading a class named "$Proxy4"

This occurs in UnresolvedType.nameToSignature because the string it receives from ResolvedType.getDeclaringType is "" (i.e., it strips off the leading $, treating the type as if it were a nested type of nothing).

I'm not sure of the best resolution, but maybe the loop in ResolvedType should just say while (lastDollar &gt; 0). This would handle the "leading $" case as an identifier rather than trying to look up the empty string. This might help with Hibernate's $$ types too...

Here is the stack when it happens:
UnresolvedType.nameToSignature(String) line: 774
UnresolvedType.forName(String) line: 309
ReferenceType(ResolvedType).getDeclaringType() line: 1255
WithinPointcut.isWithinType(ResolvedType) line: 50
WithinPointcut.fastMatch(FastMatchInfo) line: 67
AndPointcut.fastMatch(FastMatchInfo) line: 51
AndPointcut.fastMatch(FastMatchInfo) line: 51
AndPointcut.fastMatch(FastMatchInfo) line: 51
AndPointcut.fastMatch(FastMatchInfo) line: 51
AndPointcut.fastMatch(FastMatchInfo) line: 51
BcelWeaver.fastMatch(List, ResolvedType) line: 1635
BcelWeaver.weave(UnwovenClassFile, BcelObjectType, boolean) line: 1516
BcelWeaver.weaveWithoutDump(UnwovenClassFile, BcelObjectType) line: 1494
BcelWeaver.weaveAndNotify(UnwovenClassFile, BcelObjectType, IWeaveRequestor) line: 1275
BcelWeaver.weave(IClassFileProvider) line: 1097
ClassLoaderWeavingAdaptor(WeavingAdaptor).getWovenBytes(String, byte[]) line: 261
ClassLoaderWeavingAdaptor(WeavingAdaptor).weaveClass(String, byte[]) line: 194
Aj.preProcess(String, byte[], ClassLoader) line: 65</bugreport>
<testsforfix ID="120474" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testDollarClasses_pr120474"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="Dollar classes"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="181" file="output/120474/pre-fix/testresults.xml" passing="1603" size="1784"/>
<post-fix-testcases failing="181" file="output/120474/post-fix/testresults.xml" passing="1603" size="1784"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedType.java" revision="1.39" state="changed">1254c1254
&lt; 		while (lastDollar != -1) {
---
&gt; 		while (lastDollar &gt;0) { // allow for classes starting '$' (pr120474)
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.166" state="changed">44c44
&lt; 
---
&gt;   public void testDollarClasses_pr120474() { runTest("Dollar classes");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.246" state="changed">176a177,180
&gt;     
&gt;     &lt;ajc-test dir="bugs150/pr120474" pr="120474" title="Dollar classes"&gt;
&gt;      &lt;compile files="$Proxy4.java,X.aj"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs150/pr120474/X.aj" revision="1.1" state="new">public aspect X {
  before(): execution(* foo(..)) &amp;&amp; !within(X) { }
}
</file>
<file name="org.aspectj/modules/tests/bugs150/pr120474/$Proxy4.java" revision="1.1" state="new">public class $Proxy4 {
  public void foo() {}
}
</file>
</fixedFiles>
</bug>
<bug id="120543" transactionid="69122">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-import M O-+ Y</fullfingerprint>
<bugreport>It would be very useful to know exactly which version of the weaver is being used for LTW. An informational message could be issued when each WeavingAdaptor instance is created (it is possible to have multiple versions of AspectJ in a system). This message could be similar to the that issued by "ajc -version".</bugreport>
<testsforfix ID="120543" type="changed">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/ltw-tests.xml">
      <test NAME="Ensure no weaving without visible aop.xml"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/120543/pre-fix/testresults.xml" passing="1606" size="1786"/>
<post-fix-testcases failing="124" file="output/120543/post-fix/testresults.xml" passing="1200" size="1324"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.25" state="changed">37a38
&gt; import org.aspectj.bridge.Version;
165a167
&gt; 		info("AspectJ Weaver Version " + Version.text + " built on " + Version.time_text);  //$NON-NLS-1$
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/ltw-tests.xml" revision="1.7" state="changed">106a107
&gt; 				&lt;line text="info AspectJ Weaver Version"/&gt;
</file>
</fixedFiles>
</bug>
<bug id="120739" transactionid="74332">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="12"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="12"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-null M O-== O-+ T V Y Z-if</fullfingerprint>
<bugreport>This optimization disables weaving for a ClassLoader where there are no aspects defined. This is actually useful if you have aspect exclusions that exclude all the aspects defined in a parent class loader. It is also helpful in the trivial/rare case where there is an aop.xml definition with no aspect definitions.</bugreport>
<testsforfix ID="120739" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testNoAspects"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="Ensure no weaving without included aspects"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="188" file="output/120739/pre-fix/testresults.xml" passing="1827" size="2015"/>
<post-fix-testcases failing="187" file="output/120739/post-fix/testresults.xml" passing="1828" size="2015"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.43" state="changed">124a125
&gt;         if (enabled) {
126,129c127,135
&lt;         //bcelWorld.setResolutionLoader(loader.getParent());//(ClassLoader)null);//
&lt;         
&lt;         // after adding aspects
&lt;         weaver.prepareForWeave();
---
&gt;             //bcelWorld.setResolutionLoader(loader.getParent());//(ClassLoader)null);//
&gt;             
&gt;             // after adding aspects
&gt;             weaver.prepareForWeave();
&gt;         }
&gt;         else {
&gt;         	bcelWorld = null;
&gt;         	weaver = null;
&gt;         }
370a377,382
&gt;         
&gt;         /* We didn't register any aspects so disable the adaptor */
&gt;         if (namespace == null) {
&gt;         	enabled = false;
&gt;     		info("no aspects registered. Disabling weaver for class loader " + getClassLoaderName(loader));
&gt;         }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml" revision="1.24" state="changed">90a91,93
&gt;                 files="ataspectj/EmptyAspect.aj"
&gt;                 options="-1.5 -Xlint:ignore"/&gt;
&gt;         &lt;compile
97a101,103
&gt;                 files="ataspectj/EmptyAspect.aj"
&gt;                 options="-1.5 -Xlint:ignore"/&gt;
&gt;         &lt;compile
108a115
&gt; 				&lt;line text="info register aspect ataspectj.EmptyAspect"/&gt;
122a130,132
&gt;                 files="ataspectj/EmptyAspect.aj"
&gt;                 options="-1.5 -Xlint:ignore"/&gt;
&gt;         &lt;compile
253c263
&lt;                 files="ataspectj/ltwlog/MessageHolder.java,ataspectj/ltwreweavable/MainReweavableLogging.java,ataspectj/ltwreweavable/AspectReweavableLogging.java,ataspectj/ltwreweavable/Advisable.java"
---
&gt;                 files="ataspectj/ltwlog/MessageHolder.java,ataspectj/ltwreweavable/MainReweavableLogging.java,ataspectj/ltwreweavable/AspectReweavableLogging.java,ataspectj/ltwreweavable/Advisable.java,ataspectj/ltwreweavable/EmptyAtAspect.java"
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.39" state="changed">18d17
&lt; //import org.aspectj.systemtest.ajc150.GenericsTests;
135a135,139
&gt; 	
&gt; 	public void testNoAspects(){
&gt; //		setSystemProperty(WeavingAdaptor.WEAVING_ADAPTOR_VERBOSE,"true");
&gt; 		runTest("Ensure no weaving without included aspects");
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.34" state="changed">609a610,631
&gt; 
&gt; 	&lt;ajc-test dir="ltw"
&gt;       title="Ensure no weaving without included aspects"
&gt;       keywords="reweavable"&gt;
&gt;         &lt;compile
&gt;         	files="TestMain.java, Main.java"
&gt;         &gt;
&gt;         &lt;/compile&gt;	
&gt;         &lt;run class="TestMain" ltw="aop-optionsonly.xml"&gt;
&gt;         	&lt;stdout&gt;
&gt;                 &lt;line text="Main.main"/&gt;
&gt;                 &lt;line text="Main.test1"/&gt;
&gt;                 &lt;line text="Main.test2"/&gt;
&gt;             &lt;/stdout&gt;
&gt;         	&lt;stderr&gt;
&gt; 				&lt;line text="info AspectJ Weaver Version"/&gt;
&gt; 				&lt;line text="info register classloader org.aspectj.weaver.loadtime.WeavingURLClassLoader"/&gt;
&gt; 				&lt;line text="info using"/&gt;
&gt; 				&lt;line text="info no aspects registered. Disabling weaver for class loader org.aspectj.weaver.loadtime.WeavingURLClassLoader"/&gt;
&gt;             &lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/aop-dumpbeforeandafter.xml" revision="1.4" state="changed">2a3,5
&gt; 	&lt;aspects&gt;
&gt; 		&lt;aspect name="ataspectj.EmptyAspect"/&gt;
&gt; 	&lt;/aspects&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/EmptyAspect.aj" revision="1.1" state="new">package ataspectj;

public aspect EmptyAspect {
	
}</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/aop-dumpproxy.xml" revision="1.2" state="changed">2a3,5
&gt; 	&lt;aspects&gt;
&gt; 		&lt;aspect name="ataspectj.EmptyAspect"/&gt;
&gt; 	&lt;/aspects&gt;
</file>
<file name="org.aspectj/modules/tests/ltw/aop-optionsonly.xml" revision="1.1" state="new">&lt;aspectj&gt;
    &lt;weaver options="-verbose"/&gt;
&lt;/aspectj&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwreweavable/aop-ltwreweavable-declared.xml" revision="1.2" state="changed">4a5
&gt; 		&lt;aspect name="ataspectj.ltwreweavable.EmptyAtAspect"/&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwreweavable/aop-ltwreweavable-omitted.xml" revision="1.2" state="changed">4c4,6
&lt;     &lt;aspects/&gt;
---
&gt;     &lt;aspects&gt;
&gt; 		&lt;aspect name="ataspectj.ltwreweavable.EmptyAtAspect"/&gt;
&gt;     &lt;/aspects&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwreweavable/EmptyAtAspect.java" revision="1.1" state="new">package ataspectj.ltwreweavable;

import org.aspectj.lang.annotation.Aspect;

@Aspect
public class EmptyAtAspect {

}
    </file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/aop-dump.xml" revision="1.3" state="changed">2a3,5
&gt; 	&lt;aspects&gt;
&gt; 		&lt;aspect name="ataspectj.EmptyAspect"/&gt;
&gt; 	&lt;/aspects&gt;
</file>
</fixedFiles>
</bug>
<bug id="120909" transactionid="70159">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="4"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V</fullfingerprint>
<bugreport>1. ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates() 

junit.framework.AssertionFailedError: Errors:Couldn't find void java.util.HashMap.onEntry() in the bcel set 
Couldn't find void java.util.HashMap.onExit() in the bcel set 
Couldn't find void java.util.HashMap.transfer0(java.util.HashMap$Entry[]) in the bcel set 

    at junit.framework.Assert.fail(Assert.java:47) 
    at junit.framework.Assert.assertTrue(Assert.java:20) 
    at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:278) 
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
    at java.lang.reflect.Method.invoke(Method.java:615) 
    at junit.framework.TestCase.runTest(TestCase.java:154) 
    at junit.framework.TestCase.runBare(TestCase.java:127) 
    at junit.framework.TestResult$1.protect(TestResult.java:106) 
    at junit.framework.TestResult.runProtected(TestResult.java:124) 
    at junit.framework.TestResult.run(TestResult.java:109) 
    at junit.framework.TestCase.run(TestCase.java:118) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) 
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) 
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) 

This failure occures because when we compare BeclWorld with ReflectionWorld we are still picking up the default (Sun) version of HashMap in JRE15_LIB for BCEL. The solution is to create both worlds with the same class loader.

2. Ajc150Tests.testModifierOverrides() 

junit.framework.AssertionFailedError: Expecting output: 
execution(void pr119749.C.m()): execMe[@pr119749$Me()] 
execution(void pr119749.C.m()): execEx 
But found output: 
execution(void pr119749.C.m()): execMe[@pr119749.Me()] 
execution(void pr119749.C.m()): execEx 

First difference is on line 1 

    at junit.framework.Assert.fail(Assert.java:47) 
    at org.aspectj.testing.OutputSpec.matchAgainst(OutputSpec.java:58) 
    at org.aspectj.testing.RunSpec.execute(RunSpec.java:61) 
    at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) 
    at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) 
    at org.aspectj.systemtest.ajc150.Ajc150Tests.testModifierOverrides(Ajc150Tests.java:852) 
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) 
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
    at java.lang.reflect.Method.invoke(Method.java:615) 
    at junit.framework.TestCase.runTest(TestCase.java:154) 
    at junit.framework.TestCase.runBare(TestCase.java:127) 
    at junit.framework.TestResult$1.protect(TestResult.java:106) 
    at junit.framework.TestResult.runProtected(TestResult.java:124) 
    at junit.framework.TestResult.run(TestResult.java:109) 
    at junit.framework.TestCase.run(TestCase.java:118) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22) 
    at junit.extensions.TestSetup$1.protect(TestSetup.java:19) 
    at junit.framework.TestResult.runProtected(TestResult.java:124) 
    at junit.extensions.TestSetup.run(TestSetup.java:23) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at junit.framework.TestSuite.runTest(TestSuite.java:208) 
    at junit.framework.TestSuite.run(TestSuite.java:203) 
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) 
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) 
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) 

This failure is due a difference between JDKs in the implementation of toString() for annotations.</bugreport>
<testsforfix ID="120909" type="changed">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java">
      <test NAME="testDelegateCreation"/>
      <test NAME="testArrayTypes"/>
      <test NAME="testPrimitiveTypes"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="modifier overrides"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="181" file="output/120909/pre-fix/testresults.xml" passing="1609" size="1790"/>
<post-fix-testcases failing="183" file="output/120909/post-fix/testresults.xml" passing="1607" size="1790"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java" revision="1.7" state="changed">44c44
&lt; 	public ReflectionWorld() {
---
&gt; 	private ReflectionWorld() {
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java" revision="1.3" state="changed">26,29d25
&lt; 	
&lt; 	public DefaultWeavingContext(){
&lt; 		loader = getClass().getClassLoader();
&lt; 	}
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java" revision="1.6" state="changed">22c22
&lt; 		World world = new ReflectionWorld();
---
&gt; 		World world = new ReflectionWorld(getClass().getClassLoader());
29c29
&lt; 		ReflectionWorld world = new ReflectionWorld();
---
&gt; 		ReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());
36c36
&lt; 		ReflectionWorld world = new ReflectionWorld();
---
&gt; 		ReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.254" state="changed">22c22
&lt;              &lt;line text="execution(void pr119749.C.m()): execMe[@pr119749$Me()]"/&gt;
---
&gt;              &lt;line text="execution(void pr119749.C.m()): execMe[Me]"/&gt;
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java" revision="1.7" state="changed">19a20
&gt; import org.aspectj.bridge.IMessageHandler;
250c251
&lt;         BcelWorld bcelWorld = new BcelWorld();
---
&gt;         BcelWorld bcelWorld = new BcelWorld(getClass().getClassLoader(),IMessageHandler.THROW,null);
292c293
&lt; 		world = new ReflectionWorld();
---
&gt; 		world = new ReflectionWorld(getClass().getClassLoader());
</file>
<file name="org.aspectj/modules/tests/bugs150/pr119749.aj" revision="1.2" state="changed">13c13
&lt;         @interface Me{}
---
&gt;         @interface Me { String value() default "Me"; }
56c56
&lt;                         log(thisJoinPoint, "execMe[" + me + "]");
---
&gt;                     log(thisJoinPoint, "execMe[" + me.value() + "]");
62c62
&lt; }
\ Kein Zeilenumbruch am Dateiende.
---
&gt; }
</file>
</fixedFiles>
</bug>
<bug id="121395" transactionid="69084">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="5"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-new K-null K-true M O-! O-+ T V Y Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>An invalid aspectj path (missing jar file) throws an filenotfoundexception:

java.io.FileNotFoundException
at java.io.FileInputStream.open(Native Method)
at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromJarFile(BcelWeaver.java:202)
at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:192)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:623)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:209)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

FileNotFoundException thrown: /Users/frankstolle/Documents/workspace/lib_aspects/deploy/lib_aspects.jar (No such file or directory)



should generate an problem entry in the problems-list.</bugreport>
<testsforfix ID="121395" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testInvalidAspectpath_pr121395"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/121395/pre-fix/testresults.xml" passing="1769" size="1955"/>
<post-fix-testcases failing="180" file="output/121395/post-fix/testresults.xml" passing="1775" size="1955"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.86" state="changed">631c631,636
&lt; 			bcelWeaver.addLibraryJarFile(f);
---
&gt; 			if (!f.exists()) {
&gt; 				IMessage message = new Message("invalid aspectpath entry: "+f.getName(),null,true);
&gt; 				handler.handleMessage(message);
&gt; 			} else {
&gt; 				bcelWeaver.addLibraryJarFile(f);
&gt; 			}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.30" state="changed">18a19
&gt; import java.util.HashSet;
20a22
&gt; import java.util.Set;
63a66,76
&gt; 
&gt; 	// source code doesnt matter, we are checking invalid path handling
&gt; 	public void testInvalidAspectpath_pr121395() {
&gt; 		initialiseProject("P1");
&gt; 		File f = new File("foo.jar");
&gt; 		Set s = new HashSet();
&gt; 		s.add(f);
&gt; 		configureAspectPath(s);
&gt; 		build("P1"); // This first build will be batch
&gt; 		checkForError("invalid aspectpath entry");
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java" revision="1.14" state="changed">71a72,75
&gt; 	
&gt; 	public static void configureAspectPath(Set aspectpath) {
&gt; 		MyProjectPropertiesAdapter.setAspectpath(aspectpath);
&gt; 	} 
81a86
&gt; 		MyProjectPropertiesAdapter.reset();
366a372,375
&gt; 		public static void reset() {
&gt; 			_instance.aspectPath=null;
&gt; 		}
&gt; 		
368a378
&gt; 		private Set aspectPath = null;
390a401,404
&gt; 		public static void setAspectpath(Set path) {
&gt; 			_instance.aspectPath = path;
&gt; 		}
&gt; 		
506,507c520,521
&lt; 			log("MyProjectProperties.getAspectPath()");
&lt; 			return null;
---
&gt; 			log("MyProjectProperties.getAspectPath("+aspectPath+")");
&gt; 			return aspectPath;
</file>
</fixedFiles>
</bug>
<bug id="121533" transactionid="73492">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="11"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="12"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-return K-super M T V Y Z-if</fullfingerprint>
<bugreport>I am not able to move a .aj file from the default package to another package.

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:357)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:291)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:447)
	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:131)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.ReorgMoveStarter.run(ReorgMoveStarter.java:77)
	at org.eclipse.jdt.internal.ui.packageview.SelectionTransferDropAdapter.handleDropMove(SelectionTransferDropAdapter.java:220)
	at org.eclipse.jdt.internal.ui.packageview.SelectionTransferDropAdapter.drop(SelectionTransferDropAdapter.java:138)
	at org.eclipse.jdt.internal.ui.dnd.JdtViewerDropAdapter.drop(JdtViewerDropAdapter.java:130)
	at org.eclipse.jdt.internal.ui.dnd.DelegatingDropAdapter$3.run(DelegatingDropAdapter.java:134)
	at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)
	at org.eclipse.core.runtime.Platform.run(Platform.java:783)
	at org.eclipse.jdt.internal.ui.dnd.DelegatingDropAdapter.drop(DelegatingDropAdapter.java:132)
	at org.eclipse.swt.dnd.DNDListener.handleEvent(DNDListener.java:65)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:843)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:867)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:852)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:660)
	at org.eclipse.swt.dnd.DropTarget.notifyListeners(DropTarget.java:480)
	at org.eclipse.swt.dnd.DropTarget.Drop(DropTarget.java:405)
	at org.eclipse.swt.dnd.DropTarget.access$7(DropTarget.java:350)
	at org.eclipse.swt.dnd.DropTarget$3.method6(DropTarget.java:236)
	at org.eclipse.swt.internal.ole.win32.COMObject.callback6(COMObject.java:117)
	at org.eclipse.swt.internal.ole.win32.COM.DoDragDrop(Native Method)
	at org.eclipse.swt.dnd.DragSource.drag(DragSource.java:277)
	at org.eclipse.swt.dnd.DragSource.access$0(DragSource.java:267)
	at org.eclipse.swt.dnd.DragSource$1.handleEvent(DragSource.java:161)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:843)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3080)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2713)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1699)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1663)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:367)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:278)
	at org.eclipse.core.launcher.Main.run(Main.java:973)
	at org.eclipse.core.launcher.Main.main(Main.java:948)
Caused by: java.lang.IllegalArgumentException: Compilation unit name must end with .java
	at org.eclipse.jdt.internal.core.PackageFragment.getCompilationUnit(PackageFragment.java:192)
	at org.eclipse.jdt.internal.corext.refactoring.reorg.OverwriteHelper.canOverwrite(OverwriteHelper.java:209)
	at org.eclipse.jdt.internal.corext.refactoring.reorg.OverwriteHelper.confirmCuOverwritting(OverwriteHelper.java:125)
	at org.eclipse.jdt.internal.corext.refactoring.reorg.OverwriteHelper.confirmOverwritting(OverwriteHelper.java:105)
	at org.eclipse.jdt.internal.corext.refactoring.reorg.OverwriteHelper.confirmOverwritting(OverwriteHelper.java:90)
	at org.eclipse.jdt.internal.corext.refactoring.reorg.ReorgPolicyFactory$FilesFoldersAndCusReorgPolicy.confirmOverwritting(ReorgPolicyFactory.java:546)
	at org.eclipse.jdt.internal.corext.refactoring.reorg.ReorgPolicyFactory$FilesFoldersAndCusReorgPolicy.checkFinalConditions(ReorgPolicyFactory.java:535)
	at org.eclipse.jdt.internal.corext.refactoring.reorg.ReorgPolicyFactory$MoveFilesFoldersAndCusPolicy.checkFinalConditions(ReorgPolicyFactory.java:1996)
	at org.eclipse.jdt.internal.corext.refactoring.reorg.JavaMoveProcessor.checkFinalConditions(JavaMoveProcessor.java:160)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:169)
	at org.eclipse.ltk.core.refactoring.Refactoring.checkAllConditions(Refactoring.java:126)
	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper$Operation.run(RefactoringExecutionHelper.java:71)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:718)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:3760)
	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:346)
	... 46 more</bugreport>
<pre-fix-testcases failing="190" file="output/121533/pre-fix/testresults.xml" passing="1825" size="2015"/>
<post-fix-testcases failing="188" file="output/121533/post-fix/testresults.xml" passing="1827" size="2015"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/javaelements/AJCompilationUnit.java" revision="1.20" state="changed">592d591
&lt; 		final String deletionClass = "org.eclipse.jdt.internal.corext.refactoring.changes.DeleteSourceManipulationChange"; //$NON-NLS-1$
594a594
&gt; 		final String deletionClass = "org.eclipse.jdt.internal.corext.refactoring.changes.DeleteSourceManipulationChange"; //$NON-NLS-1$
602a603,612
&gt; 		
&gt; 		// are we being called in the context of a move/DnD operation?
&gt; 		final String moveClass = "org.eclipse.jdt.internal.corext.refactoring.changes.CompilationUnitReorgChange"; //$NON-NLS-1$
&gt; 		if (callerName.equals(moveClass)) {
&gt; 			// need to return a handle identifier that JDT can use (bug 121533)
&gt; 			String modifiedHandle = super.getHandleIdentifier().replace(
&gt; 					AspectElement.JEM_ASPECT_CU,
&gt; 					JavaElement.JEM_COMPILATIONUNIT);
&gt; 			return modifiedHandle;
&gt; 		}
</file>
</fixedFiles>
</bug>
<bug id="121616" transactionid="69789">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-return M T V Z-if</fullfingerprint>
<bugreport>Encountered during a JavaPolis demo. I was using a pre-release 
development version. However, reproducable with latest post-release 
development version as well.

Create the following source file:

package banking;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

public class Main {
	public static void main(String[] args) {
		System.out.println("Main");
	}
}

@Aspect
class MainLogger {
	@Pointcut("execution(* main(..))")
	public void log(JoinPoint thisJoinPoint) {
		System.out.println("Before " thisJoinPoint");
	}
}

Note that the import statement for JoinPoint is lacking. Compiling this 
source file crahses the compiler. Adding import statement for JoinPoint 
makes it work fine.

C:\work\aop\src\workspace\CallDebugBug&gt;ajc -version
AspectJ Compiler DEVELOPMENT built on Tuesday Dec 20, 2005 at 13:58:29 GMT

C:\work\aop\src\workspace\CallDebugBug&gt;ajc -1.5 banking\Main.java
C:\work\aop\src\workspace\CallDebugBug\banking\Main.java [error] Internal compil
er error
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi
sitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417
)
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi
sitor.convertToPointcutDeclaration(ValidateAtAspectJAnnotationsVisitor.java:513)

        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi
sitor.visit(ValidateAtAspectJAnnotationsVisitor.java:188)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.t
raverse(MethodDeclaration.java:185)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.tra
verse(TypeDeclaration.java:1195)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDecl
aration.traverse(CompilationUnitDeclaration.java:339)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(
AjCompilerAdapter.java:154)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_asp
ectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compil
er.java:517)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compil
er.java:329)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:811)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuild
Manager.java:230)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBu
ildManager.java:156)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:326)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
        at org.aspectj.tools.ajc.Main.main(Main.java:83)

(no source information available)
C:\work\aop\src\workspace\CallDebugBug\banking\Main.java:16 [error] JoinPoint ca
nnot be resolved to a type
public void log(JoinPoint thisJoinPoint) {
                ^^^^^^^
C:\work\aop\src\workspace\CallDebugBug\banking\Main.java:17 [error] Syntax error
, insert ")" to complete MethodInvocation
System.out.println("Before " thisJoinPoint");

C:\work\aop\src\workspace\CallDebugBug\banking\Main.java:17 [error] Syntax error
, insert ";" to complete BlockStatements
System.out.println("Before " thisJoinPoint");

ABORT

Exception thrown from AspectJ DEVELOPMENT

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack,
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.

when validating @AspectJ annotations log
when analysing types defined in compilation unit C:\work\aop\src\workspace\CallD
ebugBug\banking\Main.java
when processing compilation unit C:\work\aop\src\workspace\CallDebugBug\banking\
Main.java
when batch building with classpath: c:\java\jdk1.5.0_04\jre\lib\ext\dnsns.jar;c:
\java\jdk1.5.0_04\jre\lib\ext\localedata.jar;c:\java\jdk1.5.0_04\jre\lib\ext\sun
jce_provider.jar;c:\java\jdk1.5.0_04\jre\lib\ext\sunpkcs11.jar;c:\java\jdk1.5.0_
04\lib\tools.jar;c:\java\jdk1.5.0_04\jre\lib\rt.jar;C:\java\aspectj\aspectj5\lib
\aspectjrt.jar;C:\java\log4j\jakarta-log4j-1.2.8\dist\lib\log4j-1.2.8.jar;C:\jav
a\jess\Jess61p5\jess.jar;c:\java\j2sdkee1.3.1\lib\system\cloudscape.jar;c:\java\
j2sdkee1.3.1\lib\system\tools.jar;c:\java\j2sdkee1.3.1\lib\cloudscape\RmiJdbc.ja
r;c:\java\j2sdkee1.3.1\lib\cloudscape\cloudclient.jar;c:\java\j2sdkee1.3.1\lib\c
lasses;c:\java\j2sdkee1.3.1\classes;c:\java\j2sdkee1.3.1\lib\j2ee.jar;c:\java\j2
sdkee1.3.1\lib\toolclasses;c:\java\j2sdkee1.3.1\lib\j2eetools.jar;c:\java\j2sdke
e1.3.1\lib\locale;c:\java\j2sdkee1.3.1\lib\j2ee.jar;c:\java\j2sdkee1.3.1\lib\jha
ll.jar;c:\java\j2sdkee1.3.1\lib\locale;c:\java\jdk1.5.0_04\lib\tools.jar;c:\java
\j2sdkee1.3.1\lib\jhall.jar;C:\java\ws\axis\axis-1_1\lib\axis.jar;C:\java\ws\axi
s\axis-1_1\lib\axis-ant.jar;C:\java\ws\axis\axis-1_1\lib\commons-discovery.jar;C
:\java\ws\axis\axis-1_1\lib\commons-logging.jar;C:\java\ws\axis\axis-1_1\lib\jax
rpc.jar;C:\java\ws\axis\axis-1_1\lib\saaj.jar;C:\java\ws\axis\axis-1_1\lib\log4j
-1.2.8.jar;C:\java\ws\axis\axis-1_1\lib\wsdl4j.jar;C:\java\concurrency\concurren
cy.jar;C:\java\junit\junit3.8.1\junit.jar;.;
null
java.lang.NullPointerException
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi
sitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417
)
        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi
sitor.convertToPointcutDeclaration(ValidateAtAspectJAnnotationsVisitor.java:513)

        at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi
sitor.visit(ValidateAtAspectJAnnotationsVisitor.java:188)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.t
raverse(MethodDeclaration.java:185)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.tra
verse(TypeDeclaration.java:1195)
        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDecl
aration.traverse(CompilationUnitDeclaration.java:339)
        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(
AjCompilerAdapter.java:154)
        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_asp
ectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compil
er.java:517)
        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compil
er.java:329)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat
ion(AjBuildManager.java:811)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuild
Manager.java:230)
        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBu
ildManager.java:156)
        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
        at org.aspectj.tools.ajc.Main.run(Main.java:326)
        at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
        at org.aspectj.tools.ajc.Main.main(Main.java:83)


1 fail|abort, 4 errors</bugreport>
<testsforfix ID="121616" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testAtAspectWithoutJoinPointImport_pr121616"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="@AJ without JoinPoint import"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/121616/pre-fix/testresults.xml" passing="1797" size="1983"/>
<post-fix-testcases failing="187" file="output/121616/post-fix/testresults.xml" passing="1796" size="1983"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java" revision="1.17" state="changed">149a150,152
&gt; 		if (methodDeclaration.hasErrors()) {
&gt; 			return false;
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.22" state="changed">162a163,166
&gt;   public void testAtAspectWithoutJoinPointImport_pr121616() {
&gt; 	  runTest("@AJ without JoinPoint import");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.20" state="changed">178a179,184
&gt;     &lt;ajc-test dir="bugs151" title="@AJ without JoinPoint import"&gt;
&gt;         &lt;compile files="pr121616.java" options="-1.5"&gt;
&gt;           &lt;message kind="error" line="13" text="JoinPoint cannot be resolved to a type"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs151/pr121616.java" revision="1.1" state="new">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

class Main {
        public static void main(String[] args) {
                System.out.println("Main");
        }
}

@Aspect
class MainLogger {
    @Before("execution(* main(..))")
    public void log(JoinPoint thisJoinPoint) {
            System.out.println("Before " + thisJoinPoint);
    }
}
</file>
</fixedFiles>
</bug>
<bug id="122370" transactionid="68614">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint/>
<fullfingerprint/>
<bugreport>Adding a setter to the Moody example makes it clear that the annotation style (@DeclareParents) results in different behavior than the classic (declare parents) style.

Calling the setter in a "declare parents"-advised object behaves as one would expect.  However, calling the setter with a "@DeclareParents"-advised object has no effect -- that is, you can call the setter (and see that it's been called) and immediately call the getter, only to find that the value didn't change.  The following examples (all in "package moody;") illustrate:

public enum Mood { HAPPY, JOLLY }

Classic style:
-------------
public aspect ClassicMoodIndicator {
   public interface Moody {
      Mood getMood();
      void setMood(Mood mood);
   }

   private Mood Moody.mood = Mood.HAPPY;

   public Mood Moody.getMood() { return mood; }
   public void Moody.setMood(Mood mood) { this.mood = mood; }

   declare parents : moody.ClassicMoodImplementor implements Moody;
}

public class ClassicMoodImplementor { }

Annotation style:
----------------
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareParents;

@Aspect
public class AnnotationMoodIndicator {
   public interface Moody {
      Mood getMood();
      void setMood(Mood mood);
   }

   public static class MoodyImpl implements Moody {
      private Mood mood = Mood.HAPPY;

      public Mood getMood() { return mood; }
      public void setMood(Mood mood) { this.mood = mood; }
   }

   @DeclareParents(value="moody.AnnotationMoodImplementor",defaultImpl=MoodyImpl.class)
   private Moody implementedInterface;
}

public class AnnotationMoodImplementor { }

JUnit TestCase:
--------------
import junit.framework.TestCase;

public class MoodTester extends TestCase {
   public MoodTester(String name) { super(name); }

   public void testClassic() {
      ClassicMoodImplementor cmi0 = new ClassicMoodImplementor();
      ClassicMoodImplementor cmi1 = new ClassicMoodImplementor();
      
      assertEquals("cmi0 should be HAPPY", Mood.HAPPY, cmi0.getMood());
      
      cmi1.setMood(Mood.JOLLY);
      assertEquals("cmi1 should be JOLLY", Mood.JOLLY, cmi1.getMood());
      assertEquals("cmi0 should be *still* be HAPPY", Mood.HAPPY, cmi0.getMood());
   }
   
   public void testAnnotation() {
      AnnotationMoodImplementor ami0 = new AnnotationMoodImplementor();
      AnnotationMoodImplementor ami1 = new AnnotationMoodImplementor();
      
      assertEquals("ami0 should be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood());
      
      ((AnnotationMoodIndicator.Moody) ami1).setMood(Mood.JOLLY);
      assertEquals("ami1 should be JOLLY", Mood.JOLLY, ((AnnotationMoodIndicator.Moody) ami1).getMood());
      assertEquals("ami0 should be *still* be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood());
   }
}

Result:
------
The test run is as follows:
..F
Time: 0.021
There was 1 failure:
1) testAnnotation(moody.MoodTester)junit.framework.AssertionFailedError: ami1 should be JOLLY expected:&lt;JOLLY&gt; but was:&lt;HAPPY&gt;
       at moody.MoodTester.testAnnotation(MoodTester.java:27)
       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
       at moody.MoodTester.main(MoodTester.java:7)

FAILURES!!!
Tests run: 2,  Failures: 1,  Errors: 0

For classic, you can see that cmi1.setMood was successful and cmi0/cmi1 are decoupled (that is, calling setMood on cmi1 has no impact on cmi0).  The annotation style, however, fails because ami1.setMood appears to have done nothing.  The result should have been that ami1 is JOLLY and ami0 HAPPY (I include the second assert because both ami0 &amp; ami1 ended up JOLLY in RC1).

The current behavior makes @DeclareParents unusable for retaining field state (near as I can tell, it retains state throughout the method invocation, but not beyond it, like it is creating and discarding a backing object with each method invocation).</bugreport>
<testsforfix ID="122370" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testAtAspectDeclareParentsRetainsFieldState_pr122370"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="@AJ declare parents retains field state"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/122370/pre-fix/testresults.xml" passing="1797" size="1983"/>
<post-fix-testcases failing="185" file="output/122370/post-fix/testresults.xml" passing="1798" size="1983"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.71" state="changed">1113c1113
&lt;             BranchInstruction ifNonNull = InstructionFactory.createBranchInstruction(Constants.IFNULL, null);
---
&gt;             BranchInstruction ifNonNull = InstructionFactory.createBranchInstruction(Constants.IFNONNULL, null);
1115c1115,1117
&lt;             InstructionHandle ifNonNullElse = body.append(InstructionConstants.ALOAD_0);
---
&gt;             
&gt;             // Create and store a new instance
&gt;            	body.append(InstructionConstants.ALOAD_0);
1119a1122,1124
&gt;             
&gt;             // if not null use the instance we've got
&gt;             InstructionHandle ifNonNullElse =  body.append(InstructionConstants.ALOAD_0);
1121d1125
&lt;             body.append(InstructionConstants.ALOAD_0);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.21" state="changed">184a185,195
&gt;     &lt;ajc-test dir="bugs151/pr122370" title="@AJ declare parents retains field state"&gt;
&gt;         &lt;compile files="moody/AnnotationMoodImplementor.java, moody/AnnotationMoodIndicator.java, moody/Mood.java, moody/MainClass.java" options="-1.5"/&gt;
&gt;        &lt;run class="moody.MainClass"&gt;
&gt;             &lt;stdout&gt;
&gt;              &lt;line text="ami0's mood is HAPPY"/&gt;
&gt;              &lt;line text="ami1's mood is now JOLLY"/&gt;
&gt;              &lt;line text="ami0's mood is still HAPPY"/&gt;
&gt;             &lt;/stdout&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.23" state="changed">166a167,170
&gt;   public void testAtAspectDeclareParentsRetainsFieldState_pr122370() {
&gt; 	  runTest("@AJ declare parents retains field state");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/bugs151/pr122370/moody/Mood.java" revision="1.1" state="new">package moody;

public enum Mood {
	 HAPPY, JOLLY 
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr122370/moody/AnnotationMoodIndicator.java" revision="1.1" state="new">package moody;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareParents;

@Aspect
public class AnnotationMoodIndicator {
   public interface Moody {
      Mood getMood();
      void setMood(Mood mood);
   }

   public static class MoodyImpl implements Moody {
      private Mood mood = Mood.HAPPY;

      public Mood getMood() { return mood; }
      public void setMood(Mood mood) { this.mood = mood; }
   }

  
@DeclareParents(value="moody.AnnotationMoodImplementor",defaultImpl=MoodyImpl.class)
   private Moody implementedInterface;
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr122370/moody/MainClass.java" revision="1.1" state="new">package moody;

public class MainClass {

	public static void main(String[] args) {
		AnnotationMoodImplementor ami0 = new AnnotationMoodImplementor();
		AnnotationMoodImplementor ami1 = new AnnotationMoodImplementor();

		System.out.println("ami0's mood is " + ((AnnotationMoodIndicator.Moody) ami0).getMood());
		((AnnotationMoodIndicator.Moody) ami1).setMood(Mood.JOLLY);
		System.out.println("ami1's mood is now " + ((AnnotationMoodIndicator.Moody) ami1).getMood());
		System.out.println("ami0's mood is still " + ((AnnotationMoodIndicator.Moody) ami0).getMood());
	}
	

	
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr122370/moody/AnnotationMoodImplementor.java" revision="1.1" state="new">package moody;

public class AnnotationMoodImplementor {

}
</file>
</fixedFiles>
</bug>
<bug id="122580" transactionid="74326">
<property name="files-churned" value="5"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="17"/>
<property name="lines-added" value="27"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="60"/>
<property name="lines-churned" value="89"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-else K-false K-if K-import K-new K-null K-return K-this K-try M O-== O-|| O-! O-&amp;&amp; O-+ O-cast T V Y Z-cast Z-if Z-throw</fullfingerprint>
<bugreport>Here is a stack trace I am getting when I try to use AspectJ 1.5.0 final release's load-time weaving with JRockIt 1.4.2_08 using -Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent to load Weblogic Server 8.1 SP2. I debugged the code in Eclipse and discovered that the weaver was being initialized while loading IMessage$Kind, so the JRockIt VM simply hasn't run staticinitialization yet, making IMessage.INFO null.

I was able to fix this stack trace by hoisting the check for loading AspectJ code up BEFORE initializing a weaving adaptor i.e., changing line 55 of Aj.java to be
        if (loader == null || className == null || className.startsWith("org/aspectj/")) {

I then commented out line 251 of WeavingAdaptor to avoid a duplicate check:
	private boolean shouldWeaveName (String name) {
		return !((/*(name.startsWith("org.apache.bcel.")||//FIXME AV why ? bcel is wrapped in org.aspectj.
                name.startsWith("org.aspectj.")||*/ // now checked earlier, to avoid circularity issues in initialization 
                name.startsWith("java.")
                || name.startsWith("javax."))
                //|| name.startsWith("$Proxy")//JDK proxies//FIXME AV is that 1.3 proxy ? fe. ataspect.$Proxy0 is a java5 proxy...
                || name.startsWith("sun.reflect."));//JDK reflect
	}

Note that this bug does NOT occur when using a JRockIt 1.5.0 VM, even with the -Xmanagement command line argument.

Stack Trace:
java.lang.IllegalArgumentException: null kind
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110)
	at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
	at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)
	at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70)
	at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61)
	at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74)
	at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source)
	at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source)
	at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source)
	at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194)
	at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source)
	at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source)
	at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source)
	at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source)
	at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source)
	at jrockit.vm.RNI.trampoline()V(Unknown Source)
	at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:???)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
java.lang.IllegalArgumentException: null kind
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67)
	at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110)
	at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
	at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)
	at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70)
	at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61)
	at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74)
	at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source)
	at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source)
	at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source)
	at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194)
	at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source)
	at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source)
	at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source)
	at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source)
	at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source)
	at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source)
	at jrockit.vm.RNI.trampoline()V(Unknown Source)
	at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:???)
	at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343)
	at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)</bugreport>
<testsforfix ID="122580" type="new">
    <file LOCATION="org.aspectj/modules/loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.java">
      <test NAME="testJRockitAgent"/>
      <test NAME="testPreProcess"/>
      <test NAME="testJrockitRecursionProtection"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="193" file="output/122580/pre-fix/testresults.xml" passing="1839" size="2032"/>
<post-fix-testcases failing="192" file="output/122580/post-fix/testresults.xml" passing="1843" size="2035"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/.classpath" revision="1.7" state="changed"/>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/Aj.java" revision="1.16" state="changed">66c66
&lt;         } catch (Throwable t) {
---
&gt;         } catch (Exception t) {
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.java" revision="1.3" state="changed">2,7c2,6
&lt;  * Copyright (c) 2005 Contributors.
&lt;  * All rights reserved. 
&lt;  * This program and the accompanying materials are made available 
&lt;  * under the terms of the Eclipse Public License v1.0 
&lt;  * which accompanies this distribution and is available at 
&lt;  * http://eclipse.org/legal/epl-v10.html 
---
&gt;  * Copyright (c) 2006 IBM Corporation and others.
&gt;  * All rights reserved. This program and the accompanying materials 
&gt;  * are made available under the terms of the Eclipse Public License v1.0
&gt;  * which accompanies this distribution, and is available at
&gt;  * http://www.eclipse.org/legal/epl-v10.html
10c9
&lt;  *   Alexandre Vasseur         initial implementation (derivative from AspectWerkz)
---
&gt;  *     Matthew Webster - initial implementation
13a13,15
&gt; import java.util.Stack;
&gt; 
&gt; import com.bea.jvm.ClassLibrary;
15d16
&lt; import com.jrockit.management.rmp.RmpSocketListener;
18,30c19,21
&lt;  * JRockit (tested with 7SP4 and 8.1) preprocessor Adapter based on JMAPI &lt;p/&gt;JRockit has a low
&lt;  * level API for hooking ClassPreProcessor, allowing the use of online weaving at full speed.
&lt;  * Moreover, JRockit does not allow java.lang.ClassLoader overriding thru -Xbootclasspath/p option.
&lt;  * &lt;p/&gt;The ClassPreProcessor
&lt;  * implementation and all third party jars CAN reside in the standard classpath. &lt;p/&gt;The command
&lt;  * line will look like:
&lt;  * &lt;code&gt;"%JAVA_COMMAND%" -Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent -cp ...&lt;/code&gt;
&lt;  * Note: there can be some NoClassDefFoundError due to classpath limitation - as described in
&lt;  * http://edocs.bea.com/wls/docs81/adminguide/winservice.html &lt;p/&gt;In order to use the BEA JRockit
&lt;  * management server (for further connection of management console or runtime analyzer), the regular
&lt;  * option -Xmanagement will not have any effect prior to JRockit 8.1 SP2. Instead, use &lt;code&gt;-Dmanagement&lt;/code&gt;.
&lt;  *
&lt;  * @author &lt;a href="mailto:alex AT gnilux DOT com"&gt;Alexandre Vasseur&lt;/a&gt;
---
&gt;  * BEA JRocket JMAPI agent. 
&gt;  * 
&gt;  * Use "-Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent"
34,77c25,84
&lt;     /**
&lt;      * Concrete preprocessor
&lt;      */
&lt;     private final static ClassPreProcessor s_preProcessor;
&lt; 
&lt;     private static boolean START_RMP_SERVER = false;
&lt; 
&lt;     static {
&lt;         START_RMP_SERVER = System.getProperties().containsKey("management");
&lt;         try {
&lt;             s_preProcessor = new Aj();
&lt;             s_preProcessor.initialize();
&lt;         } catch (Exception e) {
&lt;             throw new ExceptionInInitializerError("could not initialize JRockitAgent preprocessor due to: " + e.toString());
&lt;         }
&lt;     }
&lt; 
&lt;     /**
&lt;      * The JMAPI ClassPreProcessor must be self registrating
&lt;      */
&lt;     public JRockitAgent() {
&lt;         if (START_RMP_SERVER) {
&lt;             // the management server will be spawned in a new thread
&lt;             /*RmpSocketListener management = */new RmpSocketListener();
&lt;         }
&lt;         JVMFactory.getJVM().getClassLibrary().setClassPreProcessor(this);
&lt;     }
&lt; 
&lt;     /**
&lt;      * Weave a class
&lt;      *
&lt;      * @param caller   classloader
&lt;      * @param name     of the class to weave
&lt;      * @param bytecode original
&lt;      * @return bytecode weaved
&lt;      */
&lt;     public byte[] preProcess(ClassLoader caller, String name, byte[] bytecode) {
&lt;         if (caller == null || caller.getParent() == null) {
&lt;             return bytecode;
&lt;         } else {
&lt;             return s_preProcessor.preProcess(name, bytecode, caller);
&lt;         }
&lt;     }
&lt; }
\ Kein Zeilenumbruch am Dateiende.
---
&gt; 	private ClassPreProcessor preProcessor;
&gt; 	
&gt; 	/*
&gt; 	 * This is used to implement the recursion protection offered by JVMTI
&gt; 	 * but not by JRockit JMAPI. I we are called to preProcess a class while
&gt; 	 * already preProcessing another we will return immediately
&gt; 	 */
&gt; 	private static ThreadLocalStack stack = new ThreadLocalStack();
&gt; 	
&gt; 	
&gt; 	public JRockitAgent () {
&gt; 		this.preProcessor = new Aj();
&gt; 		
&gt; 	    ClassLibrary cl = JVMFactory.getJVM().getClassLibrary();
&gt;         cl.setClassPreProcessor(this);
&gt; 	}
&gt; 	
&gt; 	public byte[] preProcess(ClassLoader loader, String className, byte[] bytes) {
&gt; 		byte[] newBytes = bytes;
&gt; 
&gt; 		if (stack.empty()) {
&gt; 			stack.push(className);
&gt; 			newBytes =  preProcessor.preProcess(className, bytes, loader);
&gt; 			stack.pop();
&gt; 		}
&gt; 		
&gt; 		return newBytes;
&gt; 	}
&gt; 
&gt; 	private static class ThreadLocalStack extends ThreadLocal {
&gt; 
&gt; 		public boolean empty () {
&gt; 			Stack stack = (Stack)get();
&gt; 			return stack.empty();
&gt; 		}
&gt; 
&gt; 		public Object peek () {
&gt; 			Object obj = null;
&gt; 			Stack stack = (Stack)get();
&gt; 			if (!stack.empty()) obj = stack.peek();
&gt; 			return obj;
&gt; 		}
&gt; 		
&gt; 		public void push (Object obj) {
&gt; 			Stack stack = (Stack)get();
&gt; 			if (!stack.empty() &amp;&amp; obj == stack.peek()) throw new RuntimeException(obj.toString());
&gt; 			stack.push(obj);
&gt; 		}
&gt; 		
&gt; 		public Object pop () {
&gt; 			Stack stack = (Stack)get();
&gt; 			return stack.pop();
&gt; 		}
&gt; 		
&gt; 		protected Object initialValue() {
&gt; 			return new Stack();
&gt; 		}
&gt; 	}
&gt; 
&gt; }
</file>
<file name="org.aspectj/modules/loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package org.aspectj.weaver.loadtime;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.jar.JarFile;
import java.util.zip.ZipEntry;

import com.bea.jvm.ClassPreProcessor;
import com.bea.jvm.JVMFactory;

import junit.framework.TestCase;

public class JRockitAgentTest extends TestCase {

	protected void setUp() throws Exception {
		super.setUp();
	}

	protected void tearDown() throws Exception {
		super.tearDown();
	}

	public void testJRockitAgent() {
		ClassPreProcessor preProcessor = new JRockitAgent();
		ClassPreProcessor expectedPreProcessor = JVMFactory.getJVM().getClassLibrary().getClassPreProcessor();
		assertEquals("JRocketAgent must be registered",expectedPreProcessor,preProcessor);
	}

	public void testPreProcess() {
		ClassPreProcessor preProcessor = new JRockitAgent();
		preProcessor.preProcess(null,"foo.Bar",new byte[] {});
	}

	public void testJrockitRecursionProtection () {
		URLClassLoader thisLoader = (URLClassLoader)getClass().getClassLoader();
		try {
			ClassLoader loader = new JRockitClassLoader(thisLoader);
			Class clazz;
			
			clazz = Class.forName("java.lang.Object",false,loader);
			clazz = Class.forName("junit.framework.TestCase",false,loader);
		}
		catch (Exception ex) {
			ex.printStackTrace();
			fail(ex.toString());
		}
	}

	private class JRockitClassLoader extends ClassLoader {
		
		public final static boolean debug = false;
		
		private List path = new LinkedList();
//		private com.bea.jvm.ClassPreProcessor agent;
		private Object agent;
		private Method preProcess;
		
		public JRockitClassLoader (URLClassLoader clone) throws Exception {
			/* Use extensions loader */
			super(clone.getParent());

			URL[] urls = clone.getURLs();
			for (int i = 0; i &lt; urls.length; i++) {
				Object pathElement;
				URL url = urls[i];
				File file = new File(url.getFile());
				if (debug) System.out.println("JRockitClassLoader.JRockitClassLoader() file" + file);
				if (file.isDirectory()) pathElement = file;
				else if (file.getName().endsWith(".jar")) pathElement = new JarFile(file);
				else throw new RuntimeException(file.getAbsolutePath().toString());
				path.add(pathElement);
			}
			
			Class agentClazz = Class.forName("org.aspectj.weaver.loadtime.JRockitAgent",false,this);
			Object obj = agentClazz.newInstance();
			if (debug) System.out.println("JRockitClassLoader.JRockitClassLoader() obj=" + obj);
			this.agent = obj;
			byte[] bytes = new byte[] {};
			Class[] parameterTypes = new Class[] { java.lang.ClassLoader.class, java.lang.String.class, bytes.getClass() }; 
			preProcess = agentClazz.getMethod("preProcess",parameterTypes);
		}
		
		protected Class findClass(String name) throws ClassNotFoundException {
			if (debug) System.out.println("&gt; JRockitClassLoader.findClass() name=" + name);
			Class clazz = null;
			try {
				clazz = super.findClass(name);
			}
			catch (ClassNotFoundException ex) {
				for (Iterator i = path.iterator(); clazz ==  null &amp;&amp; i.hasNext();) {
					byte[] classBytes = null;
					try {
						Object pathElement = i.next();
						if (pathElement instanceof File) {
							File dir = (File)pathElement;
							String className = name.replace('.','/') + ".class";
							File classFile = new File(dir,className);
							if (classFile.exists()) classBytes = loadClassFromFile(name,classFile);
						}
						else {
							JarFile jar = (JarFile)pathElement;
							String className = name.replace('.','/') + ".class";
							ZipEntry entry = jar.getEntry(className);
							if (entry != null) classBytes = loadBytesFromZipEntry(jar,entry);
						}
						
						if (classBytes != null) {
							clazz = defineClass(name,classBytes);
						}
					}
					catch (IOException ioException) {
						ex.printStackTrace();
					}
				}
			}
			
			if (debug) System.out.println("&lt; JRockitClassLoader.findClass() name=" + name);
			return clazz;
		}
		
		private Class defineClass (String name, byte[] bytes) {
			if (debug) System.out.println("&gt; JRockitClassLoader.defineClass() name=" + name);
			try {
				if (agent != null) preProcess.invoke(agent,new Object[] { this, name, bytes });
			}
			catch (IllegalAccessException iae) {
				iae.printStackTrace();
				throw new ClassFormatError(iae.getMessage());
			}
			catch (InvocationTargetException ite) {
				ite.printStackTrace();
				throw new ClassFormatError(ite.getTargetException().getMessage());
			}
			if (debug) System.out.println("&lt; JRockitClassLoader.defineClass() name=" + name);
			return super.defineClass(name,bytes,0,bytes.length);
		}
		
		private byte[] loadClassFromFile (String name, File file) throws IOException {
			if (debug) System.out.println("JRockitClassLoader.loadClassFromFile() file=" + file);

			byte[] bytes;
			bytes = new byte[(int)file.length()];
			FileInputStream fis = null;
			try {
				fis = new FileInputStream(file);
				bytes = readBytes(fis,bytes);
			}
			finally {
				if (fis != null) fis.close();
			}
			
			return bytes;
		}
		
		private byte[] loadBytesFromZipEntry (JarFile jar, ZipEntry entry) throws IOException {
			if (debug) System.out.println("JRockitClassLoader.loadBytesFromZipEntry() entry=" + entry);

			byte[] bytes;
			bytes = new byte[(int)entry.getSize()];
			InputStream is = null;
			try {
				is = jar.getInputStream(entry);
				bytes = readBytes(is,bytes);
			}
			finally {
				if (is != null) is.close();
			}
			
			return bytes;
		}
		
		private byte[] readBytes (InputStream is, byte[] bytes) throws IOException {
			for (int offset = 0; offset &lt; bytes.length;) {
				int read = is.read(bytes,offset,bytes.length - offset);
				offset += read;
			}
			return bytes;
		}
	}
}
</file>
<file name="org.aspectj/modules/loadtime/testsrc/LoadtimeModuleTests.java" revision="1.4" state="changed">17a18
&gt; import org.aspectj.weaver.loadtime.JRockitAgentTest;
30a32
&gt;         suite.addTestSuite(JRockitAgentTest.class);
</file>
<file name="org.aspectj/modules/loadtime/testsrc/org/aspectj/bea/jvm/ClassLibraryImpl.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package org.aspectj.bea.jvm;

import com.bea.jvm.ClassLibrary;
import com.bea.jvm.ClassPreProcessor;
import com.bea.jvm.NotAvailableException;

public class ClassLibraryImpl implements ClassLibrary {

	private ClassPreProcessor preProcessor;
	
	public ClassPreProcessor getClassPreProcessor() throws NotAvailableException {
		return preProcessor;
	}
	
	public void setClassPreProcessor(ClassPreProcessor classPreProcessor) {
		this.preProcessor = classPreProcessor;
	}

}
</file>
<file name="org.aspectj/modules/lib/ext/jrockit/jrockit-src.zip" revision="1.1" state="new"/>
<file name="org.aspectj/modules/loadtime/testsrc/org/aspectj/bea/jvm/JVMImpl.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package org.aspectj.bea.jvm;

import com.bea.jvm.ClassLibrary;
import com.bea.jvm.JVM;

public class JVMImpl implements JVM {

	private ClassLibrary libarary = new ClassLibraryImpl();
	
	public ClassLibrary getClassLibrary() {
		return libarary;
	}

}
</file>
<file name="org.aspectj/modules/lib/ext/jrockit/jrockit.jar" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="122728" transactionid="69971">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="blocker"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-&lt; O-() O-&amp;&amp; O-+ T V Y Z-cast Z-if</fullfingerprint>
<bugreport>When trying to run ajdoc on a moderate size code base (266 classes / interfaces / aspects), ajdoc crashes. Here's what happens:

D:\work\napa\jnapa\core&gt;ajdoc -source 1.5 -classpath D:\work\napa\jnapa\core\lib\aspectjrt.jar;D:\work\napa\jnapa\core\l
ib\dom4j-1.5.2.jar;D:\work\napa\jnapa\core\lib\groovy-all-1.0-jsr-03.jar -d D:\work\napa\jnapa\core\build\doc\internal -
author -package -argfile D:\work\napa\jnapa\core\jnapafilelist34352.lst
&gt; Calling ajc...
D:\work\napa\jnapa\commons\utils\src\fi\napa\util\aspects\CachingAspect.aj:72 [warning] advice defined in fi.napa.util.a
spects.CachingAspect has not been applied [Xlint:adviceDidNotMatch]


1 warning
&gt; Building signature files...
An internal error occured in ajdoc
Please copy the following text into an email message and send it,
along with any additional information you can add to:

       aspectj-dev@eclipse.org


java.lang.IndexOutOfBoundsException: Index: 3, Size: 3
java.lang.IndexOutOfBoundsException: Index: 3, Size: 3
        at java.util.ArrayList.RangeCheck(ArrayList.java:546)
        at java.util.ArrayList.get(ArrayList.java:321)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:124)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:113)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)
        at org.aspectj.tools.ajdoc.StubFileGenerator.processFile(StubFileGenerator.java:61)
        at org.aspectj.tools.ajdoc.StubFileGenerator.doFiles(StubFileGenerator.java:38)
        at org.aspectj.tools.ajdoc.Main.main(Main.java:157)

  The file jnapafilelist34352.lst contains only file entries w/ absolute paths, e.g. 
D:\work\napa\jnapa\core\src\fi\napa\core\tableprocessing\transfer\mapping\Transformation.java

I am using ajc and ajdoc 1.5.0 release version. I'll be happy to provide any other information that may help in solving this issue.

D:\work\napa\jnapa\core&gt;ajdoc -v
ajdoc version 1.5.0

D:\work\napa\jnapa\core&gt;ajc -v
AspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT</bugreport>
<testsforfix ID="122728" type="new">
    <file LOCATION="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.java">
      <test NAME="testEnum"/>
      <test NAME="testInlinedEnum"/>
      <test NAME="testEnumWithMethods"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="180" file="output/122728/pre-fix/testresults.xml" passing="1617" size="1797"/>
<post-fix-testcases failing="187" file="output/122728/post-fix/testresults.xml" passing="1613" size="1800"/>
<fixedFiles>
<file name="org.aspectj/modules/ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java" revision="1.12" state="changed">124c124,126
&lt; 						if (((IProgramElement)members.get(members.indexOf(member)+1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
---
&gt; 						int index = members.indexOf(member);
&gt; 						if ((index + 1 &lt; members.size()) &amp;&amp;
&gt; 								((IProgramElement)members.get(index+1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java" revision="1.5" state="changed">44a45
&gt;         suite.addTestSuite(EnumTest.class);
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.java" revision="1.1" state="new">/********************************************************************
 * Copyright (c) 2005 Contributors. All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: IBM Corporation - initial API and implementation 
 * 				 Helen Hawkins   - iniital version
 *******************************************************************/
package org.aspectj.tools.ajdoc;

import java.io.File;

import org.aspectj.util.FileUtil;

import junit.framework.TestCase;


public class EnumTest extends TestCase {

	private File outdir;
	
	protected void setUp() throws Exception {
		super.setUp();
		outdir = new File("../ajdoc/testdata/pr119453/doc");
	}
	
	protected void tearDown() throws Exception {
		super.tearDown();
		
		FileUtil.deleteContents(new File("ajdocworkingdir"));
		(new File("ajdocworkingdir")).delete();
		
		FileUtil.deleteContents(new File("testdata/pr119453/doc"));
		(new File("testdata/pr119453/doc")).delete();
	}
	
	/**
	 * Test for pr122728 - no StringOutOfBoundsException
	 * when processing an Enum
	 */
    public void testEnum() throws Exception {
        outdir.delete();
		File f = new File("../ajdoc/testdata/pr122728/src/pack/MyEnum.java");
    	
        String[] args = { 
              "-XajdocDebug",
              "-private",
              "-source", 
              "1.5",
            "-d", 
            outdir.getAbsolutePath(),
            f.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }

	/**
	 * Test for pr122728 - no StringOutOfBoundsException
	 * when processing an Enum 
	 */
    public void testInlinedEnum() throws Exception {
    	outdir.delete();
		File f = new File("../ajdoc/testdata/pr122728/src/pack/ClassWithInnerEnum.java");
    	
        String[] args = { 
              "-XajdocDebug",
              "-private",
              "-source", 
              "1.5",
            "-d", 
            outdir.getAbsolutePath(),
            f.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }
    
	/**
	 * Test for pr122728 - no StringOutOfBoundsException
	 * when processing an Enum
	 */
    public void testEnumWithMethods() throws Exception {
    	outdir.delete();
		File f = new File("../ajdoc/testdata/pr122728/src/pack/EnumWithMethods.java");
    	
        String[] args = { 
              "-XajdocDebug",
              "-private",
              "-source", 
              "1.5",
            "-d", 
            outdir.getAbsolutePath(),
            f.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }
}
</file>
<file name="org.aspectj/modules/ajdoc/testdata/pr122728/src/pack/EnumWithMethods.java" revision="1.1" state="new">package pack;

public enum EnumWithMethods {
	
	A;
	
	EnumWithMethods() {
		
	}
	
}
</file>
<file name="org.aspectj/modules/ajdoc/testdata/pr122728/src/pack/MyEnum.java" revision="1.1" state="new">package pack;

public enum MyEnum {
	
	A;
	
}
</file>
<file name="org.aspectj/modules/ajdoc/testdata/pr122728/src/pack/ClassWithInnerEnum.java" revision="1.1" state="new">package pack;

public class ClassWithInnerEnum {
	
	public static enum E {A};
	
	public void somemethod() {
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="122742" transactionid="68562">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="14"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="14"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-return K-while M O-&lt; O-|| O-() O-&amp;&amp; O-+ O-++ O-cast T V Y Z-cast Z-if Z-while</fullfingerprint>
<bugreport>If an @AspectJ aspect advises itself using after throwing advice that itself throws an exception running the resulting program causes a VerifyError:

java.lang.VerifyError: (class: A, method: stop signature: ()V) catch_type not a subclass of Throwable
	at java.lang.Class.getDeclaredMethods0(Native Method)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2365)
	at java.lang.Class.getMethod0(Class.java:2611)
	at java.lang.Class.getMethod(Class.java:1579)
	at org.aspectj.tools.ajc.AjcTestCase.run(AjcTestCase.java:608)
	at org.aspectj.testing.RunSpec.execute(RunSpec.java:56)
	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)
	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)
	at org.aspectj.systemtest.ajc150.Ajc150Tests.testError(Ajc150Tests.java:877)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</bugreport>
<testsforfix ID="122742" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testAtAspectVerifyErrorWithAfterThrowingAndthisJoinPoint_pr122742"/>
      <test NAME="testAtAspectVerifyErrorWithAfterReturningAndthisJoinPoint_pr122742"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="@AJ VerifyError with @AfterThrowing and thisJoinPoint argument"/>
      <test NAME="@AJ VerifyError with @AfterReturning and thisJoinPoint argument"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="189" file="output/122742/pre-fix/testresults.xml" passing="1797" size="1986"/>
<post-fix-testcases failing="188" file="output/122742/post-fix/testresults.xml" passing="1798" size="1986"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Advice.java" revision="1.31" state="changed">287a288,301
&gt; 			if (getConcreteAspect().isAnnotationStyleAspect()) {
&gt; 				// bug 122742 - if we're an annotation style aspect then one 
&gt; 				// of the extra parameters could be JoinPoint which we want
&gt; 				// to ignore
&gt; 				int baseParmCnt = getBaseParameterCount();
&gt; 				UnresolvedType[] genericParameterTypes = ((ResolvedMember)signature).getGenericParameterTypes();
&gt; 				while ((baseParmCnt + 1 &lt; genericParameterTypes.length)
&gt; 						&amp;&amp; (genericParameterTypes[baseParmCnt].equals(AjcMemberMaker.TYPEX_JOINPOINT)
&gt; 								|| genericParameterTypes[baseParmCnt].equals(AjcMemberMaker.TYPEX_STATICJOINPOINT)
&gt; 								|| genericParameterTypes[baseParmCnt].equals(AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT))) {
&gt; 					baseParmCnt++;
&gt; 				}
&gt; 				return ((ResolvedMember)signature).getGenericParameterTypes()[baseParmCnt];
&gt; 			}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.25" state="changed">17,18c17,30
&lt;     &lt;/ajc-test&gt;  
&lt;     
---
&gt;     &lt;/ajc-test&gt;
&gt;       
&gt;     &lt;ajc-test dir="bugs151/pr122742" title="@AJ VerifyError with @AfterThrowing and thisJoinPoint argument"&gt;
&gt;     	&lt;compile files="AfterThrowingTest.java" options="-1.5"/&gt;
&gt;     	&lt;run class="AfterThrowingTest"&gt;
&gt;     	&lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs151/pr122742" title="@AJ VerifyError with @AfterReturning and thisJoinPoint argument"&gt;
&gt;     	&lt;compile files="AfterReturningTest.java" options="-1.5"/&gt;
&gt;     	&lt;run class="AfterReturningTest"&gt;
&gt;     	&lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;    
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.27" state="changed">89a90,97
&gt;   public void testAtAspectVerifyErrorWithAfterThrowingAndthisJoinPoint_pr122742() {
&gt; 	  runTest("@AJ VerifyError with @AfterThrowing and thisJoinPoint argument");
&gt;   }
&gt;   
&gt;   public void testAtAspectVerifyErrorWithAfterReturningAndthisJoinPoint_pr122742() {
&gt; 	  runTest("@AJ VerifyError with @AfterReturning and thisJoinPoint argument");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/bugs151/pr122742/AfterReturningTest.java" revision="1.1" state="new">import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class AfterReturningTest {

	public static void main(String[] args) {
		new B1().start();
	}
	
	// include "JoinPoint" in the argument list
	@AfterReturning(pointcut = "execution(public B1 B1.start())", returning = "r")
	public void afterJP(JoinPoint jp, B1 r) {
		r.stop();
	}
	
	// include "JoinPoint.StaticPart" in the argument list
	@AfterReturning(pointcut = "execution(public B1 B1.start())", returning = "r")
	public void afterJPSP(JoinPoint.StaticPart jp, B1 r) {
		r.stop();
	}
	
	// include "JoinPoint.EnclosingStaticPart" in the argument list
	@AfterReturning(pointcut = "execution(public B1 B1.start())", returning = "r")
	public void afterJPESP(JoinPoint.EnclosingStaticPart jp, B1 r) {
		r.stop();
	}
	
	// include "JoinPoint and JoinPoint.EnclosingStaticPart" in the argument list
	@AfterReturning(pointcut = "execution(public B1 B1.start())", returning = "r")
	public void afterJPESP2(JoinPoint jp1, JoinPoint.EnclosingStaticPart jp, B1 r) {
		r.stop();
	}
	
	// make sure it still works if "JoinPoint" is second in the argument list
	@AfterReturning(pointcut = "execution(public B1 B1.start())", returning = "r")
	public void afterJP2(B1 r, JoinPoint jp) {
		r.stop();
	}
}

class B1 {
	
	public B1 start() {
		return new B1();
	}
	
	public void stop() {
	}
	
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr122742/AfterThrowingTest.java" revision="1.1" state="new">import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class AfterThrowingTest {

	public static void main(String[] args) {
		try {
			new B().start();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	// include "JoinPoint" in the argument list
	@AfterThrowing(pointcut = "execution(public void B.start())", throwing = "ex")
	public void handleExceptionJP(JoinPoint jp, Exception ex) {	
	}

	// include "JoinPoint.StaticPart" in the argument list
	@AfterThrowing(pointcut = "execution(public void B.start())", throwing = "ex")
	public void handleExceptionJPSP(JoinPoint.StaticPart jp, Exception ex) {	
	}
	
	// include "JoinPoint.EnclosingStaticPart" in the argument list
	@AfterThrowing(pointcut = "execution(public void B.start())", throwing = "ex")
	public void handleExceptionJPESP(JoinPoint.EnclosingStaticPart jp, Exception ex) {	
	}
	
	// include "JoinPoint" and "JoinPoint.EnclosingStaticPart" in the argument list
	@AfterThrowing(pointcut = "execution(public void B.start())", throwing = "ex")
	public void handleExceptionJPESP(JoinPoint jp1, JoinPoint.EnclosingStaticPart jp, Exception ex) {	
	}
	
	// make sure it still works if "JoinPoint" is second on the argument list
	@AfterThrowing(pointcut = "execution(public void B.start())", throwing = "ex")
	public void handleExceptionJP2(JoinPoint jp, Exception ex) {	
	}
}

class B implements I {
	public void start() throws Exception {
		throw new IllegalArgumentException();
	}	
}

interface I {
	public void start() throws Exception;
}
</file>
</fixedFiles>
</bug>
<bug id="123212" transactionid="68984">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-- O-!= O-() T V Y Z-if</fullfingerprint>
<bugreport>Exception when compile a project under svn.

java.io.FileNotFoundException
at java.io.FileOutputStream.open(Native Method)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:179)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:131)
at org.aspectj.util.FileUtil.makeOutputStream(FileUtil.java:1258)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:466)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:444)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:386)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:298)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

FileNotFoundException thrown: /home/chomats/Fede/svn/fede-repos/Tool.Product.ProductServer/classes/.svn/format (Permission non accorde)</bugreport>
<pre-fix-testcases failing="183" file="output/123212/pre-fix/testresults.xml" passing="1801" size="1984"/>
<post-fix-testcases failing="184" file="output/123212/post-fix/testresults.xml" passing="1800" size="1984"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.88" state="changed">500a501,503
&gt; 				(resourceName.startsWith(".svn/")) || 
&gt; 				(resourceName.indexOf("/.svn/")!=-1) ||
&gt; 				(resourceName.endsWith("/.svn")) ||
</file>
</fixedFiles>
</bug>
<bug id="123423" transactionid="69376">
<property name="files-churned" value="5"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="9"/>
<property name="lines-added" value="51"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="57"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-false K-new K-return K-this M T V Y</fullfingerprint>
<bugreport>Per type within aspects have a generated field ajc$withinType. Almost any time I ever use one of them, I'd like to access this field. Sometimes, e.g., for deferred initialization, I have to create a duplicate field that initializes this as such:

    private Class managedClass;
    after() returning: staticinitialization(*) {
        managedClass = thisJoinPointStaticPart.getSignature().getDeclaringType();
...

It would be nice if there were a method with the signature 
Class getWithinType() defined on any pertypewithin aspect.</bugreport>
<testsforfix ID="123423" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testPTWgetWithinTypeName_pr123423_1"/>
      <test NAME="testPTWgetWithinTypeName_pr123423_2"/>
      <test NAME="testPTWgetWithinTypeName_pr123423_3"/>
      <test NAME="testPTWgetWithinTypeName_pr123423_4"/>
      <test NAME="testPTWgetWithinTypeName_pr123423_5"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="basic usage of getWithinTypeName"/>
      <test NAME="basic usage of getWithinTypeName - annotation style"/>
      <test NAME="basic usage of getWithinTypeName - multiple types"/>
      <test NAME="basic usage of getWithinTypeName - non matching types"/>
      <test NAME="basic usage of getWithinTypeName - types in packages"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/123423/pre-fix/testresults.xml" passing="1927" size="2114"/>
<post-fix-testcases failing="189" file="output/123423/post-fix/testresults.xml" passing="1925" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/NameMangler.java" revision="1.23" state="changed">49a50
&gt; 	public static final String PERTYPEWITHIN_GETWITHINTYPENAME_METHOD    = "getWithinTypeName";
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java" revision="1.53" state="changed">78c78
&lt; 	//public ResolvedMember ptwGetWithinTypeMethod;
---
&gt; 	public ResolvedMember ptwGetWithinTypeNameMethod;
371,372c371
&lt; 			// PTWIMPL getWithinType() would need this...
&lt; 			//generatePerTypeWithinGetWithinTypeMethod(classFile); // generate public Class getWithinType() {
---
&gt; 			generatePerTypeWithinGetWithinTypeNameMethod(classFile);
730a730,749
&gt; 	private void generatePerTypeWithinGetWithinTypeNameMethod(ClassFile classFile) {
&gt; 		final EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(this.scope);
&gt; 		// Code:
&gt; 		/*
&gt; 		  Code:
&gt; 		   Stack=1, Locals=1, Args_size=1
&gt; 		   0:   aload_0
&gt; 		   1:   getfield        #14; //Field ajc$withinType:Ljava/lang/String;
&gt; 		   4:   areturn
&gt; 		 */
&gt; 		generateMethod(classFile, AjcMemberMaker.perTypeWithinGetWithinTypeNameMethod(world.fromBinding(binding),world.getWorld().isInJava5Mode()), 
&gt; 		new BodyGenerator() {
&gt; 			public void generate(CodeStream codeStream) {
&gt; 				ExceptionLabel exc = new ExceptionLabel(codeStream,world.makeTypeBinding(UnresolvedType.JAVA_LANG_EXCEPTION));
&gt; 				exc.placeStart();
&gt; 				codeStream.aload_0();
&gt; 				codeStream.getfield(world.makeFieldBinding(AjcMemberMaker.perTypeWithinWithinTypeField(typeX,typeX)));
&gt; 				codeStream.areturn();
&gt; 			}});
&gt; 	}
1047,1048c1066,1067
&lt; 				//ptwGetWithinTypeMethod = AjcMemberMaker.perTypeWithinGetWithinTypeMethod(typeX,world.getWorld().isInJava5Mode());
&lt; 				//binding.addMethod(world.makeMethodBinding(ptwGetWithinTypeMethod));
---
&gt; 				ptwGetWithinTypeNameMethod = AjcMemberMaker.perTypeWithinGetWithinTypeNameMethod(typeX,world.getWorld().isInJava5Mode());
&gt; 				binding.addMethod(world.makeMethodBinding(ptwGetWithinTypeNameMethod));
</file>
<file name="org.aspectj/modules/docs/adk15ProgGuideDB/pertypewithin.xml" revision="1.9" state="changed">46a47,61
&gt;       In addition, &lt;literal&gt;pertypewithin&lt;/literal&gt; aspects have a 
&gt;       &lt;literal&gt;getWithinTypeName&lt;/literal&gt; method that can be called
&gt;       to return the package qualified name of the type for which the
&gt;       aspect instance has been created.
&gt;    &lt;/para&gt;
&gt;    
&gt;    &lt;programlisting&gt;&lt;![CDATA[
&gt;     /**
&gt;      * return the package qualified name (eg. com.foo.MyClass) of the type
&gt;      * for which the aspect instance has been instantiated.
&gt;      */
&gt;      public String getWithinTypeName()
&gt;     ]]&gt;&lt;/programlisting&gt;
&gt;    
&gt;    &lt;para&gt;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AjcMemberMaker.java" revision="1.30" state="changed">191a192,205
&gt; 	
&gt; 	// PTWIMPL ResolvedMember for getWithinTypeName() method
&gt; 	public static ResolvedMember perTypeWithinGetWithinTypeNameMethod(UnresolvedType declaringType, boolean inJava5Mode) {
&gt; 		// public String getWithinTypeName()
&gt; 		ResolvedMemberImpl rm = new ResolvedMemberImpl(
&gt; 			Member.METHOD, 
&gt; 			declaringType,
&gt; 			Modifier.PUBLIC,
&gt; 			UnresolvedType.JAVA_LANG_STRING, // return value
&gt; 			NameMangler.PERTYPEWITHIN_GETWITHINTYPENAME_METHOD,
&gt; 			UnresolvedType.NONE
&gt; 			);	
&gt; 		return rm;
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java" revision="1.17" state="changed">126a127
&gt;             generatePerTWGetWithinTypeNameMethod(gen);
180c181
&lt; //            classGen.addField(makeFieldGen(classGen, perObjectFieldInfo).getField(), null);
---
&gt; //            classGen.addField(makeFieldGen(classGen, perObjectFieldInfo).(), null);
473a475,489
&gt;     // Create 'public String getWithinTypeName() { return ajc$withinType;}'
&gt;     private void generatePerTWGetWithinTypeNameMethod(LazyClassGen classGen) {
&gt;         InstructionFactory factory = classGen.getFactory();
&gt;         LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinGetWithinTypeNameMethod(aspectType,classGen.getWorld().isInJava5Mode()));
&gt;         flagAsSynthetic(method, false);
&gt;         classGen.addMethodGen(method);
&gt; 		//        	   0:   aload_0
&gt; 		//        	   1:   getfield        #14; //Field ajc$withinType:Ljava/lang/String;
&gt; 		//        	   4:   areturn
&gt;         InstructionList il = method.getBody();
&gt;         il.append(InstructionConstants.ALOAD_0);
&gt;         il.append(Utility.createGet(factory, AjcMemberMaker.perTypeWithinWithinTypeField(aspectType, aspectType)));
&gt;         il.append(InstructionConstants.ARETURN);
&gt;     }
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.55" state="changed">53a54,106
&gt;     &lt;ajc-test dir="features153/ptw" title="basic usage of getWithinTypeName"&gt;
&gt;       &lt;compile files="CaseOne.java"/&gt;
&gt;       &lt;run class="CaseOne"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="AClass has an aspect instance"/&gt;
&gt;           &lt;line text="The aspect instance thinks it is for type name AClass"/&gt;
&gt;  	    &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="features153/ptw" title="basic usage of getWithinTypeName - annotation style"&gt;
&gt;       &lt;compile files="CaseFive.java" options="-1.5"/&gt;
&gt;       &lt;run class="CaseFive"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="AClass has an aspect instance"/&gt;
&gt;           &lt;line text="The aspect instance thinks it is for type name AClass"/&gt;
&gt;  	    &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="features153/ptw" title="basic usage of getWithinTypeName - multiple types"&gt;
&gt;       &lt;compile files="CaseTwo.java"/&gt;
&gt;       &lt;run class="CaseTwo"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="BClass aspect instance gives a within type name of BClass"/&gt;
&gt;           &lt;line text="CClass aspect instance gives a within type name of CClass"/&gt;
&gt;           &lt;line text="AClass aspect instance gives a within type name of AClass"/&gt;
&gt;  	    &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="features153/ptw" title="basic usage of getWithinTypeName - non matching types"&gt;
&gt;       &lt;compile files="CaseThree.java"/&gt;
&gt;       &lt;run class="CaseThree"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="BClass aspect instance gives a within type name of &amp;lt;null&amp;gt;"/&gt;
&gt;           &lt;line text="CClass aspect instance gives a within type name of CClass"/&gt;
&gt;           &lt;line text="AClass aspect instance gives a within type name of AClass"/&gt;
&gt;  	    &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="features153/ptw" title="basic usage of getWithinTypeName - types in packages"&gt;
&gt;       &lt;compile files="CaseFour.java"/&gt;
&gt;       &lt;run class="a.b.CaseFour"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="BClass aspect instance gives a within type name of a.b.BClass"/&gt;
&gt;           &lt;line text="CClass aspect instance gives a within type name of a.b.CClass"/&gt;
&gt;           &lt;line text="AClass aspect instance gives a within type name of a.b.AClass"/&gt;
&gt;  	    &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.53" state="changed">30a31,35
&gt;   public void testPTWgetWithinTypeName_pr123423_1() { runTest("basic usage of getWithinTypeName");}
&gt;   public void testPTWgetWithinTypeName_pr123423_2() { runTest("basic usage of getWithinTypeName - multiple types");}
&gt;   public void testPTWgetWithinTypeName_pr123423_3() { runTest("basic usage of getWithinTypeName - non matching types");}
&gt;   public void testPTWgetWithinTypeName_pr123423_4() { runTest("basic usage of getWithinTypeName - types in packages");}
&gt;   public void testPTWgetWithinTypeName_pr123423_5() { runTest("basic usage of getWithinTypeName - annotation style");}
</file>
<file name="org.aspectj/modules/tests/features153/ptw/CaseFive.java" revision="1.1" state="new">import java.lang.reflect.Method;

import org.aspectj.lang.annotation.*;
import org.aspectj.lang.*;

class AClass {}
class BClass {}
class CClass {}

@Aspect("pertypewithin(*Class)")
public class CaseFive {
  public static void main(String []argv) throws Exception {
    new Runner().run();
  }
}

class Runner {
  public void run() throws Exception {
    if (Aspects14.hasAspect(CaseFive.class,AClass.class)) {
      System.out.println("AClass has an aspect instance");
      CaseFive instance = (CaseFive)Aspects14.aspectOf(CaseFive.class,AClass.class);
      Method m = CaseFive.class.getDeclaredMethod("getWithinTypeName",null);
      String s = (String)m.invoke(instance,null);
      System.out.println("The aspect instance thinks it is for type name "+s);
    }
  }
}
</file>
<file name="org.aspectj/modules/tests/features152/synthetic/TheWholeShow.aj" revision="1.3" state="changed">61c61
&lt;         if (name.equals("aspectOf") || name.equals("hasAspect")) continue;
---
&gt;         if (name.equals("aspectOf") || name.equals("hasAspect") || name.equals("getWithinTypeName")) continue;
</file>
<file name="org.aspectj/modules/tests/features153/ptw/CaseTwo.java" revision="1.1" state="new">// Types not in packages, and multiple mixed up instances

class AClass {}
class BClass {}
class CClass {}

public aspect CaseTwo pertypewithin(*Class) {
  public static void main(String []argv) {
    new Runner().run();
  }
}

class Runner {
  public void run() {
    CaseTwo aInstance = (CaseTwo.hasAspect(AClass.class)?CaseTwo.aspectOf(AClass.class):null);
    CaseTwo bInstance = (CaseTwo.hasAspect(BClass.class)?CaseTwo.aspectOf(BClass.class):null);
    CaseTwo cInstance = (CaseTwo.hasAspect(CClass.class)?CaseTwo.aspectOf(CClass.class):null);

    System.out.println("BClass aspect instance gives a within type name of "+
                       (bInstance==null?"&lt;null&gt;":bInstance.getWithinTypeName()));
    System.out.println("CClass aspect instance gives a within type name of "+
                       (cInstance==null?"&lt;null&gt;":cInstance.getWithinTypeName()));
    System.out.println("AClass aspect instance gives a within type name of "+
                       (aInstance==null?"&lt;null&gt;":aInstance.getWithinTypeName()));
  }
}
</file>
<file name="org.aspectj/modules/tests/features153/ptw/CaseOne.java" revision="1.1" state="new">// Types not in packages

class AClass {}
class BClass {}
class CClass {}

public aspect CaseOne pertypewithin(*Class) {
  public static void main(String []argv) {
    new Runner().run();
  }
}

class Runner {
  public void run() {
    if (CaseOne.hasAspect(AClass.class)) {
      System.out.println("AClass has an aspect instance");
      CaseOne instance = CaseOne.aspectOf(AClass.class);
      String name = instance.getWithinTypeName();
      System.out.println("The aspect instance thinks it is for type name "+name);
    }
  }
}
</file>
<file name="org.aspectj/modules/tests/features153/ptw/CaseFour.java" revision="1.1" state="new">// Types in packages

package a.b;

class AClass {}
class BClass {}
class CClass {}

public aspect CaseFour pertypewithin(*Class) {
  public static void main(String []argv) {
    new Runner().run();
  }
}

class Runner {
  public void run() {
    CaseFour aInstance = (CaseFour.hasAspect(AClass.class)?CaseFour.aspectOf(AClass.class):null);
    CaseFour bInstance = (CaseFour.hasAspect(BClass.class)?CaseFour.aspectOf(BClass.class):null);
    CaseFour cInstance = (CaseFour.hasAspect(CClass.class)?CaseFour.aspectOf(CClass.class):null);

    System.out.println("BClass aspect instance gives a within type name of "+
                       (bInstance==null?"&lt;null&gt;":bInstance.getWithinTypeName()));
    System.out.println("CClass aspect instance gives a within type name of "+
                       (cInstance==null?"&lt;null&gt;":cInstance.getWithinTypeName()));
    System.out.println("AClass aspect instance gives a within type name of "+
                       (aInstance==null?"&lt;null&gt;":aInstance.getWithinTypeName()));
  }
}
</file>
<file name="org.aspectj/modules/tests/features153/ptw/CaseThree.java" revision="1.1" state="new">// Types not in packages - BClass won't get an aspect

class AClass {}
class BClass {}
class CClass {}

public aspect CaseThree pertypewithin(*Class &amp;&amp; !BClass) {
  public static void main(String []argv) {
    new Runner().run();
  }
}

class Runner {
  public void run() {
    CaseThree aInstance = (CaseThree.hasAspect(AClass.class)?CaseThree.aspectOf(AClass.class):null);
    CaseThree bInstance = (CaseThree.hasAspect(BClass.class)?CaseThree.aspectOf(BClass.class):null);
    CaseThree cInstance = (CaseThree.hasAspect(CClass.class)?CaseThree.aspectOf(CClass.class):null);

    System.out.println("BClass aspect instance gives a within type name of "+
                       (bInstance==null?"&lt;null&gt;":bInstance.getWithinTypeName()));
    System.out.println("CClass aspect instance gives a within type name of "+
                       (cInstance==null?"&lt;null&gt;":cInstance.getWithinTypeName()));
    System.out.println("AClass aspect instance gives a within type name of "+
                       (aInstance==null?"&lt;null&gt;":aInstance.getWithinTypeName()));
  }
}
</file>
</fixedFiles>
</bug>
<bug id="123612" transactionid="69227">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-null T V</fullfingerprint>
<tag>exception</tag>
<bugreport>Given the following code:

-------------------------------------------------
public aspect A {
	declare @type : C : @MyAnnotation;
}
@interface MyAnnotation {	
}

class C {
}
-------------------------------------------------

if you comment out the declare @type statement and do an incremental build, then the following ArrayIndexOutOfBoundsException occurs:

java.lang.ArrayIndexOutOfBoundsException: 0
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:754)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:571)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:357)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:209)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)



This is against the latest code in HEAD.</bugreport>
<testsforfix ID="123612" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr123612"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="166" file="output/123612/pre-fix/testresults.xml" passing="1483" size="1649"/>
<post-fix-testcases failing="186" file="output/123612/post-fix/testresults.xml" passing="1654" size="1840"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java" revision="1.17" state="changed">129a130,132
&gt; 		declareAnnotationOnFields=null;
&gt; 		declareAnnotationOnMethods=null;
&gt; 		declareAnnotationOnTypes=null;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.26" state="changed">469c469,476
&lt; 	
---
&gt; 
&gt; 	public void testPr123612() {
&gt; 		initialiseProject("PR123612");
&gt; 		build("PR123612");
&gt; 		alter("PR123612","inc1");
&gt; 		build("PR123612");
&gt; 		checkWasntFullBuild();
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR123612/inc1/A.aj" revision="1.1" state="new">public aspect A {
//	declare @type : C : @MyAnnotation;
}
@interface MyAnnotation {	
}

class C {
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR123612/base/A.aj" revision="1.1" state="new">public aspect A {
	declare @type : C : @MyAnnotation;
}
@interface MyAnnotation {	
}

class C {
}
</file>
</fixedFiles>
</bug>
<bug id="123695" transactionid="70267">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-null O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I have an aspect that declares an annotation on a method based on a complex condition :

declare @method : !@(Write || Read) public !static * (@MarkMyMethods *).*(..) : @Write;

Basically that means that every type that is annotated with @MarkMyMethods should have all of its public non static methods be annotated with either @Read or @Write. If neither of @Read nor @Write is present on such a method, @Write is added by default.

I have another aspect that makes every type annotated with @InjectName implement  the Named interface :

public Interface Named { public String getName(); }

public aspect NameAspect {
  declare parents: @InjectName * implements Named;
  
  private String Named.name;	
  public  String Named.getName() { return name; }
}

As soon as I annotate a class with both @MarkMyMethods and @InjectName, I get an internal null pointer exception at weave time.

However if I change the first aspect to say :

  declare @method : !@(Read) public !static * (@MarkMyMethods *).*(..) : @Write;
  or
  declare @method : !@(Write) public !static * (@MarkMyMethods *).*(..) : @Write;

instead of the !@(Read || Write) one, everything compiles fine.

Here is a link to a small application that exhibits the bug. :
  
http://www.cs.mcgill.ca/~jlegar/src_jslegare.zip

==========
Here is the error output :

java.lang.NullPointerException
at org.aspectj.weaver.patterns.WildAnnotationTypePattern.matches(WildAnnotationTypePattern.java:61)
at org.aspectj.weaver.patterns.NotAnnotationTypePattern.matches(NotAnnotationTypePattern.java:35)
at org.aspectj.weaver.patterns.SignaturePattern.matchesAnnotations(SignaturePattern.java:488)
at org.aspectj.weaver.patterns.SignaturePattern.matchesExactly(SignaturePattern.java:331)
at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:288)
at org.aspectj.weaver.patterns.DeclareAnnotation.matches(DeclareAnnotation.java:247)
at org.aspectj.weaver.bcel.BcelClassWeaver.weaveAtMethodOnITDSRepeatedly(BcelClassWeaver.java:995)
at org.aspectj.weaver.bcel.BcelClassWeaver.weaveDeclareAtMethodCtor(BcelClassWeaver.java:730)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:430)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1078)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class NameAspect extends java.lang.Object:
  TypeMungers: [(BcelTypeMunger ResolvedTypeMunger(Method, java.lang.String Named.getName())), (BcelTypeMunger ResolvedTypeMunger(Field, java.lang.String Named.name))]
     declares: [declare parents: @InjectName * extends (Named);]
  private static Throwable ajc$initFailureCause
  public static final NameAspect ajc$perSingletonInstance
  static void &lt;clinit&gt;():
    catch java.lang.Throwable -&gt; E0
    |               INVOKESTATIC NameAspect.ajc$postClinit ()V   (line 2)
    catch java.lang.Throwable -&gt; E0
                    GOTO L0
                E0: ASTORE_0
                    ALOAD_0
                    PUTSTATIC NameAspect.ajc$initFailureCause Ljava/lang/Throwable;
                L0: RETURN
  end static void &lt;clinit&gt;()

  public void &lt;init&gt;():
                    ALOAD_0     // NameAspect this   (line 2)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
                    RETURN
  end public void &lt;init&gt;()

  void ajc$declare_parents_1()    org.aspectj.weaver.MethodDeclarationLineNumber: 5:40
:
                    RETURN   (line 5)
  end void ajc$declare_parents_1()

  public static String ajc$interMethod$NameAspect$Named$getName(Named)    EffectiveSignatureAttribute(java.lang.String Named.getName(), method-execution)
:
                    ALOAD_0     // Named ajc$this_   (line 11)
                    INVOKESTATIC NameAspect.ajc$interFieldGetDispatch$NameAspect$Named$name (LNamed;)Ljava/lang/String;
                    ARETURN
  end public static String ajc$interMethod$NameAspect$Named$getName(Named)

  public static String ajc$interMethodDispatch1$NameAspect$Named$getName(Named)    EffectiveSignatureAttribute(java.lang.String Named.getName(), method-call)
:
                    ALOAD_0
                    INVOKEINTERFACE Named.getName ()Ljava/lang/String;
                    ARETURN
  end public static String ajc$interMethodDispatch1$NameAspect$Named$getName(Named)

  public static void ajc$interFieldInit$NameAspect$Named$name(Named)    org.aspectj.weaver.MethodDeclarationLineNumber: 12:279
:
                    RETURN   (line 12)
  end public static void ajc$interFieldInit$NameAspect$Named$name(Named)

  public static String ajc$interFieldGetDispatch$NameAspect$Named$name(Named)    EffectiveSignatureAttribute(java.lang.String Named.name, field-get)
:
                    ALOAD_0
                    INVOKEINTERFACE Named.ajc$interFieldGet$NameAspect$Named$name ()Ljava/lang/String;
                    ARETURN
  end public static String ajc$interFieldGetDispatch$NameAspect$Named$name(Named)

  public static void ajc$interFieldSetDispatch$NameAspect$Named$name(Named, String)    EffectiveSignatureAttribute(java.lang.String Named.name, field-set)
:
                    ALOAD_0
                    ALOAD_1
                    INVOKEINTERFACE Named.ajc$interFieldSet$NameAspect$Named$name (Ljava/lang/String;)V
                    RETURN
  end public static void ajc$interFieldSetDispatch$NameAspect$Named$name(Named, String)

  public void ajc$after$NameAspect$1$dd96786a(Named)    AdviceAttribute(after, (execution(Named+.new(..)) &amp;&amp; target(BindingTypePattern(Named, 0))), 0, 296)
:
                    GETSTATIC java.lang.System.out Ljava/io/PrintStream;   (line 15)
                    LDC "A new name was created"
                    INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
                    ALOAD_1     // Named newinstance   (line 16)
                    LDC "TikaTikaSlimShady"
                    INVOKESTATIC NameAspect.ajc$interFieldSetDispatch$NameAspect$Named$name (LNamed;Ljava/lang/String;)V
                    RETURN   (line 17)
  end public void ajc$after$NameAspect$1$dd96786a(Named)

  public static NameAspect aspectOf()    org.aspectj.weaver.AjAttribute$AjSynthetic@14d92f0
:
                    GETSTATIC NameAspect.ajc$perSingletonInstance LNameAspect;
                    IFNONNULL L0
                    NEW org.aspectj.lang.NoAspectBoundException
                    DUP
                    LDC "NameAspect"
                    GETSTATIC NameAspect.ajc$initFailureCause Ljava/lang/Throwable;
                    INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt; (Ljava/lang/String;Ljava/lang/Throwable;)V
                    ATHROW
                L0: GETSTATIC NameAspect.ajc$perSingletonInstance LNameAspect;
                    ARETURN
  end public static NameAspect aspectOf()

  public static boolean hasAspect()    org.aspectj.weaver.AjAttribute$AjSynthetic@12e2f2e
:
                    GETSTATIC NameAspect.ajc$perSingletonInstance LNameAspect;
                    IFNULL L0
                    ICONST_1
                    IRETURN
                L0: ICONST_0
                    IRETURN
  end public static boolean hasAspect()

  private static void ajc$postClinit()    org.aspectj.weaver.AjAttribute$AjSynthetic@1f0523b
:
                    NEW NameAspect
                    DUP
                    INVOKESPECIAL NameAspect.&lt;init&gt; ()V
                    PUTSTATIC NameAspect.ajc$perSingletonInstance LNameAspect;
                    RETURN
  end private static void ajc$postClinit()
end public class NameAspect

when weaving type NameAspect
when weaving aspects 
when weaving 
when batch building BuildConfig[D:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\AspectSandBox.generated.lst] #Files=8</bugreport>
<pre-fix-testcases failing="180" file="output/123695/pre-fix/testresults.xml" passing="1660" size="1840"/>
<post-fix-testcases failing="183" file="output/123695/post-fix/testresults.xml" passing="1657" size="1840"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java" revision="1.17" state="changed">61c61,62
&lt; 		if (annTypes.length!=0) {
---
&gt; 
&gt; 		if (annTypes!=null &amp;&amp; annTypes.length!=0) {
</file>
</fixedFiles>
</bug>
<bug id="124105" transactionid="69735">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V</fullfingerprint>
<bugreport>See Jeppe's post on the mailing list... will append more here soon.</bugreport>
<pre-fix-testcases failing="183" file="output/124105/pre-fix/testresults.xml" passing="1657" size="1840"/>
<post-fix-testcases failing="181" file="output/124105/post-fix/testresults.xml" passing="1659" size="1840"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java" revision="1.5" state="changed">112a113
&gt; 		signaturePattern.resolveBindings(scope,bindings);
</file>
</fixedFiles>
</bug>
<bug id="124654" transactionid="70091">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="11"/>
<property name="lines-churned" value="12"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-import M O-! O-() O-&amp;&amp; O-cast T V Z-cast Z-if</fullfingerprint>
<bugreport>The following aspect won't compile with aspect 1.5:

package aj;

import java.lang.annotation.Annotation;

public abstract aspect GenericAnnotation&lt;A extends Annotation&gt; {

    pointcut annotatedCall(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a);

    /* does not compile */
    before(A a) : annotatedCall(a) {
        System.out.println(a.annotationType());
    }
    /* */

    /* OK */
    before(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a) {
        System.out.println(a.annotationType());
    }

}

----------------------

&gt;ajc -1.5 -d aj src\aj\*
...\src\aj\GenericAnnotation.aj:10 [error] incompatible type, expected java.lang.annotation.Annotation found BindingTypePattern(TA;, 0).  Check the type specified in your pointcut before(A a) : annotatedCall(a) {

1 error

----------------

Commenting out the first advice lets this program run as expected:

package aj;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

public class Main {

    @Retention(RetentionPolicy.RUNTIME)
    @interface MyAnnotation {
    }

    static aspect ConcreteAnnotation extends GenericAnnotation&lt;MyAnnotation&gt; {
    }

    public static void main(String[] args) {
        someMethod();
    }

    @MyAnnotation
    private static void someMethod() {
    }

}</bugreport>
<testsforfix ID="124654" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testGenericAspectsAndAnnotations_pr124654"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="generic aspects and annotations"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="189" file="output/124654/pre-fix/testresults.xml" passing="1651" size="1840"/>
<post-fix-testcases failing="182" file="output/124654/post-fix/testresults.xml" passing="1658" size="1840"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java" revision="1.38" state="changed">32a33
&gt; import org.aspectj.weaver.TypeVariableReference;
226,228c227,237
&lt; 			if (!p.matchesSubtypes(parameterTypes[i]) &amp;&amp; 
&lt; 				!p.getExactType().equals(UnresolvedType.OBJECT))
&lt; 			{
---
&gt; 			
&gt; 			boolean reportProblem = false;
&gt; 			if (parameterTypes[i].isTypeVariableReference() &amp;&amp; p.getExactType().isTypeVariableReference()) {
&gt; 				UnresolvedType One = ((TypeVariableReference)parameterTypes[i]).getTypeVariable().getFirstBound();
&gt; 				UnresolvedType Two = ((TypeVariableReference)p.getExactType()).getTypeVariable().getFirstBound();
&gt; 				reportProblem = !One.resolve(scope.getWorld()).isAssignableFrom(Two.resolve(scope.getWorld()));
&gt; 			} else {
&gt; 				reportProblem = !p.matchesSubtypes(parameterTypes[i]) &amp;&amp; 
&gt; 			    !p.getExactType().equals(UnresolvedType.OBJECT);
&gt; 			}
&gt; 			if (reportProblem) {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.6" state="changed">56c56,66
&lt; 
---
&gt;     
&gt;     &lt;ajc-test dir="bugs151/pr124654" title="generic aspects and annotations"&gt;
&gt;         &lt;compile files="GenericAnnotation.java,TestSubAspect.java" options="-1.5"/&gt;
&gt;         &lt;run class="TestSubAspect"&gt;
&gt;           &lt;stderr&gt;
&gt;             &lt;line text="Reference pointcut advice. interface MyAnnotation"/&gt;
&gt;             &lt;line text="Inlined pointcut advice. interface MyAnnotation"/&gt;
&gt;             &lt;line text="run running"/&gt;
&gt;           &lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.6" state="changed">27a28
&gt;   public void testGenericAspectsAndAnnotations_pr124654() { runTest("generic aspects and annotations");}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr124654/TestSubAspect.java" revision="1.1" state="new">import java.lang.annotation.*;

public aspect TestSubAspect extends GenericAnnotation&lt;MyAnnotation&gt; {

  public static void main(String []argv) {
    new BasicType().run();
  }
}

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {}


class BasicType {
  @MyAnnotation
  public void run() {
    System.err.println("run running");
  }
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr124654/GenericAnnotation.java" revision="1.1" state="new">import java.lang.annotation.Annotation;

public abstract aspect GenericAnnotation&lt;A extends Annotation&gt; {

   pointcut annotatedCall(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a);

   before(A a) : annotatedCall(a) {
       System.err.println("Reference pointcut advice. "+a.annotationType());
   }

   before(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a) {
       System.err.println("Inlined pointcut advice. "+a.annotationType());
   }

}
</file>
</fixedFiles>
</bug>
<bug id="124808" transactionid="70148">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="6"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="8"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="12"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-import K-null K-this M O-() O-cast T V Z-cast Z-if Z-vardecl</fullfingerprint>
<bugreport>Hi,

Here is the second generics issue:

Java code:
==========

public class Test&lt;T extends Integer&gt; {
	Set&lt;T&gt; ints = new HashSet&lt;T&gt;();

	public Set&lt;T&gt; foo() {
		return ints;
	}

	public static void main(String[] args) {
		Test&lt;Integer&gt; t = new Test&lt;Integer&gt;();
		Set&lt;Integer&gt; ints = t.foo();
	}
}

Aspect:
=======
public privileged aspect TestAspect {

    pointcut gettingMemberCollection(Test t) :
                   target(t) &amp;&amp;
                   get(!public Set&lt;Number+&gt; com.mprv.secsph.*.*) &amp;&amp;
                   !within(TestAspect);

	after (Test test) : gettingMemberCollection(test) {
		System.out.println("GO Aspects!");
	}
}

Compiler output:
================
warning at after (Test test) : gettingMemberCollection(test) {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/IdeaProjects/aspectsTest/src/com/mprv/secsph/TestAspect.aj:19:0::0 advice defined in com.mprv.secsph.TestAspect has not been applied [Xlint:adviceDidNotMatch]


I would expect "gettingMemberCollection" to catch access to "ints" member of "Test" ...

Thanks a lot!
Misha.</bugreport>
<testsforfix ID="124808" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testParameterizedCollectionFieldMatching_pr124808"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="parameterized collection fields matched via pointcut"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="185" file="output/124808/pre-fix/testresults.xml" passing="1655" size="1840"/>
<post-fix-testcases failing="181" file="output/124808/post-fix/testresults.xml" passing="1659" size="1840"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java" revision="1.37" state="changed">113c113,115
&lt; 		return false;
---
&gt; 	    // was this method previously coded to return false *on purpose* ??  pr124808
&gt; 		return this.type.equals(((TypeVariableReference)matchType).getTypeVariable().getFirstBound());
&gt; 		//return false;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/TypePattern.java" revision="1.34" state="changed">27a28
&gt; import org.aspectj.weaver.TypeVariableReference;
154a156,162
&gt; 		// pr124808
&gt; 		Iterator typesIterator = null;
&gt; 		if (type.isTypeVariableReference()) {
&gt; 			typesIterator = ((TypeVariableReference)type).getTypeVariable().getFirstBound().resolve(type.getWorld()).getDirectSupertypes();
&gt; 		} else {
&gt; 			typesIterator = type.getDirectSupertypes();
&gt; 		}
157c165
&lt; 		for (Iterator i = type.getDirectSupertypes(); i.hasNext(); ) {
---
&gt; 		for (Iterator i = typesIterator; i.hasNext(); ) {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.5" state="changed">26a27
&gt;   public void testParameterizedCollectionFieldMatching_pr124808() { runTest("parameterized collection fields matched via pointcut");}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr124808/Test.java" revision="1.1" state="new">import java.util.*;

public class Test&lt;T extends Integer&gt; {
       Set&lt;T&gt; ints = new HashSet&lt;T&gt;();

       public Set&lt;T&gt; foo() {
               return ints;
       }


       public static void main(String[] args) {
               Test&lt;Integer&gt; t2 = new Test&lt;Integer&gt;();
               Set&lt;Integer&gt; ints2 = t2.foo();
       }
}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.5" state="changed">46a47,55
&gt;     
&gt;     &lt;ajc-test dir="bugs151/pr124808" title="parameterized collection fields matched via pointcut"&gt;
&gt;         &lt;compile files="Test.java,TestAspect.java" options="-1.5"/&gt;
&gt;         &lt;run class="Test"&gt;
&gt;           &lt;stderr&gt;
&gt;              &lt;line text="GO Aspects!  get(Set Test.ints)"/&gt;
&gt;           &lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/bugs151/pr124808/TestAspect.java" revision="1.1" state="new">import java.util.*;

public privileged aspect TestAspect {

   pointcut gettingMemberCollection() : get(Set&lt;Number+&gt; *);

   after() : gettingMemberCollection() {
     System.err.println("GO Aspects!  "+thisJoinPoint);
   }
}
</file>
</fixedFiles>
</bug>
<bug id="124999" transactionid="70208">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="5"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-instanceof M O-instanceof T V Z-if</fullfingerprint>
<bugreport>The following case produces a runtime error:

package aj;

public abstract aspect GenericInheritedMethod&lt;T&gt; {

    protected final T getSomething() {
        return null;
    }

}


package aj;

aspect UseInheritedMethod extends GenericInheritedMethod&lt;Integer&gt; {

    // works as expected
    before() : execution(void someMethod()) {
        System.out.println(getSomething());
    }

    // Runtime Error
    void around() : execution(void someMethod()) {
        System.out.println(getSomething());
    }

    public static void main(String[] args) {
        someMethod();
    }

    private static void someMethod() {
    }

}


&gt;java aj.UseInheritedMethod
null
Exception in thread "main" java.lang.NoSuchMethodError: aj.UseInheritedMethod.getSomething()Ljava/lang/Integer;
        at aj.UseInheritedMethod.ajc$inlineAccessMethod$aj_UseInheritedMethod$aj_UseInheritedMethod$getSomething(UseInheritedMethod.aj)
        at aj.UseInheritedMethod.ajc$around$aj_UseInheritedMethod$2$c74e36b7(UseInheritedMethod.aj:12)
        at aj.UseInheritedMethod.someMethod(UseInheritedMethod.aj:1)
        at aj.UseInheritedMethod.main(UseInheritedMethod.aj:16)

The "inlineAccessMethod" should call "getSomething()Ljava/lang/Object;" as the before advice does.</bugreport>
<testsforfix ID="124999" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testCallInheritedGenericMethod_pr124999"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="calling inherited generic method from around advice"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="182" file="output/124999/pre-fix/testresults.xml" passing="1658" size="1840"/>
<post-fix-testcases failing="186" file="output/124999/post-fix/testresults.xml" passing="1654" size="1840"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java" revision="1.21" state="changed">42a43
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding;
172c173,177
&lt; 
---
&gt; 		
&gt; 		if (binding instanceof ParameterizedMethodBinding) { // pr124999
&gt; 			binding = binding.original();
&gt; 		}
&gt; 		
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.7" state="changed">28a29
&gt;   public void testCallInheritedGenericMethod_pr124999() { runTest("calling inherited generic method from around advice");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.7" state="changed">56a57,61
&gt;     &lt;ajc-test dir="bugs151" title="calling inherited generic method from around advice"&gt;
&gt;         &lt;compile files="pr124999.aj" options="-1.5"/&gt;
&gt;         &lt;run class="pr124999"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs151/pr124999.aj" revision="1.1" state="new">abstract aspect GenericInheritedMethod&lt;T&gt; {

   protected  T getSomething() {
       return null;
   }

}


aspect pr124999 extends GenericInheritedMethod&lt;Integer&gt; {

   // Runtime Error
   void around() : execution(void someMethod()) {
       System.out.println(getSomething());
   }

   public static void main(String[] args) {
     new C().someMethod();
   }
   

}


class C {
   public void someMethod() { }
}
</file>
</fixedFiles>
</bug>
<bug id="125101" transactionid="69266">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint/>
<fullfingerprint/>
<bugreport>Hi.

I am weaving two aspects into a jar file "jar-to-jar". ajc 1.5.0 gives me a huge error message (see attachement). Would be great if I could get any recommendations on this.

Thanks!
Eric</bugreport>
<pre-fix-testcases failing="184" file="output/125101/pre-fix/testresults.xml" passing="1657" size="1841"/>
<post-fix-testcases failing="182" file="output/125101/post-fix/testresults.xml" passing="1659" size="1841"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWorld.java" revision="1.39" state="changed">309a310
&gt; 		    
</file>
</fixedFiles>
</bug>
<bug id="125405" transactionid="68267">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="18"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="18"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-null M O-== O-! O-&amp;&amp; T V Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>To reproduce: Create a new AspectJ project, and create a new aspect:

package test;

public aspect ATest
{
    // main
    public static void main(String[] args) {

    }
}
====
Then, write ATest&lt;T&gt; instead of just ATest and then save.

You should now get the warning:
2	only abstract aspects can have type parameters	ATest.aj

So far so good. Now, remove the newly added "&lt;T&gt;" and save again. This should happen:

java.lang.IllegalStateException
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:605)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:590)
at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:421)
at org.aspectj.weaver.ResolvedType.getDeclaredAdvice(ResolvedType.java:699)
at org.aspectj.weaver.ResolvedType.getDeclaredShadowMungers(ResolvedType.java:736)
at org.aspectj.weaver.ResolvedType.collectShadowMungers(ResolvedType.java:572)
at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:501)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:66)
at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:439)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: Can't ask to parameterize a member of non-generic type: test.ATest  kind(raw)</bugreport>
<testsforfix ID="125405" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr125405"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="182" file="output/125405/pre-fix/testresults.xml" passing="1773" size="1955"/>
<post-fix-testcases failing="182" file="output/125405/post-fix/testresults.xml" passing="1773" size="1955"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java" revision="1.66" state="changed">71a72
&gt; import org.aspectj.weaver.UnresolvedType.TypeKind;
959a961
&gt; 
960a963,972
&gt; 		
&gt; 		// A type can change from simple &gt; generic &gt; simple across a set of compiles. We need
&gt; 		// to ensure the entry in the typemap is promoted and demoted correctly.  The call
&gt; 		// to setGenericType() below promotes a simple to a raw. This call demotes it back
&gt; 		// to simple
&gt; 		// pr125405
&gt; 		if (!binding.isRawType() &amp;&amp; !binding.isGenericType() &amp;&amp; name.getTypekind()==TypeKind.RAW) {
&gt; 			name.demoteToSimpleType();
&gt; 		}
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ReferenceType.java" revision="1.41" state="changed">662a663,668
&gt; 	public void demoteToSimpleType() {
&gt; 		genericType      = null;
&gt; 		typeKind         = TypeKind.SIMPLE;
&gt; 		signatureErasure = null;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.29" state="changed">284a285,299
&gt; 
&gt; 	// parameterization of generic aspects
&gt; 	public void testPr125405() {
&gt; 		initialiseProject("PR125405");
&gt; 		build("PR125405");
&gt; 		checkCompileWeaveCount(1,1);
&gt; 		alter("PR125405","inc1");
&gt; 		build("PR125405");
&gt; 		// "only abstract aspects can have type parameters"
&gt; 		checkForError("only abstract aspects can have type parameters");
&gt; 		alter("PR125405","inc2");
&gt; 		build("PR125405");
&gt; 		checkCompileWeaveCount(1,1);
&gt; 		assertTrue("Should be no errors, but got "+MyTaskListManager.getErrorMessages(),MyTaskListManager.getErrorMessages().size()==0);		
&gt; 	}
568a584,592
&gt; 	public void checkForError(String anError) {
&gt; 		List messages = MyTaskListManager.getErrorMessages();
&gt; 		for (Iterator iter = messages.iterator(); iter.hasNext();) {
&gt; 			IMessage element = (IMessage) iter.next();
&gt; 			if (element.getMessage().indexOf(anError)!=-1) return;
&gt; 		}
&gt; 		fail("Didn't find the error message:\n'"+anError+"'.\nErrors that occurred:\n"+MyTaskListManager.getErrorMessages());
&gt; 	}
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="125475" transactionid="70194">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-import K-instanceof K-true O-! O-() O-&amp;&amp; O-instanceof T V Z-for Z-if</fullfingerprint>
<bugreport>I get this error:

C:\temp\ajcSandbox\ajcTest27856.tmp\TestEmptyPointcutAtAspect.java:8:0::0 Method annotated with @Pointcut() for abstract pointcut must be abstract

when compiling this aspect with ajc (it's fine with javac):

@Aspect
public class TestEmptyPointcutAtAspect {

	@Pointcut("")
	protected void scope () {}
}</bugreport>
<testsforfix ID="125475" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testEmptyPointcut_pr125475"/>
      <test NAME="testInlinevisitorNPE_pr123901"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="inlinevisitor NPE"/>
      <test NAME="empty pointcut in atAJ"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="184" file="output/125475/pre-fix/testresults.xml" passing="1776" size="1960"/>
<post-fix-testcases failing="185" file="output/125475/post-fix/testresults.xml" passing="1775" size="1960"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java" revision="1.22" state="changed">43a44
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ProblemFieldBinding;
99,100c100,101
&lt; 			
&lt; 			for (int i=0, len=ref.otherBindings.length; i &lt; len; i++) {
---
&gt; 			boolean cont = true; // don't continue if we come across a problem
&gt; 			for (int i=0, len=ref.otherBindings.length; i &lt; len &amp;&amp; cont; i++) {
103c104,105
&lt; 				receiverType = binding.type;
---
&gt; 				if (!(binding instanceof ProblemFieldBinding)) 	receiverType = binding.type;
&gt; 				else                                                cont=false;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.12" state="changed">35a36,37
&gt;   //public void testEmptyPointcut_pr125475()    { runTest("empty pointcut in atAJ");}
&gt;   public void testInlinevisitorNPE_pr123901() { runTest("inlinevisitor NPE");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.12" state="changed">7a8,13
&gt;     &lt;/ajc-test&gt;  
&gt;     
&gt;     &lt;ajc-test dir="bugs151/pr123901" title="inlinevisitor NPE"&gt;
&gt;         &lt;compile files="A.java,B.java" options="-1.5"&gt;
&gt;           &lt;message kind="error" line="5" text="a.A cannot be resolved or is not a field"/&gt;
&gt;         &lt;/compile&gt;
100a107,110
&gt;     &lt;ajc-test dir="bugs151/pr125475" title="empty pointcut in atAJ"&gt;
&gt;         &lt;compile files="TestEmptyPointcutAtAspect.java" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs151/pr125475/TestEmptyPointcutAtAspect.java" revision="1.1" state="new">@Aspect
public class TestEmptyPointcutAtAspect {

       @Pointcut("")
       protected void scope () {}
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr123901/B.java" revision="1.1" state="new">package a;
public aspect B {
   void around():call(void *(..)){ 
      A a = new A();
      a.A.a.x(); // This line raises the NPE    
      proceed();    
   }
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr123901/A.java" revision="1.1" state="new">package a;

public class A {
   public void x(){} 
}
</file>
</fixedFiles>
</bug>
<bug id="125480" transactionid="68833">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="13"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="13"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-for K-if K-null K-return K-true M O-&lt; O-== O-|| O-++ T V Y Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>An aop.xml aspect cannot inherit an abstract method but it should inherit one that has already been made concrete in a super-aspect. At the moment an abstract method "test()" causes the follow error during LTW:

info AspectJ Weaver Version DEVELOPMENT built on 
info register classloader org.aspectj.weaver.loadtime.WeavingURLClassLoader
info using /C:/temp/ajcSandbox/ajcTest6462.tmp/META-INF/aop.xml
error Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml
warning register definition failed -- (AbortException) Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml
Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml
Message: error Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml
org.aspectj.bridge.AbortException: Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml</bugreport>
<pre-fix-testcases failing="189" file="output/125480/pre-fix/testresults.xml" passing="1826" size="2015"/>
<post-fix-testcases failing="188" file="output/125480/post-fix/testresults.xml" passing="1827" size="2015"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java" revision="1.7" state="changed">173c173,175
&lt;                 		elligibleAbstractions.add(method.getName());
---
&gt;                 		// Only interested in abstract methods that take no parameters and are marked @Pointcut
&gt;                 		if (hasPointcutAnnotation(method))
&gt;                 			elligibleAbstractions.add(method.getName());
211a214,224
&gt;     
&gt;     private boolean hasPointcutAnnotation(ResolvedMember member) {
&gt;     	  AnnotationX[] as = member.getAnnotations();
&gt;     	  if (as==null || as.length==0) return false;
&gt;     	  for (int i = 0; i &lt; as.length; i++) {
&gt; 			if (as[i].getTypeSignature().equals("Lorg/aspectj/lang/annotation/Pointcut;")) {
&gt; 				return true;
&gt; 			}
&gt; 		}
&gt;     	  return false;
&gt;     }
</file>
</fixedFiles>
</bug>
<bug id="125699" transactionid="68950">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-null M O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<bugreport>Inherting the following advice in an @aspect causes an unexpected error.

	before (Object obj) : execution(* *(..)) &amp;&amp; this(obj) {
		System.out.println(thisJoinPoint);
	}

"erre the parameter thisJoinPoint is not bound in [all branches of] pointcut"</bugreport>
<testsforfix ID="125699" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testAtAspectInheritsAdviceWithTJPAndThis_pr125699"/>
      <test NAME="testAtAspectInheritsAdviceWithTJPAndThis_pr125699_2"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="inherit advice with this() and thisJoinPoint"/>
      <test NAME="inherit advice with this() and thisJoinPoint - 2"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="193" file="output/125699/pre-fix/testresults.xml" passing="1790" size="1983"/>
<post-fix-testcases failing="191" file="output/125699/post-fix/testresults.xml" passing="1790" size="1981"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java" revision="1.84" state="changed">505,507c505,510
&lt;                     //ATAJ for @AJ aspect, the formal have to be checked according to the argument number
&lt;                     // since xxxJoinPoint presence or not have side effects
&lt;                     if (advice.getConcreteAspect().isAnnotationStyleAspect()) {
---
&gt;                     // If the advice is being concretized in a @AJ aspect *and* the advice was declared in
&gt;                     // an @AJ aspect (it could have been inherited from a code style aspect) then
&gt;                     // evaluate the alternative set of formals. pr125699
&gt;                     if (advice.getConcreteAspect().isAnnotationStyleAspect()
&gt;                     	&amp;&amp; advice.getDeclaringAspect()!=null 
&gt;                     	&amp;&amp; advice.getDeclaringAspect().resolve(world).isAnnotationStyleAspect()) {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.19" state="changed">136,137c136,141
&lt;     &lt;ajc-test dir="bugs151/pr125699" title="inherit adivce with this() and thisJoinPoint"&gt;
&lt;         &lt;compile files="Tracing.aj, TestTracing.aj, AtTestTracing.java" options="-1.5"/&gt;
---
&gt;     &lt;ajc-test dir="bugs151/pr125699" title="inherit advice with this() and thisJoinPoint"&gt;
&gt;         &lt;compile files="Tracing.aj, TestTracing.aj, AtTestTracing.java" options="-1.5"&gt;
&gt;           &lt;message kind="warning" line="13" text="advice defined in Tracing has not been applied [Xlint:adviceDidNotMatch]"/&gt;
&gt;           &lt;message kind="warning" line="8" text="advice defined in Tracing has not been applied [Xlint:adviceDidNotMatch]"/&gt;
&gt;           &lt;message kind="warning" line="3" text="advice defined in Tracing has not been applied [Xlint:adviceDidNotMatch]"/&gt;
&gt;         &lt;/compile&gt;
139c143,151
&lt;     
---
&gt; 
&gt;     &lt;ajc-test dir="bugs151/pr125699" title="inherit advice with this() and thisJoinPoint - 2"&gt;
&gt;         &lt;compile files="Tracing.aj, SubAbstractTracing.aj, SubAtAj.java" options="-1.5"&gt;
&gt;           &lt;message kind="warning" line="13" text="advice defined in Tracing has not been applied [Xlint:adviceDidNotMatch]"/&gt;
&gt;           &lt;message kind="warning" line="8" text="advice defined in Tracing has not been applied [Xlint:adviceDidNotMatch]"/&gt;
&gt;           &lt;message kind="warning" line="3" text="advice defined in Tracing has not been applied [Xlint:adviceDidNotMatch]"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.21" state="changed">41a42,43
&gt;   public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699 () { runTest("inherit advice with this() and thisJoinPoint");  }
&gt;   public void testAtAspectInheritsAdviceWithTJPAndThis_pr125699_2 () {runTest("inherit advice with this() and thisJoinPoint - 2");  }
</file>
<file name="org.aspectj/modules/tests/bugs151/pr125699/SubAtAj.java" revision="1.1" state="new">import org.aspectj.lang.annotation.Aspect;

@Aspect
public class SubAtAj extends SubAbstractTracing {

}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr125699/SubAbstractTracing.aj" revision="1.1" state="new">public abstract aspect SubAbstractTracing extends Tracing {
	
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr125699/AtTestTracing.java" revision="1.2" state="changed">2d1
&lt; import org.aspectj.lang.annotation.Pointcut;
</file>
</fixedFiles>
</bug>
<bug id="125810" transactionid="70065">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="16"/>
<property name="lines-churned" value="16"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-for K-if K-null K-return K-true M O-&lt; O-! O-!= O-&amp;&amp; O-++ T V Y Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>An error is issued when a sub-aspect does not implement an inherited abstract pointcut. This is missing for a sub-@aspect.</bugreport>
<pre-fix-testcases failing="186" file="output/125810/pre-fix/testresults.xml" passing="1781" size="1967"/>
<post-fix-testcases failing="184" file="output/125810/post-fix/testresults.xml" passing="1783" size="1967"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.56" state="changed">423,424c423,424
&lt; 
&lt; 		if (hasPointcuts || dec instanceof AspectDeclaration) {
---
&gt;         
&gt; 		if (hasPointcuts || dec instanceof AspectDeclaration || isAnnotationStyleAspectDeclaration(dec)) {
436c436,450
&lt;     
---
&gt;     /**
&gt;      * Return true if the declaration has @Aspect annotation
&gt;      */
&gt; 	private boolean isAnnotationStyleAspectDeclaration(TypeDeclaration dec) { 
&gt;         Annotation[] annotations = dec.annotations;
&gt;         boolean isAtAspect = false;
&gt;         if (annotations != null) {
&gt; 			for (int i = 0; i &lt; annotations.length  &amp;&amp; !isAtAspect; i++) {
&gt; 				if (annotations[i].resolvedType.debugName().equals("org.aspectj.lang.annotation.Aspect")) {
&gt; 					isAtAspect = true;
&gt; 				}
&gt; 			}
&gt; 		}
&gt;         return isAtAspect;
&gt; 	}
438d451
&lt; 	
</file>
</fixedFiles>
</bug>
<bug id="126328" transactionid="70395">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="15"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="18"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-false K-if K-new K-return K-throw K-true K-try M O-! O-&amp;&amp; O-+ T V Y Z-if Z-throw</fullfingerprint>
<tag>exception</tag>
<bugreport>If there are &gt; 1000 jars on the combination of classpath, aspectpath, and inpath, it is possible for a ZipFile to be closed and not successfully reopened before trying to read from it again.</bugreport>
<pre-fix-testcases failing="186" file="output/126328/pre-fix/testresults.xml" passing="1781" size="1967"/>
<post-fix-testcases failing="184" file="output/126328/post-fix/testresults.xml" passing="1783" size="1967"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java" revision="1.12" state="changed">245c245,247
&lt; 			if (zipFile != null) return; // If its not null, the zip is already open
---
&gt; 			if (zipFile != null &amp;&amp; openArchives.contains(zipFile)) {
&gt; 				if (isReallyOpen()) return;
&gt; 			}
250a253,255
&gt; 				if (!isReallyOpen()) {
&gt; 					throw new BCException("Can't open archive: "+file.getName()+" (size() check failed)");					
&gt; 				}
256a262,273
&gt; 		private boolean isReallyOpen() {
&gt; 			try {
&gt; 				zipFile.size(); // this will fail if the file has been closed for
&gt; 				                // some reason;
&gt; 				return true;
&gt; 			} catch (IllegalStateException ex) {
&gt; 				// this means the zip file is closed...
&gt; 				return false;
&gt; 			}
&gt; 			
&gt; 		}
&gt; 		
</file>
</fixedFiles>
</bug>
<bug id="128128" transactionid="75671">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-false K-this K-true M T V</fullfingerprint>
<bugreport>The iajc ant task doesn't failonerror anymore.

The most relevant line is AjcTask.java:1256 with holder.numMessages(IMessage.ERROR, false) always returning 0.

The holder:MessageHandler instance delegates messages to an interceptor AntMessageHandler. The AntMessageHandler is (almost) always consuming the messages, leaving the MessageHandler.java:108 to return without recording any messages itself.

I would have liked to submit a patch with this bug report but I'm not yet sure what the correct interceptor.handleMessage(message) behavior should be in this case.

Note: The AntMessageHandler properly reporting message priorities ("error" vs. "warn") is welcome functionality - thanks.</bugreport>
<pre-fix-testcases failing="192" file="output/128128/pre-fix/testresults.xml" passing="1791" size="1983"/>
<post-fix-testcases failing="186" file="output/128128/post-fix/testresults.xml" passing="1797" size="1983"/>
<fixedFiles>
<file name="org.aspectj/modules/taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java" revision="1.47" state="changed">1233c1233
&lt;               delegate  = new AntMessageHandler(this.logger,this.verbose);
---
&gt;               delegate  = new AntMessageHandler(this.logger,this.verbose, false);
2033,2035c2033,2036
&lt; 	private boolean taskLevelVerbose;
&lt; 	
&lt; 	public AntMessageHandler(TaskLogger logger, boolean taskVerbose) {
---
&gt;     private final boolean taskLevelVerbose;
&gt;     private final boolean handledMessage;
&gt;     
&gt; 	public AntMessageHandler(TaskLogger logger, boolean taskVerbose, boolean handledMessage) {
2037a2039
&gt;         this.handledMessage = handledMessage;
2070c2072
&lt; 		return true;
---
&gt; 		return handledMessage;
</file>
</fixedFiles>
</bug>
<bug id="128174" transactionid="72981">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="26"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="26"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-instanceof K-null K-return M O-== O-!= O-cast O-instanceof T V Z-cast Z-if</fullfingerprint>
<bugreport>The inplace outline view in the AspectJ editor should show aspects, but it is not currently working and only shows classes.</bugreport>
<pre-fix-testcases failing="187" file="output/128174/pre-fix/testresults.xml" passing="1797" size="1984"/>
<post-fix-testcases failing="188" file="output/128174/post-fix/testresults.xml" passing="1796" size="1984"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/core/javaelements/AJCompilationUnitManager.java" revision="1.14" state="changed">30a31
&gt; import org.eclipse.jdt.core.ICompilationUnit;
65a67,86
&gt; 	/**
&gt; 	 * Returns the AJCompilationUnit corresponding to the given
&gt; 	 * CompilationUnit, if there is one, otherwise return the unit itself
&gt; 	 * @param cu
&gt; 	 * @return
&gt; 	 */
&gt; 	public static ICompilationUnit mapToAJCompilationUnit(ICompilationUnit cu) {
&gt; 		if (AspectJPlugin.usingCUprovider) { // mapping not required
&gt; 			return cu;
&gt; 		}
&gt; 		IResource res = cu.getResource();
&gt; 		if (res.getType() == IResource.FILE) {
&gt; 			AJCompilationUnit ajcu = INSTANCE.getAJCompilationUnit((IFile) res);
&gt; 			if (ajcu != null) {
&gt; 				return ajcu;
&gt; 			}
&gt; 		}
&gt; 		return cu;
&gt; 	}
&gt; 	
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/outline/AJOutlineInformationControl.java" revision="1.8" state="changed">19a20
&gt; import org.eclipse.ajdt.core.javaelements.AJCompilationUnitManager;
314a316,319
&gt; 			if (element instanceof ICompilationUnit) {
&gt; 				element = AJCompilationUnitManager.mapToAJCompilationUnit((ICompilationUnit)element);
&gt; 			}
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="128237" transactionid="69115">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="blocker"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-null M O-== O-!= T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I got NullPointerException during compilation of any @AspectJ code with pointcut which contains logical OR operation.

-----Here is my test case for this bug----------------

import java.io.IOException;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
class AbstractTracer 
{
	@Pointcut("(execution(public * Foo+.* (..)) || execution(public * Foo+.blablabla (..)))&amp;&amp; !execution(public Foo+.new (..))")
//	@Pointcut("(execution(public * Foo+.* (..)))&amp;&amp; !execution(public Foo+.new (..))")
	protected void methodCall(){};

	@Pointcut("methodCall()&amp;&amp; this(obj)")
	private void objectCall(Object obj) {
	};

	@Around("objectCall(obj)")
	public Object aroundMethodCall(ProceedingJoinPoint thisJoinPoint,
			Object obj) throws Throwable {
		System.out.println("Before "+thisJoinPoint.getSignature().toString());
		if ( thisJoinPoint.getSignature().toString().indexOf("A")!= -1)
		{
			throw new IOException("Hello from Aspect!");
//			throw new Exception("Hello from Aspect!");
		}
		Object result = thisJoinPoint.proceed();
		System.out.println("After "+thisJoinPoint.getSignature().toString());
		return result;
	}

}


public class Foo {
	public void methodA() throws IOException {
		throw new IOException("Foo.methodA");
	}

	public void methodB(boolean b) throws Exception
	{
		if ( b )
		{
			throw new Exception("Foo.methodB");
		}
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Foo obj = new Foo();
		try
		{
			obj.methodA();
			System.out.println("Something going wrong!");
		}
		catch ( IOException e)
		{
			System.out.println("All right! We got exception");
			e.printStackTrace(System.out);
		}
		try
		{
			obj.methodB(false);
			System.out.println("All right!");
		}
		catch ( Exception e)
		{
			System.out.println("Something going wrong! We got exception");
			e.printStackTrace(System.out);
		}
		
	}

}

------------------------------------------------------

and here is acj error log
------------------------------------------------------
---- AspectJ Properties ---
AspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT
---- Dump Properties ---
Dump file: ajcore.20060216.175147.608.txt
Dump reason: java.lang.NullPointerException
Dump on exception: true
Dump at exit condition: abort
---- Exception Information ---
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.BcelWeaver.validateOrBranch(BcelWeaver.java:611)
	at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:579)
	at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:511)
	at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:449)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)
---- System Properties ---
java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition
sun.boot.library.path=/opt/Java/jdk1.5.0_04/jre/lib/i386
java.vm.version=1.5.0_04-b05
java.vm.vendor=Sun Microsystems Inc.
java.vendor.url=http://java.sun.com/
path.separator=:
java.vm.name=Java HotSpot(TM) Client VM
file.encoding.pkg=sun.io
user.country=RU
sun.os.patch.level=unknown
java.vm.specification.name=Java Virtual Machine Specification
user.dir=/home/kei/ajdt-workspace/AspectJTests
java.runtime.version=1.5.0_04-b05
java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment
java.endorsed.dirs=/opt/Java/jdk1.5.0_04/jre/lib/endorsed
os.arch=i386
java.io.tmpdir=/tmp
line.separator=

java.vm.specification.vendor=Sun Microsystems Inc.
os.name=Linux
sun.jnu.encoding=UTF-8
java.library.path=/opt/Java/jdk1.5.0_04/jre/lib/i386/client:/opt/Java/jdk1.5.0_04/jre/lib/i386:/opt/Java/jdk1.5.0_04/jre/../lib/i386:.:
java.specification.name=Java Platform API Specification
java.class.version=49.0
sun.management.compiler=HotSpot Client Compiler
os.version=2.6.15-1.1831_FC4
user.home=/home/kei
user.timezone=Europe/Kiev
java.awt.printerjob=sun.print.PSPrinterJob
file.encoding=UTF-8
java.specification.version=1.5
java.class.path=components/aspectjweaver.jar:components/aspectjtools.jar:components/aspectjrt.jar:components/aspectjlib.jar:/build/auroratest.jar:/opt/Java/aspectj1.5/lib/aspectjtools.jar:/opt/Java/jdk1.5.0_04/lib/tools.jar
user.name=kei
java.vm.specification.version=1.0
java.home=/opt/Java/jdk1.5.0_04/jre
sun.arch.data.model=32
user.language=ru
java.specification.vendor=Sun Microsystems Inc.
java.vm.info=mixed mode, sharing
java.version=1.5.0_04
java.ext.dirs=/opt/Java/jdk1.5.0_04/jre/lib/ext
sun.boot.class.path=/opt/Java/jdk1.5.0_04/jre/lib/rt.jar:/opt/Java/jdk1.5.0_04/jre/lib/i18n.jar:/opt/Java/jdk1.5.0_04/jre/lib/sunrsasign.jar:/opt/Java/jdk1.5.0_04/jre/lib/jsse.jar:/opt/Java/jdk1.5.0_04/jre/lib/jce.jar:/opt/Java/jdk1.5.0_04/jre/lib/charsets.jar:/opt/Java/jdk1.5.0_04/jre/classes
java.vendor=Sun Microsystems Inc.
file.separator=/
java.vendor.url.bug=http://java.sun.com/cgi-bin/bugreport.cgi
sun.io.unicode.encoding=UnicodeLittle
sun.cpu.endian=little
sun.cpu.isalist=
---- Command Line ---
-1.5
Foo.java
---- Full Classpath ---
/opt/Java/jdk1.5.0_04/jre/lib/rt.jar(39713589 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/i18n.jar(missing)
/opt/Java/jdk1.5.0_04/jre/lib/sunrsasign.jar(missing)
/opt/Java/jdk1.5.0_04/jre/lib/jsse.jar(549315 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/jce.jar(81799 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/charsets.jar(8627836 bytes)
/opt/Java/jdk1.5.0_04/jre/classes(missing)
/opt/Java/jdk1.5.0_04/jre/lib/ext/localedata.jar(802502 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunpkcs11.jar(175414 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/dnsns.jar(8176 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunjce_provider.jar(153235 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bctsp-jdk15-129.jar(38357 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk15-129.jar(1168795 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3daudio.jar(1386793 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk15-129.jar(124831 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dcore.jar(2514820 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dutils.jar(1401997 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/vecmath.jar(290018 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk14-129.jar(1157625 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk14-129.jar(126679 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjweaver.jar(1746917 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjrt.jar(108647 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjlib.jar(7845 bytes)
/build/auroratest.jar(missing)
/opt/Java/jdk1.5.0_04/lib/tools.jar(7015499 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/localedata.jar(802502 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunpkcs11.jar(175414 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/dnsns.jar(8176 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/sunjce_provider.jar(153235 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bctsp-jdk15-129.jar(38357 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk15-129.jar(1168795 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3daudio.jar(1386793 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk15-129.jar(124831 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dcore.jar(2514820 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/j3dutils.jar(1401997 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/vecmath.jar(290018 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk14-129.jar(1157625 bytes)
/opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk14-129.jar(126679 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjweaver.jar(1746917 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjrt.jar(108647 bytes)
/home/kei/ajdt-workspace/AspectJTests/components/aspectjlib.jar(7845 bytes)
/build/auroratest.jar(missing)
/opt/Java/jdk1.5.0_04/lib/tools.jar(7015499 bytes)
---- Compiler Messages ---
abort ABORT -- (NullPointerException) null
null
java.lang.NullPointerException
	at org.aspectj.weaver.bcel.BcelWeaver.validateOrBranch(BcelWeaver.java:611)
	at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:579)
	at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:511)
	at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:449)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)

---- org.aspectj.weaver.bcel.BcelWorld ----
Shadow mungers:
(around(extraFlags: 2): (persingleton(AbstractTracer) &amp;&amp; (((execution(public * Foo+.*(..)) || execution(public * Foo+.blablabla(..))) &amp;&amp; !execution(public Foo+.new(..))) &amp;&amp; this(BindingTypePattern(java.lang.Object, 1))))-&gt;java.lang.Object AbstractTracer.aroundMethodCall(org.aspectj.lang.ProceedingJoinPoint, java.lang.Object))
Type mungers:
(BcelTypeMunger null)
(BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void java.lang.Object.()))
Late Type mungers:
(BcelTypeMunger null)
------------------------------------------------------------------

I got same error with latest (aspectj-DEVELOPMENT-20060216105006) night build.</bugreport>
<testsforfix ID="128237" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testAtAspectNoNPEWithPcdContainingOrThisAndWildcard_pr128237"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="@AJ no npe with pointcut containing or, this and a wildcard"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/128237/pre-fix/testresults.xml" passing="1799" size="1986"/>
<post-fix-testcases failing="191" file="output/128237/post-fix/testresults.xml" passing="1795" size="1986"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java" revision="1.85" state="changed">614c614,618
&lt; 				if (!leftBindings[i].equals(rightBindings[i])) {
---
&gt; 				if (leftBindings[i] == null) {
&gt; 					if (rightBindings[i] != null) {
&gt; 						ambiguousNames.add(names[i]);
&gt; 					}
&gt; 				} else if (!leftBindings[i].equals(rightBindings[i])) {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.26" state="changed">172a173,176
&gt;   public void testAtAspectNoNPEWithPcdContainingOrThisAndWildcard_pr128237() {
&gt; 	  runTest("@AJ no npe with pointcut containing or, this and a wildcard");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.24" state="changed">210a211,214
&gt;     &lt;ajc-test dir="bugs151" title="@AJ no npe with pointcut containing or, this and a wildcard"&gt;
&gt;         &lt;compile files="pr128237.java" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs151/pr128237.java" revision="1.1" state="new">import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
class AbstractTracer 
{
	
    @Pointcut("(execution(public * Foo.anotherMethod*(..)) || execution(public * Foo.methodA(..))) &amp;&amp; this(obj)")
    protected void methodExec(Object obj){};
        
    @Before("methodExec(obj)")
    public void beforeMethodExec(JoinPoint thisJoinPoint, Object obj) {
      	System.out.println("Before " + thisJoinPoint.getSignature().toString());
    }
	
}


class Foo {

	public void methodA() {
	}
	
	public void anotherMethod() {
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="128615" transactionid="73014">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="14"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="14"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-instanceof M O-cast O-instanceof T V Z-cast Z-if</fullfingerprint>
<bugreport>Using F3 or Ctrl+Click to navigate from a pointcut reference to its declaration is not working.  See org.eclipse.ajdt.ui.tests.visual.OpenDeclarationTest to reproduce.</bugreport>
<pre-fix-testcases failing="186" file="output/128615/pre-fix/testresults.xml" passing="1798" size="1984"/>
<post-fix-testcases failing="185" file="output/128615/post-fix/testresults.xml" passing="1799" size="1984"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/PointcutSourceHover.java" revision="1.2" state="changed">17a18
&gt; import org.eclipse.jdt.core.ICompilationUnit;
49a51,53
&gt; 		if (input instanceof ICompilationUnit) {
&gt; 			input = AJCompilationUnitManager.mapToAJCompilationUnit((ICompilationUnit)input);
&gt; 		}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/PointcutElementHyperlinkDetector.java" revision="1.3" state="changed">14a15
&gt; import org.eclipse.ajdt.core.javaelements.AJCompilationUnitManager;
15a17
&gt; import org.eclipse.jdt.core.ICompilationUnit;
56a59,61
&gt; 		if (input instanceof ICompilationUnit) {
&gt; 			input = AJCompilationUnitManager.mapToAJCompilationUnit((ICompilationUnit)input);
&gt; 		}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/actions/AJOpenAction.java" revision="1.6" state="changed">16a17
&gt; import org.eclipse.ajdt.core.javaelements.AJCompilationUnitManager;
25a27
&gt; import org.eclipse.jdt.core.ICompilationUnit;
131a134,136
&gt; 				if (input instanceof ICompilationUnit) {
&gt; 					input = AJCompilationUnitManager.mapToAJCompilationUnit((ICompilationUnit)input);
&gt; 				}
</file>
</fixedFiles>
</bug>
<bug id="128618" transactionid="69933">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="12"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="12"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-instanceof K-null K-return M O-! O-!= O-&amp;&amp; O-cast O-instanceof T V Z-cast Z-if</fullfingerprint>
<bugreport>The zip file I am about to attach contains two AspectJ  project, one depending on the other.  If you make a small change to MainClass.java in 'Test Project' and save you will see a strange warning in that class - "advice defined in ras.FFDC has not been applied [Xlint:adviceDidNotMatch]".  If you do a full build the warning goes away.  Note that the error would be on line 36 if there were 36 lines in the class, which relates to a line in the FFDC aspect that contains advice.</bugreport>
<testsforfix ID="128618" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr128618"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/128618/pre-fix/testresults.xml" passing="1796" size="1986"/>
<post-fix-testcases failing="188" file="output/128618/post-fix/testresults.xml" passing="1798" size="1986"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java" revision="1.10" state="changed">20a21
&gt; import org.aspectj.bridge.SourceLocation;
64a66,76
&gt; 		// bug 128618 - want to do a similar thing as in bug 62073 above, however
&gt; 		// we're not an EclipseSourceLocation we're a SourceLocation.
&gt; 		if (sLoc instanceof SourceLocation) {
&gt; 			SourceLocation sl = (SourceLocation)sLoc;
&gt; 			if (currentlyWeaving != null &amp;&amp; sl.getSourceFile() != null) {
&gt; 				if (!String.valueOf(currentlyWeaving.getFileName()).equals( sl.getSourceFile().getAbsolutePath())) {
&gt; 					return sink.handleMessage(message);
&gt; 					//throw new RuntimeException("Primary source location must match the file we are currently processing!");
&gt; 				}
&gt; 			}
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.34" state="changed">316a317,334
&gt; 	public void testPr128618() {
&gt; 		initialiseProject("PR128618_1");
&gt; 		initialiseProject("PR128618_2");
&gt; 		configureNewProjectDependency("PR128618_2","PR128618_1");
&gt; 		assertTrue("there should be no warning messages before we start",
&gt; 				MyTaskListManager.getWarningMessages().isEmpty());
&gt; 		build("PR128618_1");
&gt; 		build("PR128618_2");
&gt; 		IMessage msg = (IMessage)(MyTaskListManager.getWarningMessages().get(0));
&gt; 		assertEquals("warning should be against the FFDC.aj resource","FFDC.aj",msg.getSourceLocation().getSourceFile().getName());
&gt; 		alter("PR128618_2","inc1");
&gt; 		build("PR128618_2");
&gt; 		checkWasntFullBuild();
&gt; 		IMessage msg2 = (IMessage)(MyTaskListManager.getWarningMessages().get(0));
&gt; 		assertEquals("warning should be against the FFDC.aj resource","FFDC.aj",msg2.getSourceLocation().getSourceFile().getName());
&gt; 		assertFalse("a new warning message should have been generated", msg.equals(msg2));
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR128618_2/inc1/mainpackage/MainClass.java" revision="1.1" state="new">package mainpackage;

public class MainClass {

	public void amethod() {
	}
	     
	public void anotherMethod() {
		
	}
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR128618_2/base/ras/concrete/SubFFDCAspect.aj" revision="1.1" state="new">package ras.concrete;

import ras.FFDC;

public aspect SubFFDCAspect extends FFDC {

	protected pointcut ffdcScope() : execution(* somemethod(..));

}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR128618_2/base/mainpackage/MainClass.java" revision="1.1" state="new">package mainpackage;

public class MainClass {

	public void amethod() {
	}
	     
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR128618_1/base/ras/FFDC.aj" revision="1.1" state="new">package ras;

public abstract aspect FFDC {

	protected abstract pointcut ffdcScope ();
	
	before() : ffdcScope() {
		
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="128655" transactionid="69520">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="11"/>
<property name="lines-added" value="62"/>
<property name="lines-deleted" value="6"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="70"/>
<property name="priority" value="P2"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-else K-for K-if K-import K-instanceof K-new K-null K-return M O-&lt; O-!= O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>AJDT version: 1.3.1 (20060214104738)
AspectJ version: 1.5.1.20060131132251

Not very sure of the reason and couldn't reproduce on a smaller code base.

The compiler crashes on incremental compilation, but never when I do full "clean" build. Here is the stack trace:
java.lang.NullPointerException
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding.getAnnotationTagBits(MethodBinding.java:447)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:754)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:571)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:498)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doPendingWeaves(AjLookupEnvironment.java:365)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:179)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:258)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:164)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</bugreport>
<pre-fix-testcases failing="188" file="output/128655/pre-fix/testresults.xml" passing="1796" size="1984"/>
<post-fix-testcases failing="185" file="output/128655/post-fix/testresults.xml" passing="1799" size="1984"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.59" state="changed">35a36
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
38a40
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference;
61a64
&gt; import org.aspectj.weaver.ResolvedMember;
758a762
&gt; 		// Hideousness follows:
759a764,772
&gt; 		// There are multiple situations to consider here and they relate to the combinations of
&gt; 		// where the annotation is coming from and where the annotation is going to be put:
&gt; 		//
&gt; 		// 1. Straight full build, all from source - the annotation is from a dec@type and
&gt; 		//    is being put on some type.  Both types are real SourceTypeBindings. WORKS
&gt; 		// 2. Incremental build, changing the affected type - the annotation is from a
&gt; 		//    dec@type in a BinaryTypeBinding (so has to be accessed via bcel) and the
&gt; 		//    affected type is a real SourceTypeBinding.  Mostly works (pr128665)
&gt; 		// 3. ?
761,766d773
&lt; 		
&lt; 		// TODO asc determine if there really is a problem here (see comment below)
&lt; 		
&lt; 		// ClassCastException here means we probably have either a parameterized type or a raw type, we need the
&lt; 		// commented out code to get it to work ... currently uncommented because I've not seen a case where its
&lt; 		// required yet ...
768,773c775,804
&lt; 		MethodBinding[]	mbs = stb.getMethods(decA.getAnnotationMethod().toCharArray());
&lt; 		long abits = mbs[0].getAnnotationTagBits(); // ensure resolved
&lt; 		TypeDeclaration typeDecl = ((SourceTypeBinding)mbs[0].declaringClass).scope.referenceContext;
&lt; 		AbstractMethodDeclaration methodDecl = typeDecl.declarationOf(mbs[0]);
&lt; 		Annotation[] toAdd = methodDecl.annotations; // this is what to add
&lt; 		abits = toAdd[0].resolvedType.getAnnotationTagBits();
---
&gt; 		Annotation[] toAdd = null;
&gt; 		long abits = 0;
&gt; 		
&gt; 		// Might have to retrieve the annotation through BCEL and construct an eclipse one for it.
&gt; 		if (stb instanceof BinaryTypeBinding) {
&gt; 			ReferenceType rt = (ReferenceType)factory.fromEclipse(stb);
&gt; 			ResolvedMember[] methods = rt.getDeclaredMethods();
&gt; 			ResolvedMember decaMethod = null;
&gt; 			String nameToLookFor = decA.getAnnotationMethod();
&gt; 			for (int i = 0; i &lt; methods.length; i++) {
&gt; 				if (methods[i].getName().equals(nameToLookFor)) {decaMethod = methods[i];break;}
&gt; 			}
&gt; 			if (decaMethod!=null) { // could assert this ...
&gt; 				AnnotationX[] axs = decaMethod.getAnnotations();
&gt; 				toAdd = new Annotation[1];
&gt; 				toAdd[0] = createAnnotationFromBcelAnnotation(axs[0],decaMethod.getSourceLocation().getOffset(),factory);
&gt; 				// BUG BUG BUG - We dont test these abits are correct, in fact we'll be very lucky if they are.
&gt; 				// What does that mean?  It means on an incremental compile you might get away with an
&gt; 				// annotation that isn't allowed on a type being put on a type.
&gt; 				abits = toAdd[0].resolvedType.getAnnotationTagBits(); 
&gt; 			}		
&gt; 		} else {
&gt; 			// much nicer, its a real SourceTypeBinding so we can stay in eclipse land
&gt; 			MethodBinding[]	mbs = stb.getMethods(decA.getAnnotationMethod().toCharArray());
&gt; 			abits = mbs[0].getAnnotationTagBits(); // ensure resolved
&gt; 			TypeDeclaration typeDecl = ((SourceTypeBinding)mbs[0].declaringClass).scope.referenceContext;
&gt; 			AbstractMethodDeclaration methodDecl = typeDecl.declarationOf(mbs[0]);
&gt; 			toAdd = methodDecl.annotations; // this is what to add
&gt; 			abits = toAdd[0].resolvedType.getAnnotationTagBits();
&gt; 		}
880a912,936
&gt; 	
&gt; 	/**
&gt; 	 * Transform an annotation from its AJ form to an eclipse form.  We *DONT* care about the
&gt; 	 * values of the annotation.  that is because it is only being stuck on a type during
&gt; 	 * type completion to allow for other constructs (decps, decas) that might be looking for it -
&gt; 	 * when the class actually gets to disk it wont have this new annotation on it and during
&gt; 	 * weave time we will do the right thing copying across values too.
&gt; 	 */
&gt; 	private static Annotation createAnnotationFromBcelAnnotation(AnnotationX annX,int pos, EclipseFactory factory) {
&gt; 		String name = annX.getTypeName();
&gt; 		TypeBinding tb = factory.makeTypeBinding(annX.getSignature());
&gt; 		char[][] typeName = CharOperation.splitOn('.',name.toCharArray());
&gt; 		long[] positions = new long[] {pos};
&gt; 		TypeReference annType = new QualifiedTypeReference(typeName,positions);
&gt; 		NormalAnnotation ann = new NormalAnnotation(annType,pos);
&gt; 		ann.resolvedType=tb; // yuck - is this OK in all cases?
&gt; 		// We don't need membervalues...
&gt; //		Expression pcExpr = new StringLiteral(pointcutExpression.toCharArray(),pos,pos);
&gt; //		MemberValuePair[] mvps = new MemberValuePair[2];
&gt; //		mvps[0] = new MemberValuePair("value".toCharArray(),pos,pos,pcExpr);
&gt; //		Expression argNamesExpr = new StringLiteral(argNames.toCharArray(),pos,pos);
&gt; //		mvps[1] = new MemberValuePair("argNames".toCharArray(),pos,pos,argNamesExpr);
&gt; //		ann.memberValuePairs = mvps;
&gt; 		return ann;
&gt; 	}
</file>
</fixedFiles>
</bug>
<bug id="128699" transactionid="69646">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="minor"/>
<concisefingerprint>Z</concisefingerprint>
<fullfingerprint>Y Z-throw</fullfingerprint>
<bugreport>The error associated with the declare construct is incorrect. 
The current message is:

"expected one of error, warning, parents, soft, dominates"

dominates should be changed to "precendence" and new annotation related declararions should be mentioned. Here is a suggestion:

"expected one of error, warning, parents, soft, precedence, @type, @method, @constructor, @field"</bugreport>
<pre-fix-testcases failing="189" file="output/128699/pre-fix/testresults.xml" passing="1795" size="1984"/>
<post-fix-testcases failing="186" file="output/128699/post-fix/testresults.xml" passing="1798" size="1984"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PatternParser.java" revision="1.51" state="changed">142c142
&lt; 			throw new ParserException("expected one of error, warning, parents, soft, dominates",
---
&gt; 			throw new ParserException("expected one of error, warning, parents, soft, precedence, @type, @method, @constructor, @field",
</file>
</fixedFiles>
</bug>
<bug id="128744" transactionid="68623">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if M T V Y Z-if</fullfingerprint>
<bugreport>LTW doesn't work using JRE1.4 in Eclipse

now I want to support JRE1.4 when LTW.
I defined a aop.xml file in application META-INF path, it works fine using JRE1.4 in command-line, aop.xml file is used when LTW, the command as below:

"D:\work\BTM\eclipse 3.1.1\eclipse-SDK-3.1.1-win32\eclipse-1.4.2\jre\bin\java" -classpath "C:\aspectj1.5\lib\aspectjweaver.jar" "-Djava.system.class.loader=org.aspectj.weaver.loadtime.WeavingURLClassLoader" "-Daj.class.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest;C:\aspectj1.5\doc\examples\armtest\jar\btm-deps-e3.1.jar;C:\aspectj1.5\doc\examples\armtest\jar\btm-rt.jar" Hello


but it doesn't work in Eclipse, I added upper command to VM arguments, it can't find aop.xml, because if I changed aop.xml to be wrong, there is no any error when execute the application in Eclipse , but there will be error when execute it in command-line, based on this point, I think that aop.xml didn't be used in Eclipse, I also tried to add "-Daj.aspect.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest", but it is still. so I want to confirm if AspectJ only supports command-line for JRE1.4? doesn't support Eclipse for JRE1.4?

BTW, my Eclipse env: eclipse 3.1.1 + ajdt_1.3_for_eclipse_3.1 + Sun JDK 1.4.2.
I also tried to use eclipse 3.1.2, but this problem is still existed.</bugreport>
<testsforfix ID="128744" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testBrokenLTW_pr128744"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="broken ltw"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="184" file="output/128744/pre-fix/testresults.xml" passing="1802" size="1986"/>
<post-fix-testcases failing="184" file="output/128744/post-fix/testresults.xml" passing="1802" size="1986"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java" revision="1.6" state="changed">167c167,174
&lt;                     elligibleAbstractions.add(method.getName());
---
&gt;                 	String n = method.getName();
&gt;                 	if (n.startsWith("ajc$pointcut")) { // Allow for the abstract pointcut being from a code style aspect compiled with -1.5 (see test for 128744)
&gt;                 		n = n.substring(14);
&gt;                 		n = n.substring(0,n.indexOf("$"));
&gt;                 		elligibleAbstractions.add(n);
&gt;                 	} else {
&gt;                 		elligibleAbstractions.add(method.getName());
&gt;                 	}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.25" state="changed">44a45
&gt;   public void testBrokenLTW_pr128744() { runTest("broken ltw"); }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.23" state="changed">134a135,144
&gt;     &lt;ajc-test dir="bugs151/pr128744" title="broken ltw"&gt;
&gt;         &lt;compile files="Hello.java World.java" options="-1.5" /&gt;
&gt;         &lt;run class="Hello" ltw="aop.xml"&gt;
&gt;         	&lt;stdout&gt;
&gt;                 &lt;line text="Hello"/&gt;
&gt;                 &lt;line text="World"/&gt;
&gt;             &lt;/stdout&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs151/pr128744/World.java" revision="1.1" state="new">

public abstract aspect World {
	public abstract pointcut monitoredOperation();
	
	after() : monitoredOperation() {
		System.out.println("World");
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr128744/aop.xml" revision="1.1" state="new">&lt;?xml version="1.0" encoding="UTF-8" ?&gt; 
&lt;aspectj&gt;
  &lt;aspects&gt;
    &lt;aspect name="World" /&gt; 
    &lt;concrete-aspect name="World1" extends="World"&gt;
      &lt;pointcut name="monitoredOperation" expression="execution(* sayHello())" /&gt; 
    &lt;/concrete-aspect&gt;
  &lt;/aspects&gt;

  &lt;weaver options="-verbose -showWeaveInfo" /&gt; 
&lt;/aspectj&gt;</file>
<file name="org.aspectj/modules/tests/bugs151/pr128744/Hello.java" revision="1.1" state="new">
public class Hello {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//System.out.println("main");
		sayHello();
	}
	
	public static void sayHello(){
		System.out.println("Hello");	
	}

}
</file>
</fixedFiles>
</bug>
<bug id="129525" transactionid="74300">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="18"/>
<property name="lines-added" value="24"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="14"/>
<property name="lines-churned" value="38"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-else K-false K-if K-import K-new K-this K-throw K-true K-try M O-! O-&amp;&amp; O-+ T V Y Z-if Z-throw</fullfingerprint>
<bugreport>The load-time weaving system can produce truly massive quantities of output when there's a weaving error, since the system dumps the bytecode to syserr. It would be much better to produce an ajcore file and just point to it, or use some other log.</bugreport>
<testsforfix ID="129525" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testReweavableAspectNotRegistered_pr129525"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="reweavableAspectNotRegistered error"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/129525/pre-fix/testresults.xml" passing="1916" size="2102"/>
<post-fix-testcases failing="186" file="output/129525/post-fix/testresults.xml" passing="1916" size="2102"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java" revision="1.8" state="changed">26a27
&gt; import org.aspectj.bridge.AbortException;
27a29,30
&gt; import org.aspectj.weaver.tools.Trace;
&gt; import org.aspectj.weaver.tools.TraceFactory;
39a43,44
&gt; 	
&gt; 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(WeavingURLClassLoader.class);
50a56
&gt; 		if (trace.isTraceEnabled()) trace.enter("&lt;init&gt;",this,new Object[] { urls, parent });
51a58
&gt; 		if (trace.isTraceEnabled()) trace.exit("&lt;init&gt;");
108a116
&gt; 		if (trace.isTraceEnabled()) trace.enter("defineClass",this,new Object[] { name, b, cs });
119c127,136
&lt; 			b = adaptor.weaveClass(name,b);
---
&gt; 			try {
&gt; 				b = adaptor.weaveClass(name,b);
&gt; 			}
&gt; 			catch (AbortException ex) {
&gt; 	    		trace.error("defineClass",ex);
&gt; 	    		throw ex;
&gt; 			}
&gt; 			catch (Throwable th) {
&gt; 	    		trace.error("defineClass",th);
&gt; 			}
121c138,140
&lt; 		return super.defineClass(name, b, cs);
---
&gt; 		Class clazz = super.defineClass(name, b, cs);
&gt; 		if (trace.isTraceEnabled()) trace.exit("defineClass",clazz);
&gt; 		return clazz;
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.55" state="changed">357a358,359
&gt;     	boolean success = true;
&gt;     	
395a398
&gt;                         success = false;
414a418,423
&gt;         /* We couldn't register one or more aspects so disable the adaptor */
&gt;         if (!success) {
&gt;         	disable();
&gt;     		warn("failure(s) registering aspects. Disabling weaver for class loader " + getClassLoaderName(loader));
&gt;         }
&gt;         
416c425
&lt;         if (namespace == null) {
---
&gt;         else if (namespace == null) {
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.40" state="changed">82a83
&gt; 	private boolean abortOnError = false;
155a157
&gt; 		abortOnError = true;
193a196,197
&gt; 		if (trace.isTraceEnabled()) trace.enter("disable",this);
&gt; 
195a200,201
&gt; 		
&gt; 		if (trace.isTraceEnabled()) trace.exit("disable");
472c478
&lt; 				if (0 &lt;= message.getKind().compareTo(IMessage.ERROR)) {
---
&gt; 				if (abortOnError &amp;&amp; 0 &lt;= message.getKind().compareTo(IMessage.ERROR)) {
556c562
&lt; 			if (0 &lt;= message.getKind().compareTo(failKind)) {
---
&gt; 			if (abortOnError &amp;&amp; 0 &lt;= message.getKind().compareTo(failKind)) {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/tracing/tracing.xml" revision="1.5" state="changed">55,56c55,58
&lt; 	  	    	&lt;line text="warning register definition failed"/&gt;
&lt; 	  	    	&lt;line text="warning register definition failed"/&gt;
---
&gt; 	  	    	&lt;line text="error Concrete-aspect 'IncludedMissingAspect' could not be registered"/&gt;
&gt; 	  	    	&lt;line text="error Concrete-aspect 'IncludedMissingAspect' could not be registered"/&gt;
&gt; 	  	    	&lt;line text="warning failure(s) registering aspects. Disabling weaver for class loader"/&gt;
&gt; 	  	    	&lt;line text="warning failure(s) registering aspects. Disabling weaver for class loader"/&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.58" state="changed">486c486,487
&lt;             &lt;line text="warning register definition failed"/&gt;
---
&gt;             &lt;line text="error Concrete-aspect 'TraceHelloWorld' could not be registered"/&gt;
&gt;             &lt;line text="warning failure(s) registering aspects. Disabling weaver for class loader"/&gt;
500c501,502
&lt;             &lt;line text="warning register definition failed"/&gt;
---
&gt;             &lt;line text="error Concrete-aspect 'TraceHelloWorld' could not be registered"/&gt;
&gt;             &lt;line text="warning failure(s) registering aspects. Disabling weaver for class loader"/&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.29" state="changed">335a336,351
&gt;     &lt;ajc-test dir="ltw" title="reweavableAspectNotRegistered error"&gt;
&gt;       &lt;compile files="HelloWorld.java, ExceptionHandler.aj" options="-showWeaveInfo"&gt;
&gt;         &lt;message kind="weave" text="Join point 'method-execution(void HelloWorld.main(java.lang.String[]))' in Type 'HelloWorld' (HelloWorld.java:3) advised by around advice from 'ExceptionHandler' (ExceptionHandler.aj:2)"/&gt;
&gt;       &lt;/compile&gt;
&gt;       &lt;compile files="EmptyAspect.aj"&gt;
&gt;       &lt;/compile&gt;
&gt;       &lt;run class="HelloWorld" ltw="aop-missingaspect.xml"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="Hello World!"/&gt;
&gt;         &lt;/stdout&gt;
&gt;         &lt;stderr&gt;
&gt;         	&lt;line text="error aspect 'ExceptionHandler' woven into 'HelloWorld' must be defined to the weaver (placed on the aspectpath, or defined in an aop.xml file if using LTW)."/&gt;
&gt;         &lt;/stderr&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.29" state="changed">68a69,72
&gt;   public void testReweavableAspectNotRegistered_pr129525 () {
&gt; 	  runTest("reweavableAspectNotRegistered error");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/ltw/pakkage/EmptyAspect.aj" revision="1.1" state="new">public aspect EmptyAspect {
	
}</file>
<file name="org.aspectj/modules/tests/ltw/aop-missingaspect.xml" revision="1.1" state="new">&lt;aspectj&gt;
	&lt;aspects&gt;
		&lt;aspect name="EmptyAspect"/&gt;
	&lt;/aspects&gt;
&lt;/aspectj&gt;</file>
</fixedFiles>
</bug>
<bug id="129566" transactionid="68853">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-else K-if O-- O-!= T V Y Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>After "upgrading" to eclipse 3.2M5a and AJDT 20060224163227 I repeatedly get the following stack trace on a regular Java class:

java.lang.ArrayIndexOutOfBoundsException
at org.aspectj.weaver.ReferenceType.determineThoseTypesToUse(ReferenceType.java:465)
at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:411)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1199)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1047)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:234)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:157)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ArrayIndexOutOfBoundsException thrown: -1

This happens even when the class is the only file in a fresh project (without any aspects!); existing AJ projects work fine as soon as this class is excluded from the build path. When the class is moved into a different project and referenced as dependency everything works as expected.
This used to work fine with previous versions of AJDT up to the last release for eclipse 3.1.</bugreport>
<pre-fix-testcases failing="186" file="output/129566/pre-fix/testresults.xml" passing="1685" size="1871"/>
<post-fix-testcases failing="188" file="output/129566/post-fix/testresults.xml" passing="1815" size="2003"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ReferenceType.java" revision="1.45" state="changed">473c473,478
&lt; 				retVal[i]= paramTypes[rank];
---
&gt; 				// -1 probably means it is a reference to a type variable on the outer generic type (see pr129566)
&gt; 				if (rank!=-1) {
&gt; 					retVal[i] = paramTypes[rank];
&gt; 				} else {
&gt; 					retVal[i] = tParms[i];
&gt; 				}
</file>
</fixedFiles>
</bug>
<bug id="129927" transactionid="75231">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="blocker"/>
<concisefingerprint>Z</concisefingerprint>
<fullfingerprint>T V Z-cast</fullfingerprint>
<tag>exception</tag>
<bugreport>After updating from build 20060224163227 to 20060228113754 (running on eclipse I20060223-1656 which seems to be 3.2M5a) I get the following stack trace after trying to open an AspectJ editor on a .aj source file:

java.lang.ClassCastException: org.eclipse.jface.text.source.AnnotationModel cannot be cast to org.eclipse.jdt.core.IProblemRequestor
	at org.eclipse.ajdt.internal.ui.editor.AspectJEditor.doSetInput(AspectJEditor.java:376)
	at org.eclipse.ui.texteditor.AbstractTextEditor$17.run(AbstractTextEditor.java:2397)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:360)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:305)
	at org.eclipse.jface.window.ApplicationWindow$1.run(ApplicationWindow.java:739)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.jface.window.ApplicationWindow.run(ApplicationWindow.java:736)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2215)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:2415)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:2442)
	at org.eclipse.ui.internal.EditorManager.createSite(EditorManager.java:825)
	at org.eclipse.ui.internal.EditorReference.createPartHelper(EditorReference.java:578)
	at org.eclipse.ui.internal.EditorReference.createPart(EditorReference.java:367)
	at org.eclipse.ui.internal.WorkbenchPartReference.getPart(WorkbenchPartReference.java:555)
	at org.eclipse.ui.internal.PartPane.setVisible(PartPane.java:285)
	at org.eclipse.ui.internal.presentations.PresentablePart.setVisible(PresentablePart.java:140)
	at org.eclipse.ui.internal.presentations.util.PresentablePartFolder.select(PresentablePartFolder.java:266)
	at org.eclipse.ui.internal.presentations.util.LeftToRightTabOrder.select(LeftToRightTabOrder.java:65)
	at org.eclipse.ui.internal.presentations.util.TabbedStackPresentation.selectPart(TabbedStackPresentation.java:394)
	at org.eclipse.ui.internal.PartStack.refreshPresentationSelection(PartStack.java:1140)
	at org.eclipse.ui.internal.PartStack.setSelection(PartStack.java:1093)
	at org.eclipse.ui.internal.PartStack.showPart(PartStack.java:1312)
	at org.eclipse.ui.internal.PartStack.showPart(PartStack.java:1278)
	at org.eclipse.ui.internal.PartStack.add(PartStack.java:453)
	at org.eclipse.ui.internal.EditorStack.add(EditorStack.java:101)
	at org.eclipse.ui.internal.PartStack.add(PartStack.java:440)
	at org.eclipse.ui.internal.EditorStack.add(EditorStack.java:110)
	at org.eclipse.ui.internal.EditorSashContainer.addEditor(EditorSashContainer.java:60)
	at org.eclipse.ui.internal.EditorAreaHelper.addToLayout(EditorAreaHelper.java:214)
	at org.eclipse.ui.internal.EditorAreaHelper.addEditor(EditorAreaHelper.java:204)
	at org.eclipse.ui.internal.EditorManager.createEditorTab(EditorManager.java:805)
	at org.eclipse.ui.internal.EditorManager.openEditorFromDescriptor(EditorManager.java:705)
	at org.eclipse.ui.internal.EditorManager.openEditor(EditorManager.java:666)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditorBatched(WorkbenchPage.java:2390)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:2325)
	at org.eclipse.ui.internal.WorkbenchPage.access$10(WorkbenchPage.java:2317)
	at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:2303)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2298)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2283)
	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:287)
	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:164)
	at org.eclipse.jdt.internal.ui.actions.OpenActionUtil.open(OpenActionUtil.java:49)
	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:181)
	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:165)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:267)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:243)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerActionGroup.handleOpen(PackageExplorerActionGroup.java:296)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerPart$4.open(PackageExplorerPart.java:650)
	at org.eclipse.jface.viewers.StructuredViewer$2.run(StructuredViewer.java:780)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
	at org.eclipse.core.runtime.Platform.run(Platform.java:816)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:44)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:148)
	at org.eclipse.jface.viewers.StructuredViewer.fireOpen(StructuredViewer.java:778)
	at org.eclipse.jface.viewers.StructuredViewer.handleOpen(StructuredViewer.java:1009)
	at org.eclipse.jface.viewers.StructuredViewer$6.handleOpen(StructuredViewer.java:1108)
	at org.eclipse.jface.util.OpenStrategy.fireOpenEvent(OpenStrategy.java:244)
	at org.eclipse.jface.util.OpenStrategy.access$2(OpenStrategy.java:239)
	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java:278)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3287)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2907)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1899)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1863)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:417)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:106)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:99)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:374)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:282)
	at org.eclipse.core.launcher.Main.run(Main.java:977)
	at org.eclipse.core.launcher.Main.main(Main.java:952)</bugreport>
<pre-fix-testcases failing="190" file="output/129927/pre-fix/testresults.xml" passing="1813" size="2003"/>
<post-fix-testcases failing="193" file="output/129927/post-fix/testresults.xml" passing="1810" size="2003"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJEditor.java" revision="1.51" state="changed">369a370
&gt; 				JavaUI.getWorkingCopyManager().connect(input);	
373,374c374,375
&lt; 					isEditingAjFile = true;
&lt; 	
---
&gt; 					isEditingAjFile = true;	
&gt; 					IAnnotationModel annotationModel = getDocumentProvider().getAnnotationModel(input);
376,377c377
&lt; 					
&lt; 					unit.becomeWorkingCopy((IProblemRequestor)getDocumentProvider().getAnnotationModel(input), null);
---
&gt; 					unit.becomeWorkingCopy((IProblemRequestor) annotationModel, null);
379,381c379,381
&lt; 							.getWorkingCopyManager()).setWorkingCopy(input, unit);				
&lt; 				}
&lt; 				JavaUI.getWorkingCopyManager().connect(input);						
---
&gt; 							.getWorkingCopyManager()).setWorkingCopy(input, unit);
&gt; 				
&gt; 				}					
</file>
</fixedFiles>
</bug>
<bug id="130300" transactionid="69010">
<property name="files-churned" value="10"/>
<property name="java-files-churned" value="7"/>
<property name="classes-churned" value="7"/>
<property name="methods-churned" value="7"/>
<property name="hunks" value="24"/>
<property name="lines-added" value="8"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="30"/>
<property name="lines-churned" value="39"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-null M O-!= T V Y Z-cond Z-if</fullfingerprint>
<bugreport>This option is redundant apart from use in AspectJ development and maintenance. It is confusing to users and is a source new problems for LTW.</bugreport>
<testsforfix ID="130300" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
      <test NAME="testAjcLTWPerClauseTest_XterminateAfterCompilation"/>
      <test NAME="testAjcLTWAroundInlineMungerTest_XterminateAfterCompilation"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java">
      <test NAME="testIllegalAccessErrorWithAroundAdviceTerminateAfterCompilationLTW_pr119657"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml">
      <test NAME="IllegalAccessError with around advice on interface method call using -XterminateAfterCompilation and LTW"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml">
      <test NAME="AjcLTW PerClauseTest -XterminateAfterCompilation"/>
      <test NAME="AjcLTW AroundInlineMungerTest -XterminateAfterCompilation"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/130300/pre-fix/testresults.xml" passing="1813" size="2003"/>
<post-fix-testcases failing="74" file="output/130300/post-fix/testresults.xml" passing="876" size="950"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.50" state="changed">540,541c540,543
&lt;         	} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
&lt; 				buildConfig.setNoWeave(true);
---
&gt;         	} else if (arg.equals("-noWeave") || arg.equals( "-XnoWeave")) {
&gt; 				showWarning("the noweave option is no longer required and is being ignored");
&gt;         	} else if (arg.equals( "-XterminateAfterCompilation")) {
&gt; 				buildConfig.setTerminateAfterCompilation(true);
</file>
<file name="org.aspectj/modules/ajde/testdata/JarManifestTest/noweave.lst" revision="1.2" state="changed">3c3
&lt; -noweave
\ Kein Zeilenumbruch am Dateiende.
---
&gt; -terminateAfterCompilation
\ Kein Zeilenumbruch am Dateiende.
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore.java" revision="1.6" state="changed">33c33
&lt; 	public static final String COMPILER_NO_WEAVE             = AjCompilerOptions.OPTION_NoWeave;
---
&gt; 	public static final String COMPILER_TERMINATE_AFTER_COMPILATION             = AjCompilerOptions.OPTION_TerminateAfterCompilation;
</file>
<file name="org.aspectj/modules/testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java" revision="1.29" state="changed">1662c1662
&lt;                         factory.create("XnoWeave"),
---
&gt;                         factory.create("XterminateAfterCompilation"),
</file>
<file name="org.aspectj/modules/docs/devGuideDB/antsupport.xml" revision="1.19" state="changed">435c435
&lt;             	noWeave,
---
&gt;             	terminateAfterCompilation,
438c438
&lt;                     (reweavable, noWeave, etc.).
---
&gt;                     (reweavable, terminateAfterCompilation, etc.).
442c442
&lt; 				&lt;entry&gt;&lt;para&gt;Xnoweave
---
&gt; 				&lt;entry&gt;&lt;para&gt;XterminateAfterCompilation
444,448c444,445
&lt; 				&lt;entry&gt;&lt;para&gt;		
&lt; 				Experimental option to produce binaries that can only be used as input 
&lt; 				for the &lt;literal&gt;-injars&lt;/literal&gt; or &lt;literal&gt;-inpath&lt;/literal&gt; option.
&lt; 				Usually aspects are compiled normally and put on the
&lt; 				&lt;literal&gt;aspectpath&lt;/literal&gt;.
---
&gt; 				&lt;entry&gt;&lt;para&gt;
&gt; 				Terminates before the weaving process, dumping out unfinished class files.
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java" revision="1.18" state="changed">114c114
&lt; 		args.add("-noweave");
---
&gt; 		args.add("-XterminateAfterCompilation");
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java" revision="1.20" state="changed">40c40
&lt; 	public static final String OPTION_NoWeave                 = "org.aspectj.ajdt.core.compiler.weaver.NoWeave";
---
&gt; 	public static final String OPTION_TerminateAfterCompilation                 = "org.aspectj.ajdt.core.compiler.weaver.TerminateAfterCompilation";
65c65
&lt; 	public boolean noWeave = false;
---
&gt; 	public boolean terminateAfterCompilation = false;
133c133
&lt; 		map.put(OPTION_NoWeave, this.noWeave ? ENABLED : DISABLED);
---
&gt; 		map.put(OPTION_TerminateAfterCompilation, this.terminateAfterCompilation ? ENABLED : DISABLED);
166c166
&lt; 		if ((optionValue = optionsMap.get(OPTION_NoWeave)) != null) {
---
&gt; 		if ((optionValue = optionsMap.get(OPTION_TerminateAfterCompilation)) != null) {
168c168
&lt; 				this.noWeave = true;
---
&gt; 				this.terminateAfterCompilation = true;
170c170
&lt; 				this.noWeave = false;
---
&gt; 				this.terminateAfterCompilation = false;
281c281
&lt; 		buf.append("\n\t- no weave: ").append(this.noWeave ? ENABLED : DISABLED); //$NON-NLS-1$
---
&gt; 		buf.append("\n\t- terminate after compilation: ").append(this.terminateAfterCompilation ? ENABLED : DISABLED); //$NON-NLS-1$
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java" revision="1.22" state="changed">51c51
&lt; 	private boolean isXNoWeave;
---
&gt; 	private boolean isXTerminateAfterCompilation;
84d83
&lt; 	 * @param isXNoWeave
96c95
&lt; 							 boolean isXNoWeave,
---
&gt; 							 boolean isXterminateAfterCompilation,
107c106
&lt; 		this.isXNoWeave = isXNoWeave;
---
&gt; 		this.isXTerminateAfterCompilation = isXterminateAfterCompilation;
180c179
&lt; 			if (isXNoWeave || (reportedErrors &amp;&amp; !proceedOnError)) {
---
&gt; 			if (isXTerminateAfterCompilation || (reportedErrors &amp;&amp; !proceedOnError)) {
210c209
&lt; 		if (isXNoWeave) {
---
&gt; 		if (isXTerminateAfterCompilation) {
</file>
<file name="org.aspectj/modules/taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java" revision="1.48" state="changed">291c291
&lt;         // many now deprecated: reweavable*, noWeave, ...
---
&gt;         // many now deprecated: reweavable*
295c295
&lt;             	"noWeave","hasMember",
---
&gt;             	"terminateAfterCompilation","hasMember",
505,506c505,506
&lt;     public void setXNoweave(boolean noweave) {  
&lt;         cmd.addFlag("-XnoWeave", noweave);
---
&gt;     public void setXTerminateAfterCompilation(boolean b) {  
&gt;         cmd.addFlag("-XterminateAfterCompilation", b);
512a513,520
&gt;     public void setXNoWeave(boolean b) {
&gt;     	if (logger!=null) logger.warning("the noweave option is no longer required and is being ignored");
&gt;     }
&gt;     
&gt;     public void setNoWeave(boolean b) {
&gt;     	if (logger!=null) logger.warning("the noweave option is no longer required and is being ignored");
&gt;     }
&gt;     
1885,1886c1893,1894
&lt;             } else if ("-Xnoweave".equals(flag)) {
&lt;                 setXNoweave(true);
---
&gt;             } else if ("-XterminateAfterCompilation".equals(flag)) {
&gt;                 setXTerminateAfterCompilation(true);
</file>
<file name="org.aspectj/modules/docs/devGuideDB/ajc.xml" revision="1.21" state="changed">114c114
&lt; 		&lt;/para&gt;&lt;/listitem&gt;
---
&gt;         &lt;/para&gt;&lt;/listitem&gt;
429,432c429,430
&lt;         &lt;term&gt;-Xnoweave&lt;/term&gt;
&lt;         &lt;listitem&gt;&lt;para&gt;(Experimental) produce unwoven class files
&lt;         for input using -injars. (deprecated - .class files are by
&lt;         default reweavable and can be input using -inpath.)
---
&gt;         &lt;term&gt;-XterminateAfterCompilation&lt;/term&gt;
&gt;         &lt;listitem&gt;&lt;para&gt;Causes compiler to terminate before weaving
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java" revision="1.38" state="changed">357,358c357,358
&lt;         if (!isNoWeave() &amp;&amp; global.isNoWeave()) {
&lt;             setNoWeave(true);
---
&gt;         if (!isTerminateAfterCompilation() &amp;&amp; global.isTerminateAfterCompilation()) {
&gt;             setTerminateAfterCompilation(true);
459,460c459,460
&lt; 	public boolean isNoWeave() {
&lt; 		return options.noWeave;
---
&gt; 	public boolean isTerminateAfterCompilation() {
&gt; 		return options.terminateAfterCompilation;
463,464c463,464
&lt; 	public void setNoWeave(boolean noWeave) {
&lt; 		options.noWeave = noWeave;
---
&gt; 	public void setTerminateAfterCompilation(boolean b) {
&gt; 		options.terminateAfterCompilation = b;
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/messages.properties" revision="1.24" state="changed"/>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.94" state="changed">1160c1160
&lt; 						buildConfig.isNoWeave(),
---
&gt; 						buildConfig.isTerminateAfterCompilation(),
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml" revision="1.23" state="changed">8c8
&lt;     &lt;ajc-test dir="java5/ataspectj" title="AjcLTW PerClauseTest -XnoWeave"&gt;
---
&gt;     &lt;ajc-test dir="java5/ataspectj" title="AjcLTW PerClauseTest -XterminateAfterCompilation"&gt;
11c11
&lt;                 options="-1.5 -XnoWeave"/&gt;
---
&gt;                 options="-1.5 -XterminateAfterCompilation"/&gt;
25c25
&lt;                 options="-1.5 -XnoWeave"/&gt;
---
&gt;                 options="-1.5 -XterminateAfterCompilation"/&gt;
38c38
&lt;     &lt;ajc-test dir="java5/ataspectj" title="AjcLTW AroundInlineMungerTest -XnoWeave"&gt;
---
&gt;     &lt;ajc-test dir="java5/ataspectj" title="AjcLTW AroundInlineMungerTest -XterminateAfterCompilation"&gt;
41c41
&lt;                 options="-1.5 -XnoWeave"/&gt;
---
&gt;                 options="-1.5 -XterminateAfterCompilation"/&gt;
143c143
&lt;     		options="-1.5 -XnoWeave"
---
&gt;     		options="-1.5 -XterminateAfterCompilation"
162c162
&lt;     		options="-1.5 -XnoWeave"
---
&gt;     		options="-1.5 -XterminateAfterCompilation"
187c187
&lt;     		options="-1.5 -XnoWeave"
---
&gt;     		options="-1.5 -XterminateAfterCompilation"
213c213
&lt;     		options="-1.5 -XnoWeave"
---
&gt;     		options="-1.5 -XterminateAfterCompilation"
262c262
&lt;             options="-1.5 -XnoWeave"
---
&gt;             options="-1.5 -XterminateAfterCompilation"
270c270
&lt;             options="-1.5 -Xdev:NoAtAspectJProcessing -XnoWeave"
---
&gt;             options="-1.5 -Xdev:NoAtAspectJProcessing -XterminateAfterCompilation"
278c278
&lt;             options="-1.5 -Xdev:NoAtAspectJProcessing -XnoWeave"
---
&gt;             options="-1.5 -Xdev:NoAtAspectJProcessing -XterminateAfterCompilation"
286c286
&lt;             options="-1.5 -XnoWeave"/&gt;
---
&gt;             options="-1.5 -XterminateAfterCompilation"/&gt;
293c293
&lt;             options="-1.5 -XnoWeave"
---
&gt;             options="-1.5 -XterminateAfterCompilation"
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.263" state="changed">6168c6168
&lt;    &lt;ajc-test dir="bugs150/pr119657" title="IllegalAccessError with around advice on interface method call using -XnoWeave and LTW"&gt;
---
&gt;    &lt;ajc-test dir="bugs150/pr119657" title="IllegalAccessError with around advice on interface method call using -XterminateAfterCompilation and LTW"&gt;
6170c6170
&lt;      &lt;compile files="accounts/recovery/Recovery.aj" options="-XnoWeave"/&gt;
---
&gt;      &lt;compile files="accounts/recovery/Recovery.aj" options="-XterminateAfterCompilation"/&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/inpath/inpath-tests.xml" revision="1.3" state="changed">28c28
&lt;       title="The compiler crashes when using aspect libraries created without using -noweave"&gt;
---
&gt;       title="The compiler crashes when using aspect libraries created without using -terminateAfterCompile"&gt;
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java" revision="1.16" state="changed">368c368
&lt; 		buildOptions.setNonStandardOptions( "-XnoWeave" );
---
&gt; 		buildOptions.setNonStandardOptions( "-XterminateAfterCompilation" );
371c371
&lt; 		assertTrue( "XnoWeave", buildConfig.isNoWeave() );
---
&gt; 		assertTrue( "XterminateAfterCompilation", buildConfig.isTerminateAfterCompilation() );
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java" revision="1.25" state="changed">39,40c39,40
&lt; 	public void testAjcLTWPerClauseTest_XnoWeave() {
&lt; 		runTest("AjcLTW PerClauseTest -XnoWeave");
---
&gt; 	public void testAjcLTWPerClauseTest_XterminateAfterCompilation() {
&gt; 		runTest("AjcLTW PerClauseTest -XterminateAfterCompilation");
51,52c51,52
&lt;     public void testAjcLTWAroundInlineMungerTest_XnoWeave() {
&lt;         runTest("AjcLTW AroundInlineMungerTest -XnoWeave");
---
&gt;     public void testAjcLTWAroundInlineMungerTest_XterminateAfterCompilation() {
&gt;         runTest("AjcLTW AroundInlineMungerTest -XterminateAfterCompilation");
</file>
<file name="org.aspectj/modules/taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java" revision="1.28" state="changed">717c717
&lt; 		task.setXNoweave(true);
---
&gt; 		task.setXTerminateAfterCompilation(true);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java" revision="1.181" state="changed">836,837c836,837
&lt;   public void testIllegalAccessErrorWithAroundAdviceNoWeaveLTW_pr119657() {
&lt; 	  runTest("IllegalAccessError with around advice on interface method call using -XnoWeave and LTW");
---
&gt;   public void testIllegalAccessErrorWithAroundAdviceTerminateAfterCompilationLTW_pr119657() {
&gt; 	  runTest("IllegalAccessError with around advice on interface method call using -XterminateAfterCompilation and LTW");
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java" revision="1.6" state="changed">39c39
&lt; 		assertFalse(options.noWeave);
---
&gt; 		assertFalse(options.terminateAfterCompilation);
62c62
&lt; 		options.noWeave = true;
---
&gt; 		options.terminateAfterCompilation = true;
73c73
&lt; 		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_NoWeave));
---
&gt; 		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_TerminateAfterCompilation));
97c97
&lt; 		map.put(AjCompilerOptions.OPTION_NoWeave,CompilerOptions.ENABLED);
---
&gt; 		map.put(AjCompilerOptions.OPTION_TerminateAfterCompilation,CompilerOptions.ENABLED);
109c109
&lt; 		assertTrue(options.noWeave);
---
&gt; 		assertTrue(options.terminateAfterCompilation);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/inpath/InPathTests.java" revision="1.3" state="changed">41c41
&lt; //    runTest("The compiler crashes when using aspect libraries created without using -noweave");
---
&gt; //    runTest("The compiler crashes when using aspect libraries created without using -terminateAfterCompilation");
</file>
<file name="org.aspectj/modules/tests/product/testScripts/cmdline11/script.sh" revision="1.2" state="changed"/>
</fixedFiles>
</bug>
<bug id="130719" transactionid="74728">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="8"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="13"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-new O-== O-|| O-!= T V Y Z-if</fullfingerprint>
<bugreport>New Aspect wizard visual test fails on Aspect11.
This can be reproduced manually using the OpenDeclaration ui test project.

Open the new aspect wizard on this project and press the browse supertype button and type "AbstractGetInfo". This aspect should appear in the dialog, but it doesn't.

One of the OpenDeclaration visual tests is failing due to the same problem.</bugreport>
<pre-fix-testcases failing="138" file="output/130719/pre-fix/testresults.xml" passing="1573" size="1711"/>
<post-fix-testcases failing="188" file="output/130719/post-fix/testresults.xml" passing="1815" size="2003"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/dialogs/AJCUTypeInfo.java" revision="1.7" state="changed">21,22d20
&lt; 	public static final int ASPECT = 16;
&lt; 
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/dialogs/TypeInfoViewer.java" revision="1.12" state="changed">651,670c651,662
&lt; 			TypeInfo[] result = new TypeInfo[0];
&lt; //			AspectJ Change Begin	
&lt; 			if(fElementKind != AJCUTypeInfo.ASPECT) {
&lt; //			AspectJ Change End	
&lt; 					engine.searchAllTypeNames(
&lt; 					packPattern == null ? null : packPattern.toCharArray(), 
&lt; 					fFilter.getNamePattern().toCharArray(), 
&lt; 					fFilter.getSearchFlags(), 
&lt; 					fElementKind, 
&lt; 					fScope, 
&lt; 					fReqestor, 
&lt; 					IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, 
&lt; 					monitor);
&lt; 				if (DEBUG)
&lt; 					System.out.println("Time needed until search has finished: " + (System.currentTimeMillis() - start)); //$NON-NLS-1$
&lt; 				result= fReqestor.getResult();
&lt; //			AspectJ Change Begin	
&lt; 			} 
&lt; //			AspectJ Change End	
&lt; 			
---
&gt; 			engine.searchAllTypeNames(
&gt; 				packPattern == null ? null : packPattern.toCharArray(), 
&gt; 				fFilter.getNamePattern().toCharArray(), 
&gt; 				fFilter.getSearchFlags(), 
&gt; 				fElementKind, 
&gt; 				fScope, 
&gt; 				fReqestor, 
&gt; 				IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, 
&gt; 				monitor);
&gt; 			if (DEBUG)
&gt; 				System.out.println("Time needed until search has finished: " + (System.currentTimeMillis() - start)); //$NON-NLS-1$
&gt; 			TypeInfo[] result= fReqestor.getResult();
672,683c664,672
&lt; 			if(fElementKind == AJCUTypeInfo.ASPECT || fElementKind == IJavaSearchConstants.TYPE) {
&lt; 				List types = getAspectJTypes(fScope, packPattern == null ? null : packPattern.toCharArray(), 
&lt; 						fFilter.getNamePattern().toCharArray()); 
&lt; 				TypeInfo[] typesIncludingAspects = new TypeInfo[result.length + types.size()];			
&lt; 				System.arraycopy(result, 0, typesIncludingAspects, 0, result.length);
&lt; 				int index = result.length;
&lt; 				for (Iterator iter = types.iterator(); iter.hasNext();) {
&lt; 					TypeInfo info = (TypeInfo) iter.next();
&lt; 					typesIncludingAspects[index] = info;
&lt; 					index ++;
&lt; 				}
&lt; 				result = typesIncludingAspects;
---
&gt; 			List types = getAspectJTypes(fScope, packPattern == null ? null : packPattern.toCharArray(), 
&gt; 					fFilter.getNamePattern().toCharArray()); 
&gt; 			TypeInfo[] typesIncludingAspects = new TypeInfo[result.length + types.size()];			
&gt; 			System.arraycopy(result, 0, typesIncludingAspects, 0, result.length);
&gt; 			int index = result.length;
&gt; 			for (Iterator iter = types.iterator(); iter.hasNext();) {
&gt; 				TypeInfo info = (TypeInfo) iter.next();
&gt; 				typesIncludingAspects[index] = info;
&gt; 				index ++;
684a674
&gt; 			result = typesIncludingAspects;
</file>
</fixedFiles>
</bug>
<bug id="130780" transactionid="74785">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null M O-!= T V Z-if</fullfingerprint>
<bugreport>I converted my demos workspace from eclipse 3.1 to 3.2m5. With AJDT 1.4.0 (most recent published build) and Eclipse 3.2M5. I'm experiencing terrible performance problems trying to show a visualization of a project of any size. I have JHotDraw with several aspects in it. Under 3.1 the visualization comes up quickly. Under 3.2 the AJDT event trace says:

19:01:33	 AspectJ reports build successful, build was: FULL
19:01:33	 Timer event: 34203ms: Total time spent in AJDE
19:01:38	 Timer event: 4391ms: Create element map (28530 rels in project: JHotDraw)

...

19:11:17	 AJDTContentProvider.selectionChanged(): Marking visualiser content as out of date
19:15:55	 AJDTContentProvider.updateData() executed - took 277828ms

That's a LONG time...

If I just select a single package with 10-20 source files it still takes 30 seconds or so. I've restarted the workspace, done clean builds, added and removed the aspectj nature... nothing seems to make any difference.

Absolute killer for doing any kind of talk or demo!

JHotDraw is of a similar-ish size to WSIF I should think.

This is with:
Eclipse AspectJ Development Tools

Version: 1.4.0
Build id: 20060302045935
AspectJ version: 1.5.1.20060131132251</bugreport>
<pre-fix-testcases failing="142" file="output/130780/pre-fix/testresults.xml" passing="1548" size="1690"/>
<post-fix-testcases failing="187" file="output/130780/post-fix/testresults.xml" passing="1816" size="2003"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/visualiser/AJDTContentProvider.java" revision="1.6" state="changed">41a42
&gt; 	private List includedFiles;
121,138c122,133
&lt; 		try {
&lt; 			if (currentlySelectedJE instanceof IJavaProject) {
&lt; 				IPackageFragment[] packageFragments = ((IJavaProject)currentlySelectedJE).getPackageFragments();
&lt; 				for (int i = 0; i &lt; packageFragments.length; i++) {
&lt; 					if (!(packageFragments[i].isReadOnly())) {
&lt; 						IPackageFragment packageFragment = packageFragments[i];
&lt; 						List classes = getMembersForPackage(packageFragment);
&lt; 						if(classes.size() &gt; 0) {
&lt; 							boolean defaultPackage = packageFragment.isDefaultPackage();
&lt; 							IGroup group = new JDTGroup(packageFragment.getElementName());
&lt; 							if(defaultPackage) {
&lt; 								group.setName("(default package)"); //$NON-NLS-1$
&lt; 								group.setTooltip("(default package)"); //$NON-NLS-1$
&lt; 							}
&lt; 							for (Iterator iter = classes.iterator(); iter.hasNext();) {
&lt; 								IMember member = (IMember) iter.next();
&lt; 								group.add(member);
&lt; 								currentMembers.add(member);
---
&gt; 		if (currentProject != null) {
&gt; 			includedFiles = BuildConfig.getIncludedSourceFiles(currentProject.getProject());
&gt; 			try {
&gt; 				if (currentlySelectedJE instanceof IJavaProject) {
&gt; 					IPackageFragment[] packageFragments = ((IJavaProject)currentlySelectedJE).getPackageFragments();
&gt; 					for (int i = 0; i &lt; packageFragments.length; i++) {
&gt; 						if (!(packageFragments[i].isReadOnly())) {
&gt; 							IPackageFragment packageFragment = packageFragments[i];
&gt; 							List classes = getMembersForPackage(packageFragment);
&gt; 							if(classes.size() &gt; 0) {
&gt; 								boolean defaultPackage = packageFragment.isDefaultPackage();
&gt; 								IGroup group = new JDTGroup(packageFragment.getElementName());
140c135,136
&lt; 									((SimpleMember)member).setFullName(member.getName());
---
&gt; 									group.setName("(default package)"); //$NON-NLS-1$
&gt; 									group.setTooltip("(default package)"); //$NON-NLS-1$
141a138,146
&gt; 								for (Iterator iter = classes.iterator(); iter.hasNext();) {
&gt; 									IMember member = (IMember) iter.next();
&gt; 									group.add(member);
&gt; 									currentMembers.add(member);
&gt; 									if(defaultPackage) {
&gt; 										((SimpleMember)member).setFullName(member.getName());
&gt; 									}
&gt; 								}
&gt; 								currentGroups.add(group);	
143d147
&lt; 							currentGroups.add(group);	
146,155c150,168
&lt; 				}
&lt; 			} else if (currentlySelectedJE instanceof IPackageFragment) {
&lt; 				IPackageFragment packageFragment = (IPackageFragment)currentlySelectedJE;
&lt; 				List classes = getMembersForPackage(packageFragment);
&lt; 				if(classes.size() &gt; 0) {
&lt; 					boolean defaultPackage = packageFragment.isDefaultPackage();
&lt; 					IGroup group = new JDTGroup(packageFragment.getElementName());
&lt; 					if(defaultPackage) {
&lt; 						group.setName("(default package)"); //$NON-NLS-1$
&lt; 						group.setTooltip("(default package)"); //$NON-NLS-1$
---
&gt; 				} else if (currentlySelectedJE instanceof IPackageFragment) {
&gt; 					IPackageFragment packageFragment = (IPackageFragment)currentlySelectedJE;
&gt; 					List classes = getMembersForPackage(packageFragment);
&gt; 					if(classes.size() &gt; 0) {
&gt; 						boolean defaultPackage = packageFragment.isDefaultPackage();
&gt; 						IGroup group = new JDTGroup(packageFragment.getElementName());
&gt; 						if(defaultPackage) {
&gt; 							group.setName("(default package)"); //$NON-NLS-1$
&gt; 							group.setTooltip("(default package)"); //$NON-NLS-1$
&gt; 						}
&gt; 						for (Iterator iter = classes.iterator(); iter.hasNext();) {
&gt; 							IMember member = (IMember) iter.next();
&gt; 							group.add(member);
&gt; 							currentMembers.add(member);
&gt; 							if(defaultPackage) {
&gt; 								((SimpleMember)member).setFullName(member.getName());
&gt; 							}						
&gt; 						}
&gt; 						currentGroups.add(group);					
157,159c170,180
&lt; 					for (Iterator iter = classes.iterator(); iter.hasNext();) {
&lt; 						IMember member = (IMember) iter.next();
&lt; 						group.add(member);
---
&gt; 				} else if (currentlySelectedJE instanceof ICompilationUnit) {
&gt; 					JDTMember member = null;
&gt; 					if (includedFiles.contains(currentlySelectedJE.getResource())) { 
&gt; 						String memberName = currentlySelectedJE.getElementName();
&gt; 						if(memberName.endsWith(".java")){ //$NON-NLS-1$
&gt; 							memberName = memberName.substring(0, memberName.length() - 5); 					
&gt; 						} else if(memberName.endsWith(".aj")){ //$NON-NLS-1$
&gt; 							memberName = memberName.substring(0, memberName.length() - 3); 					
&gt; 						}							
&gt; 						member = new JDTMember(memberName, currentlySelectedJE);
&gt; 						member.setSize(getLength((ICompilationUnit)currentlySelectedJE));
160a182,191
&gt; 					}
&gt; 					if(member != null) {
&gt; 						IPackageFragment packageFrag = (IPackageFragment)((ICompilationUnit)currentlySelectedJE).getParent();
&gt; 						boolean defaultPackage = packageFrag.isDefaultPackage();
&gt; 						// ?!? Need to confirm a group for the pkg frag is OK in the case of a selection like thiss
&gt; 						IGroup group = new JDTGroup(packageFrag.getElementName());
&gt; 						if(defaultPackage) {
&gt; 							group.setName("(default package)"); //$NON-NLS-1$
&gt; 							group.setTooltip("(default package)"); //$NON-NLS-1$
&gt; 						}
162,163c193,196
&lt; 							((SimpleMember)member).setFullName(member.getName());
&lt; 						}						
---
&gt; 							member.setFullName(member.getName());						
&gt; 						} 
&gt; 						group.add(member);
&gt; 						currentGroups.add(group);
165,193d197
&lt; 					currentGroups.add(group);					
&lt; 				}
&lt; 			} else if (currentlySelectedJE instanceof ICompilationUnit) {
&lt; 				JDTMember member = null;
&lt; 				if (BuildConfig.isIncluded(currentlySelectedJE.getResource())) { 
&lt; 					String memberName = currentlySelectedJE.getElementName();
&lt; 					if(memberName.endsWith(".java")){ //$NON-NLS-1$
&lt; 						memberName = memberName.substring(0, memberName.length() - 5); 					
&lt; 					} else if(memberName.endsWith(".aj")){ //$NON-NLS-1$
&lt; 						memberName = memberName.substring(0, memberName.length() - 3); 					
&lt; 					}							
&lt; 					member = new JDTMember(memberName, currentlySelectedJE);
&lt; 					member.setSize(getLength((ICompilationUnit)currentlySelectedJE));
&lt; 					currentMembers.add(member);
&lt; 				}
&lt; 				if(member != null) {
&lt; 					IPackageFragment packageFrag = (IPackageFragment)((ICompilationUnit)currentlySelectedJE).getParent();
&lt; 					boolean defaultPackage = packageFrag.isDefaultPackage();
&lt; 					// ?!? Need to confirm a group for the pkg frag is OK in the case of a selection like thiss
&lt; 					IGroup group = new JDTGroup(packageFrag.getElementName());
&lt; 					if(defaultPackage) {
&lt; 						group.setName("(default package)"); //$NON-NLS-1$
&lt; 						group.setTooltip("(default package)"); //$NON-NLS-1$
&lt; 					}
&lt; 					if(defaultPackage) {
&lt; 						member.setFullName(member.getName());						
&lt; 					} 
&lt; 					group.add(member);
&lt; 					currentGroups.add(group);
194a199
&gt; 			} catch (JavaModelException jme) {
196c201,203
&lt; 		} catch (JavaModelException jme) {
---
&gt; 			long etime = System.currentTimeMillis();
&gt; 	
&gt; 			AJLog.log("AJDTContentProvider.updateData() executed - took "+(etime-stime)+"ms"); //$NON-NLS-1$ //$NON-NLS-2$
198,200d204
&lt; 		long etime = System.currentTimeMillis();
&lt; 
&lt; 		AJLog.log("AJDTContentProvider.updateData() executed - took "+(etime-stime)+"ms"); //$NON-NLS-1$ //$NON-NLS-2$
267c271
&lt; 						if(BuildConfig.isIncluded(ijes[j].getResource())) {  
---
&gt; 						if(includedFiles.contains(ijes[j].getResource())) {  
</file>
</fixedFiles>
</bug>
<bug id="130837" transactionid="70154">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-new K-null K-return O-== T V Y Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417)
at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.resolveAndSetPointcut(ValidateAtAspectJAnnotationsVisitor.java:364)
at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.validateAdvice(ValidateAtAspectJAnnotationsVisitor.java:336)
at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visit(ValidateAtAspectJAnnotationsVisitor.java:186)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(AjCompilerAdapter.java:154)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:517)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:234)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:189)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:164)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</bugreport>
<pre-fix-testcases failing="44" file="output/130837/pre-fix/testresults.xml" passing="639" size="683"/>
<post-fix-testcases failing="74" file="output/130837/post-fix/testresults.xml" passing="876" size="950"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java" revision="1.18" state="changed">412a413
&gt; 		if (mDecl.binding == null) return new FormalBinding[0];
420c421
&lt; 			TypeBinding argTypeBinding = mDecl.binding.parameters[i];
---
&gt;             TypeBinding argTypeBinding = mDecl.binding.parameters[i];
</file>
</fixedFiles>
</bug>
<bug id="130869" transactionid="71142">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="21"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="22"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-break K-for K-if M O-&lt; O-! O-() O-&amp;&amp; O-++ O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>Ok, so I'm on the bleeding edge of aspect design here... but I have a generic aspect of the form

public abstract aspect MyAspect&lt;T extends Bar&gt; { 

  declare warning : T.somePC() : "a match";

}

and Bar is defined as:

public abstract aspect Bar {

  public abstract pointcut somePC();

}

(yes, what that enables is indeed unbelievably cool).

We fail (perhaps unsurprisingly) when compiling the generic aspect because we can't find the pointcut somePC in T. We should of course be looking in the upper bound when searching for a pointcut in a type variable...</bugreport>
<testsforfix ID="130869" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testGenericAspectsWithAnnotationTypeParameters"/>
      <test NAME="testPointcutInterfaces_pr130869"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="Generic aspects with annotation type parameters"/>
      <test NAME="Pointcut interfaces"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="188" file="output/130869/pre-fix/testresults.xml" passing="1815" size="2003"/>
<post-fix-testcases failing="188" file="output/130869/post-fix/testresults.xml" passing="1815" size="2003"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java" revision="1.40" state="changed">140a141,143
&gt; 		if (searchType.isTypeVariableReference()) {
&gt; 			searchType = ((TypeVariableReference)searchType).getTypeVariable().getUpperBound().resolve(scope.getWorld());
&gt; 		}
176c179
&lt; 			if (onType != null) {
---
&gt; 			if (onType != null  &amp;&amp; !onType.isTypeVariableReference()) {
212c215
&lt; 			}
---
&gt; 			} 
277d279
&lt; 			}
278a281,299
&gt; 				if (onType.isTypeVariableReference()) {
&gt; 					// need to replace on type with the binding for the type variable
&gt; 					// in the declaring type
&gt; 					if (declaringType.isParameterizedType()) {
&gt; 						TypeVariable[] tvs = declaringType.getGenericType().getTypeVariables();
&gt; 						String typeVariableName = ((TypeVariableReference)onType).getTypeVariable().getName();
&gt; 						for (int i = 0; i &lt; tvs.length; i++) {
&gt; 							if (tvs[i].getName().equals(typeVariableName)) {
&gt; 								ResolvedType realOnType = declaringType.getTypeParameters()[i].resolve(declaringType.getWorld());
&gt; 								onType = realOnType;
&gt; 								searchStart = realOnType;
&gt; 								break;
&gt; 							}
&gt; 						}
&gt; 					}
&gt; 				}
&gt; 
&gt; 			}
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.29" state="changed">212a213,220
&gt;   public void testGenericAspectsWithAnnotationTypeParameters() {
&gt; 	  runTest("Generic aspects with annotation type parameters");
&gt;   }
&gt;   
&gt;   public void testPointcutInterfaces_pr130869() {
&gt; 	  runTest("Pointcut interfaces");
&gt;   }
&gt;   
220a229
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.27" state="changed">230a231,248
&gt;     &lt;ajc-test dir="bugs151" title="Generic aspects with annotation type parameters"&gt;
&gt;         &lt;compile files="GenericAspectWithAnnotationTypeParameter.aj" options="-1.5"/&gt;
&gt;         &lt;run class="GenericAspectWithAnnotationTypeParameter"&gt;
&gt;             &lt;stdout&gt;
&gt;                 &lt;line text="annotation match - no binding"/&gt;
&gt;                 &lt;line text="execution with annotation match"/&gt;
&gt;                 &lt;line text="annotation match - binding"/&gt;
&gt;                 &lt;line text="hello"/&gt;
&gt;             &lt;/stdout&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs151" title="Pointcut interfaces"&gt;
&gt;         &lt;compile files="pr130869.aj" options="-1.5"&gt;
&gt;           &lt;message kind="warning" line="30" text="no directly runnable classes"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs151/GenericAspectWithAnnotationTypeParameter.aj" revision="1.1" state="new">import java.lang.annotation.Annotation;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

public class GenericAspectWithAnnotationTypeParameter {
	
	@AnnOne
	@AnnTwo
	public static void main(String[] args) {
		System.out.println("hello");
	}
	
	
}

@Retention(RetentionPolicy.RUNTIME)
@interface AnnOne {}
@interface AnnTwo {}

abstract aspect AnnotationMatcher&lt;A extends Annotation&gt; {
	
	before() : execution(* *(..)) &amp;&amp; @annotation(A) {
		System.out.println("annotation match - no binding");
	}
	
	before() : execution(@A * *(..)) {
		System.out.println("execution with annotation match");
	}
	
	before(A anAnnotation) : execution(* *(..)) &amp;&amp; @annotation(anAnnotation) {
		System.out.println("annotation match - binding");
	}
}

aspect AnnOneMatcher extends AnnotationMatcher&lt;AnnOne&gt; {}</file>
<file name="org.aspectj/modules/tests/bugs151/pr130869.aj" revision="1.1" state="new">abstract aspect AbstractSystemArchitecture {

	public abstract pointcut inMyApplication();
	
	// more pointcuts below...
	
}

aspect MySystemArchitecture extends AbstractSystemArchitecture {
	
	public pointcut inMyApplication() : within(SomeClass);
	
}

abstract aspect NoDirectlyRunnableClasses&lt;A extends AbstractSystemArchitecture&gt; {
	
	declare warning : execution(public static void main(String[])) &amp;&amp;
	                  A.inMyApplication()
	                : "no directly runnable classes";

}

aspect NoRunnablesInMyApp extends NoDirectlyRunnableClasses&lt;MySystemArchitecture&gt; {
	
}


class SomeClass {

	public static void main(String[] args) {  // CW L30
		System.out.println("hello");
	}

}

class SomeOtherClass {

	public static void main(String[] args) {  // no warning
		System.out.println("hello");
	}

}</file>
</fixedFiles>
</bug>
<bug id="131010" transactionid="74525">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-null M O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Following exception occurs upon clicking on a Java project in the Package Explorer (Eclipse 3.2M5a, AspectJ 1.4.0.20060307084510, Java 5).  AspectJ nature is not enabled on the concerned project.

!ENTRY org.eclipse.ui.workbench 4 2 2006-03-08 19:04:35.983
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.ui.workbench".
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ajdt.internal.ui.ImageDecorator.decorateImage(ImageDecorator.java:116)
        at org.eclipse.ui.internal.decorators.FullDecoratorDefinition.decorateImage(FullDecoratorDefinition.java:111)
        at org.eclipse.ui.internal.decorators.FullImageDecoratorRunnable.run(FullImageDecoratorRunnable.java:28)
        at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
        at org.eclipse.core.runtime.Platform.run(Platform.java:816)</bugreport>
<pre-fix-testcases failing="115" file="output/131010/pre-fix/testresults.xml" passing="940" size="1055"/>
<post-fix-testcases failing="189" file="output/131010/post-fix/testresults.xml" passing="1814" size="2003"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/ImageDecorator.java" revision="1.6" state="changed">116c116
&lt; 			if (file.getFileExtension().equals(AJProperties.EXTENSION)) {
---
&gt; 			if (file.getFileExtension() != null &amp;&amp; file.getFileExtension().equals(AJProperties.EXTENSION)) {
</file>
</fixedFiles>
</bug>
<bug id="131505" transactionid="69878">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="10"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="20"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-new K-null K-return K-this M O-== O-! O-!= T V Z-if Z-vardecl</fullfingerprint>
<bugreport>Using the -outxml option in AJDT the generated aop.xml files are not correct after the first build and contain all the aspects that have ever been built (including those in different projects and duplicates if an aspect has been built twice).  It seems that there is a global list of aspects (aspectNames in AjBuildManager) that is never cleared.</bugreport>
<testsforfix ID="131505" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr131505"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="185" file="output/131505/pre-fix/testresults.xml" passing="1818" size="2003"/>
<post-fix-testcases failing="187" file="output/131505/post-fix/testresults.xml" passing="1816" size="2003"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java" revision="1.27" state="changed">163a164
&gt; 	private List/*String*/ aspectNames;
1202a1204,1211
&gt; 	
&gt; 	public List getAspectNames() {
&gt; 		return aspectNames;
&gt; 	}
&gt; 	
&gt; 	public void initializeAspectNamesList() {
&gt; 		this.aspectNames = new LinkedList();
&gt; 	}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.97" state="changed">28d27
&lt; import java.util.LinkedList;
135d133
&lt; 	private List aspectNames = new LinkedList();
538,540c536,540
&lt; 		for (Iterator i = aspectNames.iterator(); i.hasNext();) {
&lt; 			String name = (String)i.next();
&lt; 			ps.println("&lt;aspect name=\"" + name + "\"/&gt;");
---
&gt; 		if (state.getAspectNames() != null) {
&gt; 			for (Iterator i = state.getAspectNames().iterator(); i.hasNext();) {
&gt; 				String name = (String)i.next();
&gt; 				ps.println("&lt;aspect name=\"" + name + "\"/&gt;");
&gt; 			}			
954c954,959
&lt; 					aspectNames.add(name);
---
&gt; 					if (state.getAspectNames() == null) {
&gt; 						state.initializeAspectNamesList();
&gt; 					}
&gt; 					if (!state.getAspectNames().contains(name)) {
&gt; 						state.getAspectNames().add(name);
&gt; 					}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.41" state="changed">13a14
&gt; import java.io.BufferedReader;
16a18
&gt; import java.io.FileReader;
689a692,739
&gt; 	public void testPr131505() {
&gt; 		configureNonStandardCompileOptions("-outxml");
&gt; 		initialiseProject("PR131505");
&gt; 		build("PR131505");
&gt; 		checkWasFullBuild();
&gt; 		// aop.xml file shouldn't contain any aspects
&gt; 		checkXMLAspectCount("PR131505","",0);
&gt; 		// add a new aspect A which should be included in the aop.xml file
&gt; 		alter("PR131505","inc1");
&gt; 		build("PR131505");
&gt; 		checkWasFullBuild();
&gt; 		checkXMLAspectCount("PR131505","",1);
&gt; 		checkXMLAspectCount("PR131505","A",1);
&gt; 		// make changes to the class file which shouldn't affect the contents
&gt; 		// of the aop.xml file
&gt; 		alter("PR131505","inc2");
&gt; 		build("PR131505");
&gt; 		checkWasntFullBuild();
&gt; 		checkXMLAspectCount("PR131505","",1);
&gt; 		checkXMLAspectCount("PR131505","A",1);		
&gt; 		// add another new aspect A1 which should also be included in the aop.xml file
&gt; 		// ...there should be no duplicate entries in the file
&gt; 		alter("PR131505","inc3");
&gt; 		build("PR131505");
&gt; 		checkWasFullBuild();
&gt; 		checkXMLAspectCount("PR131505","",2);
&gt; 		checkXMLAspectCount("PR131505","A1",1);
&gt; 		checkXMLAspectCount("PR131505","A",1);
&gt; 		// delete aspect A1 which meanss that aop.xml file should only contain A
&gt; 		File a1 = new File(getWorkingDir().getAbsolutePath() 
&gt; 				+ File.separatorChar + "PR131505" + File.separatorChar + "A1.aj");
&gt; 		a1.delete();
&gt; 		build("PR131505");
&gt; 		checkWasFullBuild();
&gt; 		checkXMLAspectCount("PR131505","",1);
&gt; 		checkXMLAspectCount("PR131505","A1",0);
&gt; 		checkXMLAspectCount("PR131505","A",1);	
&gt; 		// add another aspect called A which is in a different package, both A
&gt; 		// and pkg.A should be included in the aop.xml file
&gt; 		alter("PR131505","inc4");
&gt; 		build("PR131505");
&gt; 		checkWasFullBuild();
&gt; 		checkXMLAspectCount("PR131505","",2);
&gt; 		checkXMLAspectCount("PR131505","A",1);
&gt; 		checkXMLAspectCount("PR131505","pkg.A",1);
&gt; 	}
&gt; 	
&gt; 	
850a901,939
&gt; 	
&gt; 	/**
&gt; 	 * Count the number of times a specified aspectName appears in the default
&gt; 	 * aop.xml file and compare with the expected number of occurrences. If just 
&gt; 	 * want to count the number of aspects mentioned within the file then 
&gt; 	 * pass "" for the aspectName, otherwise, specify the name of the 
&gt; 	 * aspect interested in.
&gt; 	 */
&gt; 	private void checkXMLAspectCount(String projectName, String aspectName, int expectedOccurrences) {
&gt; 		int aspectCount = 0;
&gt; 		File aopXML = new File(getWorkingDir().getAbsolutePath() 
&gt; 				+ File.separatorChar + projectName + File.separatorChar 
&gt; 				+ "bin" + File.separatorChar + "META-INF" + File.separatorChar + "aop.xml");
&gt; 
&gt; 		if (!aopXML.exists()) {
&gt; 			fail("Expected file " + aopXML.getAbsolutePath() + " to exist but it doesn't");
&gt; 		}
&gt; 		try {
&gt; 			BufferedReader reader = new BufferedReader(new FileReader(aopXML));
&gt; 			String line = reader.readLine();
&gt; 			while (line != null) {
&gt; 				if (aspectName.equals("") &amp;&amp; line.indexOf("aspect name=\"") != -1) {
&gt; 					aspectCount++;
&gt; 				} else if (line.indexOf("aspect name=\""+aspectName+"\"") != -1) {
&gt; 					aspectCount++;
&gt; 				}
&gt; 				line = reader.readLine();
&gt; 			}
&gt; 			reader.close();
&gt; 		} catch (IOException ie) {
&gt; 			ie.printStackTrace();
&gt; 		}
&gt; 		if (aspectCount != expectedOccurrences) {
&gt; 			fail("Expected aspect " + aspectName + " to appear " + expectedOccurrences + " times" +
&gt; 					" in the aop.xml file but found " + aspectCount + " occurrences");
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR131505/inc4/pkg/A.aj" revision="1.1" state="new">package pkg;

public aspect A {

	pointcut p() : execution(public void C.method2(..));
	
	before() : p() {
	}
	
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR131505/inc3/A1.aj" revision="1.1" state="new">public aspect A1 {
	
	pointcut p() : execution(public void C.method2(..));
	
	before() : p() {
	}
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR131505/base/C.java" revision="1.1" state="new">public class C {

	public void method1() {	
	}
	
	public void method2() {
	}
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR131505/inc2/C.java" revision="1.1" state="new">public class C {

	public void method1() {	
	}
	
	public void method2() {
	}
	
	public void method3() {
	}
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR131505/inc1/A.aj" revision="1.1" state="new">public aspect A {

	pointcut p() : execution(public void C.method1(..));
	
	before() : p() {
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="131932" transactionid="68646">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V</fullfingerprint>
<bugreport>import java.util.List;

public aspect Slide74 {

	public X Bar&lt;X&gt;.getFirst() {
		return lts.get(0);
	}
	
	static class Bar&lt;T&gt; {
		List&lt;T&gt; lts;
	}
}

in AJDT, this program incorrectly shows the relationship from the TYPE to the Bar class rather than from the ITD to the Bar class.</bugreport>
<testsforfix ID="131932" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testStructureModelForGenericITD_pr131932"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="structure model for generic itd"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/131932/pre-fix/testresults.xml" passing="1813" size="2003"/>
<post-fix-testcases failing="190" file="output/131932/post-fix/testresults.xml" passing="1813" size="2003"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java" revision="1.18" state="changed">92a93
&gt; 	    nftm.setSourceLocation(getSourceLocation());
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/NewMethodTypeMunger.java" revision="1.20" state="changed">109a110
&gt; 		nmtm.setSourceLocation(getSourceLocation());
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java" revision="1.17" state="changed">139c139,141
&lt; 		return new NewConstructorTypeMunger(parameterizedSignature,syntheticConstructor,explicitConstructor,getSuperMethodsCalled(),typeVariableAliases);
---
&gt; 		NewConstructorTypeMunger nctm = new NewConstructorTypeMunger(parameterizedSignature,syntheticConstructor,explicitConstructor,getSuperMethodsCalled(),typeVariableAliases);
&gt; 		nctm.setSourceLocation(getSourceLocation());
&gt; 		return nctm;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.29" state="changed">254a255,257
&gt;     &lt;ajc-test dir="bugs151" title="structure model for generic itd"&gt;
&gt;         &lt;compile files="pr131932.aj" options="-1.5 -emacssym"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.31" state="changed">13a14
&gt; import java.util.Iterator;
114a116,194
&gt;   public void testStructureModelForGenericITD_pr131932() {
&gt;  	  //AsmManager.setReporting("c:/debug.txt",true,true,true,true);
&gt; 	  runTest("structure model for generic itd");
&gt; 	  IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt;  	   
&gt;   	  // get the IProgramElements corresponding to the ITDs and classes
&gt;   	  IProgramElement foo = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.CLASS,"Foo");
&gt;   	  assertNotNull("Couldn't find Foo element in the tree",foo);
&gt;   	  IProgramElement bar = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.CLASS,"Bar");
&gt;   	  assertNotNull("Couldn't find Bar element in the tree",bar);
&gt; 
&gt;   	  IProgramElement method = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.INTER_TYPE_METHOD,"Bar.getFirst()");  	   	 
&gt;   	  assertNotNull("Couldn't find 'Bar.getFirst()' element in the tree",method);
&gt;   	  IProgramElement field = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.INTER_TYPE_FIELD,"Bar.children");  	   	 
&gt;   	  assertNotNull("Couldn't find 'Bar.children' element in the tree",field);
&gt;   	  IProgramElement constructor = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,"Foo.Foo(List&lt;T&gt;)");  	   	 
&gt;   	  assertNotNull("Couldn't find 'Foo.Foo(List&lt;T&gt;)' element in the tree",constructor);
&gt;   	  
&gt;   	  // check that the relationship map has 'itd method declared on bar'
&gt;   	  List matches = AsmManager.getDefault().getRelationshipMap().get(method);
&gt;   	  assertNotNull("itd Bar.getFirst() should have some relationships but does not",matches);
&gt;   	  assertTrue("method itd should have one relationship but has " + matches.size(), matches.size() == 1);
&gt;   	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("itd Bar.getFirst() should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
&gt;   	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the Bar class but is IPE with label "
&gt;   			  + target.toLabelString(),bar,target);
&gt; 
&gt;   	  // check that the relationship map has 'itd field declared on bar'
&gt;   	  matches = AsmManager.getDefault().getRelationshipMap().get(field);
&gt;   	  assertNotNull("itd Bar.children should have some relationships but does not",matches);
&gt;   	  assertTrue("field itd should have one relationship but has " + matches.size(), matches.size() == 1);
&gt;   	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("itd Bar.children should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
&gt;   	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the Bar class but is IPE with label "
&gt;   			  + target.toLabelString(),bar,target);
&gt; 
&gt;   	  // check that the relationship map has 'itd constructor declared on foo'
&gt;   	  matches = AsmManager.getDefault().getRelationshipMap().get(constructor);
&gt;   	  assertNotNull("itd Foo.Foo(List&lt;T&gt;) should have some relationships but does not",matches);
&gt;   	  assertTrue("constructor itd should have one relationship but has " + matches.size(), matches.size() == 1);
&gt;   	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("itd Foo.Foo(List&lt;T&gt;) should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
&gt;   	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the Foo class but is IPE with label "
&gt;   			  + target.toLabelString(),foo,target);
&gt;   	  
&gt;   	  // check that the relationship map has 'bar aspect declarations method and field itd'
&gt;   	  matches = AsmManager.getDefault().getRelationshipMap().get(bar);
&gt;   	  assertNotNull("Bar should have some relationships but does not",matches);
&gt;   	  assertTrue("Bar should have one relationship but has " + matches.size(), matches.size() == 1);
&gt;   	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("Bar should have two targets but has " + matchesTargets.size(),matchesTargets.size() == 2);
&gt;   	  for (Iterator iter = matchesTargets.iterator(); iter.hasNext();) {
&gt; 		  String element = (String) iter.next();
&gt; 		  target = AsmManager.getDefault().getHierarchy().findElementForHandle(element);
&gt; 		  if (!target.equals(method) &amp;&amp; !target.equals(field)) {
&gt; 			  fail("Expected rel target to be " + method.toLabelString() + " or " + field.toLabelString() 
&gt; 					+ ", found " + target.toLabelString());
&gt; 		  }
&gt; 	  }
&gt; 
&gt;   	  // check that the relationship map has 'foo aspect declarations constructor itd'
&gt;  	  matches = AsmManager.getDefault().getRelationshipMap().get(foo);
&gt;   	  assertNotNull("Foo should have some relationships but does not",matches);
&gt;   	  assertTrue("Foo should have one relationship but has " + matches.size(), matches.size() == 1);
&gt;   	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("Foo should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
&gt;  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the Foo.Foo(List&lt;T&gt;) itd but is IPE with label "
&gt;   			  + target.toLabelString(),constructor,target);
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/bugs151/pr131932.aj" revision="1.1" state="new">import java.util.List;

aspect Slide74 {
	
	public X Bar&lt;X&gt;.getFirst() {
		return lts.get(0);
    }

	&lt;T&gt; Foo&lt;T&gt;.new(List&lt;T&gt; elements) { this(); }
	
	private List&lt;C&gt; Bar&lt;C&gt;.children;// = new ArrayList&lt;C&gt;();
	
    static class Bar&lt;T&gt; {
        List&lt;T&gt; lts;
    }   
    
}

class Foo&lt;T&gt; {
	
}
</file>
</fixedFiles>
</bug>
<bug id="131933" transactionid="68311">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="5"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-instanceof O-== O-! O-() O-instanceof T V Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>import java.util.List;

public aspect Slide71 {
	before(): GenericType&lt;String&gt;.foo() {}
	before(): GenericType&lt;MyList&gt;.foo() {}
	//before(): GenericType.foo() {}
}
	
class GenericType&lt;T&gt; {
	public pointcut foo(): execution(* T.*(..));
}

that programs gives:  (because MyList is not a known type)

java.lang.ClassCastException
at org.aspectj.weaver.patterns.TypePattern.resolveExactType(TypePattern.java:193)
at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:130)
at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194)
at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:84)
at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:118)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)
at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:268)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ClassCastException thrown: org.aspectj.weaver.patterns.WildTypePattern</bugreport>
<testsforfix ID="131933" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testGenericAspectWithUnknownType_pr131933"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="no ClassCastException with generic aspect and unknown type"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/131933/pre-fix/testresults.xml" passing="1817" size="2003"/>
<post-fix-testcases failing="188" file="output/131933/post-fix/testresults.xml" passing="1815" size="2003"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/TypePattern.java" revision="1.35" state="changed">191,192c191
&lt; 		if (p == NO) return ResolvedType.MISSING;
&lt; 		
---
&gt; 		if (!(p instanceof ExactTypePattern)) return ResolvedType.MISSING;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.30" state="changed">109a110,114
&gt;   
&gt;   public void testGenericAspectWithUnknownType_pr131933() {
&gt; 	  runTest("no ClassCastException with generic aspect and unknown type");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.28" state="changed">248a249,255
&gt;     &lt;ajc-test dir="bugs151" title="no ClassCastException with generic aspect and unknown type"&gt;
&gt;         &lt;compile files="pr131933.aj" options="-1.5"&gt;
&gt;           &lt;message kind="error" line="5" text="can't bind type name 'MyList'"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt; 
&gt; 
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs151/pr131933.aj" revision="1.1" state="new">import java.util.List;

aspect Slide71 {
        before(): GenericType&lt;String&gt;.foo() {}
        before(): GenericType&lt;MyList&gt;.foo() {}
        //before(): GenericType.foo() {}
}

class GenericType&lt;T&gt; {
        public pointcut foo(): execution(* T.*(..));
}
</file>
</fixedFiles>
</bug>
<bug id="132130" transactionid="70158">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint/>
<fullfingerprint>Y</fullfingerprint>
<bugreport>For this program (when all entered into *one* file) I don't see a marker from the declare to the annotated method.  If the annotated method is in another file, I do... (not sure if fields/ctors/types are also a problem..)

public aspect basic {

        declare @method:
                 * debit(..):
                 @Secured(role="supervisor");

}

class BankAccount {
        public void debit(long accId,long amount) {
        }
}

@interface Secured {
        String role();
}</bugreport>
<testsforfix ID="132130" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testDeclareAnnotationAppearsInStructureModel_pr132130"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="declare annotation appears in structure model when in same file"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/132130/pre-fix/testresults.xml" passing="1817" size="2003"/>
<post-fix-testcases failing="191" file="output/132130/post-fix/testresults.xml" passing="1812" size="2003"/>
<fixedFiles>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/internal/ProgramElement.java" revision="1.29" state="changed">430c430
&lt; 				if (it.hasNext()) sb.append(", ");
---
&gt; 				if (it.hasNext()) sb.append(",");
</file>
<file name="org.aspectj/modules/ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java" revision="1.17" state="changed">173c173
&lt; 				"afterReturning(int, int): namedWithArgs..",
---
&gt; 				"afterReturning(int,int): namedWithArgs..",
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.32" state="changed">78,80c78,80
&lt;   	  assertEquals("foo(int, java.lang.Object)",pe.toLabelString());
&lt;   	  assertEquals("C.foo(int, java.lang.Object)",pe.toLinkLabelString());
&lt;   	  assertEquals("foo(int, java.lang.Object)",pe.toSignatureString());
---
&gt;   	  assertEquals("foo(int,java.lang.Object)",pe.toLabelString());
&gt;   	  assertEquals("C.foo(int,java.lang.Object)",pe.toLinkLabelString());
&gt;   	  assertEquals("foo(int,java.lang.Object)",pe.toSignatureString());
82,84c82,84
&lt;   	  assertEquals("foo(int, Object)",pe.toLabelString(false));
&lt;   	  assertEquals("C.foo(int, Object)",pe.toLinkLabelString(false));
&lt;   	  assertEquals("foo(int, Object)",pe.toSignatureString(false));
---
&gt;   	  assertEquals("foo(int,Object)",pe.toLabelString(false));
&gt;   	  assertEquals("C.foo(int,Object)",pe.toLinkLabelString(false));
&gt;   	  assertEquals("foo(int,Object)",pe.toSignatureString(false));
194a195,258
&gt;   
&gt;   public void testDeclareAnnotationAppearsInStructureModel_pr132130() {
&gt; 	  //AsmManager.setReporting("c:/debug.txt",true,true,true,true);
&gt; 	  runTest("declare annotation appears in structure model when in same file");
&gt; 	  IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt; 	  
&gt;   	  // get the IProgramElements corresponding to the different code entries
&gt;   	  IProgramElement decam = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,"declare @method: * debit(..) : @Secured(role = \"supervisor\")");  	   	 
&gt;   	  assertNotNull("Couldn't find 'declare @method' element in the tree",decam);
&gt;   	  IProgramElement method = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.METHOD,"debit(long,long)");
&gt;   	  assertNotNull("Couldn't find the 'debit(long,long)' method element in the tree",method);
&gt;   	  IProgramElement decac = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,"declare @constructor: BankAccount+.new(..) : @Secured(role = \"supervisor\")");  	   	 
&gt;   	  assertNotNull("Couldn't find 'declare @constructor' element in the tree",decac);
&gt;   	  IProgramElement ctr = top.findElementForLabel(top.getRoot(),
&gt;   			  IProgramElement.Kind.CONSTRUCTOR,"BankAccount(String,int)");
&gt;   	  assertNotNull("Couldn't find the 'BankAccount(String,int)' constructor element in the tree",ctr);
&gt; 
&gt;   	  
&gt;   	  // check that decam has a annotates relationship with the debit method
&gt;   	  List matches = AsmManager.getDefault().getRelationshipMap().get(decam);	
&gt;   	  assertNotNull("'declare @method' should have some relationships but does not",matches);
&gt;   	  assertTrue("'declare @method' should have one relationships but has " + matches.size(),matches.size()==1);
&gt;   	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("'declare @method' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
&gt;   	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the 'debit(long,long)' method but is IPE with label "
&gt;   			  + target.toLabelString(),method,target);
&gt;   	  
&gt;   	  // check that the debit method has an annotated by relationship with the declare @method
&gt;   	  matches = AsmManager.getDefault().getRelationshipMap().get(method);	
&gt;   	  assertNotNull("'debit(long,long)' should have some relationships but does not",matches);
&gt;   	  assertTrue("'debit(long,long)' should have one relationships but has " + matches.size(),matches.size()==1);
&gt;   	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("'debit(long,long)' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
&gt;   	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the 'declare @method' ipe but is IPE with label "
&gt;   			  + target.toLabelString(),decam,target);
&gt; 
&gt;   	  // check that decac has a annotates relationship with the constructor
&gt;   	  matches = AsmManager.getDefault().getRelationshipMap().get(decac);	
&gt;   	  assertNotNull("'declare @method' should have some relationships but does not",matches);
&gt;   	  assertTrue("'declare @method' should have one relationships but has " + matches.size(),matches.size()==1);
&gt;   	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("'declare @method' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
&gt;   	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the 'debit(long, long)' method but is IPE with label "
&gt;   			  + target.toLabelString(),ctr,target);
&gt;   	  
&gt;   	  // check that the constructor has an annotated by relationship with the declare @constructor
&gt;   	  matches = AsmManager.getDefault().getRelationshipMap().get(ctr);	
&gt;   	  assertNotNull("'debit(long, long)' should have some relationships but does not",matches);
&gt;   	  assertTrue("'debit(long, long)' should have one relationships but has " + matches.size(),matches.size()==1);
&gt;   	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
&gt;   	  assertTrue("'debit(long, long)' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
&gt;   	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
&gt;   	  assertEquals("target of relationship should be the 'declare @method' ipe but is IPE with label "
&gt;   			  + target.toLabelString(),decac,target);
&gt; 
&gt; 
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.30" state="changed">258a259,262
&gt;     &lt;ajc-test dir="bugs151" title="declare annotation appears in structure model when in same file"&gt;
&gt;         &lt;compile files="pr132130.aj" options="-1.5 -emacssym"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.java" revision="1.15" state="changed">85c85
&lt; 		checkInterTypeMapping("InterTypeDecCoverage", "Point", "Point.check(int, Line)", 
---
&gt; 		checkInterTypeMapping("InterTypeDecCoverage", "Point", "Point.check(int,Line)", 
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java" revision="1.15" state="changed">114c114
&lt; 		String methodMsg = "Point.check(int, Line)";
---
&gt; 		String methodMsg = "Point.check(int,Line)";
138c138
&lt; 		String params = "namedWithArgs(int, int)";
---
&gt; 		String params = "namedWithArgs(int,int)";
179c179
&lt; 		String afterReturning = "afterReturning(int, int): namedWithArgs..";
---
&gt; 		String afterReturning = "afterReturning(int,int): namedWithArgs..";
</file>
<file name="org.aspectj/modules/tests/bugs151/pr132130.aj" revision="1.1" state="new"> aspect basic {

    declare @method : * debit(..) : @Secured(role="supervisor");
    declare @constructor : BankAccount+.new(..) : @Secured(role="supervisor");
}

class BankAccount {
	
	public BankAccount(String s, int i) {
	}
    public void debit(long accId,long amount) {
    }
}

@interface Secured {
    String role();
}
</file>
</fixedFiles>
</bug>
<bug id="132132" transactionid="73304">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="45"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="47"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-false K-if K-import K-instanceof K-package K-return K-super M O-&lt;= O-== O-&gt;= O-() O-&amp;&amp; O-cast O-instanceof T V Y Z-cast Z-if</fullfingerprint>
<bugreport>The LTW launcher needs JDK 1.4 or later but this is not policed by the setup. If you are using 1.3 you will get a NoClassDefFoundError for the class with the main method. This is because the mechanism used by the launcher attempts to register a new weaving class loader with the JVM and this fails silently.</bugreport>
<pre-fix-testcases failing="188" file="output/132132/pre-fix/testresults.xml" passing="1827" size="2015"/>
<post-fix-testcases failing="189" file="output/132132/post-fix/testresults.xml" passing="1826" size="2015"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/text/UIMessages.java" revision="1.38" state="changed">349a350
&gt; 	public static String LTW_error_wrong_jre;
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/text/UIMessages.properties" revision="1.44" state="changed"/>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/launching/LTWTabGroup.java" revision="1.2" state="changed">22d21
&lt; import org.eclipse.jdt.debug.ui.launchConfigurations.JavaJRETab;
41c40
&lt; 				new JavaJRETab(),
---
&gt; 				new AJJRETab(),
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/launching/AJJRETab.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *     Matt Chapman - initial version
 *******************************************************************************/
package org.eclipse.ajdt.internal.launching;

import org.eclipse.ajdt.internal.ui.text.UIMessages;
import org.eclipse.debug.core.ILaunchConfiguration;
import org.eclipse.debug.ui.ILaunchConfigurationTab;
import org.eclipse.jdt.debug.ui.launchConfigurations.JavaJRETab;
import org.eclipse.jdt.launching.IVMInstall;
import org.eclipse.jdt.launching.IVMInstall2;
import org.eclipse.jdt.launching.JavaRuntime;

public class AJJRETab extends JavaJRETab {

	/**
	 * @see ILaunchConfigurationTab#isValid(ILaunchConfiguration)
	 */
	public boolean isValid(ILaunchConfiguration config) {
		boolean valid = super.isValid(config);
		if (valid) {
			// bug 132132: LTW requires a &gt;= 1.4 jre
			IVMInstall jre = JavaRuntime.getVMInstall(fJREBlock.getPath());
			if (jre instanceof IVMInstall2) {
				String version = ((IVMInstall2)jre).getJavaVersion();
				if (version.charAt(0) == '1'
						&amp;&amp; version.charAt(1) == '.'
						&amp;&amp; (version.charAt(2) &gt;= '0' &amp;&amp; version.charAt(2) &lt;= '3')) {
					setErrorMessage(UIMessages.LTW_error_wrong_jre);
					return false;
				}
			}
		}
		return valid;
	}
}
</file>
</fixedFiles>
</bug>
<bug id="132349" transactionid="70004">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="23"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-if K-new K-null K-return K-super M O-&lt; O-! O-!= O-&amp;&amp; O-+ O-++ T V Y Z-for Z-if Z-vardecl</fullfingerprint>
<tag>exception</tag>
<bugreport>Using the 1.5 compiler from the 20th of December or Eclipse with the AJDT plugin 1.5.0.20051220093604 to compile the following code:

public class TopLevelType&lt;E&gt; {
	public static class NestedType {}
}

aspect SomeAspect {
	public void TopLevelType.NestedType.someMethod() {
	}
}

results in: 

C:\Dokumente und Einstellungen\Michi\Eigene Dateien\Temp\tmp\TopLevelType.java [error] Internal compiler error
java.lang.IllegalStateException: Use generic type, not parameterized type
	at org.aspectj.weaver.ResolvedTypeMunger.&lt;init&gt;(ResolvedTypeMunger.java:69)
	at org.aspectj.weaver.NewMethodTypeMunger.&lt;init&gt;(NewMethodTypeMunger.java:28)
	at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration.java:197)
	at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1066)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:442)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:326)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)

(no source information available)
ABORT
	
Exception thrown from AspectJ 1.5.0

This might be logged as a bug already -- find current bugs at
  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler

Bugs for exceptions thrown have titles File:line from the top stack, 
e.g., "SomeFile.java:243"

If you don't find the exception below in a bug, please add a new bug
at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ
To make the bug a priority, please include a test program
that can reproduce this exception.
Use generic type, not parameterized type

when collecting itds and declares SomeAspect
when completing type bindings 
when batch building with classpath: C:\Programme\Java\jre1.5.0_06\lib\ext\dnsns.jar;C:\Programme\Java\jre1.5.0_06\lib\ext\localedata.jar;C:\Programme\Java\jre1.5.0_06\lib\ext\sunjce_provider.jar;C:\Programme\Java\jre1.5.0_06\lib\ext\sunpkcs11.jar;C:\Programme\Java\aspectj1.5\lib\aspectjrt.jar;
Use generic type, not parameterized type
java.lang.IllegalStateException: Use generic type, not parameterized type
	at org.aspectj.weaver.ResolvedTypeMunger.&lt;init&gt;(ResolvedTypeMunger.java:69)
	at org.aspectj.weaver.NewMethodTypeMunger.&lt;init&gt;(NewMethodTypeMunger.java:28)
	at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration.java:197)
	at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1066)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:442)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:326)
	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:326)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:240)
	at org.aspectj.tools.ajc.Main.main(Main.java:83)


1 fail|abort, 1 error</bugreport>
<testsforfix ID="132349" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testItdOnInnerTypeOfGenericType_pr132349"/>
      <test NAME="testAtAspectNoInvalidAbsoluteTypeName_pr126560"/>
      <test NAME="testAtAspectNoInvalidAbsoluteTypeName_pr126560_2"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="ITD on inner type of generic type"/>
      <test NAME="@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same package"/>
      <test NAME="@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same file"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/132349/pre-fix/testresults.xml" passing="1813" size="2003"/>
<post-fix-testcases failing="186" file="output/132349/post-fix/testresults.xml" passing="1817" size="2003"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java" revision="1.34" state="changed">1589a1590,1609
&gt;         
&gt;         public UnresolvedType lookupType(String name, IHasPosition location) {
&gt;         	// bug 126560  
&gt;         	if (m_enclosingType != null) {
&gt;         		// add the package we're in to the list of imported
&gt;             	// prefixes so that we can find types in the same package 
&gt; 			String pkgName = m_enclosingType.getPackageName();
&gt; 			if (pkgName != null &amp;&amp; !pkgName.equals("")) {
&gt; 				String[] currentImports = getImportedPrefixes();
&gt; 				String[] newImports = new String[currentImports.length + 1];
&gt; 				for (int i = 0; i &lt; currentImports.length; i++) {
&gt; 					newImports[i] = currentImports[i];
&gt; 				}
&gt; 				newImports[currentImports.length] = pkgName.concat(".");
&gt; 				setImportedPrefixes(newImports);
&gt; 			}
&gt; 		}
&gt;         	return super.lookupType(name,location);
&gt;         }
&gt;         
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/SimpleScope.java" revision="1.8" state="changed">46a47,49
&gt; //			// make sure we're matching against the
&gt; //			// type name rather than part of it
&gt; //			if (importedName.endsWith("." + name)) {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.38" state="changed">27a28
&gt;  // public void testItdOnInnerTypeOfGenericType_pr132349() { runTest("ITD on inner type of generic type");}
54a56,64
&gt;   
&gt;   public void testAtAspectNoInvalidAbsoluteTypeName_pr126560() {
&gt; 	  runTest("@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same package");
&gt;   }
&gt;   
&gt;   public void testAtAspectNoInvalidAbsoluteTypeName_pr126560_2() {
&gt; 	  runTest("@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same file");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.35" state="changed">5a6,23
&gt;     &lt;ajc-test dir="bugs151/pr132349" title="ITD on inner type of generic type"&gt;
&gt;      &lt;compile files="TopLevelType.java" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs151/pr126560" title="@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same package"&gt;
&gt;         &lt;compile files="pkg1/C.java, pkg1/A.java" options="-1.5"&gt;
&gt;           &lt;message kind="error" line="8" text="error"/&gt;
&gt;           &lt;message kind="warning" line="5" text="warning"/&gt;
&gt; 	    &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs151/pr126560" title="@AJ deow doesn't throw an invalidAbsoluteTypeName when specify type in the same file"&gt;
&gt;         &lt;compile files="pkg2/InOneFile.java" options="-1.5"&gt;
&gt;           &lt;message kind="warning" line="14" text="call hello"/&gt;
&gt;           &lt;message kind="error" line="15" text="call hi"/&gt;
&gt; 	    &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs151/pr126560/pkg2/InOneFile.java" revision="1.1" state="new">package pkg2;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareWarning;
import org.aspectj.lang.annotation.DeclareError;

public class InOneFile {

    public void hello() {}

    public void hi() {}

    public void target() {
        hello();
        hi();
    }

    @Aspect
    public static class DeowAspect {

        @DeclareWarning("call(* InOneFile.hello())")
        final static String onHello = "call hello";

        @DeclareError("call(* InOneFile.hi())")
        final static String onHi = "call hi";
    }
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr132349/TopLevelType.java" revision="1.1" state="new">public class TopLevelType&lt;E&gt; {
        public static class NestedType {}
}

aspect SomeAspect {
        public void TopLevelType.NestedType.someMethod() {
        }
}</file>
<file name="org.aspectj/modules/tests/bugs151/pr126560/pkg1/A.java" revision="1.1" state="new">package pkg1;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareWarning;
import org.aspectj.lang.annotation.DeclareError;

@Aspect
public class A {

	@DeclareWarning("execution(* C.warningMethod())")
    static final String warning = "warning";

    @DeclareError("execution(* C.badMethod())")
    static final String error = "error";
	
}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr126560/pkg1/C.java" revision="1.1" state="new">package pkg1;

public class C {

	public void warningMethod() {
	}
	
	public void badMethod() {
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="132591" transactionid="74354">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="11"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="11"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new K-null K-return K-true M O-+ T V Y Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>See also bug #57666 which is related (but has to do with manifests):

I have a META-INF/aop.xml file in my aspectpath and another one in the source path. That shouldn't even be a duplicate, because the aspectpath resource should NOT be copied to output at all.

In AspectJ build:  1.5.1.20060309143651

I am now getting:

java.util.zip.ZipException
at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163)
at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeOutxmlFile(AjBuildManager.java:549)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:320)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ZipException thrown: duplicate entry: META-INF/aop.xml</bugreport>
<testsforfix ID="132591" type="new">
    <file LOCATION="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/OutxmlTest.java">
      <test NAME="testOutxmlToOutjarWithAop_xml"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/132591/pre-fix/testresults.xml" passing="1825" size="2015"/>
<post-fix-testcases failing="193" file="output/132591/post-fix/testresults.xml" passing="1823" size="2016"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.104" state="changed">134a135
&gt; 	private boolean ignoreOutxml;
497a499,506
&gt; 		if (filename.equals(buildConfig.getOutxmlName())) {
&gt; 			ignoreOutxml = true;
&gt; 			IMessage msg = new Message("-outxml/-outxmlfile option ignored because resource already exists: '" + filename + "'",
&gt; 					   IMessage.WARNING,
&gt; 					   null,
&gt; 					   new SourceLocation(srcLocation,0));
&gt; 			handler.handleMessage(msg);
&gt; 		}
557a567,568
&gt; 		if (ignoreOutxml) return;
&gt; 		
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java" revision="1.11" state="changed">123,129d122
&lt; 		File srcBase = new File(getProjectSourcePath());
&lt; 		File[] fromResources = FileUtil.listFiles(srcBase, new FileFilter() {
&lt; 			public boolean accept(File pathname) {
&lt; 				String name = pathname.getName().toLowerCase();
&lt; 				return !name.endsWith(".class") &amp;&amp; !name.endsWith(".java") &amp;&amp; !name.endsWith(".aj");
&lt; 			}
&lt; 		});
131,133d123
&lt; 		for (int i = 0; i &lt; fromResources.length; i++) {
&lt; 			String normPath = FileUtil.normalizedPath(fromResources[i] ,srcBase);
&lt; 			map.put(normPath, fromResources[i]);
134a125,146
&gt; 		/* Allow the user to override the testProjectPath by using sourceRoots */ 
&gt; 		File[] srcBase;
&gt; 		if (sourceRoots == null || sourceRoots.isEmpty()) {
&gt; 			srcBase = new File[] { new File(getProjectSourcePath()) };
&gt; 		}
&gt; 		else {
&gt; 			srcBase = new File[sourceRoots.size()];
&gt; 			sourceRoots.toArray(srcBase);
&gt; 		}
&gt; 		
&gt; 		for (int j = 0; j &lt; srcBase.length; j++) {
&gt; 			File[] fromResources = FileUtil.listFiles(srcBase[j], new FileFilter() {
&gt; 				public boolean accept(File pathname) {
&gt; 					String name = pathname.getName().toLowerCase();
&gt; 					return !name.endsWith(".class") &amp;&amp; !name.endsWith(".java") &amp;&amp; !name.endsWith(".aj");
&gt; 				}
&gt; 			});
&gt; 			for (int i = 0; i &lt; fromResources.length; i++) {
&gt; 				String normPath = FileUtil.normalizedPath(fromResources[i] ,srcBase[j]);
&gt; 				map.put(normPath, fromResources[i]);
&gt; 
&gt; 			}
135a148
&gt; 		
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/OutxmlTest.java" revision="1.5" state="changed">15a16,18
&gt; import java.util.HashSet;
&gt; import java.util.List;
&gt; import java.util.Set;
105a109,132
&gt; 	/**
&gt; 	 * Aim: Test "-outxml" option produces a warning if "META-INF/aop.xml 
&gt; 	 * already exists in source
&gt; 	 * 
&gt; 	 */
&gt; 	public void testOutxmlToOutjarWithAop_xml () {
&gt; 		File f = new File( AjdeTests.testDataPath(PROJECT_DIR + "/src-resources"));
&gt; 		Set roots = new HashSet();
&gt; 		roots.add(f);
&gt; 		ideManager.getProjectProperties().setSourceRoots(roots);
&gt; 		File outjar = openFile(OUTJAR_NAME);
&gt; 		ideManager.getProjectProperties().setOutJar(outjar.getAbsolutePath());
&gt; 		assertTrue("Build failed: " + ideManager.getCompilationSourceLineTasks(),doSynchronousBuild("outxml-to-outjar-with-aop_xml.lst"));
&gt; //		assertTrue("Build warnings: " + ideManager.getCompilationSourceLineTasks(),ideManager.getCompilationSourceLineTasks().isEmpty());
&gt; 		assertFalse("Build warnings for exisiting resource expected",ideManager.getCompilationSourceLineTasks().isEmpty());
&gt; 		List msgs = NullIdeManager.getIdeManager().getCompilationSourceLineTasks();
&gt; 		String msg = ((NullIdeTaskListManager.SourceLineTask)msgs.get(0)).message.getMessage();
&gt; 		assertTrue("Wrong message: " + msg,msg.startsWith("-outxml/-outxmlfile option ignored because resource already exists:"));
&gt; 		
&gt; 		File aopxml = openFile(BIN_DIR + "/" + DEFAULT_AOPXML_NAME);
&gt; 		assertFalse(DEFAULT_AOPXML_NAME + " should not exisit",aopxml.exists());
&gt; 		assertJarContainsEntry(outjar,DEFAULT_AOPXML_NAME);
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/ajde/testdata/OutxmlTest/outxml-to-outjar-with-aop_xml.lst" revision="1.1" state="new">-outxml
</file>
<file name="org.aspectj/modules/ajde/testdata/OutxmlTest/src-resources/META-INF/aop.xml" revision="1.1" state="new">&lt;aspectj&gt;
&lt;/aspectj&gt;</file>
</fixedFiles>
</bug>
<bug id="132926" transactionid="69078">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="9"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="14"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-for K-if K-null K-return M O-&lt; O-== O-! O-++ O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>Just upgraded to latest AJDT (Version: 1.3.1, Build id: 20060322082516
AspectJ version: 1.5.1.20060320075953)
and the compiler crashed while rebulding the project (which used to work fine 
using using the March 16th version). Retrying with 'clean' build produced the
same crash.

java.lang.NullPointerException
at org.aspectj.weaver.AnnotationX.ensureAtTargetInitialized(AnnotationX.java:158)
at org.aspectj.weaver.AnnotationX.specifiesTarget(AnnotationX.java:98)
at org.aspectj.weaver.bcel.BcelWeaver.verifyTargetIsOK(BcelWeaver.java:1450)
at org.aspectj.weaver.bcel.BcelWeaver.applyDeclareAtType(BcelWeaver.java:1417)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1366)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1223)
at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1211)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1058)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:241)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</bugreport>
<testsforfix ID="132926" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testDeca"/>
      <test NAME="testCrashingWithASM_pr132926_1"/>
      <test NAME="testCrashingWithASM_pr132926_2"/>
      <test NAME="testCrashingWithASM_pr132926_3"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="crashing on annotation type resolving with asm - 1"/>
      <test NAME="crashing on annotation type resolving with asm - 2"/>
      <test NAME="crashing on annotation type resolving with asm - 3"/>
      <test NAME="doubly annotating a method with declare"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/132926/pre-fix/testresults.xml" passing="1813" size="2003"/>
<post-fix-testcases failing="188" file="output/132926/post-fix/testresults.xml" passing="1815" size="2003"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AnnotationX.java" revision="1.5" state="changed">157,165c157
&lt;   			supportedTargets = new HashSet();
&lt;   			List values = atTargetAnnotation.getBcelAnnotation().getValues();
&lt;   		  	ElementNameValuePair envp = (ElementNameValuePair)values.get(0);
&lt;   		  	ArrayElementValue aev = (ArrayElementValue)envp.getValue();
&lt;   		  	ElementValue[] evs = aev.getElementValuesArray();
&lt;   		  	for (int i = 0; i &lt; evs.length; i++) {
&lt;   				EnumElementValue ev = (EnumElementValue)evs[i];
&lt;   				supportedTargets.add(ev.getEnumValueString());
&lt;   			}
---
&gt;   			supportedTargets = atTargetAnnotation.getTargets();
168a161,189
&gt;   
&gt;   /**
&gt;    * For the @Target annotation, this will return a set of the elementtypes it can be applied to.
&gt;    * For non @Target annotations, it returns null.
&gt;    */
&gt;   public Set /* of String */ getTargets() {
&gt; 	  if (!signature.equals(UnresolvedType.AT_TARGET)) return null;
&gt; 	  Set supportedTargets = new HashSet();
&gt; 	  if (mode==MODE_BCEL) {
&gt; 	    List values = getBcelAnnotation().getValues();
&gt; 	  	ElementNameValuePair envp = (ElementNameValuePair)values.get(0);
&gt; 	  	ArrayElementValue aev = (ArrayElementValue)envp.getValue();
&gt; 	  	ElementValue[] evs = aev.getElementValuesArray();
&gt; 	  	for (int i = 0; i &lt; evs.length; i++) {
&gt; 			EnumElementValue ev = (EnumElementValue)evs[i];
&gt; 			supportedTargets.add(ev.getEnumValueString());
&gt; 		}
&gt; 	  } else {
&gt; 		  List values = theRealASMAnnotation.getNameValuePairs();
&gt; 		  AnnotationNameValuePair nvp = (AnnotationNameValuePair)values.get(0);
&gt; 		  ArrayAnnotationValue aav = (ArrayAnnotationValue)nvp.getValue();
&gt; 		  AnnotationValue[] avs = aav.getValues();
&gt; 		  for (int i = 0; i &lt; avs.length; i++) {
&gt; 			AnnotationValue value = avs[i];
&gt; 			supportedTargets.add(value.stringify());
&gt; 		  }
&gt; 	  }
&gt; 	  return supportedTargets;
&gt;   }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.31" state="changed">4a5,20
&gt; 
&gt;     &lt;ajc-test dir="bugs151/pr132926" pr="132926" title="crashing on annotation type resolving with asm - 1"&gt;
&gt;      &lt;compile files="InputAnnotation.java,AffectedType.java" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs151/pr132926" pr="132926" title="crashing on annotation type resolving with asm - 2"&gt;
&gt;      &lt;compile files="InputAnnotation.java" outjar="foo.jar" options="-1.5"/&gt;
&gt;      &lt;compile files="AffectedType.java" classpath="foo.jar" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs151/pr132926" pr="132926" title="crashing on annotation type resolving with asm - 3"&gt;
&gt;      &lt;compile files="InputAnnotation2.java" outjar="foo.jar" options="-1.5"/&gt;
&gt;      &lt;compile files="AffectedType.java" classpath="foo.jar" options="-1.5"&gt;
&gt;      	&lt;message kind="error" line="9" text="AffectedType is not a valid target for annotation InputAnnotation, this annotation can only be applied to these element types {METHOD}"/&gt;
&gt;      &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
10a27,37
&gt;     &lt;ajc-test dir="bugs151/Deca" title="doubly annotating a method with declare"&gt;
&gt;       &lt;compile files="DecA.java" options="-1.5"/&gt;
&gt;       &lt;run class="DecA"&gt;
&gt;         &lt;stderr&gt;
&gt;           &lt;line text="There are 2 annotations on public void m()"/&gt;
&gt;           &lt;line text="1) @One()"/&gt;
&gt;           &lt;line text="2) @Two()"/&gt;
&gt;         &lt;/stderr&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.33" state="changed">27a28,33
&gt; 	// reported on the list...
&gt; //  public void testDeca() { runTest("doubly annotating a method with declare");}
&gt; 	
&gt;   public void testCrashingWithASM_pr132926_1() { runTest("crashing on annotation type resolving with asm - 1");}
&gt;   public void testCrashingWithASM_pr132926_2() { runTest("crashing on annotation type resolving with asm - 2");}
&gt;   public void testCrashingWithASM_pr132926_3() { runTest("crashing on annotation type resolving with asm - 3");}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr132926/InputAnnotation2.java" revision="1.1" state="new">import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface InputAnnotation {}
</file>
<file name="org.aspectj/modules/tests/bugs151/Deca/DecA.java" revision="1.1" state="new">import java.lang.annotation.Annotation;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Method;
import java.util.Iterator;

@Retention(RetentionPolicy.RUNTIME)
@interface One {}

@Retention(RetentionPolicy.RUNTIME)
@interface Two {}

class Target {
  public void m() {}
}

aspect X {
  declare @method: * Target.*(..): @One;
  declare @method: * Target.*(..): @Two;
}

public class DecA {
  public static void main(String []argv) {
	  try {
		  Class c = Target.class;
		  Method m = c.getDeclaredMethod("m",null);
		  Annotation[] anns =  m.getAnnotations();
		  System.err.println("There are "+anns.length+" annotations on public void m():");
		  for (int i = 0; i &lt; anns.length; i++) {
			System.err.println((i+1)+") "+anns[i]);
		  }
	  } catch (Exception e) {
		  e.printStackTrace();
	  }
  }
}</file>
<file name="org.aspectj/modules/tests/bugs151/pr132926/InputAnnotation.java" revision="1.1" state="new">import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface InputAnnotation {}
</file>
<file name="org.aspectj/modules/tests/bugs151/pr132926/AffectedType.java" revision="1.1" state="new">public class AffectedType {

	public static void main(String[] args) {
		
	}
}

aspect X {
	declare @type: AffectedType: @InputAnnotation;
}</file>
</fixedFiles>
</bug>
<bug id="133117" transactionid="68981">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="9"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-import K-new K-true M O-! O-() O-cast T V Y Z-cast Z-if</fullfingerprint>
<bugreport>When the noGuardForLazyTjp compiler option is set to warning or error and a piece of advice causes this warning to show up, you get one warning for every join point matched by the advice.  I think just one would probably be enough...</bugreport>
<testsforfix ID="133117" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr133117"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/133117/pre-fix/testresults.xml" passing="1828" size="2015"/>
<post-fix-testcases failing="190" file="output/133117/post-fix/testresults.xml" passing="1825" size="2015"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/Lint.java" revision="1.34" state="changed">103c103
&lt; 		new Kind("noGuardForLazyTjp","can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at {0}");
---
&gt; 		new Kind("noGuardForLazyTjp","can not build thisJoinPoint lazily for this advice since it has no suitable guard");
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java" revision="1.45" state="changed">26d25
&lt; import org.aspectj.bridge.ISourceLocation;
58a58
&gt;     private boolean hasReportedNoGuardForLazyTJP = false;
159c159
&lt; 			if (!isAround &amp;&amp; !hasGuardTest &amp;&amp; world.getLint().noGuardForLazyTjp.isEnabled()) {
---
&gt; 			if (!hasReportedNoGuardForLazyTJP &amp;&amp; !isAround &amp;&amp; !hasGuardTest &amp;&amp; world.getLint().noGuardForLazyTjp.isEnabled()) {
160a161
&gt; 				// ... only want to record it once against the advice(bug 133117)
162,165c163,166
&lt; 					    new String[] {shadow.toString()},
&lt; 					    getSourceLocation(),
&lt; 					    new ISourceLocation[] { ((BcelShadow)shadow).getSourceLocation() }
&lt; 					);				
---
&gt; 						"",
&gt; 					    getSourceLocation()
&gt; 				);	
&gt; 				hasReportedNoGuardForLazyTJP = true;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.51" state="changed">887a888,909
&gt; 
&gt; 	public void testPr133117() {
&gt; 		configureNonStandardCompileOptions("-Xlint:warning");
&gt; 		initialiseProject("PR133117");
&gt; 		build("PR133117");
&gt; 		assertTrue("There should only be one xlint warning message reported:\n"
&gt; 				+MyTaskListManager.getWarningMessages(),
&gt; 				MyTaskListManager.getWarningMessages().size()==1);	
&gt; 		alter("PR133117","inc1");
&gt; 		build("PR133117");
&gt; 		List warnings = MyTaskListManager.getWarningMessages();
&gt; 		List noGuardWarnings = new ArrayList();
&gt; 		for (Iterator iter = warnings.iterator(); iter.hasNext();) {
&gt; 			IMessage element = (IMessage) iter.next();
&gt; 			if (element.getMessage().indexOf("Xlint:noGuardForLazyTjp") != -1) {
&gt; 				noGuardWarnings.add(element);
&gt; 			}
&gt; 		}
&gt; 		assertTrue("There should only be two Xlint:noGuardForLazyTjp warning message reported:\n"
&gt; 				+noGuardWarnings,noGuardWarnings.size() == 2);
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/xlint/xlint-tests.xml" revision="1.6" state="changed">21c21
&lt; 		  &lt;message kind="warning" line="14" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(void Test.main(java.lang.String[])) [Xlint:noGuardForLazyTjp]"/&gt;
---
&gt; 			&lt;message kind="warning" line="14" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard [Xlint:noGuardForLazyTjp]"/&gt;
27c27
&lt; 			&lt;message kind="warning" line="9" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(void Test.main(java.lang.String[]))"/&gt;
---
&gt; 			&lt;message kind="warning" line="9" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard"/&gt;
55c55
&lt; 		  &lt;message kind="warning" line="16" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(void LazyTjpTest2.test2())"/&gt;
---
&gt; 		  &lt;message kind="warning" line="16" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard"/&gt;
62c62
&lt; 		  &lt;message kind="warning" line="17" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(void LazyTjpTest3.test2())"/&gt;
---
&gt; 		  &lt;message kind="warning" line="17" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard"/&gt;
69c69
&lt; 		  &lt;message kind="warning" line="13" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(void LazyTjpTest4.test1())"/&gt;
---
&gt; 		  &lt;message kind="warning" line="13" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard"/&gt;
71c71
&lt; 		  &lt;message kind="warning" line="17" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(void LazyTjpTest4.test1())"/&gt;
---
&gt; 		  &lt;message kind="warning" line="17" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard"/&gt;
79c79
&lt; 		  &lt;message kind="warning" line="13" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(void LazyTjpTest5.test1())"/&gt;
---
&gt; 		  &lt;message kind="warning" line="13" text="can not build thisJoinPoint lazily for this advice since it has no suitable guard"/&gt;
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR133117/base/Tracing.aj" revision="1.1" state="new">public aspect Tracing {

    pointcut publicMethods() : execution(public * *(..));

    before() : publicMethods() {
        System.out.println("Entering "+thisJoinPoint);
    }

}

class MainClass {

	
	public static void main(String[] args) {
		
	}
	
	public String toString() {
		return super.toString();
	}
	
	
	public int hashCode() {
		return super.hashCode();
	}
	
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR133117/inc1/Tracing.aj" revision="1.1" state="new">public aspect Tracing {

    pointcut publicMethods() : execution(public * *(..));

    before() : publicMethods() {
        System.out.println("Entering "+thisJoinPoint);
    }
    
    after() : publicMethods() {
    	System.out.println("Exiting " + thisJoinPoint);
    }
}

class MainClass {

	
	public static void main(String[] args) {
		
	}
	
	public String toString() {
		return super.toString();
	}
	
	
	public int hashCode() {
		return super.hashCode();
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="133307" transactionid="69742">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="15"/>
<property name="lines-added" value="90"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="38"/>
<property name="lines-churned" value="130"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-class K-false K-for K-if K-import K-interface K-new K-null K-package K-return K-this K-true M O-== O-! O-+ O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>I have the following construct:

public interface TestIF&lt;T extends TestIF&gt; {}

public class TestClass {}

public aspect TestAspect {

    declare parents: TestClass implements TestIF&lt;TestClass&gt;; 

}



The later aspect does not compile, although 

public class TestClass implements TestIF&lt;TestClass&gt; {

}
is a valid class.</bugreport>
<testsforfix ID="133307" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java">
      <test NAME="testCircularGenerics_pr133307"/>
      <test NAME="testDeca"/>
      <test NAME="testDeca2"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml">
      <test NAME="circular generics"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/133307/pre-fix/testresults.xml" passing="1816" size="2003"/>
<post-fix-testcases failing="117" file="output/133307/post-fix/testresults.xml" passing="992" size="1109"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java" revision="1.19" state="changed">25a26
&gt; import org.aspectj.weaver.patterns.IVerificationRequired;
47a49,50
&gt; 
&gt; 	private List /*IVerificationRequired*/ verificationList = null; // List of things to be verified once the type system is 'complete'
263a267
&gt; 		verificationList=null;
269a274,283
&gt; 
&gt; 	/**
&gt; 	 * Record something that needs verifying when we believe the type system is complete.
&gt; 	 * Used for things that can't be verified as we go along - for example some
&gt; 	 * recursive type variable references (pr133307)
&gt; 	 */
&gt; 	public void recordNecessaryCheck(IVerificationRequired verification) {
&gt; 		if (verificationList==null) verificationList = new ArrayList();
&gt; 		verificationList.add(verification);
&gt; 	}
271a286,298
&gt; 	/**
&gt; 	 * Called when type bindings are complete - calls all registered verification
&gt; 	 * objects in turn.
&gt; 	 */
&gt; 	public void verify() {
&gt; 		if (verificationList==null) return;
&gt; 		for (Iterator iter = verificationList.iterator(); iter.hasNext();) {
&gt; 			IVerificationRequired element = (IVerificationRequired) iter.next();
&gt; 			element.verify();
&gt; 		}
&gt; 		verificationList = null;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java" revision="1.65" state="changed">23a24
&gt; import org.aspectj.bridge.ISourceLocation;
928d928
&lt; 		return checkBoundsOK(scope,genericType,requireExactType);
930c930,939
&lt; 		// return true;
---
&gt; 		// pr133307 - delay verification until type binding completion, these next few lines replace
&gt; 		// the call to checkBoundsOK
&gt; 		if (!boundscheckingoff) {
&gt; 			VerifyBoundsForTypePattern verification = 
&gt; 				new VerifyBoundsForTypePattern(scope,genericType,requireExactType,typeParameters,getSourceLocation());
&gt; 			scope.getWorld().getCrosscuttingMembersSet().recordNecessaryCheck(verification);
&gt; 		}
&gt; //		return checkBoundsOK(scope,genericType,requireExactType);
&gt; 		
&gt; 		 return true;
933,962c942,996
&lt; 	public boolean checkBoundsOK(IScope scope,ResolvedType genericType,boolean requireExactType) {
&lt; 		if (boundscheckingoff) return true;
&lt; 		TypeVariable[] tvs = genericType.getTypeVariables();
&lt; 		TypePattern[] typeParamPatterns = typeParameters.getTypePatterns();
&lt; 		if (typeParameters.areAllExactWithNoSubtypesAllowed()) {
&lt; 			for (int i = 0; i &lt; tvs.length; i++) {
&lt; 				UnresolvedType ut = typeParamPatterns[i].getExactType();
&lt; 				boolean continueCheck = true;
&lt; 				// FIXME asc dont like this but ok temporary measure.  If the type parameter 
&lt; 				// is itself a type variable (from the generic aspect) then assume it'll be
&lt; 				// ok... (see pr112105)  Want to break this? Run GenericAspectK test.
&lt; 				if (ut.isTypeVariableReference()) {
&lt; 					continueCheck = false;
&lt; 				}
&lt; 				
&lt; 				if (continueCheck &amp;&amp;	
&lt; 						!tvs[i].canBeBoundTo(ut.resolve(scope.getWorld()))) {
&lt; 					// issue message that type parameter does not meet specification
&lt; 					String parameterName = ut.getName();
&lt; 					if (ut.isTypeVariableReference()) parameterName = ((TypeVariableReference)ut).getTypeVariable().getDisplayName();
&lt; 					String msg = 
&lt; 						WeaverMessages.format(
&lt; 							WeaverMessages.VIOLATES_TYPE_VARIABLE_BOUNDS,
&lt; 							parameterName,
&lt; 							new Integer(i+1),
&lt; 							tvs[i].getDisplayName(),
&lt; 							genericType.getName());
&lt; 					if (requireExactType)  scope.message(MessageUtil.error(msg,getSourceLocation()));	
&lt; 					else				   scope.message(MessageUtil.warn(msg,getSourceLocation()));	
&lt; 					return false;
---
&gt; 	/**
&gt; 	 * By capturing the verification in this class, rather than performing it in verifyTypeParameters(),
&gt; 	 * we can cope with situations where the interactions between generics and declare parents would
&gt; 	 * otherwise cause us problems.  For example, if verifying as we go along we may report a problem
&gt; 	 * which would have been fixed by a declare parents that we haven't looked at yet.  If we
&gt; 	 * create and store a verification object, we can verify this later when the type system is
&gt; 	 * considered 'complete'
&gt; 	 */
&gt; 	static class VerifyBoundsForTypePattern implements IVerificationRequired {
&gt; 		
&gt; 		private IScope scope;
&gt; 		private ResolvedType genericType;
&gt; 		private boolean requireExactType;
&gt; 		private TypePatternList typeParameters = TypePatternList.EMPTY;
&gt; 		private ISourceLocation sLoc;
&gt; 		
&gt; 		public VerifyBoundsForTypePattern(IScope scope, ResolvedType genericType, boolean requireExactType,
&gt; 				TypePatternList typeParameters, ISourceLocation sLoc) {
&gt; 			this.scope = scope;
&gt; 			this.genericType = genericType;
&gt; 			this.requireExactType = requireExactType;
&gt; 			this.typeParameters = typeParameters;
&gt; 			this.sLoc = sLoc;
&gt; 		}
&gt; 		
&gt; 		public void verify() {
&gt; 			TypeVariable[] tvs = genericType.getTypeVariables();
&gt; 			TypePattern[] typeParamPatterns = typeParameters.getTypePatterns();
&gt; 			if (typeParameters.areAllExactWithNoSubtypesAllowed()) {
&gt; 				for (int i = 0; i &lt; tvs.length; i++) {
&gt; 					UnresolvedType ut = typeParamPatterns[i].getExactType();
&gt; 					boolean continueCheck = true;
&gt; 					// FIXME asc dont like this but ok temporary measure.  If the type parameter 
&gt; 					// is itself a type variable (from the generic aspect) then assume it'll be
&gt; 					// ok... (see pr112105)  Want to break this? Run GenericAspectK test.
&gt; 					if (ut.isTypeVariableReference()) {
&gt; 						continueCheck = false;
&gt; 					}
&gt; 					
&gt; 					System.err.println("Verifying "+ut.getName()+" meets bounds for "+tvs[i]);
&gt; 					if (continueCheck &amp;&amp;	
&gt; 							!tvs[i].canBeBoundTo(ut.resolve(scope.getWorld()))) {
&gt; 						// issue message that type parameter does not meet specification
&gt; 						String parameterName = ut.getName();
&gt; 						if (ut.isTypeVariableReference()) parameterName = ((TypeVariableReference)ut).getTypeVariable().getDisplayName();
&gt; 						String msg = 
&gt; 							WeaverMessages.format(
&gt; 								WeaverMessages.VIOLATES_TYPE_VARIABLE_BOUNDS,
&gt; 								parameterName,
&gt; 								new Integer(i+1),
&gt; 								tvs[i].getDisplayName(),
&gt; 								genericType.getName());
&gt; 						if (requireExactType)  scope.message(MessageUtil.error(msg,sLoc));	
&gt; 						else				   scope.message(MessageUtil.warn(msg,sLoc));	
&gt; 					}
966d999
&lt; 		return true;
967a1001,1037
&gt; 
&gt; 	// pr133307 - moved to verification object
&gt; //	public boolean checkBoundsOK(IScope scope,ResolvedType genericType,boolean requireExactType) {
&gt; //		if (boundscheckingoff) return true;
&gt; //		TypeVariable[] tvs = genericType.getTypeVariables();
&gt; //		TypePattern[] typeParamPatterns = typeParameters.getTypePatterns();
&gt; //		if (typeParameters.areAllExactWithNoSubtypesAllowed()) {
&gt; //			for (int i = 0; i &lt; tvs.length; i++) {
&gt; //				UnresolvedType ut = typeParamPatterns[i].getExactType();
&gt; //				boolean continueCheck = true;
&gt; //				// FIXME asc dont like this but ok temporary measure.  If the type parameter 
&gt; //				// is itself a type variable (from the generic aspect) then assume it'll be
&gt; //				// ok... (see pr112105)  Want to break this? Run GenericAspectK test.
&gt; //				if (ut.isTypeVariableReference()) {
&gt; //					continueCheck = false;
&gt; //				}
&gt; //				
&gt; //				if (continueCheck &amp;&amp;	
&gt; //						!tvs[i].canBeBoundTo(ut.resolve(scope.getWorld()))) {
&gt; //					// issue message that type parameter does not meet specification
&gt; //					String parameterName = ut.getName();
&gt; //					if (ut.isTypeVariableReference()) parameterName = ((TypeVariableReference)ut).getTypeVariable().getDisplayName();
&gt; //					String msg = 
&gt; //						WeaverMessages.format(
&gt; //							WeaverMessages.VIOLATES_TYPE_VARIABLE_BOUNDS,
&gt; //							parameterName,
&gt; //							new Integer(i+1),
&gt; //							tvs[i].getDisplayName(),
&gt; //							genericType.getName());
&gt; //					if (requireExactType)  scope.message(MessageUtil.error(msg,getSourceLocation()));	
&gt; //					else				   scope.message(MessageUtil.warn(msg,getSourceLocation()));	
&gt; //					return false;
&gt; //				}
&gt; //			}
&gt; //		}
&gt; //		return true;
&gt; //	}
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.62" state="changed">256a257
&gt; 		factory.getWorld().getCrosscuttingMembersSet().verify();
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java" revision="1.35" state="changed">28,29c28,30
&lt; //  public void testDeca() { runTest("doubly annotating a method with declare");}	
&lt; //  public void testDeca2() { runTest("doubly annotating a method with declare - 2");}	
---
&gt;   public void testCircularGenerics_pr133307() { runTest("circular generics");}
&gt;   //  public void testDeca() { runTest("doubly annotating a method with declare");}	
&gt;   //  public void testDeca2() { runTest("doubly annotating a method with declare - 2");}	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc151/ajc151.xml" revision="1.33" state="changed">21a22,25
&gt;     &lt;ajc-test dir="bugs151/pr133307" title="circular generics"&gt;
&gt;       &lt;compile files="Broken.aj" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt;  
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ajc150.xml" revision="1.264" state="changed">4494c4494,4495
&lt;        &lt;message kind="error" line="16" text="The method m4(String) is undefined for the type Base"/&gt;
---
&gt; 	   &lt;!-- see pr133307, shame about this --&gt;
&gt;        &lt;!--message kind="error" line="16" text="The method m4(String) is undefined for the type Base"/--&gt;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/IVerificationRequired.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2006 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *     Andy Clement IBM     initial implementation 
 * ******************************************************************/
package org.aspectj.weaver.patterns;


/**
 * Implementors provide a 'verify()' method that is invoked at the end of type
 * binding completion.
 * @see WildTypePattern.VerifyBoundsForTypePattern
 */
public interface IVerificationRequired {
	public void verify();
}</file>
<file name="org.aspectj/modules/tests/bugs151/pr133307/Broken.aj" revision="1.1" state="new">interface TestIF&lt;T extends TestIF&gt; {}

class TestClass {}

aspect TestAspect {
   declare parents: TestClass implements TestIF&lt;TestClass&gt;;
}</file>
</fixedFiles>
</bug>
<bug id="134343" transactionid="73137">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-- O-!= O-() T V Y Z-if</fullfingerprint>
<bugreport>This aspect incorrectly prompted me to import the type Test when I did organize imports. Result:

//imported types follow
import junit.framework.Test;
import junit.framework.TestCase;

public aspect DefineTestTypes {
        
    declare parents: 
        glassbox.inspector..* &amp;&amp; (junit.framework.TestCase+ || *..Test* || glassbox.inspector.test..*)
        implements ITestCode;</bugreport>
<testsforfix ID="134343" type="new">
    <file LOCATION="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/codeconversion/AspectsConvertingParserTest.java">
      <test NAME="testBug134343"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="191" file="output/134343/pre-fix/testresults.xml" passing="1824" size="2015"/>
<post-fix-testcases failing="188" file="output/134343/post-fix/testresults.xml" passing="1827" size="2015"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core/src/org/eclipse/ajdt/codeconversion/AspectsConvertingParser.java" revision="1.7" state="changed">192c192,193
&lt; 						&amp;&amp; Character.isUpperCase(name[0]))
---
&gt; 						&amp;&amp; Character.isUpperCase(name[0])
&gt; 						&amp;&amp; (content[scanner.getCurrentTokenStartPosition()-1]!='.')) {
193a195
&gt; 				}
</file>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.core.tests/src/org/eclipse/ajdt/core/tests/codeconversion/AspectsConvertingParserTest.java" revision="1.5" state="changed">49a50,66
&gt; 	
&gt; 	public void testBug134343() {
&gt; 		String source = "public aspect Aspect {\n" //$NON-NLS-1$
&gt; 				+ "	   declare parents : foo.inspector..* &amp;&amp;\n" //$NON-NLS-1$
&gt; 				+ " (junit.framework.TestCase+ || *..Test*\n" //$NON-NLS-1$
&gt;     		    + " ||foo.inspector.test..*) implements Serializable;\n" //$NON-NLS-1$
&gt; 				+ "};\n"; //$NON-NLS-1$
&gt; 		ConversionOptions conversionOptions = ConversionOptions.STANDARD;
&gt; 		AspectsConvertingParser conv = new AspectsConvertingParser(source
&gt; 				.toCharArray());
&gt; 		conv.convert(conversionOptions);
&gt; 		String converted = new String(conv.content);
&gt; 		assertTrue("Parser should not have considered Test as an import", //$NON-NLS-1$
&gt; 				converted.indexOf("Test x") == -1); //$NON-NLS-1$
&gt; 		assertTrue("Parser should not have considered TestCase as an import", //$NON-NLS-1$
&gt; 				converted.indexOf("TestCase x") == -1); //$NON-NLS-1$
&gt; 	}
</file>
</fixedFiles>
</bug>
<bug id="134541" transactionid="69215">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="10"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="11"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null T V Z-if</fullfingerprint>
<bugreport>When advice doesn't match in a 1.5.0 enabled project, there is an adviceDidNotMatch warning against the line number of the advice. If you insert a line before this advice and save then the warning stays associated with the original line and not the new one. Full building puts the warning against the new line. 

This is a regression and didn't happen in AJ 1.5.0.</bugreport>
<testsforfix ID="134541" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr134541"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="196" file="output/134541/pre-fix/testresults.xml" passing="1808" size="2004"/>
<post-fix-testcases failing="188" file="output/134541/post-fix/testresults.xml" passing="1816" size="2004"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java" revision="1.20" state="changed">78a79,83
&gt; 				if (careAboutShadowMungers) {
&gt; 					// bug 134541 - even though we haven't changed we may have updated the 
&gt; 					// sourcelocation for the shadowMunger which we need to pick up
&gt; 					shadowMungers = null;
&gt; 				}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembers.java" revision="1.26" state="changed">241d240
&lt; 				shadowMungers = other.shadowMungers;
242a242,246
&gt; 			// replace the existing list of shadowmungers with the 
&gt; 			// new ones in case anything like the sourcelocation has
&gt; 			// changed, however, don't want this flagged as a change
&gt; 			// which will force a full build - bug 134541
&gt; 			shadowMungers = other.shadowMungers;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.44" state="changed">848a849,862
&gt; 	public void testPr134541() {
&gt; 		initialiseProject("PR134541");
&gt; 		build("PR134541");
&gt; 		assertEquals("[Xlint:adviceDidNotMatch] should be associated with line 5",5,
&gt; 				((IMessage)MyTaskListManager.getWarningMessages().get(0)).getSourceLocation().getLine());
&gt; 		alter("PR134541","inc1");
&gt; 		build("PR134541");
&gt; 		checkWasntFullBuild(); // we've only added a white space therefore we 
&gt; 		                       // shouldn't be doing a full build
&gt; 		assertEquals("[Xlint:adviceDidNotMatch] should now be associated with line 7",7,
&gt; 				((IMessage)MyTaskListManager.getWarningMessages().get(0)).getSourceLocation().getLine());
&gt; 	}
&gt; 	
&gt; 	
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR134541/inc1/A.aj" revision="1.1" state="new">public aspect A {
	
	pointcut p() : execution(* *.*(..));
	
	
	
	before() : p() {
	}
	
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR134541/base/A.aj" revision="1.1" state="new">public aspect A {
	
	pointcut p() : execution(* *.*(..));
	
	before() : p() {
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="135001" transactionid="69820">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="24"/>
<property name="lines-churned" value="28"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-import K-null K-return K-true M O-== O-&amp;&amp; T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:2109)
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:232)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:639)
at org.aspectj.weaver.Shadow.implement(Shadow.java:456)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</bugreport>
<testsforfix ID="135001" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testAspectLibrariesAndASM_pr135001"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="aspect libraries and asm"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/135001/pre-fix/testresults.xml" passing="1817" size="2004"/>
<post-fix-testcases failing="190" file="output/135001/post-fix/testresults.xml" passing="1814" size="2004"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWorld.java" revision="1.43" state="changed">247,248c247,251
&lt;     }       
&lt; 
---
&gt;     } 
&gt;     
&gt;     // SECRETAPI: used for testing ASM loading of delegates...
&gt;     public boolean fallbackToLoadingBcelDelegatesForAspects = true;
&gt;     
291c294,309
&lt; 	        	return buildAsmDelegate(ty,cf);
---
&gt; 	        	ReferenceTypeDelegate delegate =  buildAsmDelegate(ty,cf);
&gt; 	        	if (fallbackToLoadingBcelDelegatesForAspects &amp;&amp; delegate.isAspect()) {
&gt; 	        		// bugger - pr135001 - we can't inline around advice from an aspect because we don't load the instructions.
&gt; 	        		// fixing this quick to get AJDT upgraded with a good 1.5.2dev build.
&gt; 	        		// other fixes would be:
&gt; 	        		// 1. record that we are loading the superclass for an aspect, so we know to make it a BCEL delegate
&gt; 	        		//
&gt; 	        		// the 'fix' here is only reasonable because there are many less aspects than classes!
&gt; 	        		
&gt; 	        		// Create a BCEL delegate
&gt; 	        		if (jc == null) jc = lookupJavaClass(classPath, name);
&gt; 	    	        if (jc == null) return delegate; // worrying situation ?!?
&gt; 	    	        else            return buildBcelDelegate(ty, jc, false);
&gt; 	        	} else {
&gt; 	        		return delegate;
&gt; 	        	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.95" state="changed">57a58
&gt; import org.aspectj.bridge.MessageUtil;
2107,2108c2108,2115
&lt;         BcelObjectType ot = BcelWorld.getBcelObjectType((declaringType.isParameterizedType()?declaringType.getGenericType():declaringType)); 
&lt;         
---
&gt;         ResolvedType rt = (declaringType.isParameterizedType()?declaringType.getGenericType():declaringType);
&gt;         BcelObjectType ot = BcelWorld.getBcelObjectType(rt); 
&gt; //        if (ot==null) {
&gt; //        	world.getMessageHandler().handleMessage(
&gt; //        	  MessageUtil.warn("Unable to find modifiable delegate for the aspect '"+rt.getName()+"' containing around advice - cannot implement inlining",munger.getSourceLocation()));
&gt; //        	weaveAroundClosure(munger, hasDynamicTest);
&gt; //			return;
&gt; //        }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
package org.aspectj.systemtest.ajc152;

import java.io.File;
import junit.framework.Test;

import org.aspectj.testing.XMLBasedAjcTestCase;

public class Ajc152Tests extends org.aspectj.testing.XMLBasedAjcTestCase {
  public void testAspectLibrariesAndASM_pr135001() { runTest("aspect libraries and asm");}
  
  
  /////////////////////////////////////////
  public static Test suite() {
    return XMLBasedAjcTestCase.loadSuite(Ajc152Tests.class);
  }

  protected File getSpecFile() {
    return new File("../tests/src/org/aspectj/systemtest/ajc152/ajc152.xml");
  }

  
}</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/AllTestsAspectJ152.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
package org.aspectj.systemtest.ajc152;

import junit.framework.Test;
import junit.framework.TestSuite;

public class AllTestsAspectJ152 {

	public static Test suite() {
		TestSuite suite = new TestSuite("AspectJ 1.5.2 tests");
		//$JUnit-BEGIN$
		suite.addTest(Ajc152Tests.suite());
        //$JUnit-END$
		return suite;
	}
}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.1" state="new">&lt;!DOCTYPE suite SYSTEM "../tests/ajcTestSuite.dtd"[]&gt;

&lt;!-- AspectJ v1.5.2 Tests --&gt;
&lt;suite&gt;

    &lt;ajc-test dir="bugs152/pr135001" title="aspect libraries and asm"&gt;
      &lt;compile files="AbstractAspect.java" outjar="lib.jar" options="-1.5"/&gt;
      &lt;compile files="Foo.java,ConcreteAspect.java" classpath="lib.jar" options="-1.5 -showWeaveInfo"&gt;
        &lt;message kind="weave" text="Join point 'method-call(void Foo.foo())' in Type 'Foo' (Foo.java:3) advised by around advice from 'ConcreteAspect' (AbstractAspect.java:5)"/&gt;
      &lt;/compile&gt;
      &lt;run class="Foo"&gt;
         &lt;stderr&gt;
           &lt;line text="In the advice!"/&gt;
         &lt;/stderr&gt;
      &lt;/run&gt;
    &lt;/ajc-test&gt;
    
&lt;/suite&gt;</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java" revision="1.2" state="changed">59a60
&gt;         world.fallbackToLoadingBcelDelegatesForAspects = false;
61a63
&gt;     	
395c397,398
&lt;     	BcelWorld slowWorld = new BcelWorld(BcweaverTests.TESTDATA_PATH+"/forAsmDelegateTesting/stuff.jar");slowWorld.setFastDelegateSupport(false);
---
&gt;     	BcelWorld slowWorld = new BcelWorld(BcweaverTests.TESTDATA_PATH+"/forAsmDelegateTesting/stuff.jar");
&gt;     	slowWorld.setFastDelegateSupport(false);
396a400
&gt;         fastWorld.fallbackToLoadingBcelDelegatesForAspects = false;
419c423,424
&lt;         
---
&gt;         fastWorld.fallbackToLoadingBcelDelegatesForAspects = false;
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/AllTests15.java" revision="1.5" state="changed">11a12
&gt; import org.aspectj.systemtest.ajc152.AllTestsAspectJ152;
20a22
&gt; 		suite.addTest(AllTestsAspectJ152.suite());
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135001/AbstractAspect.java" revision="1.1" state="new">public abstract aspect AbstractAspect {
	
	abstract pointcut scope();
	
	void around(): scope() {
		System.err.println("In the advice!");
		proceed();
	}
}</file>
<file name="org.aspectj/modules/tests/bugs152/pr135001/Foo.java" revision="1.1" state="new">public class Foo {
	public static void main(String[] args) {
		new Foo().foo();
	}
	
	public void foo() {
		
	}
}</file>
<file name="org.aspectj/modules/tests/bugs152/pr135001/ConcreteAspect.java" revision="1.1" state="new">public aspect ConcreteAspect extends AbstractAspect {
	pointcut scope(): call(* foo(..));
}</file>
</fixedFiles>
</bug>
<bug id="135068" transactionid="70226">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="21"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="21"/>
<property name="priority" value="P2"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-noop M O-&amp;&amp; O-+ T V Y Z-if</fullfingerprint>
<bugreport>I get "VerifyError: Incompatible object argument for function call" error when using LTW with @Aspect stype aspects. Interestingly enough, LTW works as expected with equivalent .aj style aspect. Compile time weaving works with both aspect styles. Tested on Linux with AspectJ 1.5.0, 1.5.1 and DEVELOPMENT-20060404163823 and SUN 1.5.0_06 and IBM 1.5.0SR1 JVMs. I will attach example project shortly.</bugreport>
<testsforfix ID="135068" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testVerifyErrorLTW_pr135068"/>
      <test NAME="testVerifyErrorLTW_pr135068_2"/>
      <test NAME="testVerifyErrorLTW_pr135068_3"/>
      <test NAME="testVerifyErrorLTW_pr135068_4"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="ltw verifyerror"/>
      <test NAME="ltw verifyerror - 2"/>
      <test NAME="ltw verifyerror - 3"/>
      <test NAME="ltw verifyerror - 4"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="75" file="output/135068/pre-fix/testresults.xml" passing="875" size="950"/>
<post-fix-testcases failing="188" file="output/135068/post-fix/testresults.xml" passing="1827" size="2015"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java" revision="1.38" state="changed">42a43
&gt; import org.aspectj.bridge.MessageUtil;
437a439,452
&gt;         
&gt;         // semantic check - advice must not be static
&gt;         if (hasAtAspectJAnnotation &amp;&amp; struct.method.isStatic()) {
&gt;             msgHandler.handleMessage(MessageUtil.error("Advice cannot be declared static '" + methodToString(struct.method) + "'",type.getSourceLocation()));
&gt; //                    new Message(
&gt; //                            "Advice cannot be declared static '" + methodToString(struct.method) + "'",
&gt; //                            IMessage.ERROR,
&gt; //                            null,
&gt; //                            type.getSourceLocation()
&gt; //                    )
&gt; //            );
&gt;             ;// go ahead
&gt;         }
&gt;         
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java" revision="1.19" state="changed">284a285
&gt; 	 * 6) Advice must not be static
297a299,303
&gt; 
&gt; 		if (Modifier.isStatic(methodDeclaration.modifiers)) {
&gt; 			methodDeclaration.scope.problemReporter()
&gt; 				.signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,"advice can not be declared static");
&gt; 		}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.18" state="changed">274a275,301
&gt; 	
&gt; 	&lt;ajc-test dir="bugs152/pr135068" title="ltw verifyerror"&gt;
&gt; 	    &lt;compile files="C.java,Ajava.java" options="-1.5 -XnoInline"/&gt;
&gt; 	    &lt;run class="C"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     	&lt;ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 2"&gt;
&gt; 	    &lt;compile files="C2.java,Ajava2.java" options="-1.5 -XnoInline"&gt;
&gt; 	      &lt;message kind="error" line="13" text="advice can not be declared static"/&gt;
&gt; 	    &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     	&lt;ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 3"&gt;
&gt; 	    &lt;compile files="t/C.java" options="-1.5"/&gt;
&gt;         &lt;compile files="t/Ajava.java" options="-1.5"&gt;
&gt;           &lt;message kind="warning" line="13" text="advice defined"/&gt;
&gt;         &lt;/compile&gt;
&gt;         &lt;run class="t.C" ltw="aop.xml"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     	&lt;ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 4"&gt;
&gt; 	    &lt;compile files="t/C2.java" options="-1.5"/&gt;
&gt;         &lt;compile files="t/Ajava2.java" options="-1.5"&gt;
&gt; 	      &lt;message kind="error" line="13" text="advice can not be declared static"/&gt;
&gt;         &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.21" state="changed">19a20,23
&gt;   public void testVerifyErrorLTW_pr135068() { runTest("ltw verifyerror");}
&gt;   public void testVerifyErrorLTW_pr135068_2() { runTest("ltw verifyerror - 2");}
&gt;   public void testVerifyErrorLTW_pr135068_3() { runTest("ltw verifyerror - 3");}
&gt;   public void testVerifyErrorLTW_pr135068_4() { runTest("ltw verifyerror - 4");}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/t/Ajava2.java" revision="1.1" state="new">package t;

import java.net.InetAddress;
import java.net.UnknownHostException;

import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class Ajava2 {

	@Around("call(public java.net.InetAddress t.C2.getAddress() throws java.net.UnknownHostException)")
	public static InetAddress getAddress() throws UnknownHostException {
		return InetAddress.getLocalHost();
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/t/C2.java" revision="1.1" state="new">package t;

import java.net.InetAddress;
import java.net.UnknownHostException;

public class C2 {

	public InetAddress getAddress() throws UnknownHostException {
		return null;
	}
	
	private void test() throws UnknownHostException {
		System.out.println(getAddress().toString());
	}

	public static void main(String[] args) throws Exception {
		C2 c = new C2();
		c.test();
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/aop.xml" revision="1.1" state="new">&lt;aspectj&gt;
  &lt;aspects&gt;
    &lt;aspect name="t.Ajava"/&gt;
  &lt;/aspects&gt;

  &lt;weaver&gt;
    &lt;include within="t..*"/&gt;
  &lt;/weaver&gt;
&lt;/aspectj&gt;
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/Ajava.java" revision="1.1" state="new">
import java.net.InetAddress;
import java.net.UnknownHostException;

import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.*;

@Aspect
public class Ajava {

	@Around("call(public java.net.InetAddress C.getAddress() throws java.net.UnknownHostException)")
	public InetAddress getAddress() throws UnknownHostException {
		return InetAddress.getLocalHost();
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/Aaj.aj" revision="1.1" state="new">import java.net.InetAddress;

public aspect Aaj {

	InetAddress around() throws java.net.UnknownHostException : call(public java.net.InetAddress C.getAddress() throws java.net.UnknownHostException) {
		return InetAddress.getLocalHost();
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/t/C.java" revision="1.1" state="new">package t;

import java.net.InetAddress;
import java.net.UnknownHostException;

public class C {

	public InetAddress getAddress() throws UnknownHostException {
		return null;
	}
	
	private void test() throws UnknownHostException {
		System.out.println(getAddress().toString());
	}

	public static void main(String[] args) throws Exception {
		C c = new C();
		c.test();
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/t/Aaj.aj" revision="1.1" state="new">package t;

import java.net.InetAddress;

public aspect Aaj {

	InetAddress around() throws java.net.UnknownHostException : call(public java.net.InetAddress t.C.getAddress() throws java.net.UnknownHostException) {
		return InetAddress.getLocalHost();
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/t/Ajava.java" revision="1.1" state="new">package t;

import java.net.InetAddress;
import java.net.UnknownHostException;

import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class Ajava {

	@Around("call(public java.net.InetAddress t.C.getAddress() throws java.net.UnknownHostException)")
	public InetAddress getAddress() throws UnknownHostException {
		return InetAddress.getLocalHost();
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/C.java" revision="1.1" state="new">
import java.net.InetAddress;
import java.net.UnknownHostException;

public class C {

	public static InetAddress getAddress() throws UnknownHostException {
		return null;
	}
	
	public static void main(String[] args) throws Exception {
		System.out.println(getAddress().toString());
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/C2.java" revision="1.1" state="new">
import java.net.InetAddress;
import java.net.UnknownHostException;

public class C2 {

	public static InetAddress getAddress() throws UnknownHostException {
		return null;
	}
	
	public static void main(String[] args) throws Exception {
		System.out.println(getAddress().toString());
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/A.java" revision="1.1" state="new">aspect A {
  static before(): call(* *(..)) {}
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr135068/Ajava2.java" revision="1.1" state="new">
import java.net.InetAddress;
import java.net.UnknownHostException;

import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.*;

@Aspect
public class Ajava2 {

	@Around("call(public java.net.InetAddress C2.getAddress() throws java.net.UnknownHostException)")
	public static InetAddress getAddress() throws UnknownHostException {
		return InetAddress.getLocalHost();
	}
}
</file>
</fixedFiles>
</bug>
<bug id="135780" transactionid="69781">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="27"/>
<property name="lines-deleted" value="4"/>
<property name="lines-modified" value="17"/>
<property name="lines-churned" value="48"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-false K-if K-import K-interface K-new K-null K-return K-try M O-== O-|| T V Z-if</fullfingerprint>
<bugreport>The thisJoinPoint.printString() fails on a 1.1 VM because it relies on a java.lang.ref.SoftReference. I need this to work because we're using AspectJ on an embedded device that is still using a pre-1.2 VM.

The problem lies in org.aspectj.runtime.reflect.SignatureImpl. The attached patch fixes it and passes all the tests. I tested the failing program manually on a 1.1 VM, but automating the test would require adding a 1.1 VM to the regression test infrastructure.

Sample:

public aspect Java11Test {
    before() : execution(* *(..)) {
        System.out.println(thisJoinPoint.toString());
    }
    public static void main(String args[]) {}
}

&gt;ajc -target 1.1 Java11Test.aj

&gt;\java\jre1.1.8_010\bin\jre -cp .;%CLASSPATH% Java11Test
Exception in thread "main" java.lang.NoClassDefFoundError: java/lang/ref/SoftRef
erence
        at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(Joi
nPointImpl.java:43)
        at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(Joi
nPointImpl.java:48)
        at Java11Test.ajc$before$Java11Test$1$3444dde4(Java11Test.aj:3)
        at Java11Test.main(Java11Test.aj)</bugreport>
<pre-fix-testcases failing="187" file="output/135780/pre-fix/testresults.xml" passing="1817" size="2004"/>
<post-fix-testcases failing="191" file="output/135780/post-fix/testresults.xml" passing="1813" size="2004"/>
<fixedFiles>
<file name="org.aspectj/modules/lib/aspectj/lib/aspectjrt.jar" revision="1.23" state="changed"/>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java" revision="1.7" state="changed">19d18
&lt; import java.lang.ref.SoftReference;
30c29
&lt;     SoftReference toStringCacheRef;
---
&gt;     Cache stringCache;
42,45c41,51
&lt; 		String[] toStringCache = null;
&lt; 		if (toStringCacheRef == null || toStringCacheRef.get() == null) {
&lt; 			toStringCache = new String[3];
&lt; 			if (useCache) toStringCacheRef = new SoftReference(toStringCache);
---
&gt; 		String result = null;
&gt; 		if (useCache) {
&gt; 			if (stringCache == null) {
&gt; 				try {
&gt; 					stringCache = new CacheImpl();
&gt; 				} catch (Throwable t) {
&gt; 					useCache = false;
&gt; 				}
&gt; 			} else {
&gt; 				result = stringCache.get(sm.cacheOffset);
&gt; 			}
47,48c53,54
&lt; 		else {
&lt; 			toStringCache = (String[])toStringCacheRef.get();
---
&gt; 		if (result == null) {
&gt; 			result = createToString(sm);
50,52c56,57
&lt; 		
&lt; 		if (toStringCache[sm.cacheOffset] == null) {
&lt; 			toStringCache[sm.cacheOffset] = createToString(sm);
---
&gt; 		if (useCache) {
&gt; 			stringCache.set(sm.cacheOffset, result);
54c59
&lt; 		return toStringCache[sm.cacheOffset];
---
&gt; 		return result;
194a200,226
&gt; 	private static interface Cache {
&gt; 
&gt; 		String get(int cacheOffset);
&gt; 
&gt; 		void set(int cacheOffset, String result);	
&gt; 		
&gt; 	}
&gt; 	
&gt; 	// separate implementation so we don't need SoftReference to hold the field...
&gt; 	private static final class CacheImpl implements Cache {		
&gt; 		private java.lang.ref.SoftReference toStringCacheRef;
&gt; 		public CacheImpl() { 
&gt; 			toStringCacheRef = new java.lang.ref.SoftReference(new String[3]);
&gt; 		}
&gt; 		
&gt; 		public String get(int cacheOffset) {
&gt; 			return array()[cacheOffset];
&gt; 		}
&gt; 
&gt; 		public void set(int cacheOffset, String result) {
&gt; 			array()[cacheOffset] = result;
&gt; 		}
&gt; 		
&gt; 		private String[] array() {
&gt; 			return (String[])toStringCacheRef.get();
&gt; 		}
&gt; 	}
</file>
<file name="org.aspectj/modules/lib/test/aspectjrt.jar" revision="1.42" state="changed"/>
</fixedFiles>
</bug>
<bug id="136665" transactionid="69087">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="12"/>
<property name="lines-added" value="11"/>
<property name="lines-deleted" value="4"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="21"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-import K-new K-throw K-try M O-+ T V Y Z-throw</fullfingerprint>
<bugreport>[iajc] error at (no source information available)
     [iajc] File.aj:0::0 Internal compiler error
     [iajc] org.aspectj.weaver.BCException: Can't open archive: missingjar

     [iajc] when resolving types defined in compilation unit File.aj
     [iajc] when processing compilation unit File.aj
     [iajc] when batch building BuildConfig[null] #Files=14
     [iajc]
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureO
pen(ClassPathManager.java:258)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(Cl
assPathManager.java:225)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManage
r.java:92)
     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.j
ava:287)
     [iajc]     at org.aspectj.weaver.World.resolveToReferenceType(World.java:33
5)
     [iajc]     at org.aspectj.weaver.World.resolve(World.java:251)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld
(WildTypePattern.java:716)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFr
omFullyQualifiedTypeName(WildTypePattern.java:690)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(W
ildTypePattern.java:623)
     [iajc]     at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(
SignaturePattern.java:82)
     [iajc]     at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(Ki
ndedPointcut.java:259)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPo
intcut.java:74)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:19
4)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.fin
ishResolveTypes(PointcutDesignator.java:84)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.reso
lveStatements(AdviceDeclaration.java:118)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMet
hodDeclaration.resolve(AbstractMethodDeclaration.java:400)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara
tion.resolve(TypeDeclaration.java:1088)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.reso
lve(AspectDeclaration.java:116)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara
tion.resolve(TypeDeclaration.java:1137)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Compilation
UnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.proces
s(Compiler.java:514)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compil
e(Compiler.java:329)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.perform
Compilation(AjBuildManager.java:845)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:241)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu
ild(AjBuildManager.java:161)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1
12)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:
60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:356)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTas
k.java:1262)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1
056)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja
va:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)

     [iajc]     at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386)
     [iajc]     at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.j
ava:106)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja
va:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)

     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1062
)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:673)
     [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:188)
     [iajc]     at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
     [iajc]     at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)
     [iajc] Caused by: java.util.zip.ZipException: error in opening zip file
     [iajc] java.util.zip.ZipException: error in opening zip file
     [iajc]     at java.util.zip.ZipFile.open(Native Method)
     [iajc]     at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:111)
     [iajc]     at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:127)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureO
pen(ClassPathManager.java:252)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(Cl
assPathManager.java:225)
     [iajc]     at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManage
r.java:92)
     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.j
ava:287)
     [iajc]     at org.aspectj.weaver.World.resolveToReferenceType(World.java:33
5)
     [iajc]     at org.aspectj.weaver.World.resolve(World.java:251)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld
(WildTypePattern.java:716)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFr
omFullyQualifiedTypeName(WildTypePattern.java:690)
     [iajc]     at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(W
ildTypePattern.java:623)
     [iajc]     at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(
SignaturePattern.java:82)
     [iajc]     at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(Ki
ndedPointcut.java:259)
     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPo
intcut.java:74)
     [iajc]     at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:19
4)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.fin
ishResolveTypes(PointcutDesignator.java:84)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.reso
lveStatements(AdviceDeclaration.java:118)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMet
hodDeclaration.resolve(AbstractMethodDeclaration.java:400)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara
tion.resolve(TypeDeclaration.java:1088)
     [iajc]     at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.reso
lve(AspectDeclaration.java:116)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara
tion.resolve(TypeDeclaration.java:1137)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Compilation
UnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.proces
s(Compiler.java:514)
     [iajc]     at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compil
e(Compiler.java:329)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.perform
Compilation(AjBuildManager.java:845)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild
(AjBuildManager.java:241)
     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu
ild(AjBuildManager.java:161)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1
12)
     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:
60)
     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:356)
     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTas
k.java:1262)
     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1
056)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja
va:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)

     [iajc]     at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386)
     [iajc]     at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.j
ava:106)
     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja
va:275)
     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:364)
     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:341)
     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:369)
     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1214)

     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1062
)
     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:673)
     [iajc]     at org.apache.tools.ant.Main.startAnt(Main.java:188)
     [iajc]     at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196)
     [iajc]     at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55)
     [iajc] abort ABORT -- (BCException) Can't open archive: wissing.jar
     [iajc] when resolving types defined in compilation unit File.aj
     [iajc] when processing compilation unit File.aj
     [iajc] when batch building BuildConfig[null] #Files=14</bugreport>
<pre-fix-testcases failing="191" file="output/136665/pre-fix/testresults.xml" passing="1813" size="2004"/>
<post-fix-testcases failing="188" file="output/136665/post-fix/testresults.xml" passing="1816" size="2004"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java" revision="1.13" state="changed">17a18
&gt; import java.io.FileNotFoundException;
92,93c93,100
&lt; 			ClassFile ret = entry.find(name);
&lt; 			if (ret != null) return ret;
---
&gt; 			try {
&gt; 				ClassFile ret = entry.find(name);
&gt; 				if (ret != null) return ret;
&gt; 			} catch (IOException ioe) {
&gt; 				// this is NOT an error: it's valid to have missing classpath entries
&gt; 				i.remove();
&gt; 			}
&gt; 
116c123,127
&lt; 			ret.addAll(entry.getAllClassFiles());
---
&gt; 			try {
&gt; 				ret.addAll(entry.getAllClassFiles());
&gt; 			} catch (IOException e) {
&gt; 				i.remove();
&gt; 			}
130,131c141,142
&lt; 		public abstract ClassFile find(String name);
&lt; 		public abstract List getAllClassFiles();
---
&gt; 		public abstract ClassFile find(String name) throws IOException;
&gt; 		public abstract List getAllClassFiles() throws IOException;
224c235
&lt; 		public ClassFile find(String name) {
---
&gt; 		public ClassFile find(String name) throws IOException {
232c243
&lt; 		public List getAllClassFiles() {
---
&gt; 		public List getAllClassFiles() throws IOException {
244c255
&lt; 		private void ensureOpen() {
---
&gt; 		private void ensureOpen() throws IOException {
248,258c259,264
&lt; 			try {
&lt; 				if (openArchives.size()&gt;=maxOpenArchives) {
&lt; 					closeSomeArchives(openArchives.size()/10); // Close 10% of those open
&lt; 				}
&lt; 				zipFile = new ZipFile(file);
&lt; 				if (!isReallyOpen()) {
&lt; 					throw new BCException("Can't open archive: "+file.getName()+" (size() check failed)");					
&lt; 				}
&lt; 				openArchives.add(zipFile);
&lt; 			} catch (IOException ioe) {
&lt; 				throw new BCException("Can't open archive: "+file.getName(),ioe);
---
&gt; 			if (openArchives.size()&gt;=maxOpenArchives) {
&gt; 				closeSomeArchives(openArchives.size()/10); // Close 10% of those open
&gt; 			}
&gt; 			zipFile = new ZipFile(file);
&gt; 			if (!isReallyOpen()) {
&gt; 				throw new FileNotFoundException("Can't open archive: "+file.getName()+" (size() check failed)");					
259a266
&gt; 			openArchives.add(zipFile);
</file>
</fixedFiles>
</bug>
<bug id="136707" transactionid="75919">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="12"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="12"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-this M O-+ T V Y Z-if</fullfingerprint>
<bugreport>The iajc ant task should produce a summary of what it is doing, like the javac task does:

[javac] Compiling 189 source files to C:\project\classes</bugreport>
<testsforfix ID="136707" type="new">
    <file LOCATION="org.aspectj/modules/taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java">
      <test NAME="testDefaultFileComplete"/>
      <test NAME="testLogCommand"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="124" file="output/136707/pre-fix/testresults.xml" passing="961" size="1085"/>
<post-fix-testcases failing="191" file="output/136707/post-fix/testresults.xml" passing="1845" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/docs/devGuideDB/antsupport.xml" revision="1.21" state="changed">484c484,492
&lt; 				If true, emit compiler status messages during the compile.				
---
&gt; 				If true, log compiler verbose messages as Project.INFO during the compile.
&gt; 				&lt;/para&gt;&lt;/entry&gt;
&gt; 			&lt;/row&gt;
&gt; 			&lt;row&gt;
&gt; 				&lt;entry&gt;&lt;para&gt;logCommand
&gt; 				&lt;/para&gt;&lt;/entry&gt;
&gt; 				&lt;entry&gt;&lt;para&gt;
&gt; 				If true, log compiler command elements as Project.INFO
&gt; 				(rather than the usual Project.VERBOSE level).				
</file>
<file name="org.aspectj/modules/taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java" revision="1.55" state="changed">404a405,407
&gt;     /** log command in non-verbose mode */
&gt;     private boolean logCommand; 
&gt; 
449a453
&gt;         logCommand = false;
497a502,505
&gt;     public void setLogCommand(boolean logCommand) {
&gt;         this.logCommand = logCommand;
&gt;     }
&gt;     
1066c1074,1078
&lt;             logVerbose("ajc " + Arrays.asList(args));
---
&gt;             if (logCommand) {
&gt;                 log("ajc " + Arrays.asList(args));                
&gt;             } else {
&gt;                 logVerbose("ajc " + Arrays.asList(args));
&gt;             }
</file>
<file name="org.aspectj/modules/taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java" revision="1.31" state="changed">24a25
&gt; import java.util.ArrayList;
30a32
&gt; import org.apache.tools.ant.BuildEvent;
31a34
&gt; import org.apache.tools.ant.BuildListener;
718,736c721,762
&lt; 	public void testDefaultFileComplete() {
&lt; 		AjcTask task = getTask("default.lst");
&lt; 		task.setDebugLevel("none");
&lt; 		task.setDeprecation(true);
&lt; 		task.setFailonerror(false);
&lt; 		task.setNoExit(true); // ok to override Ant?
&lt; 		task.setNoImportError(true);
&lt; 		task.setNowarn(true);
&lt; 		task.setXTerminateAfterCompilation(true);
&lt; 		task.setPreserveAllLocals(true);
&lt; 		task.setProceedOnError(true);
&lt; 		task.setReferenceInfo(true);
&lt; 		task.setSource("1.3");
&lt; 		task.setTarget("1.1");
&lt; 		task.setTime(true);
&lt; 		task.setVerbose(true);
&lt; 		task.setXlint("info");
&lt; 		runTest(task, NO_EXCEPTION, MessageHolderChecker.INFOS);
&lt; 	}
---
&gt;     public void testDefaultFileComplete() {
&gt;         AjcTask task = getTask("default.lst");
&gt;         defaultSettings(task);
&gt;         runTest(task, NO_EXCEPTION, MessageHolderChecker.INFOS);
&gt;     }
&gt;     private void defaultSettings(AjcTask task) {
&gt;         task.setDebugLevel("none");
&gt;         task.setDeprecation(true);
&gt;         task.setFailonerror(false);
&gt;         task.setNoExit(true); // ok to override Ant?
&gt;         task.setNoImportError(true);
&gt;         task.setNowarn(true);
&gt;         task.setXTerminateAfterCompilation(true);
&gt;         task.setPreserveAllLocals(true);
&gt;         task.setProceedOnError(true);
&gt;         task.setReferenceInfo(true);
&gt;         task.setSource("1.3");
&gt;         task.setTarget("1.1");
&gt;         task.setTime(true);
&gt;         task.setVerbose(true);
&gt;         task.setXlint("info");        
&gt;     }
&gt;     
&gt;     public void testLogCommand() {
&gt;         final String DEFAULT = "default.lst";
&gt;         AjcTask task = getTask(DEFAULT);
&gt;         defaultSettings(task);
&gt;         task.setVerbose(false);
&gt;         task.setLogCommand(true);
&gt;         LogListener listener = new LogListener(Project.MSG_INFO);
&gt;         task.getProject().addBuildListener(listener);
&gt;         runTest(task, NO_EXCEPTION, MessageHolderChecker.INFOS);
&gt;         String[] results = listener.getResults();
&gt;         boolean matched = false;
&gt;         for (int i = 0; !matched &amp;&amp; (i &lt; results.length); i++) {
&gt;             String s = results[i];
&gt;             matched = (null != s) &amp;&amp; (-1 != s.indexOf(DEFAULT));
&gt;         }
&gt;         if (!matched) {
&gt;             fail(DEFAULT + " not found in " + Arrays.asList(results));
&gt;         }
&gt;     }
939a966,986
&gt;     private static class LogListener implements BuildListener {
&gt;         private final ArrayList results = new ArrayList();
&gt;         private final int priority;
&gt;         private LogListener(int priority) {
&gt;             this.priority = priority;
&gt;         }
&gt;         public void buildFinished(BuildEvent event) {}
&gt;         public void buildStarted(BuildEvent event) {}
&gt;         public void messageLogged(BuildEvent event) {
&gt;             if (priority == event.getPriority()) {
&gt;                 results.add(event.getMessage());
&gt;             }
&gt;         }
&gt;         public void targetFinished(BuildEvent event) {}
&gt;         public void targetStarted(BuildEvent event) {}
&gt;         public void taskFinished(BuildEvent event) {}
&gt;         public void taskStarted(BuildEvent event) {}
&gt;         String[] getResults() {
&gt;             return (String[]) results.toArray(new String[0]);
&gt;         }
&gt;     }
</file>
</fixedFiles>
</bug>
<bug id="137867" transactionid="73001">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null O-!= T V Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>I just had the UI show error dialogs or not paint the editor and had
these stack traces in the error log. I closed the AspectJ/Java editor for the file in question and after reopening it seems to be working. I had done a shift+control+u to find identifier references before this happened, although I tried it again and it seems to be working. This is with 3.2M6 and the last AJDT for that Eclipse build.

Trace 1:

org.eclipse.jface.util.Assert$AssertionFailedException: null argument;
at org.eclipse.jface.util.Assert.isNotNull(Assert.java:150)
at org.eclipse.jface.util.Assert.isNotNull(Assert.java:126)
at org.eclipse.jface.viewers.StructuredSelection.&lt;init&gt;(StructuredSelection.java:66)
at org.eclipse.jdt.internal.ui.packageview.PackageExplorerPart.selectAndReveal(PackageExplorerPart.java:1010)
at org.eclipse.ajdt.internal.ui.editor.AspectJEditor.setFocus(AspectJEditor.java:493)
at org.eclipse.ui.internal.PartPane.setFocus(PartPane.java:309)
at org.eclipse.ui.internal.EditorPane.setFocus(EditorPane.java:117)
at org.eclipse.ui.internal.WorkbenchPage$3.run(WorkbenchPage.java:597)
at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
at org.eclipse.core.runtime.Platform.run(Platform.java:816)
at org.eclipse.ui.internal.WorkbenchPage.activatePart(WorkbenchPage.java:592)
at org.eclipse.ui.internal.WorkbenchPage.setActivePart(WorkbenchPage.java:3101)
at org.eclipse.ui.internal.WorkbenchPage.requestActivation(WorkbenchPage.java:2658)
at org.eclipse.ui.internal.PartPane.requestActivation(PartPane.java:256)
at org.eclipse.ui.internal.EditorPane.requestActivation(EditorPane.java:89)
at org.eclipse.ui.internal.PartPane.setFocus(PartPane.java:302)
at org.eclipse.ui.internal.EditorPane.setFocus(EditorPane.java:117)
at org.eclipse.ui.internal.PartStack.presentationSelectionChanged(PartStack.java:801)
at org.eclipse.ui.internal.PartStack.access$1(PartStack.java:784)
at org.eclipse.ui.internal.PartStack$1.selectPart(PartStack.java:122)
at org.eclipse.ui.internal.presentations.util.TabbedStackPresentation$1.handleEvent(TabbedStackPresentation.java:126)
at org.eclipse.ui.internal.presentations.util.AbstractTabFolder.fireEvent(AbstractTabFolder.java:267)
at org.eclipse.ui.internal.presentations.util.AbstractTabFolder.fireEvent(AbstractTabFolder.java:276)
at org.eclipse.ui.internal.presentations.defaultpresentation.DefaultTabFolder.access$1(DefaultTabFolder.java:1)
at org.eclipse.ui.internal.presentations.defaultpresentation.DefaultTabFolder$2.handleEvent(DefaultTabFolder.java:84)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:949)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:934)
at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:706)
at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3170)
at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1953)
at org.eclipse.swt.custom.CTabFolder$1.handleEvent(CTabFolder.java:288)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3346)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2966)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1914)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1878)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:419)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:95)
at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:336)
at org.eclipse.core.launcher.Main.basicRun(Main.java:280)
at org.eclipse.core.launcher.Main.run(Main.java:977)
at org.eclipse.core.launcher.Main.main(Main.java:952)

Trace 2:
java.lang.NullPointerException
at org.eclipse.ajdt.internal.ui.editor.CompilationUnitAnnotationModelWrapper.endReporting(CompilationUnitAnnotationModelWrapper.java:252)
at org.eclipse.jdt.internal.core.JavaModelManager$PerWorkingCopyInfo.endReporting(JavaModelManager.java:992)
at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:97)
at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:720)
at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:779)
at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1117)
at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:97)
at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:82)
at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:145)
at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:94)
at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:75)
at org.eclipse.jdt.internal.ui.text.JavaReconciler.process(JavaReconciler.java:339)
at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:204)</bugreport>
<pre-fix-testcases failing="188" file="output/137867/pre-fix/testresults.xml" passing="1816" size="2004"/>
<post-fix-testcases failing="187" file="output/137867/post-fix/testresults.xml" passing="1817" size="2004"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/AspectJEditor.java" revision="1.52" state="changed">493c493,495
&lt; 					packageExplorer.selectAndReveal(ajc);
---
&gt; 					if (ajc != null) {
&gt; 						packageExplorer.selectAndReveal(ajc);
&gt; 					}
</file>
</fixedFiles>
</bug>
<bug id="137922" transactionid="73380">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-|| O-() T V Z-if</fullfingerprint>
<bugreport>When a plug-in project that uses a manifest to describe dependencies is converted to an AspectJ project aspectjrt.jar is _incorrectly_ added to the classpath rather that the plug-dependencies. This can lead to duplicate entries when the correct Require-Bundle entry is added by hand (although the conversion does not update classpath if the manifest is updated first). I believe this worked in the past with plugin.xml.

To help with the creation of aspect bundles that work with the Aspects Equinox Incubator http://www.eclipse.org/equinox/incubator/aspects/ there are some other steps that could be added to the conversion process to avoid nasty errors (and BCEL dumps) downstream.

1.	Create dummy org/aspectj/aop.xml
2.	Add Export-Package: org.aspectj to manfest.mf
3.	Add Require-Bundle: org.aspectj.runtime;visibility:=reexport to manfest.mf
4.	Add AspectJ nature

Any aspect bundle that is to be used in LTW needs an aop.xml file. The package that contains it needs to be exported (otherwise woven bundles will not see the file). For the export to work the package must exist and to ensure the directory is created (when extracting from CVS) it must contain a file. Any woven bundle will need org.aspectj.runtime but should not have to require it explicitly, on the bundle that contains the aspect it is using (especially in the case of the supplements feature). If not you get a nasty BCEL dump with the following in the middle of it:

-- (AbortException) can't find critical required type org.aspectj.lang.JoinPoint$StaticPart
can't find critical required type org.aspectj.lang.JoinPoint$StaticPart
Message: error can't find critical required type org.aspectj.lang.JoinPoint$StaticPart
org.aspectj.bridge.AbortException: can't find critical required type org.aspectj.lang.JoinPoint$StaticPart</bugreport>
<pre-fix-testcases failing="190" file="output/137922/pre-fix/testresults.xml" passing="1814" size="2004"/>
<post-fix-testcases failing="188" file="output/137922/post-fix/testresults.xml" passing="1816" size="2004"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/utils/AJDTUtils.java" revision="1.24" state="changed">188a189
&gt; 		// Bugzilla 137922 - also consider bundles without a plugin.xml
190c191,192
&lt; 		        &amp;&amp; WorkspaceModelManager.hasPluginManifest(project)) {
---
&gt; 		        &amp;&amp; (WorkspaceModelManager.hasPluginManifest(project)
&gt; 		        		|| WorkspaceModelManager.hasBundleManifest(project))) {
619a622
&gt; 		// Bugzilla 137922 - also consider bundles without a plugin.xml
621c624,625
&lt; 		        &amp;&amp; WorkspaceModelManager.hasPluginManifest(project)) {
---
&gt; 		        &amp;&amp; (WorkspaceModelManager.hasPluginManifest(project)
&gt; 		        		|| WorkspaceModelManager.hasBundleManifest(project))) {
</file>
</fixedFiles>
</bug>
<bug id="138125" transactionid="73144">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null O-!= T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>AJDT 20060421121531 with Eclipse 3.2 RC1:

I get a series of errors from this problem...

Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui"
Error in JDT Core during reconcile with this stack trace

java.lang.NullPointerException
at org.eclipse.ajdt.internal.ui.editor.CompilationUnitAnnotationModelWrapper.endReporting(CompilationUnitAnnotationModelWrapper.java:252)
at org.eclipse.jdt.internal.core.JavaModelManager$PerWorkingCopyInfo.endReporting(JavaModelManager.java:992)
at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:97)
at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:720)
at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:779)
at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1120)
at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1092)
at org.eclipse.jdt.internal.corext.util.JavaModelUtil.reconcile(JavaModelUtil.java:701)
at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.getElementAt(CompilationUnitEditor.java:1292)
at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.getElementAt(CompilationUnitEditor.java:1273)
at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.adjustHighlightRange(JavaEditor.java:2144)
at org.eclipse.ui.texteditor.AbstractTextEditor.selectAndReveal(AbstractTextEditor.java:4955)
at org.eclipse.ui.texteditor.AbstractTextEditor.selectAndReveal(AbstractTextEditor.java:4929)
at org.eclipse.ui.texteditor.TextSelectionNavigationLocation.restoreLocation(TextSelectionNavigationLocation.java:255)
at org.eclipse.ui.internal.NavigationHistoryEntry.restoreLocation(NavigationHistoryEntry.java:81)
at org.eclipse.ui.internal.NavigationHistory.gotoEntry(NavigationHistory.java:385)
at org.eclipse.ui.internal.NavigationHistory.shiftEntry(NavigationHistory.java:436)
at org.eclipse.ui.internal.NavigationHistory.backward(NavigationHistory.java:420)
at org.eclipse.ui.internal.NavigationHistoryAction.run(NavigationHistoryAction.java:201)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)
at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119)
at org.eclipse.core.commands.Command.executeWithChecks(Command.java:460)
at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:424)
at org.eclipse.ui.internal.handlers.HandlerService.executeCommand(HandlerService.java:160)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:466)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:799)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:846)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:564)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:506)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:122)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Display.filterEvent(Display.java:982)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:924)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:949)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:934)
at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:962)
at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:958)
at org.eclipse.swt.widgets.Widget.wmSysKeyDown(Widget.java:2272)
at org.eclipse.swt.widgets.Control.WM_SYSKEYDOWN(Control.java:4007)
at org.eclipse.swt.widgets.Control.windowProc(Control.java:3321)
at org.eclipse.swt.widgets.Display.windowProc(Display.java:4023)
at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1920)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2964)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1914)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1878)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:419)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:95)
at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:336)
at org.eclipse.core.launcher.Main.basicRun(Main.java:280)
at org.eclipse.core.launcher.Main.run(Main.java:977)
at org.eclipse.core.launcher.Main.main(Main.java:952)

Then I got

Problems occurred when invoking code from plug-in: "org.eclipse.ui.workbench"

org.eclipse.jface.util.Assert$AssertionFailedException: null argument;
at org.eclipse.jface.util.Assert.isNotNull(Assert.java:150)
at org.eclipse.jface.util.Assert.isNotNull(Assert.java:126)
at org.eclipse.jface.viewers.StructuredSelection.&lt;init&gt;(StructuredSelection.java:66)
at org.eclipse.jdt.internal.ui.packageview.PackageExplorerPart.selectAndReveal(PackageExplorerPart.java:1044)
at org.eclipse.ajdt.internal.ui.editor.AspectJEditor.setFocus(AspectJEditor.java:493)
at org.eclipse.ui.internal.PartPane.setFocus(PartPane.java:309)
at org.eclipse.ui.internal.EditorPane.setFocus(EditorPane.java:117)
at org.eclipse.ui.internal.WorkbenchPage$3.run(WorkbenchPage.java:600)
at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
at org.eclipse.core.runtime.Platform.run(Platform.java:843)
at org.eclipse.ui.internal.WorkbenchPage.activatePart(WorkbenchPage.java:595)
at org.eclipse.ui.internal.WorkbenchPage.setActivePart(WorkbenchPage.java:3135)
at org.eclipse.ui.internal.WorkbenchPage.activate(WorkbenchPage.java:588)
at org.eclipse.ui.internal.WorkbenchPage.showEditor(WorkbenchPage.java:2564)
at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditorBatched(WorkbenchPage.java:2526)
at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:2470)
at org.eclipse.ui.internal.WorkbenchPage.access$10(WorkbenchPage.java:2462)
at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:2447)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2442)
at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2427)
at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:287)
at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:164)
at org.eclipse.jdt.internal.ui.actions.OpenActionUtil.open(OpenActionUtil.java:49)
at org.eclipse.ajdt.internal.ui.editor.actions.AJOpenAction.run(AJOpenAction.java:206)
at org.eclipse.ajdt.internal.ui.editor.actions.AJOpenAction.run(AJOpenAction.java:175)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:271)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:243)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)
at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:185)
at org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:109)
at org.eclipse.core.commands.Command.executeWithChecks(Command.java:460)
at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:424)
at org.eclipse.ui.internal.handlers.HandlerService.executeCommand(HandlerService.java:160)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:466)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:799)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:846)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:564)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:506)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:122)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Display.filterEvent(Display.java:982)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:924)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:949)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:934)
at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:962)
at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:958)
at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1557)
at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:3567)
at org.eclipse.swt.widgets.Control.windowProc(Control.java:3275)
at org.eclipse.swt.widgets.Display.windowProc(Display.java:4023)
at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1920)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2964)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1914)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1878)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:419)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:95)
at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:336)
at org.eclipse.core.launcher.Main.basicRun(Main.java:280)
at org.eclipse.core.launcher.Main.run(Main.java:977)
at org.eclipse.core.launcher.Main.main(Main.java:952)

These errors repeated themselves.

I don't know what caused the initial error.</bugreport>
<pre-fix-testcases failing="186" file="output/138125/pre-fix/testresults.xml" passing="1818" size="2004"/>
<post-fix-testcases failing="188" file="output/138125/post-fix/testresults.xml" passing="1816" size="2004"/>
<fixedFiles>
<file name="org.eclipse.ajdt/AJDT_src/org.eclipse.ajdt.ui/src/org/eclipse/ajdt/internal/ui/editor/CompilationUnitAnnotationModelWrapper.java" revision="1.4" state="changed">252,253c252,254
&lt; 		((IProblemRequestor)delegate).endReporting();
&lt; 		
---
&gt; 		if(delegate != null) {
&gt; 			((IProblemRequestor)delegate).endReporting();
&gt; 		}
</file>
</fixedFiles>
</bug>
<bug id="138143" transactionid="69506">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null K-return O-== O-!= T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>When developing aspects as annotations, i get a NullPointerException when saving a source file which has duplicated method names. Obviously that also breaks the java code itself but it also pops up an aspectj message info.

Here is a sample code:

@Aspect
public class AspectClass{
	
	@Pointcut("call(@Incoming * *(..))")
	public void incomingMessage() {
	}

	
	@Pointcut("call(@Activity * *(..))")
	public void incomingMessage() {
	}
	
}

The npe is the following:

java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.makeResolvedPointcutDefinition(EclipseSourceType.java:217)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.fillDeclaredMembers(EclipseSourceType.java:188)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getDeclaredPointcuts(EclipseSourceType.java:250)
at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.checkPointcutDeclarations(EclipseSourceType.java:267)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:433)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:236)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null

regards
Moritz Post</bugreport>
<pre-fix-testcases failing="192" file="output/138143/pre-fix/testresults.xml" passing="1812" size="2004"/>
<post-fix-testcases failing="186" file="output/138143/post-fix/testresults.xml" passing="1818" size="2004"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java" revision="1.51" state="changed">189c189
&lt; 					declaredPointcuts.add(df);
---
&gt; 					if (df!=null) declaredPointcuts.add(df);
216a217
&gt; 		if (md.binding==null) return null; // there is another error that has caused this... pr138143
</file>
</fixedFiles>
</bug>
<bug id="138171" transactionid="68797">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="9"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="9"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>HKM</concisefingerprint>
<fullfingerprint>H K-catch K-import K-new K-null K-try M O-+ T V Y</fullfingerprint>
<bugreport>This is with 1.5.1a.

I am developing a web application and I ran into this compiler crash.
The resource to be copied (Thumbs.db) was in use and therefore could
not be copied. However, AJC ended up producing an internal error instead
of a warning or a normal error.

java.io.FileNotFoundException
at java.io.FileOutputStream.open(Native Method)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:179)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:131)
at org.aspectj.util.FileUtil.makeOutputStream(FileUtil.java:1258)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:504)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:482)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:424)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:320)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

FileNotFoundException thrown: C:\work\workspace\MyCompany\class\images\Thumbs.db (Access is denied)</bugreport>
<pre-fix-testcases failing="193" file="output/138171/pre-fix/testresults.xml" passing="1822" size="2015"/>
<post-fix-testcases failing="189" file="output/138171/post-fix/testresults.xml" passing="1826" size="2015"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.100" state="changed">20a21
&gt; import java.io.FileNotFoundException;
508,511c509,520
&lt; 			OutputStream fos = 
&lt; 				FileUtil.makeOutputStream(new File(destDir,filename));
&lt; 			fos.write(content);
&lt; 			fos.close();
---
&gt; 			try {
&gt; 				OutputStream fos = 
&gt; 					FileUtil.makeOutputStream(new File(destDir,filename));
&gt; 				fos.write(content);
&gt; 				fos.close();
&gt; 			} catch (FileNotFoundException fnfe) {
&gt; 				IMessage msg = new Message("unable to copy resource to output folder: '" + filename + "' - reason: "+fnfe.getMessage(),
&gt; 										   IMessage.ERROR,
&gt; 										   null,
&gt; 										   new SourceLocation(srcLocation,0));
&gt; 				handler.handleMessage(msg);
&gt; 			}
</file>
</fixedFiles>
</bug>
<bug id="138215" transactionid="70846">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="30"/>
<property name="lines-deleted" value="14"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="44"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-if K-import K-instanceof K-new M O-() O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>When a pointcut expression used with an @DeclareWarning construct contains a reference pointcut, the warning is correctly produced at matched join points, but the compiler also gives an error saying that the referenced pointcut cannot be found.</bugreport>
<pre-fix-testcases failing="187" file="output/138215/pre-fix/testresults.xml" passing="1817" size="2004"/>
<post-fix-testcases failing="186" file="output/138215/post-fix/testresults.xml" passing="1818" size="2004"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java" revision="1.55" state="changed">50a51
&gt; import org.aspectj.weaver.bcel.AtAjAttributes.BindingScope;
51a53,56
&gt; import org.aspectj.weaver.patterns.Declare;
&gt; import org.aspectj.weaver.patterns.DeclareErrorOrWarning;
&gt; import org.aspectj.weaver.patterns.FormalBinding;
&gt; import org.aspectj.weaver.patterns.IScope;
306a312,313
&gt; 		
&gt; 		resolveAnnotationDeclares(l);
350a358,380
&gt;     
&gt;     /**
&gt;      * Extra processing step needed because declares that come from annotations are not pre-resolved.
&gt;      * We can't do the resolution until *after* the pointcuts have been resolved.
&gt;      * @param attributeList
&gt;      */
&gt;     private void resolveAnnotationDeclares(List attributeList) {
&gt;     	FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
&gt;         IScope bindingScope = new BindingScope(
&gt;                 getResolvedTypeX(),
&gt;                 getResolvedTypeX().getSourceContext(),
&gt;                 bindings
&gt;         );
&gt; 		for (Iterator iter = attributeList.iterator(); iter.hasNext();) {
&gt; 			AjAttribute a = (AjAttribute) iter.next();
&gt; 			if (a instanceof AjAttribute.DeclareAttribute) {
&gt; 				Declare decl = (((AjAttribute.DeclareAttribute)a).getDeclare());
&gt; 				if (decl instanceof DeclareErrorOrWarning) {
&gt; 				  decl.resolve(bindingScope);
&gt; 				}
&gt; 			}
&gt; 		}    	
&gt;     }
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java" revision="1.36" state="changed">1239,1244d1238
&lt;                 FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
&lt;                 IScope binding = new BindingScope(
&lt;                         struct.enclosingType,
&lt;                         struct.context,
&lt;                         bindings
&lt;                 );
1248,1249c1242
&lt;                 } else {
&lt;                     pc .resolve(binding);
---
&gt;                 } else {                	 
1266,1271d1258
&lt;                 FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
&lt;                 IScope binding = new BindingScope(
&lt;                         struct.enclosingType,
&lt;                         struct.context,
&lt;                         bindings
&lt;                 );
1276d1262
&lt;                     pc.resolve(binding);
</file>
</fixedFiles>
</bug>
<bug id="138219" transactionid="70659">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="15"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="4"/>
<property name="lines-modified" value="12"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-return K-this K-true M T V Z-if</fullfingerprint>
<bugreport>A pointcut expression for a per-clause fails to resolve if it contains any reference pointcuts referring to pointcut expressions defined in other types. (Even if that is indirectly, through a local named pointcut).</bugreport>
<testsforfix ID="138219" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testReferencePCutInPerClause_pr138219"/>
      <test NAME="testReferencePCutInPerClause_pr130722"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="FQ Reference pointcut from perclause ref pc"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/138219/pre-fix/testresults.xml" passing="1825" size="2015"/>
<post-fix-testcases failing="191" file="output/138219/post-fix/testresults.xml" passing="1824" size="2015"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java" revision="1.22" state="changed">64c64
&lt; 	public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShadowMungers) {
---
&gt; 	public boolean addOrReplaceAspect(ResolvedType aspectType, boolean inWeavingPhase) {
68c68
&lt; 			members.put(aspectType, aspectType.collectCrosscuttingMembers());
---
&gt; 			members.put(aspectType, aspectType.collectCrosscuttingMembers(inWeavingPhase));
73c73
&lt; 			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(),careAboutShadowMungers)) {
---
&gt; 			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(inWeavingPhase),inWeavingPhase)) {
79c79
&lt; 				if (!World.compareLocations &amp;&amp; careAboutShadowMungers) {
---
&gt; 				if (!World.compareLocations &amp;&amp; inWeavingPhase) {
89c89
&lt; 			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType,careAboutShadowMungers); 
---
&gt; 			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType,inWeavingPhase); 
96c96
&lt; 	private boolean addOrReplaceDescendantsOf(ResolvedType aspectType,boolean careAboutShadowMungers) {
---
&gt; 	private boolean addOrReplaceDescendantsOf(ResolvedType aspectType, boolean inWeavePhase) {
109c109
&lt; 			boolean thisChange = addOrReplaceAspect(next,careAboutShadowMungers);
---
&gt; 			boolean thisChange = addOrReplaceAspect(next,inWeavePhase);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedType.java" revision="1.48" state="changed">501,502c501,502
&lt; 	public CrosscuttingMembers collectCrosscuttingMembers() {
&lt; 		crosscuttingMembers = new CrosscuttingMembers(this);
---
&gt; 	public CrosscuttingMembers collectCrosscuttingMembers(boolean shouldConcretizeIfNeeded) {
&gt; 		crosscuttingMembers = new CrosscuttingMembers(this,shouldConcretizeIfNeeded);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembers.java" revision="1.29" state="changed">66c66,68
&lt; 	public CrosscuttingMembers(ResolvedType inAspect) {
---
&gt; 	private boolean shouldConcretizeIfNeeded = true;
&gt; 	
&gt; 	public CrosscuttingMembers(ResolvedType inAspect, boolean shouldConcretizeIfNeeded) {
68a71
&gt; 		this.shouldConcretizeIfNeeded = shouldConcretizeIfNeeded;
217,219c220,224
&lt; 		if (perClause == null || !perClause.equals(other.perClause)) {
&lt; 			changed = true;
&lt; 			perClause = other.perClause;
---
&gt; 		if (careAboutShadowMungers) {
&gt; 			if (perClause == null || !perClause.equals(other.perClause)) {
&gt; 				changed = true;
&gt; 				perClause = other.perClause;
&gt; 			}
360,363d364
&lt; 	public PerClause getPerClause() {
&lt; 		return perClause;
&lt; 	}
&lt; 
365c366,370
&lt; 		this.perClause = perClause.concretize(inAspect);
---
&gt; 		if (this.shouldConcretizeIfNeeded) {
&gt; 			this.perClause = perClause.concretize(inAspect);
&gt; 		} else {
&gt; 			this.perClause = perClause;
&gt; 		}
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java" revision="1.5" state="changed">48c48
&lt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(onAspect);
---
&gt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(onAspect,true);
67c67
&lt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(onAspect);
---
&gt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(onAspect,true);
</file>
<file name="org.aspectj/modules/tests/bugs152/pr130722/test/Test.java" revision="1.1" state="new">package test;


public class Test {

        public void foo() {

        }
}


</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java" revision="1.8" state="changed">83c83
&lt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(aType);
---
&gt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(aType,true);
111c111
&lt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(aType);
---
&gt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(aType,true);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/GenericITDsDesign.java" revision="1.4" state="changed">84c84
&lt; 		CrosscuttingMembers cmembers = resolvedType.collectCrosscuttingMembers();
---
&gt; 		CrosscuttingMembers cmembers = resolvedType.collectCrosscuttingMembers(true);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.19" state="changed">205c205
&lt;       &lt;compile files="PerThisWithReference.aj,SomeOtherType.aj" options="-1.5"&gt;
---
&gt;       &lt;compile files="PerThisWithReference.aj,SomeOtherType.aj,RegularPCWithReference.aj" options="-1.5"&gt;
206a207,216
&gt;       &lt;run class="PerThisWithReference"&gt;
&gt;         &lt;stdout&gt;
&gt;          &lt;line text="before PerThisWithReference:1"/&gt;
&gt;          &lt;line text="before PerThisWithReference:2"/&gt;
&gt;         &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs152/pr130722" pr="130722" title="FQ Reference pointcut from perclause ref pc"&gt;
&gt;       &lt;compile files="test/Test.java,test/PointcutConsumer.aj,test1/PointcutProvider.aj"/&gt;
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java" revision="1.8" state="changed">199c199
&lt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(inAspect);
---
&gt; 		CrosscuttingMembers xcut = new CrosscuttingMembers(inAspect,true);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.22" state="changed">47c47,48
&lt; //  public void testReferencePCutInPerClause_pr138219() { runTest("Can't use a FQ Reference pointcut in any pointcut expression referenced by a per-clause");}
---
&gt;   public void testReferencePCutInPerClause_pr138219() { runTest("Can't use a FQ Reference pointcut in any pointcut expression referenced by a per-clause");}
&gt;   public void testReferencePCutInPerClause_pr130722() { runTest("FQ Reference pointcut from perclause ref pc"); }
</file>
<file name="org.aspectj/modules/tests/bugs152/pr138219/PerThisWithReference.aj" revision="1.2" state="changed">2a3,11
&gt;   private static int id = 0;
&gt;   
&gt;   public PerThisWithReference() {
&gt;     id++;
&gt;   }
&gt;   
&gt;   public String toString() {
&gt;     return "PerThisWithReference:" + id;
&gt;   }
4c13,16
&lt;   pointcut mypc() : SomeOtherType.pc();
---
&gt;   public static void main(String[] args) {
&gt;     new C().foo();
&gt;     new C().foo();
&gt;   }
5a18,28
&gt;   pointcut mypc() : SomeOtherType.pc() &amp;&amp; within(C);
&gt; 
&gt;   before() : mypc() {
&gt;     System.out.println("before " + this);
&gt;   }
&gt; 
&gt; }
&gt; 
&gt; class C {
&gt; 
&gt;  public void foo() {}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr130722/test/PointcutConsumer.aj" revision="1.1" state="new">package test;

import test1.PointcutProvider;

public aspect PointcutConsumer percflow(flow()) {

        // compiler issues the following line with
        // can not find pointcut test on test.PointcutConsumer
        pointcut mytest(): PointcutProvider.test();
 
        // this also does not work with the same error message
        pointcut mytest2(): test1.PointcutProvider.test();

        pointcut flow(): mytest() || mytest2();
}</file>
<file name="org.aspectj/modules/tests/bugs152/pr138219/RegularPCWithReference.aj" revision="1.1" state="new">public aspect RegularPCWithReference {

  pointcut refersToMypc() : mypc();

  pointcut mypc() : SomeOtherType.pc();


}</file>
<file name="org.aspectj/modules/tests/bugs152/pr130722/test1/PointcutProvider.aj" revision="1.1" state="new">package test1;

import test.Test;
public aspect PointcutProvider {

        public pointcut test(): execution(* Test.*(..));
}


</file>
</fixedFiles>
</bug>
<bug id="138223" transactionid="69336">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="11"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="17"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-new K-return K-throw M O-+ T V Y Z-if Z-throw</fullfingerprint>
<bugreport>junit.framework.AssertionFailedError: test "Double at annotation matching (no binding)" failed
test "Double at annotation matching (no binding)" failed
Unexpected warning messages:
	warning at before() : transactionalOperation() {
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:20:0::0 advice defined in DoubleAnnotationMatching has not been applied [Xlint:adviceDidNotMatch]
Unexpected fail messages:
	abort trouble in: 
 class Foo extends java.lang.Object:
  void &lt;init&gt;():
                    ALOAD_0     // LFoo; this   (line 26)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    constructor-execution(void Foo.&lt;init&gt;())
    |               RETURN
    constructor-execution(void Foo.&lt;init&gt;())
  end void &lt;init&gt;()

  public void foo()    org.aspectj.weaver.MethodDeclarationLineNumber: 28:533
:
    method-execution(void Foo.foo())
    |               RETURN   (line 28)
    method-execution(void Foo.foo())
  end public void foo()

  public void bar()    org.aspectj.weaver.MethodDeclarationLineNumber: 30:563
:
    method-execution(void Foo.bar())
    |               RETURN   (line 30)
    method-execution(void Foo.bar())
  end public void bar()

end  class Foo
 -- (BCException) Impossible! annotation=[Tx]  shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533]    pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316]
when implementing on shadow method-execution(void Foo.foo())
when weaving type Foo
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1

Impossible! annotation=[Tx]  shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533]    pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316]
when implementing on shadow method-execution(void Foo.foo())
when weaving type Foo
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1

org.aspectj.weaver.BCException: Impossible! annotation=[Tx]  shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533]    pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316]
when implementing on shadow method-execution(void Foo.foo())
when weaving type Foo
when weaving classes 
when weaving 
when batch building BuildConfig[null] #Files=1

	at org.aspectj.weaver.patterns.AnnotationPointcut.findResidueInternal(AnnotationPointcut.java:201)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.IfPointcut.findResidueInternal(IfPointcut.java:173)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.patterns.OrPointcut.findResidueInternal(OrPointcut.java:96)
	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)
	at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:132)
	at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:325)
	at org.aspectj.weaver.Shadow.implement(Shadow.java:455)
	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:114)
	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)
	at org.aspectj.tools.ajc.Main.run(Main.java:367)
	at org.aspectj.tools.ajc.Main.runMain(Main.java:246)
	at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:199)
	at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:163)
	at org.aspectj.tools.ajc.AjcTestCase.ajc(AjcTestCase.java:510)
	at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:53)
	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)
	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)
	at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)


command was: ajc -classpath /Users/adrian/projects/aspectjdev/lib/test/aspectjrt.jar:../testing-client/bin:../runtime/bin:../aspectj5rt/bin:../lib/junit/junit.jar:../bridge/bin:../loadtime/bin:../weaver/bin:../weaver5/bin:../aj-build/jars/bridge.jar:../aj-build/jars/util.jar:../aj-build/jars/loadtime.jar:../aj-build/jars/weaver.jar:../aj-build/jars/weaver5.jar:../aj-build/jars/asm.jar:../lib/test/testing-client.jar:../lib/test/aspectjrt.jar:/tmp/ajcSandbox/ajcTest18924.tmp -1.5 /tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj -d /tmp/ajcSandbox/ajcTest18924.tmp
	at junit.framework.Assert.fail(Assert.java:47)
	at org.aspectj.tools.ajc.AjcTestCase.assertMessages(AjcTestCase.java:452)
	at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:56)
	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)
	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)
	at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</bugreport>
<testsforfix ID="138223" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testDoubleAnnotationMatching_pr138223"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="189" file="output/138223/pre-fix/testresults.xml" passing="1826" size="2015"/>
<post-fix-testcases failing="189" file="output/138223/post-fix/testresults.xml" passing="1826" size="2015"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java" revision="1.23" state="changed">25d24
&lt; import org.aspectj.weaver.BCException;
197,202c196,212
&lt; 			// This should not happen, we shouldn't have gotten this far 
&lt; 			// if we weren't going to find the annotation
&lt; 			if (var == null) throw new BCException("Impossible! annotation=["+annotationType+
&lt; 					                               "]  shadow=["+shadow+" at "+shadow.getSourceLocation()+
&lt; 												   "]    pointcut is at ["+getSourceLocation()+"]");//return Literal.FALSE;
&lt; 
---
&gt; 			// At this point, var *could* be null.  The only reason this could happen (if we aren't failing...)
&gt; 			// is if another binding annotation designator elsewhere in the pointcut is going to expose the annotation
&gt; 			// eg.  (execution(* a*(..)) &amp;&amp; @annotation(foo)) || (execution(* b*(..)) &amp;&amp; @this(foo))
&gt; 			// where sometimes @annotation will be providing the value, and sometimes
&gt; 			// @this will be providing the value (see pr138223)
&gt; 			
&gt; 			// If we are here for other indecipherable reasons (it's not the case above...) then
&gt; 			// you might want to uncomment this next bit of code to collect the diagnostics
&gt; //			if (var == null) throw new BCException("Impossible! annotation=["+annotationType+
&gt; //					                               "]  shadow=["+shadow+" at "+shadow.getSourceLocation()+
&gt; //												 "]    pointcut is at ["+getSourceLocation()+"]");
&gt; 			if (var==null) {
&gt; 				if (matchInternal(shadow).alwaysTrue()) 
&gt; 					return Literal.TRUE;
&gt; 				else 
&gt; 					return Literal.FALSE;
&gt; 			}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.25" state="changed">54c54
&lt; //  public void testDoubleAnnotationMatching_pr138223() { runTest("Double at annotation matching (no binding)");}
---
&gt;   public void testDoubleAnnotationMatching_pr138223() { runTest("Double at annotation matching (no binding)");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.22" state="changed">252a253,261
&gt;       &lt;run class="DoubleAnnotationMatching"&gt;
&gt;         &lt;stderr&gt;
&gt;           &lt;line text="advice running at execution(void Foo.a())"/&gt;
&gt;           &lt;line text="advice running at execution(void TxTrueFoo.a())"/&gt;
&gt;           &lt;line text="advice running at execution(void TxTrueFoo.b())"/&gt;
&gt;           &lt;line text="advice running at execution(void TxTrueFoo.c())"/&gt;
&gt;           &lt;line text="advice running at execution(void TxFalseFoo.a())"/&gt;
&gt;         &lt;/stderr&gt;
&gt;       &lt;/run&gt;
</file>
<file name="org.aspectj/modules/tests/bugs152/pr138223/DoubleAnnotationMatching.aj" revision="1.2" state="changed">3,6c3
&lt; @Retention(RetentionPolicy.RUNTIME)
&lt; @interface Tx {
&lt;   boolean readOnly() default false;
&lt; }
---
&gt; @Retention(RetentionPolicy.RUNTIME) @interface Tx {boolean value() default false;}
9,12c6,7
&lt; 
&lt; 
&lt;  pointcut methodInTxType(Tx tx) : 
&lt;    execution(* *(..)) &amp;&amp; @this(tx) &amp;&amp; if(tx.readOnly());
---
&gt;   pointcut methodInTxType(Tx tx) : 
&gt;     execution(* *(..)) &amp;&amp; @this(tx) &amp;&amp; if(tx.value());
14,15c9,10
&lt;  pointcut txMethod(Tx tx) :
&lt;    execution(* *(..)) &amp;&amp; @annotation(tx) &amp;&amp; if(tx.readOnly());
---
&gt;   pointcut txMethod(Tx tx) :
&gt;     execution(* *(..)) &amp;&amp; @annotation(tx) &amp;&amp; if(tx.value());
17,18c12,13
&lt;  pointcut transactionalOperation() :
&lt;    methodInTxType(Tx) || txMethod(Tx);
---
&gt;   pointcut transactionalOperation() :
&gt;     methodInTxType(Tx) || txMethod(Tx);
20,23c15,29
&lt;  before() : transactionalOperation() {
&lt;    // do something
&lt;  }
&lt; 
---
&gt;   before() : transactionalOperation() {
&gt;     System.err.println("advice running at "+thisJoinPoint);
&gt;   }
&gt; 
&gt;   public static void main(String [] argv) {
&gt; 	  new Foo().a();
&gt; 	  new Foo().b();
&gt; 	  new Foo().c();
&gt; 	  new TxTrueFoo().a();
&gt; 	  new TxTrueFoo().b();
&gt; 	  new TxTrueFoo().c();
&gt; 	  new TxFalseFoo().a();
&gt; 	  new TxFalseFoo().b();
&gt; 	  new TxFalseFoo().c();
&gt;   }
26,30c32,36
&lt; @Tx class Foo {
&lt; 
&lt;   public void foo() {}
&lt;   
&lt;   @Tx public void bar() {}
---
&gt; @Tx(true) class TxTrueFoo {
&gt;   @Tx(true) public void a() {}
&gt;   @Tx(false) public void b() {}
&gt;   public void c() {}
&gt; }
31a38,42
&gt; @Tx(false) class TxFalseFoo {
&gt;   @Tx(true) public void a() {}
&gt;   @Tx(false) public void b() {}
&gt;   public void c() {}
&gt; }
32a44,47
&gt; class Foo {
&gt;   @Tx(true) public void a() {}
&gt;   @Tx(false) public void b() {}
&gt;   public void c() {}
</file>
</fixedFiles>
</bug>
<bug id="138286" transactionid="69358">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-new M</fullfingerprint>
<tag>exception</tag>
<bugreport>When using perthis() with an aspect, I see the following Internal Compiler 

AJDT 1.3.1 / AspectJ 1.5.1a
Build 20060406092046
Eclipse 3.1.2, Windows XP, JDK 1.5


Error:

java.lang.ClassCastException
at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41)
at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.visit(PerThisOrTargetPointcutVisitor.java:108)
at org.aspectj.weaver.patterns.AndPointcut.accept(AndPointcut.java:119)
at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41)
at org.aspectj.weaver.PerObjectInterfaceTypeMunger.getTestTypePattern(PerObjectInterfaceTypeMunger.java:64)
at org.aspectj.weaver.PerObjectInterfaceTypeMunger.matches(PerObjectInterfaceTypeMunger.java:85)
at org.aspectj.weaver.ConcreteTypeMunger.matches(ConcreteTypeMunger.java:65)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:508)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1089)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:278)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting extends java.lang.Object:
  public void &lt;init&gt;():
                    ALOAD_0     // Lorg/apache/tapestry/internal/aspects/AbstractClassTargetting; this   (line 10)
                    INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
    initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
    |               ALOAD_0
    |               INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class;
    |               LDC org.apache.tapestry.internal.annotations.Synchronized
    |               INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z
    |               IFEQ L0
    |               ALOAD_0
    |               INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V
    | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
    | |         L0: ALOAD_0
    | |             INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class;
    | |             LDC org.apache.tapestry.internal.annotations.Synchronized
    | |             INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z
    | |             IFEQ L1
    | |             ALOAD_0
    | |             INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V
    | |         L1: RETURN
    | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
    initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;())
  end public void &lt;init&gt;()

  abstract void ajc$pointcut$$targetClasses$274()    org.aspectj.weaver.MethodDeclarationLineNumber: 16:628
;

end public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting

when weaving type org.apache.tapestry.internal.aspects.AbstractClassTargetting
when weaving aspects 
when weaving 
when batch building BuildConfig[C:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\tapestry5.generated.lst] #Files=70



I'll attach the corresponding files.</bugreport>
<testsforfix ID="138286" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testNoClassCastExceptionWithPerThis_pr138286"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="No ClassCastException with perThis"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="188" file="output/138286/pre-fix/testresults.xml" passing="1816" size="2004"/>
<post-fix-testcases failing="185" file="output/138286/post-fix/testresults.xml" passing="1819" size="2004"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java" revision="1.9" state="changed">70c70
&lt;             return node.getAnnotationTypePattern();
---
&gt;         	return new AnyWithAnnotationTypePattern( node.getAnnotationTypePattern());
128c128
&lt;             return node.getAnnotationTypePattern();
---
&gt;         	return new AnyWithAnnotationTypePattern( node.getAnnotationTypePattern());
130c130
&lt;             return node.getAnnotationTypePattern();
---
&gt;         	return new AnyWithAnnotationTypePattern( node.getAnnotationTypePattern());
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.12" state="changed">40a41,42
&gt;   public void testNoClassCastExceptionWithPerThis_pr138286() { runTest("No ClassCastException with perThis");}
&gt;   
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.10" state="changed">167a168,185
&gt;     &lt;ajc-test dir="bugs152/pr138286" pr="138286" title="No ClassCastException with perThis"&gt;
&gt;       &lt;compile files="A.aj" options="-1.5 -showWeaveInfo"&gt;      
&gt; 	    &lt;message kind="weave" text="Join point 'initialization(void A.&amp;lt;init&amp;gt;())' in Type 'A' (A.aj:9) advised by before advice from 'A' (A.aj:13) [with runtime test]"/&gt;
&gt; 	    &lt;message kind="weave" text="Join point 'initialization(void Soo.&amp;lt;init&amp;gt;())' in Type 'Soo' (A.aj:31) advised by before advice from 'A' (A.aj:13) [with runtime test]"/&gt;
&gt; 	    &lt;message kind="weave" text="Join point 'initialization(void Goo.&amp;lt;init&amp;gt;())' in Type 'Goo' (A.aj:27) advised by before advice from 'A' (A.aj:13) [with runtime test]"/&gt;
&gt; 	    &lt;message kind="weave" text="Join point 'initialization(void Foo.&amp;lt;init&amp;gt;())' in Type 'Foo' (A.aj:25) advised by before advice from 'A' (A.aj:13) [with runtime test]"/&gt;
&gt; 	    &lt;message kind="weave" text="Join point 'initialization(void Boo.&amp;lt;init&amp;gt;())' in Type 'Boo' (A.aj:29) advised by before advice from 'A' (A.aj:13) [with runtime test]"/&gt;
&gt;       &lt;/compile&gt;
&gt;       &lt;run class="A"&gt;
&gt;         &lt;stderr&gt;
&gt;           &lt;line text="class Foo"/&gt;
&gt;           &lt;line text="class Boo"/&gt;
&gt;           &lt;line text="class Boo"/&gt; &lt;!-- this one is because of the super() call in Soo's default ctor --&gt;
&gt;           &lt;line text="class Soo"/&gt;
&gt;         &lt;/stderr&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs152/pr138286/A.aj" revision="1.1" state="new">import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.*;

@Retention(RUNTIME)
@Inherited
@interface MyAnnotation {}

public aspect A perthis(annotatedClasses()) {
	
	pointcut annotatedClasses() : @this(MyAnnotation);
	
	before(): initialization(*.new(..)) {System.err.println(thisJoinPoint.getSignature().getDeclaringType()); }
	
	public static void main(String []argv) {
	  new Foo();
	  new Goo();
	  new Boo();
	  new Soo();
	}
}

// yes/no indicates if runtime match expected for staticinitialization

@MyAnnotation class Foo { } // YES

class Goo { }               // NO

@MyAnnotation class Boo { } // YES

class Soo extends Boo { }   // YES</file>
</fixedFiles>
</bug>
<bug id="138540" transactionid="69665">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-== O-|| T V Y Z-if</fullfingerprint>
<bugreport>I needed to add X="set:activateLightweightDelegates=false to my ant build configuration, to troubleshoot the out of memory permgen condition. However, the ant task support doesn't currently support adding the new -Xset style options Andy added.

Here is a small patch to pass any -Xset: options through, that worked for me.</bugreport>
<pre-fix-testcases failing="188" file="output/138540/pre-fix/testresults.xml" passing="1816" size="2004"/>
<post-fix-testcases failing="190" file="output/138540/post-fix/testresults.xml" passing="1814" size="2004"/>
<fixedFiles>
<file name="org.aspectj/modules/taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java" revision="1.50" state="changed">787c787,788
&lt;                 if (VALID_XOPTIONS.contains(token)) {
---
&gt;             	// new special case: allow -Xset:anything
&gt;                 if (VALID_XOPTIONS.contains(token) || token.indexOf("set:")==0) {
</file>
</fixedFiles>
</bug>
<bug id="141956" transactionid="69338">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-null M O-- O-!= O-&amp;&amp; T V Y Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I don't know much about the internal workings of aspectJ but this bug keeps popping up so I went through the trouble of checking of trying to debug it so that I could hopefully provide enough information to get it fixed.

This happens while using eclipse AJDT. It never happens if I fully do a clean before rebuild. It only seems to happen when doing incrmental builds (using  the project-&gt;build automatically setting). 

The error happens in the iterator that recursively builds a list of methods
to return for matching. The error is triggered here:


    // we need to know if it is an interface from Parent kind munger
            // as those are used for @AJ ITD and we precisely want to skip those
            boolean shouldSkip = false;
            for (int j = 0; j &lt; rtx.interTypeMungers.size(); j++) {
                ConcreteTypeMunger munger = (ConcreteTypeMunger) rtx.interTypeMungers.get(j);
                if (munger.getMunger().getKind() == ResolvedTypeMunger.Parent) {
                    shouldSkip = true;
                    break;
                }
            }

munger.getMunger() returns null because the munger instance is a BcelPerClauseAspectAdder. My naive fix would be to check munger.getMunger() == null or check munger.getKind(). I'm assuming that BcelPerClausAspectAdder is one that should be skipped since it is related to @AJ ??? 

Again, I don't know very much about the internal architecture of the weaver magic so I hope this is enough information. 

I would appreciate it if someone who knows more of the internals could speculate as to why this bug would never pop up on a clean build but only on incremental builds? Also it's not on all incremental builds and I haven't been able to isolate what kind of changes or compiles it triggers this, although it seems that  once I got the exception once, I keep getting it on every build until I do a clean. 

java.lang.NullPointerException
at org.aspectj.weaver.ResolvedType.addAndRecurse(ResolvedType.java:288)
at org.aspectj.weaver.ResolvedType.getMethodsWithoutIterator(ResolvedType.java:257)
at org.aspectj.weaver.ResolvedType.lookupResolvedMember(ResolvedType.java:378)
at org.aspectj.weaver.JoinPointSignatureIterator.findSignaturesFromSupertypes(JoinPointSignatureIterator.java:178)
at org.aspectj.weaver.JoinPointSignatureIterator.hasNext(JoinPointSignatureIterator.java:69)
at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:287)
at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:103)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144)
at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144)
at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:64)
at org.aspectj.weaver.Advice.match(Advice.java:109)
at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:104)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2210)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1752)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:479)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:321)
at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:192)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</bugreport>
<testsforfix ID="141956" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr141956_IncrementallyCompilingAtAj"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="188" file="output/141956/pre-fix/testresults.xml" passing="1827" size="2015"/>
<post-fix-testcases failing="191" file="output/141956/post-fix/testresults.xml" passing="1824" size="2015"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedType.java" revision="1.49" state="changed">288c288
&lt;                 if (munger.getMunger().getKind() == ResolvedTypeMunger.Parent) {
---
&gt;                 if (munger.getMunger()!=null &amp;&amp; munger.getMunger().getKind() == ResolvedTypeMunger.Parent) {
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java" revision="1.70" state="changed">78a79
&gt; 	public static int debug_mungerCount = -1;
413,414c414,417
&lt;         baseTypeMungers.addAll(getWorld().getCrosscuttingMembersSet().getLateTypeMungers());
&lt; 
---
&gt; 		// XXX by Andy removed this line finally, see pr141956
&gt;         //   baseTypeMungers.addAll(getWorld().getCrosscuttingMembersSet().getLateTypeMungers());
&gt; 		debug_mungerCount=baseTypeMungers.size();
&gt; 		
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.52" state="changed">25a26
&gt; import org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory;
622a624,647
&gt; 	/**
&gt; 	 * Checks we aren't leaking mungers across compiles (accumulating multiple instances of the same one that
&gt; 	 * all do the same thing).  On the first compile the munger is added late on - so at the time we set
&gt; 	 * the count it is still zero.  On the subsequent compiles we know about this extra one.
&gt; 	 */
&gt; 	public void testPr141956_IncrementallyCompilingAtAj() {
&gt; 		initialiseProject("PR141956");
&gt; 		build("PR141956");
&gt; 		assertTrue("Should be zero but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==0);
&gt; 		alter("PR141956","inc1");
&gt; 		build("PR141956");
&gt; 		assertTrue("Should be only one but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==1);
&gt; 		alter("PR141956","inc1");
&gt; 		build("PR141956");
&gt; 		assertTrue("Should be only one but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==1);
&gt; 		alter("PR141956","inc1");
&gt; 		build("PR141956");
&gt; 		assertTrue("Should be only one but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==1);
&gt; 		alter("PR141956","inc1");
&gt; 		build("PR141956");
&gt; 		assertTrue("Should be only one but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==1);
&gt; 	}
&gt; 	
&gt; 
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR141956/base/C.java" revision="1.1" state="new">public class C {
	public static void main(String[] args) {
		new C().foo();
	}
	public void foo() {
		System.err.println("foo running");
	}
}</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR141956/inc1/C.java" revision="1.1" state="new">public class C {
	public static void main(String[] args) {
		new C().foo();
	}
	public void foo() {
		System.err.println("foo running");
	}
}</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR141956/base/A.java" revision="1.1" state="new">import org.aspectj.lang.annotation.*;

@Aspect
public class A {

        @Before("within(C) &amp;&amp; call(* foo(..))")
        public void touchBeforeExecute() {
        	  System.err.println("foo called");
        }
}</file>
</fixedFiles>
</bug>
<bug id="142165" transactionid="68933">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="13"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-new K-null K-throw M O-== O-!= O-?: O-() O-+ T V Y Z-cond Z-if Z-throw</fullfingerprint>
<bugreport>the scheme used to rewrite pointcuts defined in XML that use AND doesnt work, they get mangled.</bugreport>
<testsforfix ID="142165" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testMisbehavingDeclareAnnotation_pr135865"/>
      <test NAME="testCompletelyBrokenAopConcretization_pr142165_1"/>
      <test NAME="testCompletelyBrokenAopConcretization_pr142165_2"/>
      <test NAME="testCompletelyBrokenAopConcretization_pr142165_3"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="188" file="output/142165/pre-fix/testresults.xml" passing="1827" size="2015"/>
<post-fix-testcases failing="193" file="output/142165/post-fix/testresults.xml" passing="1822" size="2015"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java" revision="1.39" state="changed">1723c1723,1725
&lt;             Pointcut pointcut = new PatternParser(pointcutString, struct.context).parsePointcut();
---
&gt;         	PatternParser parser = new PatternParser(pointcutString, struct.context);
&gt;             Pointcut pointcut = parser.parsePointcut();
&gt;             parser.checkEof();
1731c1733,1734
&lt;             reportError("Invalid pointcut '" + pointcutString + "': " + e.toString(), struct);
---
&gt;             reportError("Invalid pointcut '" + pointcutString + "': " + e.toString() +
&gt;             		(e.getLocation()==null?"":" at position "+e.getLocation().getStart()), struct);
1734a1738
&gt;     
</file>
<file name="org.aspectj/modules/util/src/org/aspectj/util/LangUtil.java" revision="1.18" state="changed">713c713
&lt;                 result.append(in.substring(start, loc));
---
&gt;                 result.append(replace);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/PatternParser.java" revision="1.52" state="changed">1426a1427,1432
&gt; 	public void checkEof() {
&gt; 		IToken last = tokenSource.next();
&gt; 		if (last != IToken.EOF) {
&gt; 			throw new ParserException("unexpected pointcut element", last);
&gt; 		}
&gt; 	}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.23" state="changed">19c19,23
&lt; 	
---
&gt; 
&gt; //	public void testMisbehavingDeclareAnnotation_pr135865() { runTest("misbehaving declare annotation");}
&gt;   public void testCompletelyBrokenAopConcretization_pr142165_1() { runTest("broken concretization");}
&gt;   public void testCompletelyBrokenAopConcretization_pr142165_2() { runTest("broken concretization - 2");}
&gt;   public void testCompletelyBrokenAopConcretization_pr142165_3() { runTest("broken concretization - 3");}
</file>
</fixedFiles>
</bug>
<bug id="145086" transactionid="68581">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="8"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="7"/>
<property name="lines-churned" value="15"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-null K-return M O-== T V Z-cast Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Simon ran into the same problem in setting the values. I will attach a patch to fix this, with test cases to properly verify it works in both cases.

java.lang.NullPointerException
	at org.aspectj.runtime.reflect.SignatureImpl$CacheImpl.set(SignatureImpl.java:224)
	at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:57)
	at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:62)</bugreport>
<testsforfix ID="145086" type="new">
    <file LOCATION="org.aspectj/modules/runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java">
      <test NAME="testClearCache"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="76" file="output/145086/pre-fix/testresults.xml" passing="874" size="950"/>
<post-fix-testcases failing="189" file="output/145086/post-fix/testresults.xml" passing="1828" size="2017"/>
<fixedFiles>
<file name="org.aspectj/modules/lib/aspectj/lib/aspectjrt.jar" revision="1.26" state="changed"/>
<file name="org.aspectj/modules/lib/test/aspectjrt.jar" revision="1.45" state="changed"/>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java" revision="1.10" state="changed">209c209
&lt; 	private static final class CacheImpl implements Cache {		
---
&gt; 	private static final class CacheImpl implements Cache {
211,212c211,213
&lt; 		public CacheImpl() { 
&lt; 			toStringCacheRef = new java.lang.ref.SoftReference(new String[3]);
---
&gt; 
&gt; 		public CacheImpl() {
&gt; 			makeCache();
214c215
&lt; 		
---
&gt; 
216,220c217,221
&lt;           String[] cachedArray = array();
&lt;           if (cachedArray == null) {
&lt;  		     return null;
&lt;  		  }
&lt;  		  return cachedArray[cacheOffset];
---
&gt; 			String[] cachedArray = array();
&gt; 			if (cachedArray == null) {
&gt; 				return null;
&gt; 			}
&gt; 			return cachedArray[cacheOffset];
224c225,229
&lt; 			array()[cacheOffset] = result;
---
&gt; 			String[] cachedArray = array();
&gt; 			if (cachedArray == null) {
&gt; 				cachedArray = makeCache();
&gt; 			}
&gt; 			cachedArray[cacheOffset] = result;
226c231
&lt; 		
---
&gt; 
228c233
&lt; 			return (String[])toStringCacheRef.get();
---
&gt; 			return (String[]) toStringCacheRef.get();
229a235,241
&gt; 
&gt; 		private String[] makeCache() {
&gt; 			String[] array = new String[3];
&gt; 			toStringCacheRef = new java.lang.ref.SoftReference(array);
&gt; 			return array;
&gt; 		}
&gt; 
</file>
<file name="org.aspectj/modules/runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.java" revision="1.4" state="changed">18,19d17
&lt;  * TODO To change the template for this generated type comment go to
&lt;  * Window - Preferences - Java - Code Style - Code Templates
</file>
<file name="org.aspectj/modules/runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java" revision="1.4" state="changed">12a13,15
&gt; import java.lang.ref.Reference;
&gt; import java.lang.reflect.Field;
&gt; 
33a37,56
&gt; 	
&gt; 	public void testClearCache() throws Exception {
&gt; 		MethodSignatureImpl msi = new MethodSignatureImpl(0,"test",SignatureTest.class,new Class[] { String.class, Integer.TYPE }, new String[] { "s", "i" }, new Class[] {}, Runnable.class);
&gt; 		String shortString = msi.toShortString();
&gt; 		assertSame(shortString,msi.toShortString());
&gt; 		
&gt; 		Field field = SignatureImpl.class.getDeclaredField("stringCache");
&gt; 		field.setAccessible(true);
&gt; 		Object res = field.get(msi);
&gt; 		
&gt; 		field = res.getClass().getDeclaredField("toStringCacheRef");
&gt; 		field.setAccessible(true);
&gt; 		Reference ref = (Reference)field.get(res);
&gt; 		
&gt; 		ref.clear();
&gt; 		assertEquals(shortString,msi.toShortString());
&gt; 		
&gt; 		String longString = msi.toLongString();
&gt; 		assertSame(longString,msi.toLongString()); // should be cached.		
&gt; 	}
</file>
</fixedFiles>
</bug>
<bug id="145693" transactionid="68272">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V</fullfingerprint>
<bugreport>See attached failing testCase.</bugreport>
<testsforfix ID="145693" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testAtajInheritance_pr149305_1"/>
      <test NAME="testAtajInheritance_pr149305_2"/>
      <test NAME="testAtajInheritance_pr149305_3"/>
      <test NAME="testIncorrectAnnotationValue_pr148537"/>
      <test NAME="testVerifyErrNoTypeCflowField_pr145693_1"/>
      <test NAME="testVerifyErrInpathNoTypeCflowField_pr145693_2"/>
      <test NAME="testCpathNoTypeCflowField_pr145693_3"/>
      <test NAME="testVisibilityProblem_pr149071"/>
      <test NAME="testAdviceNotWovenAspectPath_pr147841"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/145693/pre-fix/testresults.xml" passing="1850" size="2036"/>
<post-fix-testcases failing="184" file="output/145693/post-fix/testresults.xml" passing="1852" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java" revision="1.107" state="changed">674,675c674,677
&lt; 		List cp = buildConfig.getBootclasspath();
&lt; 		cp.addAll(buildConfig.getClasspath());
---
&gt; 		List cp = 
&gt; 		buildConfig.getFullClasspath(); // pr145693
&gt; 		//buildConfig.getBootclasspath();
&gt; 		//cp.addAll(buildConfig.getClasspath());
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.8" state="changed">25,27c25,27
&lt;   public void testAtajInheritance_pr149305_1() { runTest("ataj inheritance - 1");}
&lt;   public void testAtajInheritance_pr149305_2() { runTest("ataj inheritance - 2");}
&lt;   public void testAtajInheritance_pr149305_3() { runTest("ataj inheritance - 3");}
---
&gt;   public void testAtajInheritance_pr149305_1()     { runTest("ataj inheritance - 1");}
&gt;   public void testAtajInheritance_pr149305_2()     { runTest("ataj inheritance - 2");}
&gt;   public void testAtajInheritance_pr149305_3()     { runTest("ataj inheritance - 3");}
32,36c32,37
&lt;   public void testIncorrectAnnotationValue_pr148537()    { runTest("incorrect annotation value");}
&lt;   public void testVerifyErrNoTypeCflowField_pr145693_1() {	runTest("verifyErrNoTypeCflowField"); }
&lt; //  public void testVerifyErrInpathNoTypeCflowField_pr145693_2() { runTest("verifyErrInpathNoTypeCflowField"); }
&lt; //  public void testCpathNoTypeCflowField_pr145693_3()     { runTest("cpathNoTypeCflowField"); }
&lt; 
---
&gt;   public void testIncorrectAnnotationValue_pr148537()          { runTest("incorrect annotation value");}
&gt;   public void testVerifyErrNoTypeCflowField_pr145693_1()       { runTest("verifyErrNoTypeCflowField"); }
&gt;   public void testVerifyErrInpathNoTypeCflowField_pr145693_2() { runTest("verifyErrInpathNoTypeCflowField"); }
&gt;   public void testCpathNoTypeCflowField_pr145693_3()           { runTest("cpathNoTypeCflowField"); }
&gt;   public void testVisibilityProblem_pr149071()                 { runTest("visiblity problem");}
&gt;   //public void testAdviceNotWovenAspectPath_pr147841() { runTest("advice not woven on aspectpath");}
</file>
</fixedFiles>
</bug>
<bug id="145950" transactionid="69241">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="3"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="P2"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-null M O-! O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<bugreport>-XaddSerialVersionUID fails to add a serialversionuid field to a type if Serializable isn't a direct parent.  this case fails:

class X implements I { } // X will not get the field if woven
interface I implements Serializable {}

this works:

class X implements Serializable {} // X will get the field if woven

there is a mistake in the code that checks for the serializable interface</bugreport>
<pre-fix-testcases failing="193" file="output/145950/pre-fix/testresults.xml" passing="1839" size="2032"/>
<post-fix-testcases failing="191" file="output/145950/post-fix/testresults.xml" passing="1841" size="2032"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java" revision="1.54" state="changed">1301a1302,1303
&gt; 		if (aType.getSignature().equals(UnresolvedType.SERIALIZABLE.getSignature())) return true;
&gt; 		
1304,1312c1306,1307
&lt; 			if (interfaces[i].getSignature().equals(UnresolvedType.SERIALIZABLE.getSignature())) {
&lt; 				return true;
&lt; 			} else {
&lt; 				if (interfaces[i].isMissing()) continue;
&lt; 				ResolvedType superInterface = interfaces[i].getSuperclass();
&lt; 				if (superInterface != null &amp;&amp; !superInterface.isMissing()) {
&lt; 					if (implementsSerializable(superInterface)) return true;
&lt; 				}
&lt; 			}
---
&gt; 			if (interfaces[i].isMissing()) continue;
&gt; 			if (implementsSerializable(interfaces[i])) return true;
</file>
</fixedFiles>
</bug>
<bug id="146546" transactionid="69592">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="2"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V Y</fullfingerprint>
<bugreport>As part of bug 141730 we need to remove the hard coded dependency on "|" in methods which use handles to get the filename. These methods are:

AsmManager.getFileName(String)
AspectJElementHierarchy.getFileName(String)</bugreport>
<pre-fix-testcases failing="197" file="output/146546/pre-fix/testresults.xml" passing="1838" size="2035"/>
<post-fix-testcases failing="190" file="output/146546/post-fix/testresults.xml" passing="1845" size="2035"/>
<fixedFiles>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java" revision="1.24" state="changed">447d446
&lt;     // XXX shouldn't be aware of the delimiter
449c448
&lt; 		return hid.substring(0,hid.indexOf("|"));
---
&gt; 		return AsmManager.getDefault().getHandleProvider().getFileForHandle(hid);
</file>
<file name="org.aspectj/modules/asm/src/org/aspectj/asm/AsmManager.java" revision="1.24" state="changed">493d492
&lt; 	// XXX shouldn't be aware of the delimiter
495c494
&lt; 		return hid.substring(0,hid.indexOf("|"));
---
&gt; 		return getHandleProvider().getFileForHandle(hid);
</file>
</fixedFiles>
</bug>
<bug id="147701" transactionid="70071">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if M O-! O-+ T V Y Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>This is my code:

@Aspect
public class TestBeanAdvice {

    public static class ApplicationContextAwareImpl implements ApplicationContextAware {
        public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {

        }
    }

    @DeclareParents(value="org.springframework.beans.TestBean", defaultImpl=TestBeanAdvice.ApplicationContextAwareImpl.class)
    private ApplicationContextAware implementationInterface;
}

If I use this advice with the load-time weaver I get this exception:

org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'testBean' defined in class path resource [org/springframework/context/support/testbean-context.xml]: Instantiation of bean failed; nested exception is java.lang.NoClassDefFoundError: BeansException
Caused by: java.lang.NoClassDefFoundError: BeansException
	at java.lang.Class.getDeclaredMethods0(Native Method)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2365)
	at java.lang.Class.getDeclaredMethods(Class.java:1763)
	at java.beans.Introspector$1.run(Introspector.java:1265)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.beans.Introspector.getPublicDeclaredMethods(Introspector.java:1263)
	at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1129)
	at java.beans.Introspector.getBeanInfo(Introspector.java:387)
	at java.beans.Introspector.getBeanInfo(Introspector.java:159)
	at org.springframework.beans.CachedIntrospectionResults.&lt;init&gt;(CachedIntrospectionResults.java:142)
	at org.springframework.beans.CachedIntrospectionResults.forClass(CachedIntrospectionResults.java:83)
	at org.springframework.beans.BeanWrapperImpl.setIntrospectionClass(BeanWrapperImpl.java:238)
	at org.springframework.beans.BeanWrapperImpl.setWrappedInstance(BeanWrapperImpl.java:196)
	at org.springframework.beans.BeanWrapperImpl.setWrappedInstance(BeanWrapperImpl.java:179)
	at org.springframework.beans.BeanWrapperImpl.&lt;init&gt;(BeanWrapperImpl.java:132)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:502)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:356)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:256)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:167)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:253)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:332)
	at org.springframework.context.support.AspectJClassLoaderWithGenericApplicationContextTests.testCreateApplicationContextWithBeanFactoryAndAspectJClassLoader(AspectJClassLoaderWithGenericApplicationContextTests.java:63)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)

(wrapped in a Spring exception, I'm using the container)

After doing some debugging I found the exception appears when loading the dependencies of the TestBean class, so I guess there's a problem with the way the parent is declared in the bytecode of TestBean.

You can find the TestBean class here:

http://fisheye1.cenqua.com/browse/~raw,r=1.28/springframework/spring/test/org/springframework/beans/TestBean.java

Steven</bugreport>
<testsforfix ID="147701" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testPackageIgnoredForException_pr147701_1"/>
      <test NAME="testPackageIgnoredForException_pr147701_2"/>
      <test NAME="testPackageIgnoredForException_pr147701_3"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="package for exception ignored"/>
      <test NAME="package for exception ignored - 2"/>
      <test NAME="package for exception ignored - 3"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/147701/pre-fix/testresults.xml" passing="1849" size="2036"/>
<post-fix-testcases failing="186" file="output/147701/post-fix/testresults.xml" passing="1850" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java" revision="1.40" state="changed">736a737,739
&gt;                             if (!fieldType.isAssignableFrom(impl)) {
&gt;                             	reportError("@DeclareParents: defaultImpl=\""+defaultImplClassName+"\" does not implement the interface '"+fieldType.toString()+"'",struct);
&gt;                             }
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWorld.java" revision="1.46" state="changed">230c230
&lt;             ret[i] = types[i].getClassName();//makeBcelType(types[i]);
---
&gt;             ret[i] = types[i].getName();
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.79" state="changed">1171d1170
&lt;             // XXX make sure to check that we set exceptions properly on this guy.
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.47" state="changed">34a35,37
&gt;   public void testPackageIgnoredForException_pr147701_1() { runTest("package for exception ignored");}
&gt;   public void testPackageIgnoredForException_pr147701_2() { runTest("package for exception ignored - 2");}
&gt;   public void testPackageIgnoredForException_pr147701_3() { runTest("package for exception ignored - 3");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.41" state="changed">632a633,648
&gt;     
&gt;     &lt;ajc-test dir="bugs152/pr147701" title="package for exception ignored"&gt;
&gt;       &lt;compile files="TestBean.java" options="-1.5"/&gt;
&gt;       &lt;run class="a.b.c.TestBean"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs152/pr147701" title="package for exception ignored - 2"&gt;
&gt;       &lt;compile files="TestBean2.java" options="-1.5"/&gt;
&gt;       &lt;run class="a.b.c.TestBean2"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs152/pr147701" title="package for exception ignored - 3"&gt;
&gt;       &lt;compile files="TestBean3.java" options="-1.5"&gt;
&gt;         &lt;message kind="error" text="@DeclareParents: defaultImpl=&amp;quot;a.b.c.Impl&amp;quot; does not implement the interface 'a.b.c.I'"/&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
</file>
</fixedFiles>
</bug>
<bug id="147801" transactionid="69650">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="15"/>
<property name="lines-added" value="6"/>
<property name="lines-deleted" value="4"/>
<property name="lines-modified" value="15"/>
<property name="lines-churned" value="25"/>
<property name="priority" value="P3"/>
<property name="severity" value="minor"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if M T V Y Z-if</fullfingerprint>
<bugreport>I get a ClassFormatError trying to perform runtime-weaving on a DB2 class.
The class being woven is COM.ibm.db2.jdbc.app.DB2PreparedStatement.  
The full message exception is: java.lang.ClassFormatError: Repetitive method name/signature in class file COM/ibm/db2/jdbc/app/DB2PreparedStatement.

In examining the post-weave class file, it looks as if Aspectj is defining
a duplicate method within the class called getParameterMetaData().  

Here are the messages from the weaver:
04:21:13,640 INFO  [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2CallableStatement'
04:21:13,640 INFO  [STDOUT] info weaver operating in reweavable mode.  Need to verify any required types exist.
04:21:13,671 INFO  [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2PreparedStatement'
04:21:13,671 INFO  [STDOUT] info weaver operating in reweavable mode.  Need to verify any required types exist.
04:21:13,703 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:747) [with runtime test]
04:21:13,703 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test]
04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterThrowing advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:971) [with runtime test]
04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:833) [with runtime test]
04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test]</bugreport>
<testsforfix ID="147801" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testDuplicateBridgeMethods_pr147801_1"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="duplicate bridge methods"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/147801/pre-fix/testresults.xml" passing="1849" size="2036"/>
<post-fix-testcases failing="192" file="output/147801/post-fix/testresults.xml" passing="1844" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.86" state="changed">114a115
&gt; 	public boolean forDEBUG_bridgingCode = false;
758a760
&gt; 	public final static String xsetDEBUG_BRIDGING = "debugBridging"; // default false
1139,1141c1141,1150
&lt; 	        		runMinimalMemory = s.equalsIgnoreCase("true");
&lt; //	        		if (runMinimalMemory) 
&lt; //	        			getMessageHandler().handleMessage(MessageUtil.info("[runMinimalMemory=true] Optimizing bcel processing (and cost of performance) to use less memory"));
---
&gt;         		runMinimalMemory = s.equalsIgnoreCase("true");
&gt; //	        	if (runMinimalMemory) 
&gt; //	        		getMessageHandler().handleMessage(MessageUtil.info("[runMinimalMemory=true] Optimizing bcel processing (and cost of performance) to use less memory"));
&gt;         		
&gt;         		
&gt;         		s = p.getProperty(xsetDEBUG_STRUCTURAL_CHANGES_CODE,"false");
&gt;         		forDEBUG_structuralChangesCode = s.equalsIgnoreCase("true");
&gt;         		
&gt;         		s = p.getProperty(xsetDEBUG_BRIDGING,"false");
&gt;         		forDEBUG_bridgingCode = s.equalsIgnoreCase("true");
1143,1148c1152,1153
&lt; 	        		
&lt; 	        		s = p.getProperty(xsetDEBUG_STRUCTURAL_CHANGES_CODE,"false");
&lt; 	        		forDEBUG_structuralChangesCode = s.equalsIgnoreCase("true");
&lt; 	        		
&lt; 	    		}
&lt; 	        	checkedAdvancedConfiguration=true;
---
&gt;     		}
&gt;         	checkedAdvancedConfiguration=true;
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java" revision="1.75" state="changed">412c412
&lt; 			  if (debug) System.err.println("Cast "+newParamTypes[i]+" from "+paramTypes[i]);
---
&gt; 			  if (world.forDEBUG_bridgingCode) System.err.println("Bridging: Cast "+newParamTypes[i]+" from "+paramTypes[i]);
555,558d554
&lt;     // debug flag for bridge method creation
&lt; 	public static boolean debug=false;
&lt;     
&lt; 	
574c570
&lt; 		if (debug) System.err.println("  Seriously considering this might be getting overridden "+methodThatMightBeGettingOverridden);
---
&gt; 		if (typeToCheck.getWorld().forDEBUG_bridgingCode) System.err.println("  Bridging:seriously considering this might be getting overridden '"+methodThatMightBeGettingOverridden+"'");
593c589,594
&lt; 	    		return methodThatMightBeGettingOverridden; // covariance
---
&gt; 	    	    // addressing the wierd situation from bug 147801
&gt; 	    		// just check whether these things are in the right relationship for covariance...
&gt; 	    		ResolvedType superReturn = typeToCheck.getWorld().resolve(UnresolvedType.forSignature(methodThatMightBeGettingOverridden.getReturnType().getErasureSignature()));
&gt; 	    		ResolvedType subReturn   = typeToCheck.getWorld().resolve(UnresolvedType.forSignature(mrettype));
&gt; 	    		if (superReturn.isAssignableFrom(subReturn)) 
&gt; 	    			return methodThatMightBeGettingOverridden;
627c628
&lt;     	if (debug) System.err.println("  Checking for override of "+mname+" in "+typeToCheck);
---
&gt;     	if (typeToCheck.getWorld().forDEBUG_bridgingCode) System.err.println("  Bridging:checking for override of "+mname+" in "+typeToCheck);
646c647
&lt; 					if (debug) System.err.println("Possible ITD candidate "+element);
---
&gt; 					if (typeToCheck.getWorld().forDEBUG_bridgingCode) System.err.println("Possible ITD candidate "+element);
677a679
&gt; 	    world.ensureAdvancedConfigurationProcessed();
707c709
&lt; 			if (debug) System.err.println("Determining if we have to bridge to "+clazz.getName()+"."+name+""+bridgeToCandidate.getSignature());
---
&gt; 			if (world.forDEBUG_bridgingCode) System.err.println("Bridging: Determining if we have to bridge to "+clazz.getName()+"."+name+""+bridgeToCandidate.getSignature());
711c713
&lt; 			if (debug) System.err.println("Checking supertype "+theSuperclass);
---
&gt; 			if (world.forDEBUG_bridgingCode) System.err.println("Bridging: Checking supertype "+theSuperclass);
718c720
&lt; 					if (debug) System.err.println("Bridging to "+overriddenMethod);
---
&gt; 					if (world.forDEBUG_bridgingCode) System.err.println("Bridging:bridging to '"+overriddenMethod+"'");
728c730
&lt; 				if (debug) System.err.println("Checking superinterface "+interfaces[j]);
---
&gt; 				if (world.forDEBUG_bridgingCode) System.err.println("Bridging:checking superinterface "+interfaces[j]);
736c738
&lt; 						if (debug) System.err.println("Bridging to "+overriddenMethod);
---
&gt; 						if (world.forDEBUG_bridgingCode) System.err.println("Bridging:bridging to "+overriddenMethod);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.49" state="changed">34a35
&gt;   public void testDuplicateBridgeMethods_pr147801_1() { runTest("duplicate bridge methods");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.43" state="changed">722a723,732
&gt;    &lt;ajc-test dir="bugs152/pr147801" title="duplicate bridge methods"&gt;
&gt;       &lt;compile files="Advisor.aj" inpath="foo.jar" options="-1.5"/&gt;
&gt;       &lt;run class="Foo"&gt;
&gt;         &lt;stderr&gt;
&gt;           &lt;line text="x"/&gt;
&gt;           &lt;line text="1) public Sub Foo.getParameterMetaData() throws MyException"/&gt;
&gt;         &lt;/stderr&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs152/pr147801/Advisor.aj" revision="1.1" state="new">public aspect Advisor {

  before(): staticinitialization(*oo) {
    System.err.println("x");
  }

  declare parents: Foo implements java.io.Serializable;
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr147801/aop.xml" revision="1.1" state="new">&lt;aspectj&gt;
 &lt;weaver options="-verbose"/&gt;
    &lt;aspects&gt;
      &lt;aspect name="Advisor"/&gt;
    &lt;/aspects&gt;
&lt;/aspectj&gt;
</file>
<file name="org.aspectj/modules/tests/bugs152/pr147801/Foo.java" revision="1.1" state="new">import java.lang.reflect.Method;

public class Foo  implements PreparedStatement {

  public static void main(String []argv) throws Exception {
    new Foo().getParameterMetaData();
    Method[] m = Foo.class.getMethods();
    int count = 1;
    for (int i = 0; i &lt; m.length; i++) {
		Method method = m[i];
		if (method.toString().indexOf("Foo.getParameterMetaData")!=-1)
			System.err.println((count++)+") "+method);
	}
  }
  public Sub getParameterMetaData() throws MyException {
     return null;
  }
}

class Sub {}

interface PreparedStatement {
//   public ParameterMetaData getParameterMetaData() throws MyException;
}

class MyException extends Exception {}

interface ParameterMetaData {}

interface SubParameterMetaData extends ParameterMetaData {}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr147801/foo.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/bugs152/pr147801/PreparedStatement.java" revision="1.1" state="new">interface PreparedStatement {
   public ParameterMetaData getParameterMetaData() throws MyException;
}
</file>
<file name="org.aspectj/modules/tests/bugs152/pr147801/readme.txt" revision="1.1" state="new"/>
</fixedFiles>
</bug>
<bug id="148388" transactionid="74351">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M O-+ T V Y</fullfingerprint>
<bugreport>Using the code in bug #148381 (with any of the working options), LT weaver 
produces what seems a debug message:
"? WeavingClassFileProvider.acceptResult() test.Main-&gt;test.Main$AjcClosure1"

&gt; java -javaagent:%ASPECTJ_LIB_HOME%\aspectjweaver.jar test.Main
? WeavingClassFileProvider.acceptResult() test.Main-&gt;test.Main$AjcClosure1
Method Main.foo() took longer than expected
        Max expected = 1000, actual = 65371</bugreport>
<pre-fix-testcases failing="187" file="output/148388/pre-fix/testresults.xml" passing="1849" size="2036"/>
<post-fix-testcases failing="187" file="output/148388/post-fix/testresults.xml" passing="1849" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.32" state="changed">515d514
&lt; 						System.err.println("? WeavingClassFileProvider.acceptResult() " + wovenClass.getClassName() + "-&gt;" + className);
</file>
</fixedFiles>
</bug>
<bug id="148409" transactionid="69753">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="9"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="9"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-instanceof K-new K-throw M O-+ O-cast O-instanceof T V Y Z-cast Z-if Z-throw</fullfingerprint>
<tag>exception</tag>
<bugreport>I am using AspectJ load time weaving with Spring 2.0 RC1 to inject my entities, and I am getting the following exception:

java.lang.ClassCastException: org.aspectj.apache.bcel.classfile.Signature$TypeVariableSignature
	at org.aspectj.weaver.UnresolvedType.forGenericTypeSignature(UnresolvedType.java:348)
	at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:385)
	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.accept(ClassLoaderWeavingAdaptor.java:492)
	at org.aspectj.weaver.tools.WeavingAdaptor.shouldWeave(WeavingAdaptor.java:230)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:210)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)
	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
	at java.lang.ClassLoader.defineClass1(Native Method)

.
.
.

Having examined the call stack under the debugger, this seems to happening when the weaver is attempting to determine whether a particular class should be weaved. The exception is thrown in the following method, at the cast highlighted below.


    public static UnresolvedType forGenericTypeSignature(String sig,String declaredGenericSig) {
    	UnresolvedType ret = UnresolvedType.forSignature(sig);
    	ret.typeKind=TypeKind.GENERIC;
    	
    	ClassSignature csig = new GenericSignatureParser().parseAsClassSignature(declaredGenericSig);
    	
    	Signature.FormalTypeParameter[] ftps = csig.formalTypeParameters;
    	ret.typeVariables = new TypeVariable[ftps.length];
    	for (int i = 0; i &lt; ftps.length; i++) {
			Signature.FormalTypeParameter parameter = ftps[i];
			Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound; // EXCEPTION HERE!
			ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+";"));
		}
    	ret.signatureErasure = sig;
    	ret.signature = ret.signatureErasure;
    	return ret;
    }


The class in question (which is not one that requires weaving), has the following signature:

public class HibernateEntityDAO&lt;interfaceT extends SecurityEntity, concreteT extends interfaceT&gt; extends HibernateDaoSupport
        implements EntityDAO&lt;interfaceT&gt;
 
The exception is happening because the parameter.classBound member is not of type Signature.ClassTypeSignature, but an instance of Signature.TypeVariableSignature.

The loop variable i is 1, and parameter.identifier is concreteT, so it looks like it's the signature of the second type parameter (concreteT) that is tripping up the weaver.</bugreport>
<testsforfix ID="148409" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testVisibilityProblem_pr149071"/>
      <test NAME="testAdviceNotWovenAspectPath_pr147841"/>
      <test NAME="testGenericSignatures_pr148409"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="generic signature problem"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="189" file="output/148409/pre-fix/testresults.xml" passing="1847" size="2036"/>
<post-fix-testcases failing="116" file="output/148409/post-fix/testresults.xml" passing="1149" size="1265"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/UnresolvedType.java" revision="1.28" state="changed">349,350c349,359
&lt; 			Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound;
&lt; 			ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+";"));
---
&gt; 			if (parameter.classBound instanceof Signature.ClassTypeSignature) {
&gt; 				Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound;
&gt; 				ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+";"));
&gt; 			} else if (parameter.classBound instanceof Signature.TypeVariableSignature) {
&gt; 				Signature.TypeVariableSignature tvs = (Signature.TypeVariableSignature)parameter.classBound;
&gt; 				UnresolvedTypeVariableReferenceType utvrt = new UnresolvedTypeVariableReferenceType(new TypeVariable(tvs.typeVariableName));
&gt; 				ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,utvrt);
&gt; 			} else {
&gt; 			  throw new BCException("UnresolvedType.forGenericTypeSignature(): Do not know how to process type variable bound of type '"+
&gt; 					  parameter.classBound.getClass()+"'.  Full signature is '"+sig+"'");
&gt; 			}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.10" state="changed">36,37c36,38
&lt;   //public void testVisibilityProblem_pr149071()                 { runTest("visibility problem");}
&lt;   //public void testAdviceNotWovenAspectPath_pr147841() { runTest("advice not woven on aspectpath");}
---
&gt;   // public void testVisibilityProblem_pr149071()                 { runTest("visibility problem");}
&gt;   // public void testAdviceNotWovenAspectPath_pr147841()          { runTest("advice not woven on aspectpath");}
&gt;   public void testGenericSignatures_pr148409()                 { runTest("generic signature problem"); }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.9" state="changed">77a78,83
&gt;      &lt;ajc-test dir="bugs153/pr148409" title="generic signature problem"&gt;
&gt;       &lt;compile files="Blurgh.java" options="-1.5"/&gt;
&gt;       &lt;compile files="X.java" options="-1.5 -Xlint:ignore"/&gt;
&gt;       &lt;run class="Blurgh" options="-1.5" ltw="aop.xml"/&gt;
&gt;     &lt;/ajc-test&gt;    
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs153/pr148409/X.java" revision="1.1" state="new">aspect X {
  before(): staticinitialization(Fo*) { }
  before(): call(Fo*.new(..)) { }
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr148409/Blurgh.java" revision="1.1" state="new">

interface SecurityEntity {}
class Goo {}
interface Base {}
interface Hoo&lt;X&gt; { public void m(X x);}

class Foo&lt;B extends Base, C extends B&gt; extends Goo implements Hoo&lt;B&gt; {

  public void m(B b) {
  }
}


interface Interface1 extends Base {}

class Impl1 implements Interface1 {}




public class Blurgh {
  public static void main(String []argv) {
    new Foo&lt;Interface1,Impl1&gt;();
   }
}

</file>
<file name="org.aspectj/modules/tests/bugs153/pr148409/aop.xml" revision="1.1" state="new">&lt;aspectj&gt;
    &lt;aspects&gt;
         &lt;aspect name="X"/&gt; 
    &lt;/aspects&gt;
&lt;/aspectj&gt;
</file>
</fixedFiles>
</bug>
<bug id="148536" transactionid="69733">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null O-!= T V Y Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>public aspect Bug {
	declare @type : Object+ : @SomeAnnotation;
}

If SomeAnnotation cannot be found, this aspect produces an internal compiler error:

java.lang.NullPointerException
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:806)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:592)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:363)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:214)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</bugreport>
<pre-fix-testcases failing="186" file="output/148536/pre-fix/testresults.xml" passing="1850" size="2036"/>
<post-fix-testcases failing="187" file="output/148536/post-fix/testresults.xml" passing="1849" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java" revision="1.66" state="changed">806c806,807
&lt; 			abits = toAdd[0].resolvedType.getAnnotationTagBits();
---
&gt; 			if (toAdd[0].resolvedType!=null) // pr148536
&gt; 			  abits = toAdd[0].resolvedType.getAnnotationTagBits();
</file>
</fixedFiles>
</bug>
<bug id="148537" transactionid="68874">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="0"/>
<property name="classes-churned" value="0"/>
<property name="methods-churned" value="0"/>
<property name="hunks" value="0"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="0"/>
<property name="priority" value="P3"/>
<property name="severity" value="trivial"/>
<concisefingerprint/>
<fullfingerprint/>
<tag>exception</tag>
<bugreport>MyClass.java
============
public class MyClass {

	@Retention({RententionPolicy.RUNTIME})
	private @interface MyAnnotation {
	}
}

---

MyAspect.aj
===========
privileged public aspect MyAspect {

	declare @type : MyClass+ : @MyClass.MyAnnotation;

}

---

Internal Compiler Error:

java.lang.ClassCastException
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.detectStandardAnnotation(Annotation.java:99)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:280)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.getAnnotationTagBits(SourceTypeBinding.java:743)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:331)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding.getAnnotationTagBits(MethodBinding.java:450)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1268)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1081)
at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.checkSpec(AspectDeclaration.java:131)
at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1070)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:463)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:332)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:173)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

ClassCastException thrown: org.aspectj.org.eclipse.jdt.internal.compiler.ast.ArrayInitializer</bugreport>
<pre-fix-testcases failing="186" file="output/148537/pre-fix/testresults.xml" passing="1850" size="2036"/>
<post-fix-testcases failing="187" file="output/148537/post-fix/testresults.xml" passing="1849" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/org.eclipse.jdt.core/jdtcore-for-aspectj.jar" revision="1.84" state="changed"/>
<file name="org.aspectj/modules/org.eclipse.jdt.core/jdtcore-for-aspectj-src.zip" revision="1.82" state="changed"/>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.6" state="changed">32c32
&lt;  // public void testIncorrectAnnotationValue_pr148537() { runTest("incorrect annotation value");}
---
&gt;   public void testIncorrectAnnotationValue_pr148537() { runTest("incorrect annotation value");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.5" state="changed">46c46,48
&lt; 		&lt;compile files="MyClass.java" options="-1.5"/&gt;
---
&gt; 		&lt;compile files="MyClass.java" options="-1.5"&gt;
&gt; 		  &lt;message kind="error" line="5" text="Type mismatch: cannot convert from RetentionPolicy[] to RetentionPolicy"/&gt;
&gt; 		&lt;/compile&gt;
</file>
<file name="org.aspectj/modules/tests/bugs153/pr148537/MyClass.java" revision="1.2" state="changed">5c5
&lt;         @Retention({RententionPolicy.RUNTIME})
---
&gt;         @Retention({RetentionPolicy.RUNTIME})
</file>
</fixedFiles>
</bug>
<bug id="148545" transactionid="69106">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="7"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-instanceof K-null M O-() O-cast O-instanceof T V Z-cast Z-if</fullfingerprint>
<bugreport>MyEnum.java
===========
public enum MyEnum {
	ONE, TWO, THREE, FOUR, FIVE
}

---

MyAnnotation.java
=================
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
	MyEnum[] value();
}

---

MyClass.java
============
public class MyClass {

	public MyEnum getValue() {
		return MyEnum.ONE;
	}

	@MyAnnotation({ MyEnum.ONE, MyEnum.TWO })
	public void test() {
	}

	public static void main(String[] args) {
		new MyClass().test();
	}
}

---

MyAspect.aj
===========
import java.util.Arrays;

privileged public aspect MyAspect {

	Object around(MyClass o, MyAnnotation a) :
			execution(@MyAnnotation * *(..)) &amp;&amp;
			target(o) &amp;&amp;
			@annotation(a) {
		if (!isOneOf(o.getValue(), a.value()))
			throw new IllegalStateException(
					o.getValue() +
					" is not one of " +
					Arrays.toString(a.value()));
		return proceed(o, a);
	}

	private static final &lt;T&gt; boolean isOneOf(T obj, T[] arr) {
		for (T el : arr) if (obj == el) return true;
		return false;
	}
}

---

Executing the main method of MyClass produces:

Exception in thread "main" java.lang.NoSuchMethodError: MyAspect.isOneOf(LMyEnum;[LMyEnum;)Z
	at MyAspect.ajc$privMethod$MyAspect$MyAspect$isOneOf(MyAspect.aj:1)
	at MyClass.test_aroundBody1$advice(MyClass.java:109)
	at MyClass.test(MyClass.java:1)
	at MyClass.main(MyClass.java:12)

---

What's interesting is that if you remove the "privileged" modifier from the aspect definition, then it works fine.</bugreport>
<pre-fix-testcases failing="186" file="output/148545/pre-fix/testresults.xml" passing="1850" size="2036"/>
<post-fix-testcases failing="189" file="output/148545/post-fix/testresults.xml" passing="1847" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java" revision="1.19" state="changed">35a36
&gt; import org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding;
60c61,67
&lt; 		ResolvedMember key = inAspect.factory.makeResolvedMember(baseMethod);
---
&gt; 		ResolvedMember key = null;
&gt; 		
&gt; 		if (baseMethod instanceof ParameterizedMethodBinding) {
&gt; 			key = inAspect.factory.makeResolvedMember(((ParameterizedMethodBinding)baseMethod).original());
&gt; 		} else {
&gt; 			key = inAspect.factory.makeResolvedMember(baseMethod);
&gt; 		}
</file>
</fixedFiles>
</bug>
<bug id="148693" transactionid="69905">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="5"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="5"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-false K-if O-== T V Y Z-if</fullfingerprint>
<bugreport>'Number of LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public static mypackage.MyAspect aspectOf() [(Unknown attribute org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots '0' ('There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.').'.

=================================================
package mypackage; 

public aspect MyAspect { 

    pointcut executeMethod(): within(TestClass) &amp;&amp; execution(* *(..)); 

    before(): executeMethod() { 
     System.out.println("Enter "+thisJoinPointStaticPart); 
    } 
    after(): executeMethod() { 
     System.out.println("Leave "+thisJoinPointStaticPart); 
    } 
} 

class TestClass { 

public static void main(String[] args) { 
} 

} 

================================================
JustIce by Enver Haase, (C) 2001-2002. 
&lt;http://bcel.sourceforge.net&gt; 
&lt;http://jakarta.apache.org/bcel&gt; 

Now verifying: mypackage.TestClass 

Pass 1: 
VERIFIED_OK 
Passed verification. 

Pass 2: 
VERIFIED_OK 
Passed verification. 

Pass 3a, method number 0 ['public void &lt;init&gt;()']: 
VERIFIED_OK 
Passed verification. 

Pass 3b, method number 0 ['public void &lt;init&gt;()']: 
VERIFIED_OK 
Passed verification. 

Pass 3a, method number 1 ['public static void main(String[] args) [(Unknown 
attribute org.aspectj.weaver.MethodDeclarationLineNumber: 
00 00 00 05 00 00 00 46)]']: 
VERIFIED_REJECTED 
Instruction invokestatic[184](3) 28 constraint violated: Return type 
class/interface could not be verified successfully: 'Number of 
LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public 
static mypackage.MyAspect aspectOf() [(Unknown attribute 
org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots 
'0' ('There may be no more than one LocalVariableTable attribute per local 
variable in the Code attribute.').'. 

Pass 3b, method number 1 ['public static void main(String[] args) [(Unknown 
attribute org.aspectj.weaver.MethodDeclarationLineNumber: 
00 00 00 05 00 00 00 46)]']: 
VERIFIED_NOTYET 
Not yet verified. 

Pass 3a, method number 2 ['static void &lt;clinit&gt;()']: 
VERIFIED_OK 
Passed verification. 

Pass 3b, method number 2 ['static void &lt;clinit&gt;()']: 
VERIFIED_OK 
Passed verification. 

Warnings: 
Pass 2: Attribute '(Unknown attribute 
org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 
00 00... (truncated))' as an attribute of the ClassFile structure 'public 
class mypackage.TestClass extends java.lang.Object 
filename  mypackage.TestClass 
compiled from  TestClass.java 
compiler version 46.0 
access flags  33 
constant pool  69 entries 
ACC_SUPER flag  true 

Attribute(s): 
SourceFile(TestClass.java) 
(Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 
00 00 00 00 00 00 00 00... (truncated)) 
(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 
79 70... (truncated)) 

1 fields: 
private static final org.aspectj.lang.JoinPoint$StaticPart 
ajc$tjp_0 

3 methods: 
public void &lt;init&gt;() 
public static void main(String[] args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)] 
static void &lt;clinit&gt;() 
' is unknown and will therefore be ignored. 
Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 
00 00 01 00 12 6d 79 70... (truncated))' as an attribute of the ClassFile 
structure 'public class mypackage.TestClass extends java.lang.Object 
filename  mypackage.TestClass 
compiled from  TestClass.java 
compiler version 46.0 
access flags  33 
constant pool  69 entries 
ACC_SUPER flag  true 

Attribute(s): 
SourceFile(TestClass.java) 
(Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 
00 00 00 00 00 00 00 00... (truncated)) 
(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 
79 70... (truncated)) 

1 fields: 
private static final org.aspectj.lang.JoinPoint$StaticPart 
ajc$tjp_0 

3 methods: 
public void &lt;init&gt;() 
public static void main(String[] args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)] 
static void &lt;clinit&gt;() 
' is unknown and will therefore be ignored. 
Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 0, length = 
5, index = 0:mypackage.TestClass this)&gt;' as an attribute of Code attribute 
'&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be ignored and is 
only useful for debuggers and such. 
Pass 2: Attribute '&lt;LineNumberTable: LineNumber(0, 3)&gt;' as an attribute of 
Code attribute '&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be 
ignored and is only useful for debuggers and such. 
Pass 2: Attribute '(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)' as an attribute of Method 'public static void main(String[] 
args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]' is unknown and will therefore be ignored. 
Pass 2: Attribute '(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)' as an attribute of Method 'public static void main(String[] 
args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]' is neither Code nor Exceptions and is therefore only of use 
for debuggers and such. 
Pass 2: Unknown attribute '(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)'. This attribute is not known in any context! 
Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 9, length = 
0, index = 0:String[] args)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' 
(method 'public static void main(String[] args) [(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]') will effectively be ignored and is only useful for debuggers 
and such. 
Pass 2: Attribute '&lt;LineNumberTable: LineNumber(9, 6)&gt;' as an attribute of 
Code attribute '&lt;CODE&gt;' (method 'public static void main(String[] args) 
[(Unknown attribute 
org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 
00 00 00 46)]') will effectively be ignored and is only useful for debuggers 
and such. 
Pass 2: Class or interface initialization method 'static void &lt;clinit&gt;()' 
has superfluous access modifier(s) set: everything but ACC_STRICT is 
ignored. 
Pass 2: Attribute '&lt;LineNumberTable: LineNumber(0, 1)&gt;' as an attribute of 
Code attribute '&lt;CODE&gt;' (method 'static void &lt;clinit&gt;()') will effectively 
be ignored and is only useful for debuggers and such. 
Pass 2: Unknown attribute '(Unknown attribute 
org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 
00 00... (truncated))'. This attribute is not known in any context! 
Pass 2: Unknown attribute '(Unknown attribute 
org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... 
(truncated))'. This attribute is not known in any context!</bugreport>
<testsforfix ID="148693" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testVerificationFailureForAspectOf_pr148693"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/148693/pre-fix/testresults.xml" passing="1850" size="2036"/>
<post-fix-testcases failing="185" file="output/148693/post-fix/testresults.xml" passing="1851" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java" revision="1.52" state="changed">436a437,439
&gt; 		boolean b = codeStream.generateLocalVariableTableAttributes; // pr148693
&gt; 		if (codeStream.maxLocals==0) 
&gt; 		  codeStream.generateLocalVariableTableAttributes=false;
437a441,442
&gt; 		codeStream.generateLocalVariableTableAttributes=b;
&gt; 		
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.4" state="changed">17,24c17
&lt; import org.aspectj.apache.bcel.Repository;
&lt; import org.aspectj.apache.bcel.classfile.JavaClass;
&lt; import org.aspectj.apache.bcel.classfile.Method;
&lt; import org.aspectj.apache.bcel.util.ClassPath;
&lt; import org.aspectj.apache.bcel.util.SyntheticRepository;
&lt; import org.aspectj.apache.bcel.verifier.VerificationResult;
&lt; import org.aspectj.apache.bcel.verifier.Verifier;
&lt; import org.aspectj.apache.bcel.verifier.VerifierFactory;
---
&gt; import org.aspectj.testing.Utils;
34a28,31
&gt;   public void testVerificationFailureForAspectOf_pr148693() {
&gt; 	runTest("verification problem");   // build the code
&gt; 	Utils.verifyClass(ajc,"mypackage.MyAspect"); // verify it &lt;&lt;&lt; BRAND NEW VERIFY UTILITY FOR EVERYONE TO TRY ;)
&gt;   }
36,90d32
&lt; 
&lt;   // work in progress
&lt; 
&lt; //	public void testVerificationFailureForAspectOf_pr148693() throws ClassNotFoundException {
&lt; //		runTest("verification problem");
&lt; //		verifyClass("mypackage.MyAspect");
&lt; //	}
&lt; 	
&lt; 
&lt; 	// TODO refactor into a util class
&lt; 	/**
&lt; 	 * Performs verification of a class - the supplied class is expected to exist in the sandbox
&lt; 	 * directory so typically this is called after a small compile step has been invoked to build it.
&lt; 	 */
&lt; 	public void verifyClass(String clazzname) {
&lt; 		JavaClass jc = null;
&lt; 		try {
&lt; 			jc = getClassFrom(ajc.getSandboxDirectory().getAbsolutePath(),clazzname);
&lt; 		} catch (ClassNotFoundException cnfe) {
&lt; 			fail("Could not find "+clazzname+" in the sandbox: "+ajc.getSandboxDirectory());
&lt; 		}
&lt; 		assertTrue("Could not find class",jc!=null);
&lt; 		Repository.setRepository(jc.getRepository());
&lt; 		Verifier v = VerifierFactory.getVerifier("mypackage.MyAspect"); 
&lt; 		VerificationResult vr = v.doPass1();
&lt; 		System.err.println(vr);
&lt; 		
&lt; 		assertTrue("Verification: "+vr,vr.getStatus()==VerificationResult.VERIFIED_OK);
&lt; 		vr = v.doPass2();
&lt; 		System.err.println(vr);
&lt; 		assertTrue("Verification: "+vr,vr.getStatus()==VerificationResult.VERIFIED_OK);
&lt; 		Method[] ms = jc.getMethods();
&lt; 		for (int i = 0; i &lt; ms.length; i++) {
&lt; 			System.err.println("Pass3a for "+ms[i]);
&lt; 			vr = v.doPass3a(i);
&lt; 			System.err.println(vr);
&lt; 			assertTrue("Verification: "+vr,vr.getStatus()==VerificationResult.VERIFIED_OK);
&lt; 			System.err.println("Pass3b for "+ms[i]);
&lt; 			vr = v.doPass3b(i);
&lt; 			System.err.println(vr);
&lt; 			assertTrue("Verification: "+vr,vr.getStatus()==VerificationResult.VERIFIED_OK);
&lt; 		}
&lt; 	}
&lt; 	
&lt; 	protected  JavaClass getClassFrom(String frompath,String clazzname) throws ClassNotFoundException {
&lt; 		SyntheticRepository repos = createRepos(frompath);
&lt; 		return repos.loadClass(clazzname);
&lt; 	}
&lt; 
&lt; 	public SyntheticRepository createRepos(String cpentry) {
&lt; 		ClassPath cp = new ClassPath(
&lt; 				cpentry+File.pathSeparator+
&lt; 				System.getProperty("java.class.path"));
&lt; 		return SyntheticRepository.getInstance(cp);
&lt; 	}	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/testing/Utils.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
package org.aspectj.testing;

import java.io.File;

import org.aspectj.apache.bcel.Repository;
import org.aspectj.apache.bcel.classfile.JavaClass;
import org.aspectj.apache.bcel.classfile.Method;
import org.aspectj.apache.bcel.util.ClassPath;
import org.aspectj.apache.bcel.util.SyntheticRepository;
import org.aspectj.apache.bcel.verifier.VerificationResult;
import org.aspectj.apache.bcel.verifier.Verifier;
import org.aspectj.apache.bcel.verifier.VerifierFactory;
import org.aspectj.tools.ajc.Ajc;

/**
 * Not quite the right place for this class..
 */
public class Utils {
	
	private final static boolean debugVerification=false;
	
	/**
	 * Performs verification of a class - the supplied class is expected to exist in the sandbox
	 * directory so typically this is called after a small compile step has been invoked to build it.
	 * @param ajc 
	 */
	public static String verifyClass(Ajc ajc, String clazzname) {
		JavaClass jc = null;
		try {
			jc = getClassFrom(ajc.getSandboxDirectory().getAbsolutePath(),clazzname);
		} catch (ClassNotFoundException cnfe) {
			return "Could not find "+clazzname+" in the sandbox: "+ajc.getSandboxDirectory();
		}
		if (jc==null) return "Could not find class "+clazzname;
		Repository.setRepository(jc.getRepository());
		Verifier v = VerifierFactory.getVerifier("mypackage.MyAspect"); 
		VerificationResult vr = v.doPass1();
		if (debugVerification) System.err.println(vr);
		
		if (vr.getStatus()!=VerificationResult.VERIFIED_OK)
			return "Verification not ok: "+vr;
		vr = v.doPass2();
		if (debugVerification) System.err.println(vr);
		if (vr.getStatus()!=VerificationResult.VERIFIED_OK)
			return "Verification not ok: "+vr;
		Method[] ms = jc.getMethods();
		for (int i = 0; i &lt; ms.length; i++) {
			if (debugVerification) System.err.println("Pass3a for "+ms[i]);
			vr = v.doPass3a(i);
			if (debugVerification) System.err.println(vr);		
			if (vr.getStatus()!=VerificationResult.VERIFIED_OK)
				return "Verification not ok: "+vr;
			if (debugVerification) System.err.println("Pass3b for "+ms[i]);
			vr = v.doPass3b(i);
			if (debugVerification) System.err.println(vr);
			if (vr.getStatus()!=VerificationResult.VERIFIED_OK)
				return "Verification not ok: "+vr;
		}
		return null;
	}
	
	protected static JavaClass getClassFrom(String frompath,String clazzname) throws ClassNotFoundException {
		SyntheticRepository repos = createRepos(frompath);
		return repos.loadClass(clazzname);
	}

	public static SyntheticRepository createRepos(String cpentry) {
		ClassPath cp = new ClassPath(
				cpentry+File.pathSeparator+
				System.getProperty("java.class.path"));
		return SyntheticRepository.getInstance(cp);
	}	
}
</file>
</fixedFiles>
</bug>
<bug id="148727" transactionid="69593">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="6"/>
<property name="priority" value="P3"/>
<property name="severity" value="blocker"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-return K-true M O-|| T V Y Z-if</fullfingerprint>
<bugreport>Separate compilation of the following program breaks on 1.5.2rc1 because of the recent change to marking aspect methods as synthetic:

public aspect Asp {
}

public class Client {
    public static void main(String argz[]) {
        System.out.println("Can call aspectOf? "+Asp.aspectOf());
    }
}

C:\devel\scratch\synthetic&gt;ajc -classpath asp.jar;%CLASSPATH% Client.java
C:\devel\scratch\synthetic\Client.java:3 [error] The method aspectOf() is undefi
ned for the type Asp
System.out.println("Can call aspectOf? "+Asp.aspectOf());


1 error

C:\devel\scratch\synthetic&gt;javac -classpath asp.jar;%CLASSPATH% Client.java
Client.java:3: cannot find symbol
symbol  : method aspectOf()
location: class Asp
        System.out.println("Can call aspectOf? "+Asp.aspectOf());
                                                    ^
1 error

Clearly it's vital that external users of a library be able to call API methods like aspectOf on library aspects.

This works:

C:\devel\scratch\synthetic&gt;ajc *.aj Client.java

C:\devel\scratch\synthetic&gt;java Client
Can call aspectOf? Asp@b89838

Patch with test integrated into CVS tree to follow...</bugreport>
<testsforfix ID="148727" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testSeparateCallAspectOf_pr148727"/>
      <test NAME="testIntegratedCallAspectOf_pr148727"/>
      <test NAME="testIncorrectOverridesEvaluation14"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="incorrect overrides evaluation - 1.4"/>
      <test NAME="integrated compilation calling aspectOf and hasAspect"/>
      <test NAME="separate compilation calling aspectOf and hasAspect"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/148727/pre-fix/testresults.xml" passing="1850" size="2036"/>
<post-fix-testcases failing="186" file="output/148727/post-fix/testresults.xml" passing="1850" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/NameMangler.java" revision="1.22" state="changed">74,78c74,79
&lt; 		else if (declaredInAspect) {
&lt; 			if (methodName.equals("aspectOf") || methodName.equals("hasAspect")) {
&lt; 				return true;
&lt; 			}
&lt; 		} 
---
&gt; // these aren't the droids you're looking for...move along...... pr148727
&gt; //		else if (declaredInAspect) {
&gt; //			if (methodName.equals("aspectOf") || methodName.equals("hasAspect")) {
&gt; //				return true;
&gt; //			}
&gt; //		} 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.52" state="changed">383a384,393
&gt;     &lt;ajc-test dir="bugs152/binaryDecp" title="incorrect overrides evaluation - 1.4"&gt;
&gt;       &lt;compile files="IsItSynthetic.java" options="-1.5"/&gt;
&gt;       &lt;compile files="Top.java" options="-source 1.5 -target 1.5" outjar="a.jar"/&gt;
&gt;       &lt;compile files="Bottom.java" classpath="$sandbox/a.jar" options="-source 1.4 -target 1.4" outjar="b.jar"/&gt;
&gt;       &lt;compile files="Middle.java" classpath="$sandbox/a.jar" options="-source 1.4 -target 1.4" outjar="c.jar"/&gt;
&gt;       &lt;compile files="X2.aj" classpath="$sandbox/a.jar;$sandbox/b.jar;$sandbox/c.jar" options="-Xlint:ignore" outjar="x.jar"/&gt;
&gt;       &lt;run class="Bottom" classpath="a.jar;b.jar;c.jar;x.jar" ltw="aop.xml"/&gt;
&gt;         &lt;!--message kind="weave" text="Setting superclass of type 'Bottom' (Bottom.java) to 'Middle' (X2.aj)"/--&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
794a805,825
&gt;     
&gt;     &lt;ajc-test dir="bugs152/pr148727"  pr="148727"
&gt; 		title="integrated compilation calling aspectOf and hasAspect"  &gt;
&gt; 	    &lt;compile files="Asp.aj, Client.java" options="-source 1.4"/&gt;
&gt;         &lt;run class="Client"&gt;
&gt;           &lt;stdout&gt;
&gt;             &lt;line text="Can call aspectOf? Asp@"/&gt;
&gt;           &lt;/stdout&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs152/pr148727"  pr="148727"
&gt; 		title="separate compilation calling aspectOf and hasAspect"  &gt;
&gt; 	    &lt;compile files="Asp.aj" outjar="asp.jar"/&gt;
&gt; 	    &lt;compile files="Client.java" classpath="asp.jar" options="-source 1.4"/&gt;
&gt;         &lt;run class="Client"&gt;
&gt;           &lt;stdout&gt;
&gt;             &lt;line text="Can call aspectOf? Asp@"/&gt;
&gt;           &lt;/stdout&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.57" state="changed">37a38,39
&gt;   public void testSeparateCallAspectOf_pr148727() { runTest("separate compilation calling aspectOf and hasAspect"); }
&gt;   public void testIntegratedCallAspectOf_pr148727() { runTest("integrated compilation calling aspectOf and hasAspect"); }
99a102
&gt; //  public void testIncorrectOverridesEvaluation14() { runTest("incorrect overrides evaluation - 1.4"); }
</file>
<file name="org.aspectj/modules/tests/bugs152/pr148727/Asp.aj" revision="1.1" state="new">public aspect Asp {
}
</file>
<file name="org.aspectj/modules/tests/features152/synthetic/TheWholeShow.aj" revision="1.2" state="changed">60a61
&gt;         if (name.equals("aspectOf") || name.equals("hasAspect")) continue;
</file>
<file name="org.aspectj/modules/tests/bugs152/pr148727/Client.java" revision="1.1" state="new">public class Client {
    public static void main(String argz[]) {
        if (!Asp.hasAspect()) 
          throw new RuntimeException("ou est le aspect?");
        System.out.println("Can call aspectOf? "+Asp.aspectOf());
    }
}
</file>
</fixedFiles>
</bug>
<bug id="148737" transactionid="68832">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-|| T V Y Z-if</fullfingerprint>
<tag>exception</tag>
<bugreport>I believe this is similar to 112880.  The message and stack trace I am getting are

 -- (IllegalStateException) Can't ask to parameterize a member of non-generic type: com...object  kind(raw)
Can't ask to parameterize a member of non-generic type: com...object  kind(raw)
java.lang.IllegalStateException: Can't ask to parameterize a member of non-generic type: com....object  kind(raw)
	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:612)
	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597)
	at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508)
	at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:225)
	at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)
	at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171)
	at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)
	at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:345)
	at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:326)
.
.
.

The same code was able to be weaved under 1.5.0.  The reason why this is a major issue is 1.5.0 suffers from a StackOverflowException.</bugreport>
<testsforfix ID="148737" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testIllegalStateException_pr148737"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="illegalstateexception for non generic type"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="185" file="output/148737/pre-fix/testresults.xml" passing="1851" size="2036"/>
<post-fix-testcases failing="190" file="output/148737/post-fix/testresults.xml" passing="1846" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.55" state="changed">668c668
&lt;             		if (level.equals("1.5")){
---
&gt;             		if (level.equals("1.5") || level.equals("5")) {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.2" state="changed">16a17,22
&gt;     &lt;ajc-test dir="bugs153/pr148737" title="illegalstateexception for non generic type"&gt;
&gt;       &lt;compile files="A.java" options="-source 5 -target 5"&gt;
&gt;         &lt;message kind="warning" line="18" text="advice defined in TestAspect has not been applied"/&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.2" state="changed">22a23,24
&gt;   public void testIllegalStateException_pr148737() { runTest("illegalstateexception for non generic type");}
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs153/pr148737/A.java" revision="1.1" state="new">public abstract class A&lt;E&gt; {	
    public A() { }
    public void setUniqueID(Object o) {}
}

class B extends A {
    public B() {}    
}

class D {
    public void method() {
        B b = new B();
        b.setUniqueID(null);
    }
}

aspect TestAspect {
	before(): call(public void *.*()) { }    
}
</file>
</fixedFiles>
</bug>
<bug id="148786" transactionid="69851">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T</fullfingerprint>
<bugreport>Took me a while to discover how to recreate this problem, but this class:

public class A {
  public static void main(String []argv) {
    byte[][] bytes = new byte[][]{{0},{1}};
  }
}

causes this bytecode:

0:   iconst_2
1:   anewarray       #18; //class "[B"

and this causes the newarray joinpoint code to go bang.
(eg. before(): call(*[].new(..)) {})

java.lang.NullPointerException
        at org.aspectj.weaver.bcel.BcelWorld.fromBcel(BcelWorld.java:236)
        at org.aspectj.weaver.bcel.BcelWorld.makeJoinPointSignatureForArrayConstruction(BcelWorld.java:483)
        at org.aspectj.weaver.bcel.BcelShadow.makeArrayConstructorCall(BcelShadow.java:801)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2510)
        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2325)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:490)
        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525)
        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305)
        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)</bugreport>
<testsforfix ID="148786" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testFreakyNewArrayJoinpoint_pr148786"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="freaky new array joinpoint"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="185" file="output/148786/pre-fix/testresults.xml" passing="1851" size="2036"/>
<post-fix-testcases failing="186" file="output/148786/post-fix/testresults.xml" passing="1850" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelWorld.java" revision="1.47" state="changed">482c482
&lt; 			ObjectType ot = arrayInstruction.getLoadClassType(cpg);
---
&gt; 			Type ot = arrayInstruction.getType(cpg);
486d485
&lt; 			
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.56" state="changed">37a38
&gt;   public void testFreakyNewArrayJoinpoint_pr148786() { runTest("freaky new array joinpoint"); }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.51" state="changed">785a786,794
&gt;     
&gt;     &lt;ajc-test dir="bugs152/pr148786" title="freaky new array joinpoint"&gt;
&gt;         &lt;compile files="A.java" options="-Xjoinpoints:arrayconstruction"/&gt;
&gt;         &lt;run class="A"&gt;
&gt;           &lt;stderr&gt;
&gt;             &lt;line text="new array: class [[B"/&gt;
&gt;           &lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;    
</file>
<file name="org.aspectj/modules/tests/bugs152/pr148786/A.java" revision="1.1" state="new">public class A {
  public static void main(String []argv) {
    byte[][] bytes = new byte[][]{{0},{1}};
  }
}

aspect X {
  after() returning(Object o) : call(*[][].new(..)) {
    System.err.println("new array: "+o.getClass());
  }
}
</file>
</fixedFiles>
</bug>
<bug id="148908" transactionid="70171">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="21"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="22"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-instanceof K-new M O-+ O-cast O-instanceof T V Y Z-cast Z-if</fullfingerprint>
<bugreport>Ajdoc chokes on interfaces with initializers for final fields (it doesn't preserve the initializer value). See attached AJDT project that fails when you run ajdoc with the default options on it:

&gt; Calling ajc...
&gt; Building signature files...
&gt; Calling javadoc...
Loading source file C:\eclipse\3.2\ajdocworkingdir\BadInterface.java...
1 error
&gt; Decorating html files...
&gt; Removing generated tags (this may take a while)...
&gt; Finished.
C:\eclipse\3.2\ajdocworkingdir\BadInterface.java:9: = expected
static final Comparator MY_COMPARATOR;
                                     ^</bugreport>
<testsforfix ID="148908" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testGetSourceSignature_pr148908"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="ensure getSourceSignature correct with static field"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="71" file="output/148908/pre-fix/testresults.xml" passing="879" size="950"/>
<post-fix-testcases failing="189" file="output/148908/post-fix/testresults.xml" passing="1925" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java" revision="1.48" state="changed">666c666
&lt; 	 * Doesn't print qualified allocation expressions.
---
&gt; 	 * 
685a686,706
&gt; 		} else if (fieldDeclaration.initialization instanceof QualifiedAllocationExpression) {
&gt; 			output.append(" = "); //$NON-NLS-1$
&gt; 			QualifiedAllocationExpression qae = (QualifiedAllocationExpression)fieldDeclaration.initialization;
&gt; 			StringBuffer sb = new StringBuffer();
&gt; 			qae.printExpression(0,sb);
&gt; 			// if the source is of the form 'static I MY_I = new I() {};' calling 
&gt; 			// printExpression on the qae returns
&gt; 			//
&gt; 			// new I() {
&gt; 			//	   x() {
&gt; 			//	     super();
&gt; 			//	   }
&gt; 			// }
&gt; 			//
&gt; 			// We want to remove the x() {super();} call. Assuming that this
&gt; 			// is the first entry in the expression we can do this by finding
&gt; 			// the position of the "{" and "}" - bug 148908
&gt; 			int i = sb.toString().indexOf("{");
&gt; 			output.append(sb.substring(0,i+1));
&gt; 			int j = sb.toString().indexOf("}");
&gt; 			output.append(sb.substring(j+1));
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.41" state="changed">16a17,19
&gt; import org.aspectj.asm.AsmManager;
&gt; import org.aspectj.asm.IHierarchy;
&gt; import org.aspectj.asm.IProgramElement;
113c116,131
&lt;   /////////////////////////////////////////
---
&gt;   public void testGetSourceSignature_pr148908() {
&gt; 	runTest("ensure getSourceSignature correct with static field");
&gt; 	IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt; 	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
&gt; 	IProgramElement.Kind.FIELD,"MY_COMPARATOR");
&gt; 	String expected = "static final Comparator MY_COMPARATOR = new Comparator() {\n" +
&gt; 					"  public int compare(Object o1, Object o2) {\n" +
&gt; 					"    return 0;\n" +
&gt; 					"  }\n" +
&gt; 					"};";
&gt; 			assertEquals("expected source signature to be " + expected + 
&gt; 					" but found " + ipe.getSourceSignature(), 
&gt; 					expected, ipe.getSourceSignature());
&gt;   }
&gt;   
&gt;     /////////////////////////////////////////
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.42" state="changed">4a5,7
&gt; 	&lt;ajc-test dir="bugs153/pr148908" title="ensure getSourceSignature correct with static field"&gt;
&gt;       &lt;compile files="BadInterface.java" options="-emacssym"/&gt;
&gt;     &lt;/ajc-test&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs153/pr148908/BadInterface.java" revision="1.1" state="new">import java.util.Comparator;


public interface BadInterface {

    static final Comparator MY_COMPARATOR = new Comparator() {
        public int compare(Object o1, Object o2) {
            return 0;
        }
    };
}
</file>
</fixedFiles>
</bug>
<bug id="148972" transactionid="69415">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="7"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="7"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if M O-! O-() O-&amp;&amp; T V Y Z-if</fullfingerprint>
<bugreport>These have been reported to me on a large system doing some intricate weaving where some classes are 1.2, some 1.4, some 1.5 and the VM is 1.5.  Binary weaving declare parents sometimes refuses to allow the modification of the hierarchy because it sees a clash between two methods when there is none.  The two cases I'm fixing are:
  1. sometimes the signatures of the return types differ with the '.' or '/' problem (fix == be consistent)
  2. sometimes the syntheticness of the methods in the relationship isn't determined correctly</bugreport>
<testsforfix ID="148972" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java">
      <test NAME="testCovarianceAndDecp_pr128443_1"/>
      <test NAME="testSuperITDExplosion_pr134425"/>
      <test NAME="testMisbehavingDeclareAnnotation_pr135865"/>
      <test NAME="testMisbehavingDeclareAnnotation_pr135865_2"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="185" file="output/148972/pre-fix/testresults.xml" passing="1851" size="2036"/>
<post-fix-testcases failing="185" file="output/148972/post-fix/testresults.xml" passing="1851" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.80" state="changed">203c203,204
&lt; 	              cont = enforceDecpRule3_visibilityChanges(weaver, newParent, superMethod, subMethod) &amp;&amp; cont;
---
&gt;             	if (!(subMethod.isStatic() &amp;&amp; subMethod.getName().startsWith("access$"))) { // ignore generated accessors
&gt;                   cont = enforceDecpRule3_visibilityChanges(weaver, newParent, superMethod, subMethod) &amp;&amp; cont;
205a207
&gt;                 }
333a336,337
&gt;           superReturnTypeSig = superReturnTypeSig.replace('.','/');
&gt;           subReturnTypeSig = subReturnTypeSig.replace('.','/');
342a347,349
&gt; // this just might be a better error message...                      
&gt; //                        "The return type '"+subReturnTypeSig+"' is incompatible with the overridden method "+superMethod.getDeclaringType()+"."+
&gt; //                        superMethod.getName()+superMethod.getParameterSignature()+" which returns '"+superReturnTypeSig+"'",
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java" revision="1.58" state="changed">31a32,35
&gt; //	public void testCovarianceAndDecp_pr128443_1() { runTest("covariance and decp - 1"); }
&gt; //  public void testSuperITDExplosion_pr134425() { runTest("super ITDs");}
&gt; //  public void testMisbehavingDeclareAnnotation_pr135865() { runTest("misbehaving declare annotation");}
&gt; //  public void testMisbehavingDeclareAnnotation_pr135865_2() { runTest("misbehaving declare annotation - 2");}
37a42,44
&gt; 	
&gt; 	
&gt;   // tests added post 152rc1 and before final
40a48,49
&gt; 
&gt;   // tests adding during 152 development
72d80
&lt; //  public void testCovarianceAndDecp_pr128443_1() { runTest("covariance and decp - 1"); }
75,77d82
&lt;   //public void testSuperITDExplosion_pr134425() { runTest("super ITDs");}
&lt;   //public void testMisbehavingDeclareAnnotation_pr135865() { runTest("misbehaving declare annotation");}
&lt;   //public void testMisbehavingDeclareAnnotation_pr135865_2() { runTest("misbehaving declare annotation - 2");}
102d106
&lt; //  public void testIncorrectOverridesEvaluation14() { runTest("incorrect overrides evaluation - 1.4"); }
</file>
</fixedFiles>
</bug>
<bug id="149071" transactionid="69771">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="8"/>
<property name="lines-churned" value="12"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-false K-if K-null K-return K-true K-while M O-== O-! O-!= O-&amp;&amp; T V Z-if Z-while</fullfingerprint>
<bugreport>This code fails, but should work:

public aspect AspectItd {
    //private interface Holder {}
    private int Holder.x;
    static aspect Inner {
        int doIt(Holder h) {
            return h.x++;
        }
    }
}

interface Holder{}

C:\devel\scratch\inner&gt;ajc AspectItd.java
C:\devel\scratch\inner\AspectItd.java:6 [error] The field Holder.x is not visibl
e
return h.x++;


1 error

This appears to be incorrectly applying the visibility rules based on the declared type (i.e., a private defined on Holder shouldn't be visible in Inner), whereas of course it should be using the aspect's visibility rule: the field is visible to AspectItd, hence to Inner.

If you make the interface an inner type, then it works properly (i.e., comment out interface Holder and uncomment the line above). By analogy, this Java code also works:

public class Java {
    private int x;
    static class Inner {
        int doIt(Java j) {
            return j.x++;
        }
    }
}</bugreport>
<testsforfix ID="149071" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testVisibilityProblem_pr149071"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="189" file="output/149071/pre-fix/testresults.xml" passing="1925" size="2114"/>
<post-fix-testcases failing="192" file="output/149071/post-fix/testresults.xml" passing="1922" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeFieldBinding.java" revision="1.16" state="changed">85a86,89
&gt; 			// see pr149071 - it has caused me to comment out this block below - what
&gt; 			// is it trying to achieve?  Possibly it should be using the scope.parentScope (the class scope of
&gt; 			// where the reference is being made) rather than the receiver type
&gt; 			
87,92c91,98
&lt; 			boolean receiverTypeIsSameOrInsideDeclaringType = receiverType == declaringType;
&lt; 			ReferenceBinding typeToCheckNext = receiverType.enclosingType();
&lt; 			while (!receiverTypeIsSameOrInsideDeclaringType &amp;&amp; typeToCheckNext!=null) {
&lt; 				if (typeToCheckNext==declaringType) receiverTypeIsSameOrInsideDeclaringType=true;
&lt; 			}
&lt; 			if (!receiverTypeIsSameOrInsideDeclaringType) return false;
---
&gt; //			boolean receiverTypeIsSameOrInsideDeclaringType = receiverType == declaringType;
&gt; //			ReferenceBinding typeToCheckNext = receiverType.enclosingType();
&gt; //			while (!receiverTypeIsSameOrInsideDeclaringType &amp;&amp; typeToCheckNext!=null) {
&gt; //				if (typeToCheckNext==declaringType) receiverTypeIsSameOrInsideDeclaringType=true;
&gt; //			}
&gt; //			if (!receiverTypeIsSameOrInsideDeclaringType) return false;
&gt; 			
&gt; 			
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.46" state="changed">31a32
&gt;   public void testVisibilityProblem_pr149071()                 { runTest("visibility problem");}
66d66
&lt;   // public void testVisibilityProblem_pr149071()                 { runTest("visibility problem");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.47" state="changed">192a193
&gt;       &lt;run class="AspectItd"/&gt;
</file>
<file name="org.aspectj/modules/tests/bugs153/pr149071/AspectItd.java" revision="1.2" state="changed">4c4
&lt;     static aspect Inner {
---
&gt;     static class Inner {
8a9,12
&gt;     
&gt;     public static void main(String []argv) {
&gt;     	new Inner().doIt(new HolderImpl());
&gt;     }
11a16,17
&gt; 
&gt; class HolderImpl implements Holder {}
</file>
</fixedFiles>
</bug>
<bug id="149289" transactionid="74284">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="4"/>
<property name="lines-added" value="20"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="22"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-class K-import K-package O-+ T V Y</fullfingerprint>
<bugreport>Both AJDT (Bug 71066) and AspectJ (Bug 95516) support the generation of an aop.xml to declare the set of know aspects for LTW. However if the user modifies the file to add options etc then the changes can be over-written. There is a need to allow the user to provide their own configuration in a separate file.</bugreport>
<pre-fix-testcases failing="191" file="output/149289/pre-fix/testresults.xml" passing="1911" size="2102"/>
<post-fix-testcases failing="188" file="output/149289/post-fix/testresults.xml" passing="1914" size="2102"/>
<fixedFiles>
<file name="org.aspectj/modules/ajde/testdata/OutxmlTest/src-resources/META-INF/aop.xml" revision="1.2" state="deleted"/>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.54" state="changed">30a31
&gt; import org.aspectj.bridge.Constants;
55c56
&lt;     private final static String AOP_XML = "META-INF/aop.xml";
---
&gt;     private final static String AOP_XML = Constants.AOP_USER_XML + ";" + Constants.AOP_AJC_XML;
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java" revision="1.56" state="changed">496c496
&lt;                 buildConfig.setOutxmlName("META-INF/aop.xml");  
---
&gt;                 buildConfig.setOutxmlName(org.aspectj.bridge.Constants.AOP_AJC_XML);  
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java" revision="1.24" state="changed">500c500
&lt; 		assertEquals("Wrong outxml","META-INF/aop.xml",config.getOutxmlName());
---
&gt; 		assertEquals("Wrong outxml","META-INF/aop-ajc.xml",config.getOutxmlName());
</file>
<file name="org.aspectj/modules/taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java" revision="1.33" state="changed">789,790c789,790
&lt; 		File outxmlFile = new File(destDir,"META-INF/aop.xml");
&lt; 		assertTrue("META-INF/aop.xml missing",outxmlFile.exists());
---
&gt; 		File outxmlFile = new File(destDir,"META-INF/aop-ajc.xml");
&gt; 		assertTrue("META-INF/aop-ajc.xml missing",outxmlFile.exists());
</file>
<file name="org.aspectj/modules/ajde/testsrc/org/aspectj/ajde/OutxmlTest.java" revision="1.6" state="changed">21a22
&gt; import org.aspectj.bridge.Constants;
29c30
&lt; 	public static final String DEFAULT_AOPXML_NAME = "META-INF/aop.xml"; 
---
&gt; 	public static final String DEFAULT_AOPXML_NAME = Constants.AOP_AJC_XML; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.66" state="changed">1659c1659
&lt; 				+ "bin" + File.separatorChar + "META-INF" + File.separatorChar + "aop.xml");
---
&gt; 				+ "bin" + File.separatorChar + "META-INF" + File.separatorChar + "aop-ajc.xml");
</file>
<file name="org.aspectj/modules/ajde/testdata/OutxmlTest/src-resources/META-INF/aop-ajc.xml" revision="1.1" state="new">&lt;aspectj&gt;
&lt;/aspectj&gt;</file>
<file name="org.aspectj/modules/bridge/src/org/aspectj/bridge/Constants.java" revision="1.1" state="new">/*******************************************************************************
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
package org.aspectj.bridge;

public class Constants {

	/* Default resource names for user and generate aop.xml file */
	public final static String AOP_USER_XML = "META-INF/aop.xml";
    public final static String AOP_AJC_XML = "META-INF/aop-ajc.xml";

}
</file>
</fixedFiles>
</bug>
<bug id="149305" transactionid="69784">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="3"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if O-!= T V Y Z-if</fullfingerprint>
<bugreport>Compiling following code placed in different packages causes unexpected error.
======================================================
package com.codesrc.ozonator;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import com.codesrc.ozonator.identity.User;

@Aspect
public abstract class AbstractOzonator
{

  @Pointcut("")
  protected abstract void readMethodExecution();

  @Pointcut("readMethodExecution() &amp;&amp; this(ozonated)")
  private void ozonatedReadExecution(Object ozonated){};

  @Around("ozonatedReadExecution(ozonated)")
  public Object aroundGetterCallNoRecurse( ProceedingJoinPoint thisJoinPoint,
      Object ozonated) throws Throwable
  {
    System.out.println("thisJoinPoint="+thisJoinPoint+", ozonated="+ozonated);
      return thisJoinPoint.proceed();
  }

}
-------------------------------------------------------------
package com.codesrc.ozonator.identity;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

import com.codesrc.ozonator.AbstractOzonator;

@Aspect
public class IdentityOzonator extends AbstractOzonator 
{
    @Pointcut("execution(public *  com.codesrc.ozonator.identity.User+.get*(..)) ")
	protected void readMethodExecution() {}
}
========================================================================

/home/kei/tmp/0/t3/src/com/codesrc/ozonator/identity/IdentityOzonator.java:1 [error] the parameter thisJoinPoint is not bound in [all branches of] pointcut
(no source information available)

If I place all code into one package, then the code is being compiled successfuly.

This bag looks like Bug 125699, but I use aspectj-1.5.2.rc1.</bugreport>
<testsforfix ID="149305" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testCFlowXMLAspectLTW_pr149096"/>
      <test NAME="testAtajInheritance_pr149305_1"/>
      <test NAME="testAtajInheritance_pr149305_2"/>
      <test NAME="testAtajInheritance_pr149305_3"/>
      <test NAME="testVerificationFailureForAspectOf_pr148693"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="191" file="output/149305/pre-fix/testresults.xml" passing="1845" size="2036"/>
<post-fix-testcases failing="187" file="output/149305/post-fix/testresults.xml" passing="1849" size="2036"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembers.java" revision="1.31" state="changed">240,241c240,244
&lt; 				Pointcut p = munger.getPointcut();
&lt; 				Pointcut newP = pr.rewrite(p);
---
&gt; 				Pointcut p          = munger.getPointcut();
&gt; 				Pointcut newP       = pr.rewrite(p);
&gt; 				if (p.m_ignoreUnboundBindingForNames.length!=0) {// *sigh* dirty fix for dirty hacky implementation pr149305
&gt; 					newP.m_ignoreUnboundBindingForNames = p.m_ignoreUnboundBindingForNames;
&gt; 				}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.3" state="changed">16a17,24
&gt; import org.aspectj.apache.bcel.Repository;
&gt; import org.aspectj.apache.bcel.classfile.JavaClass;
&gt; import org.aspectj.apache.bcel.classfile.Method;
&gt; import org.aspectj.apache.bcel.util.ClassPath;
&gt; import org.aspectj.apache.bcel.util.SyntheticRepository;
&gt; import org.aspectj.apache.bcel.verifier.VerificationResult;
&gt; import org.aspectj.apache.bcel.verifier.Verifier;
&gt; import org.aspectj.apache.bcel.verifier.VerifierFactory;
22c30
&lt; 
---
&gt;   // public void testCFlowXMLAspectLTW_pr149096() { runTest("cflow xml concrete aspect"); }
23a32,37
&gt;   public void testAtajInheritance_pr149305_1() { runTest("ataj inheritance - 1");}
&gt;   public void testAtajInheritance_pr149305_2() { runTest("ataj inheritance - 2");}
&gt;   public void testAtajInheritance_pr149305_3() { runTest("ataj inheritance - 3");}
&gt; 
&gt; 
&gt;   // work in progress
24a39,91
&gt; //	public void testVerificationFailureForAspectOf_pr148693() throws ClassNotFoundException {
&gt; //		runTest("verification problem");
&gt; //		verifyClass("mypackage.MyAspect");
&gt; //	}
&gt; 	
&gt; 
&gt; 	// TODO refactor into a util class
&gt; 	/**
&gt; 	 * Performs verification of a class - the supplied class is expected to exist in the sandbox
&gt; 	 * directory so typically this is called after a small compile step has been invoked to build it.
&gt; 	 */
&gt; 	public void verifyClass(String clazzname) {
&gt; 		JavaClass jc = null;
&gt; 		try {
&gt; 			jc = getClassFrom(ajc.getSandboxDirectory().getAbsolutePath(),clazzname);
&gt; 		} catch (ClassNotFoundException cnfe) {
&gt; 			fail("Could not find "+clazzname+" in the sandbox: "+ajc.getSandboxDirectory());
&gt; 		}
&gt; 		assertTrue("Could not find class",jc!=null);
&gt; 		Repository.setRepository(jc.getRepository());
&gt; 		Verifier v = VerifierFactory.getVerifier("mypackage.MyAspect"); 
&gt; 		VerificationResult vr = v.doPass1();
&gt; 		System.err.println(vr);
&gt; 		
&gt; 		assertTrue("Verification: "+vr,vr.getStatus()==VerificationResult.VERIFIED_OK);
&gt; 		vr = v.doPass2();
&gt; 		System.err.println(vr);
&gt; 		assertTrue("Verification: "+vr,vr.getStatus()==VerificationResult.VERIFIED_OK);
&gt; 		Method[] ms = jc.getMethods();
&gt; 		for (int i = 0; i &lt; ms.length; i++) {
&gt; 			System.err.println("Pass3a for "+ms[i]);
&gt; 			vr = v.doPass3a(i);
&gt; 			System.err.println(vr);
&gt; 			assertTrue("Verification: "+vr,vr.getStatus()==VerificationResult.VERIFIED_OK);
&gt; 			System.err.println("Pass3b for "+ms[i]);
&gt; 			vr = v.doPass3b(i);
&gt; 			System.err.println(vr);
&gt; 			assertTrue("Verification: "+vr,vr.getStatus()==VerificationResult.VERIFIED_OK);
&gt; 		}
&gt; 	}
&gt; 	
&gt; 	protected  JavaClass getClassFrom(String frompath,String clazzname) throws ClassNotFoundException {
&gt; 		SyntheticRepository repos = createRepos(frompath);
&gt; 		return repos.loadClass(clazzname);
&gt; 	}
&gt; 
&gt; 	public SyntheticRepository createRepos(String cpentry) {
&gt; 		ClassPath cp = new ClassPath(
&gt; 				cpentry+File.pathSeparator+
&gt; 				System.getProperty("java.class.path"));
&gt; 		return SyntheticRepository.getInstance(cp);
&gt; 	}	
&gt;   
</file>
</fixedFiles>
</bug>
<bug id="150271" transactionid="74298">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="13"/>
<property name="lines-added" value="16"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="21"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-false K-if K-return K-true M O-! T V Y Z-if</fullfingerprint>
<bugreport>It would be nice if basic information about load-time weaving (what version of AspectJ is being used, what loaders are doing weaving and what configuration is being used) was available without all of the -verbose information listing of all classes woven or not woven.

It's also unfortunate that the flags for weaving level are 2 quite different ones:
-Daj.weaving.verbose -Dorg.aspectj.weaver.showWeaveInfo

Why not something like -Dorg.aspectj.weaver.level=[none|summary|info|verbose]

summary: just what configuration is used
info: list affected join points etc. (like showWeaveInfo)
verbose: all (like verbose now)</bugreport>
<testsforfix ID="150271" type="changed">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml">
      <test NAME="weaveinfo messages with include and exclude"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/ltw-tests.xml">
      <test NAME="Define concrete sub-aspect using aop.xml"/>
      <test NAME="Ensure 1st aspect is rewoven when weaving 2nd aspect"/>
      <test NAME="Override suppressing of warning when advice doesn't match using -Xlintfile"/>
      <test NAME="Warning when advice doesn't match using -Xlint:default"/>
      <test NAME="Override suppressing of warning when advice doesn't match using -Xlint:warning"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/150271/pre-fix/testresults.xml" passing="1916" size="2102"/>
<post-fix-testcases failing="191" file="output/150271/post-fix/testresults.xml" passing="1911" size="2102"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.53" state="changed">676c676
&lt; 		info("generating class '" + name + "'");
---
&gt; 		debug("generating class '" + name + "'");
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.39" state="changed">236c236
&lt; 						info("weaving '" + name + "'");
---
&gt; 						debug("weaving '" + name + "'");
240c240
&lt; 			            info("weaving '" + name + "'");
---
&gt; 			            debug("weaving '" + name + "'");
243c243
&lt; 						info("not weaving '" + name + "'");
---
&gt; 						debug("not weaving '" + name + "'");
246c246
&lt; 					info("cannot weave '" + name + "'");
---
&gt; 					debug("cannot weave '" + name + "'");
394a395,398
&gt; 	protected boolean debug (String message) {
&gt; 		return MessageUtil.debug(messageHandler,message);
&gt; 	}
&gt; 	
544a549
&gt;             ignore(IMessage.DEBUG);
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/Options.java" revision="1.18" state="changed">37a38
&gt;     private final static String OPTION_debug = "-debug";
108a110,111
&gt;             }  else if (arg.equalsIgnoreCase(OPTION_debug)) {
&gt;                 weaverOption.debug = true;
143a147,149
&gt;         if (weaverOption.debug) {
&gt;             weaverOption.messageHandler.dontIgnore(IMessage.DEBUG);
&gt;         }
158a165
&gt;         boolean debug;
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.java" revision="1.3" state="changed">23a24
&gt;     boolean isDebug = false;
45a47,49
&gt;         if (kind.isSameOrLessThan(IMessage.DEBUG)) {
&gt;             return !isDebug;
&gt;         }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml" revision="1.27" state="changed">5c5
&lt;         &lt;ant file="ajc-ant.xml" target="javac.ltw" verbose="true"/&gt;
---
&gt;         &lt;ant file="ajc-ant.xml" target="RunThemAllWithJavacCompiledAndLTW" verbose="true"/&gt;
116,117c116,117
&lt;         		&lt;line text="info not weaving 'com.foo.bar.Test$$EnhancerByCGLIB$$12345'"/&gt;
&lt;         		&lt;line text="info weaving 'com.foo.bar.Test'"/&gt;
---
&gt;         		&lt;line text="debug not weaving 'com.foo.bar.Test$$EnhancerByCGLIB$$12345'"/&gt;
&gt;         		&lt;line text="debug weaving 'com.foo.bar.Test'"/&gt;
185,186c185,186
&lt; 				&lt;line text="info weaving 'ataspectj.ltwlog.Main'"/&gt;
&lt; 				&lt;line text="info weaving 'ataspectj.ltwlog.Aspect1'"/&gt;
---
&gt; 				&lt;line text="debug weaving 'ataspectj.ltwlog.Main'"/&gt;
&gt; 				&lt;line text="debug weaving 'ataspectj.ltwlog.Aspect1'"/&gt;
210c210
&lt; 				&lt;line text="info weaving 'ataspectj.ltwlog.Main'"/&gt;
---
&gt; 				&lt;line text="debug weaving 'ataspectj.ltwlog.Main'"/&gt;
212c212
&lt; 				&lt;line text="info weaving 'ataspectj.ltwlog.Aspect1'"/&gt;
---
&gt; 				&lt;line text="debug weaving 'ataspectj.ltwlog.Aspect1'"/&gt;
267c267
&lt;         &lt;ant file="ajc-ant.xml" target="ltw.oldAspectsDeclared" verbose="true"/&gt;
---
&gt;         &lt;ant file="ajc-ant.xml" target="Compile time aspects declared to ltw weaver" verbose="true"/&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc152/ajc152.xml" revision="1.57" state="changed">706,707c706,707
&lt;           &lt;line text="info weaving"/&gt;
&lt;           &lt;line text="info not weaving"/&gt;
---
&gt; 			&lt;line text="debug weaving"/&gt;
&gt;             &lt;line text="debug not weaving"/&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/ltw-tests.xml" revision="1.19" state="changed">9c9
&lt;             options="-showWeaveInfo"
---
&gt;             options="-showWeaveInfo -verbose"
17c17
&lt;             options="-showWeaveInfo"
---
&gt;             options="-showWeaveInfo -verbose"
230,231c230,231
&lt;                 &lt;line text="info generating class 'ConcreteAspect'"/&gt;
&lt;                 &lt;line text="info weaving 'Main'"/&gt;
---
&gt;                 &lt;line text="debug generating class 'ConcreteAspect'"/&gt;
&gt;                 &lt;line text="debug weaving 'Main'"/&gt;
399c399
&lt; 	        	&lt;line text="info weaving 'Main'"/&gt;
---
&gt; 	        	&lt;line text="debug weaving 'Main'"/&gt;
422c422
&lt; 	        	&lt;line text="info weaving 'Main'"/&gt;
---
&gt; 	        	&lt;line text="debug weaving 'Main'"/&gt;
445c445
&lt; 	        	&lt;line text="info weaving 'Main'"/&gt;
---
&gt; 	        	&lt;line text="debug weaving 'Main'"/&gt;
468c468
&lt; 	        	&lt;line text="info weaving 'Main'"/&gt;
---
&gt; 	        	&lt;line text="debug weaving 'Main'"/&gt;
</file>
<file name="org.aspectj/modules/tests/ltw/aop-nomatch.xml" revision="1.2" state="changed">6c6
&lt;     &lt;weaver options="-verbose -showWeaveInfo"/&gt;
---
&gt;     &lt;weaver options="-verbose -debug -showWeaveInfo"/&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/aop-dumpbeforeandafter.xml" revision="1.5" state="changed">6c6
&lt;     &lt;weaver options="-XlazyTjp -verbose"&gt;
---
&gt;     &lt;weaver options="-XlazyTjp -verbose -debug"&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwlog/aop-verboseandshow.xml" revision="1.4" state="changed">2c2
&lt;     &lt;weaver options="-showWeaveInfo -verbose"/&gt;
---
&gt;     &lt;weaver options="-showWeaveInfo -verbose -debug"/&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ajc-ant.xml" revision="1.21" state="changed">2c2
&lt; &lt;project name="ltw" default="javac.ltw"&gt;
---
&gt; &lt;project name="ltw" default="RunThemAllWithJavacCompiledAndLTW"&gt;
8a9,10
&gt;     &lt;target name="RunThemAllWithJavacCompiledAndLTW" depends="compile:javac, ltw"/&gt;
&gt; 
71,72d72
&lt;     &lt;target name="javac.ltw" depends="compile:javac, ltw"/&gt;
&lt; 
171c171
&lt;     &lt;target name="ltw.oldAspectsDeclared"&gt;
---
&gt;     &lt;target name="Compile time aspects declared to ltw weaver"&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/TestHelper.java" revision="1.8" state="changed">60,62c60,62
&lt;         if (message.getKind().isSameOrLessThan(IMessage.INFO)) {
&lt;             ;
&lt;         } else {
---
&gt;         if (message.getKind().isSameOrLessThan(IMessage.INFO));
&gt;         if (message.getKind().isSameOrLessThan(IMessage.DEBUG));
&gt;         else {
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/ltwlog/aop-verbose.xml" revision="1.5" state="changed">2c2
&lt;     &lt;weaver options="-verbose"/&gt;
---
&gt;     &lt;weaver options="-verbose -debug"/&gt;
</file>
<file name="org.aspectj/modules/tests/ltw/aop-emptytests.xml" revision="1.2" state="changed">5c5
&lt; 	&lt;weaver options="-verbose"&gt;
---
&gt; 	&lt;weaver options="-verbose -debug"&gt;
</file>
<file name="org.aspectj/modules/tests/ltw/aop-nomatchxlint.xml" revision="1.2" state="changed">6c6
&lt;     &lt;weaver options="-verbose -showWeaveInfo -Xlint:warning"/&gt;
---
&gt;     &lt;weaver options="-verbose -debug -showWeaveInfo -Xlint:warning"/&gt;
</file>
<file name="org.aspectj/modules/tests/ltw/aop-nomatchxlintfile.xml" revision="1.2" state="changed">6c6
&lt;     &lt;weaver options="-verbose -showWeaveInfo -Xlintfile:Xlint-nomatch.properties"/&gt;
---
&gt;     &lt;weaver options="-verbose -debug -showWeaveInfo -Xlintfile:Xlint-nomatch.properties"/&gt;
</file>
<file name="org.aspectj/modules/tests/ltw/aop-defineaspect.xml" revision="1.3" state="changed">7c7
&lt; 	&lt;weaver options="-verbose"/&gt;
---
&gt; 	&lt;weaver options="-verbose -debug"/&gt;
</file>
</fixedFiles>
</bug>
<bug id="150671" transactionid="70202">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M O-&amp;&amp;</fullfingerprint>
<bugreport>When an aspect has a declare error statement involving a pointcut that captures the setting of a volatile field, a compilation error is not produced.  

This bug can be reproduced as follows.  Consider the following class:

class A {
   private volatile int state;

   public void foo() {
      state = 0;
   }
}

Now consider this aspect:

aspect FSM {
   declare error: set(* A.state): "Changing state";
}

The setting of the state field in method foo() does not result in a compilation error as expected.  

I originally noticed this bug when using AJDT 1.4 with Eclipse 3.2.  However this has been reproduced and confirmed with the aspectj 1.5.2 compiler.</bugreport>
<testsforfix ID="150671" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testMatchVolatileField_pr150671"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="match volatile field"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/150671/pre-fix/testresults.xml" passing="1864" size="2054"/>
<post-fix-testcases failing="189" file="output/150671/post-fix/testresults.xml" passing="1865" size="2054"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java" revision="1.29" state="changed">324c324
&lt;     	return (modifiers &amp; Constants.ACC_BRIDGE)!=0;
---
&gt;     	return (modifiers &amp; Constants.ACC_BRIDGE)!=0 &amp;&amp; getKind().equals(METHOD);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.17" state="changed">239a240,246
&gt;   
&gt;     &lt;ajc-test dir="bugs153" title="match volatile field"&gt;
&gt;       &lt;compile files="pr150671.aj" options="-Xset:activateLightweightDelegates=false"&gt;
&gt;         &lt;message kind="error" line="7" text="Changing state"/&gt;
&gt;         &lt;message kind="error" line="8" text="test"/&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.18" state="changed">48a49,50
&gt;   public void testMatchVolatileField_pr150671() {runTest("match volatile field");};
&gt;   
</file>
<file name="org.aspectj/modules/tests/bugs153/pr150671.aj" revision="1.1" state="new">class C {

	   private volatile int state;
	   private int test;
	   
	   public void foo() {
	      state = 0;
	      test = 0;
	   }
	
}

aspect FSM {
	   declare error: set(* C.state): "Changing state";
	   declare error: set(* C.test): "test";
}
</file>
</fixedFiles>
</bug>
<bug id="151182" transactionid="74271">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>K</concisefingerprint>
<fullfingerprint>K-synchronized T V</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Hi,

I created a logging aspect for our application some time ago using 1.5.0 of AspectJ. I enabled this from time to time using Load Time Weaving.

I have recently recompiled the aspect using 1.5.2 and tried to run it also using the 1.5.2 weaver jar, but it fails with a NullPointerException.

This is part of one of the many stacktraces:

20 jul 2006 07:42:49,046 - java.lang.NullPointerException
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1367)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1237)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1072)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:284)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:212)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)
20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
20 jul 2006 07:42:49,062 - 	at sun.instrument.TransformerManager.transform(Unknown Source)
20 jul 2006 07:42:49,062 - 	at sun.instrument.InstrumentationImpl.transform(Unknown Source)
20 jul 2006 07:42:49,062 - 	at java.lang.ClassLoader.defineClass1(Native Method)
20 jul 2006 07:42:49,062 - 	at java.lang.ClassLoader.defineClass(Unknown Source)

I then tried with the 1.5.0 weaver jar (although the aspect was compiled using 1.5.2) and this ran without problems.</bugreport>
<pre-fix-testcases failing="189" file="output/151182/pre-fix/testresults.xml" passing="1865" size="2054"/>
<post-fix-testcases failing="188" file="output/151182/post-fix/testresults.xml" passing="1866" size="2054"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/Aj.java" revision="1.20" state="changed">70,75c70,77
&lt;             WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
&lt;             if (weavingAdaptor == null) {
&lt;         		if (trace.isTraceEnabled()) trace.exit("preProcess",bytes);
&lt;             	return bytes;
&lt;             }
&lt;             return weavingAdaptor.weaveClass(className, bytes);
---
&gt;         	synchronized (loader) {
&gt;                 WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
&gt;                 if (weavingAdaptor == null) {
&gt;             		if (trace.isTraceEnabled()) trace.exit("preProcess",bytes);
&gt;                 	return bytes;
&gt;                 }
&gt;                 return weavingAdaptor.weaveClass(className, bytes);
&gt; 			}
</file>
</fixedFiles>
</bug>
<bug id="151673" transactionid="69567">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="21"/>
<property name="lines-deleted" value="3"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="24"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-instanceof K-null K-while M O-== O-&gt;= O-- O--- O-! O-() O-&amp;&amp; O-cast O-instanceof T V Y Z-cast Z-if Z-while</fullfingerprint>
<bugreport>We have had a user report a problem where after advice being woven into a particular method is producing code that does not verify.  The problem occurs if the bytecode being input to the weaving process includes a subroutine that contains the return from the method.

Here is the problematic snippet produced by some unknown compiler:
   200:	invokespecial	#17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V
   203:	athrow
   204:	aload_3
   205:	astore	6
   207:	jsr	234
   210:	aload	6
   212:	areturn
   213:	astore	4
   215:	aload	4
   217:	invokevirtual	#79; //Method java/lang/Throwable.printStackTrace:()V
   220:	jsr	234
   223:	goto	238
   226:	astore	7
   228:	jsr	234
   231:	aload	7
   233:	athrow
   234:	astore	8
   236:	aload_3
   237:	areturn
   238:	return
  Exception table:
   from   to  target type
     2   213   213   Class javax/ejb/FinderException

     2   226   226   any

see the jsr's jump to 234, but before the subroutine return at 238 there is an areturn out of the method (this method returns a String).

After weaving we get something like this:

   200:	invokespecial	#17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V
   203:	athrow
   204:	aload_3
   205:	astore	6
   207:	jsr	238
   210:	aload	6
   212:	astore	9
   214:	goto	248
   217:	astore	4
   219:	aload	4
   221:	invokevirtual	#79; //Method java/lang/Throwable.printStackTrace:()V
   224:	jsr	238
   227:	goto	246
   230:	astore	7
   232:	jsr	238
   235:	aload	7
   237:	athrow
   238:	astore	8
   240:	aload_3
   241:	astore	9
   243:	goto	248
   246:	astore	9
   248:	invokestatic	#299; //Method After.aspectOf:()LAfter;
   251:	invokevirtual	#302; //Method After.ajc$afterReturning$After$1$26d6d4a7:()V
   254:	aload	9
   256:	return

see how the areturn has been lost - this code will blow up with a verify error (the string is on the stack, we just ignore it and 'return' normally)</bugreport>
<pre-fix-testcases failing="189" file="output/151673/pre-fix/testresults.xml" passing="1888" size="2077"/>
<post-fix-testcases failing="185" file="output/151673/post-fix/testresults.xml" passing="1892" size="2077"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/testdata/AfterHelloWorld.txt" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/AfterFancyHelloWorld.txt" revision="1.5" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/AfterReturningFancyHelloWorld.txt" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/CflowNonStaticBeforeHelloWorld.txt" revision="1.5" state="changed"/>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java" revision="1.104" state="changed">51a52
&gt; import org.aspectj.apache.bcel.generic.RETURN;
1794a1796,1801
&gt; 	 * 
&gt; 	 * Sometimes the 'last return' isnt the right one - some rogue code can 
&gt; 	 * include the real return from the body of a subroutine that exists at the end
&gt; 	 * of the method. In this case the last return is RETURN but that may not be
&gt; 	 * correct for a method with a non-void return type... pr151673
&gt; 	 * 
1802,1803d1808
&lt;     	InstructionHandle lastReturnHandle = (InstructionHandle)returns.get(returns.size() - 1);
&lt;     	Instruction newReturnInstruction = Utility.copyInstruction(lastReturnHandle.getInstruction());
1804a1810,1820
&gt;     		// Find the last *correct* return - this is a method with a non-void return type
&gt;     		// so ignore RETURN
&gt;     		Instruction  newReturnInstruction = null;
&gt;     		int i=returns.size()-1;
&gt;     		while (newReturnInstruction == null &amp;&amp; i&gt;=0) {
&gt;     			InstructionHandle ih = (InstructionHandle)returns.get(i);
&gt;     			if (!(ih.getInstruction() instanceof RETURN)) {
&gt;     				newReturnInstruction = Utility.copyInstruction(ih.getInstruction());
&gt;     			}
&gt;     			i--;
&gt;     		}
1806a1823
&gt;         	returnInstructions.append(newReturnInstruction);
1807a1825,1826
&gt;         	InstructionHandle lastReturnHandle = (InstructionHandle)returns.get(returns.size() - 1);
&gt;         	Instruction newReturnInstruction = Utility.copyInstruction(lastReturnHandle.getInstruction());
1810d1828
&lt;     	returnInstructions.append(newReturnInstruction);
</file>
<file name="org.aspectj/modules/weaver/testdata/ArgsAfterReturningFancyHelloWorld.txt" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/ArgsBeforeAfterHelloWorld.txt" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/AfterReturningHelloWorld.txt" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/CflowNonStaticBeforeFancyHelloWorld.txt" revision="1.5" state="changed"/>
<file name="org.aspectj/modules/weaver/testdata/ArgsAfterReturningHelloWorld.txt" revision="1.4" state="changed"/>
<file name="org.aspectj/modules/tests/features152/synchronization/transformed/expected/C.m3.txt" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/tests/features152/synchronization/transformed/expected/C.m.txt" revision="1.3" state="changed"/>
<file name="org.aspectj/modules/tests/features152/synchronization/transformed/expected/C.m33.txt" revision="1.3" state="changed"/>
</fixedFiles>
</bug>
<bug id="151845" transactionid="69852">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null O-!= T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>Building of a large project fails while weaving. 
NPE in EclipseSourceContext.removeUnnecessaryProblems(..)

The project was just migrated to Eclipse 3.2
Eclipse newly installed with Eclipse SDK and via Update manager with
AJDT, CDT, Web/J2EE tools, SubClipse, SpringIDE.

Same Project workes in Eclipse 3.1.
Simple Test AspectJ-Project workes OK
Building with Ant/AspectJ compiler (as external Tools Launch in Eclipse)
works.

I tried the following, but got the error anyway:
 - Checked out as a new AspectJ Project
 - upgraded to the developement Version of AJDT</bugreport>
<pre-fix-testcases failing="189" file="output/151845/pre-fix/testresults.xml" passing="1865" size="2054"/>
<post-fix-testcases failing="190" file="output/151845/post-fix/testresults.xml" passing="1864" size="2054"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java" revision="1.12" state="changed">82,90c82,92
&lt; 		for (int i = 0; i &lt; probs.length; i++) {
&lt; 			IProblem problem = probs[i];
&lt; 			if (problem == null) continue;
&lt; 			if (problem.getID() == IProblem.UnusedMethodDeclaredThrownException 
&lt; 					|| problem.getID() == IProblem.UnusedConstructorDeclaredThrownException) {
&lt; 				if (problem.getSourceLineNumber() == problemLineNumber) {
&lt; 					UnusedDeclaredThrownExceptionFilter filter = 
&lt; 						new UnusedDeclaredThrownExceptionFilter(problem);
&lt; 					result.removeProblems(filter);	
---
&gt; 		if (probs!=null) {
&gt; 			for (int i = 0; i &lt; probs.length; i++) {
&gt; 				IProblem problem = probs[i];
&gt; 				if (problem == null) continue;
&gt; 				if (problem.getID() == IProblem.UnusedMethodDeclaredThrownException 
&gt; 						|| problem.getID() == IProblem.UnusedConstructorDeclaredThrownException) {
&gt; 					if (problem.getSourceLineNumber() == problemLineNumber) {
&gt; 						UnusedDeclaredThrownExceptionFilter filter = 
&gt; 							new UnusedDeclaredThrownExceptionFilter(problem);
&gt; 						result.removeProblems(filter);	
&gt; 					}
</file>
</fixedFiles>
</bug>
<bug id="151938" transactionid="74358">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="4"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null K-return O-!= T V Z-if</fullfingerprint>
<bugreport>If you start a java 5 VM with AspectJ's load-time weaver specified more than once using the -javaagent flag, if there is an aop.xml file defined, it chokes badly: it tries to reweave the woven AspectJ code and emits massive amounts of bytecode. It would be better if AspectJ detected that it was specified more than once and gave a warning then disabled all but one of the agents. Failing that, it would be better to fail and give an error message than emit the bytecode.

This issue came up for our automated installer, which adds a -javaagent flag to VM startup commands. If the script is wrapped twice, it can generate a duplicate. We are making our scripts more intelligent to avoid this issue, but we are probably not the only people who will hit this issue (e.g., if someone manually edits both setclasspath.bat and catalina.bat to add the flag for a Tomcat instance...)</bugreport>
<testsforfix ID="151938" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testDuplicateJVMTIAgents_pr151938"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="Duplicate JVMTI agents"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/151938/pre-fix/testresults.xml" passing="1886" size="2076"/>
<post-fix-testcases failing="191" file="output/151938/post-fix/testresults.xml" passing="1885" size="2076"/>
<fixedFiles>
<file name="org.aspectj/modules/lib/test/loadtime5.jar" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java" revision="1.2" state="changed">41a42,45
&gt;     	/* Handle duplicate agents */
&gt;     	if (s_instrumentation != null) {
&gt;     		return;
&gt;     	}
</file>
<file name="org.aspectj/modules/weaver5/testdata/logging.properties" revision="1.2" state="changed"/>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.21" state="changed">51c51,53
&lt;   
---
&gt; 
&gt;   public void testDuplicateJVMTIAgents_pr151938() {runTest("Duplicate JVMTI agents");};
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.20" state="changed">242a243,250
&gt; 
&gt;     &lt;ajc-test dir="java5/ataspectj" title="Duplicate JVMTI agents"&gt;
&gt;         &lt;compile files="HelloWorld.java"/&gt;
&gt;         &lt;compile files="MessageHandler.java"/&gt;
&gt; &lt;!--        &lt;compile files="Aspect.aj" options="-outxml"/&gt; --&gt;
&gt;         &lt;compile files="Aspect.aj" options="-outxml -outjar aspects.jar"/&gt;
&gt;         &lt;ant file="ajc-ant.xml" target="Duplicate JVMTI agents" verbose="true"/&gt;
&gt;     &lt;/ajc-test&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/aop-messagehandler.xml" revision="1.1" state="new">&lt;aspectj&gt;
	&lt;weaver options="-XmessageHandlerClass:MessageHandler"/&gt;
&lt;/aspectj&gt;</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/MessageHandler.java" revision="1.1" state="new">import org.aspectj.bridge.AbortException;
import org.aspectj.bridge.IMessage;
import org.aspectj.bridge.IMessageHandler;
import org.aspectj.bridge.IMessage.Kind;

public class MessageHandler implements IMessageHandler {

	public boolean handleMessage(IMessage message) throws AbortException {
		System.out.println(message);
		if (message.getKind() == IMessage.ERROR) {
			System.exit(-1);
		}
		else if (message.getKind() == IMessage.ABORT) {
			throw new AbortException(message.toString());
		}
		return true;
	}

	public boolean isIgnoring(IMessage.Kind kind) {
		return false;
	}

    public void dontIgnore(IMessage.Kind kind) {
    	
    }
	
}</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/HelloWorld.java" revision="1.1" state="new">public class HelloWorld {

	public static void main (String[] args) {
		System.out.println("Hello World!");
	}
	
}</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/Aspect.aj" revision="1.1" state="new">public aspect Aspect {
	before () : execution(public static void main(String[])) {
		System.out.println(thisJoinPoint);
	}
}</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ajc-ant.xml" revision="1.20" state="changed">223a224,242
&gt;     &lt;target name="Duplicate JVMTI agents"&gt;
&gt;         &lt;copy file="${aj.root}/tests/java5/ataspectj/aop-messagehandler.xml"
&gt;               tofile="${aj.sandbox}/META-INF/aop.xml"/&gt;
&gt;         &lt;java fork="yes" classname="HelloWorld" failonerror="yes"&gt;
&gt;             &lt;classpath refid="aj.path"/&gt;
&gt;             &lt;!-- use META-INF/aop.xml style --&gt;
&gt;             &lt;classpath&gt;
&gt;                 &lt;pathelement path="${aj.sandbox}/aspects.jar"/&gt;
&gt;             &lt;/classpath&gt;
&gt;             &lt;jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/&gt;
&gt; &lt;!--        	
&gt; --&gt;            
&gt;             &lt;jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/&gt;
&gt;             &lt;jvmarg value="-Daj.weaving.verbose=true"/&gt;
&gt;             &lt;jvmarg value="-Djava.util.logging.config.file=${aj.root}/weaver5/testdata/logging.properties"/&gt;
&gt; &lt;!--            &lt;jvmarg line="${jdwp}"/&gt;--&gt;
&gt;         &lt;/java&gt;
&gt;     &lt;/target&gt;
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="152257" transactionid="68877">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="1"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M T V</fullfingerprint>
<tag>exception</tag>
<bugreport>Incrementally compiling code with advice throwing an excpetion gives errors 
stating that the exception can't be thrown. Full compilation compiles the code 
successfully.

AJDT Version: 1.4.1
Build id: 20060727081607
AspectJ version: 1.5.3.20060726092219

Here is the minimum code the reproduce the behavior.
// Main.java
package test;

import java.io.IOException;

public class Main {
	public void testMethod() throws IOException {
		methodThatThrows();
	}

	public static void methodThatThrows() throws IOException {
		System.out.println("Inside method that may throw an IOException");
	}
}

// IOExceptionInjector.aj
package test;

import java.io.IOException;

public aspect IOExceptionInjector {
	pointcut faultInjection() : call(void methodThatThrows() throws IOException);

	void around() throws IOException : faultInjection() {
		throw new IOException("Exception injected by aspect."); 
	}
}

1. Modify something in Main.java (add and delete a space, for example). 
2. Save to compile incremetally.

An error is issued for the call to methodThatThrows() stating
"Severity and Description	Path	Resource	Location	Creation Time	Id
can't throw checked exception 'java.io.IOException' at this join point 'method-call(void test.Main.methodThatThrows())'	IncrementalCompilerHandlingException/src/test	Main.java	line 7	1154196826350	7956
"

Do a full rebuild and the error goes away.</bugreport>
<testsforfix ID="152257" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPr152257"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="189" file="output/152257/pre-fix/testresults.xml" passing="1887" size="2076"/>
<post-fix-testcases failing="188" file="output/152257/post-fix/testresults.xml" passing="1888" size="2076"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java" revision="1.3" state="changed">349c349
&lt; 				weaver.getWorld().flush();
---
&gt; //		        weaver.getWorld().flush(); // pr152257
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.91" state="changed">1135a1136
&gt;     /** be careful calling this - pr152257 */
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java" revision="1.30" state="changed">193c193
&lt; 				weaver.getWorld().flush();
---
&gt; //		        weaver.getWorld().flush(); // pr152257
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.60" state="changed">823c823
&lt; /*	public void testPr152257() {
---
&gt; 	public void testPr152257() {
825d824
&lt; 		super.VERBOSE=true;
830c829
&lt; //		checkWasFullBuild();
---
&gt; 		checkWasFullBuild();
835c834
&lt; //		checkWasntFullBuild();
---
&gt; 		checkWasntFullBuild();
837c836
&lt; */	
---
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="152366" transactionid="68965">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="5"/>
<property name="lines-churned" value="9"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KM</concisefingerprint>
<fullfingerprint>K-return M T V</fullfingerprint>
<bugreport>The load-time weaving definition system accepts AND in addition to &amp;amp;&amp;amp; for pointcuts, but it silently accepts and then fails to work with type patterns that use AND. Such type patterns are important when creating exceptions (e.g., excluding weblogic..* &amp;amp;&amp;amp; !weblogic.jdbc..*) and using AND is also helpful here.

I've attached a patch to support this and tests to show it's working.</bugreport>
<testsforfix ID="152366" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java">
      <test NAME="testInclusionAndPattern"/>
      <test NAME="testExclusionAndPattern"/>
      <test NAME="testAndPatternsAspects"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/ltw-tests.xml">
      <test NAME="Inclusion and patterns"/>
      <test NAME="Exclusion and patterns"/>
      <test NAME="And patterns aspects"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="196" file="output/152366/pre-fix/testresults.xml" passing="1918" size="2114"/>
<post-fix-testcases failing="188" file="output/152366/post-fix/testresults.xml" passing="1926" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java" revision="1.13" state="changed">196c196
&lt;             String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
---
&gt;             String typePattern = getWithinAttribute(attributes);
201c201
&lt;             String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
---
&gt;             String typePattern = getWithinAttribute(attributes);
206c206
&lt;             String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
---
&gt;             String typePattern = getWithinAttribute(attributes);
215c215
&lt;             String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
---
&gt;             String typePattern = getWithinAttribute(attributes);
220c220
&lt;             String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
---
&gt;             String typePattern = getWithinAttribute(attributes);
229a230,233
&gt; 	private String getWithinAttribute(Attributes attributes) {
&gt; 		return replaceXmlAnd(attributes.getValue(WITHIN_ATTRIBUTE));
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java" revision="1.13" state="changed">33,34c33,44
&lt; 
&lt; 
---
&gt;   public void testInclusionAndPattern() {
&gt;     runTest("Inclusion and patterns");  		
&gt;   }
&gt; 	
&gt;   public void testExclusionAndPattern() {
&gt; 	runTest("Exclusion and patterns");  		
&gt;   }
&gt; 	  	
&gt;   public void testAndPatternsAspects() {
&gt; 	runTest("And patterns aspects");  		
&gt;   }
&gt; 	  	  	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ltw/ltw-tests.xml" revision="1.21" state="changed">595a596,640
&gt;       
&gt; 	&lt;ajc-test dir="ltw/inclExcl" title="Inclusion and patterns" keywords="ltw"&gt;
&gt;         &lt;compile
&gt;         	files="pkg\sub\Foo.aj, pkg\Main.aj"
&gt;         	options="-outjar base.jar"
&gt;         /&gt;
&gt;         &lt;compile
&gt;         	files="tracing/Tracer.aj"
&gt;         /&gt;
&gt;         &lt;run class="pkg.Main" ltw="aop-include.xml"&gt;
&gt;             &lt;stderr&gt;
&gt;                 &lt;line text="execution(void pkg.Main.foo())"/&gt;
&gt;                 &lt;line text="Main.class"/&gt;
&gt;             &lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 	&lt;ajc-test dir="ltw/inclExcl" title="Exclusion and patterns" keywords="ltw"&gt;
&gt;         &lt;compile
&gt;         	files="pkg\sub\Foo.aj, pkg\Main.aj"
&gt;         	options="-outjar base.jar"
&gt;         /&gt;
&gt;         &lt;compile
&gt;         	files="tracing/Tracer.aj"
&gt;         /&gt;
&gt;         &lt;run class="pkg.Main" ltw="aop-exclude.xml"&gt;
&gt;             &lt;stderr&gt;
&gt;                 &lt;line text="execution(void pkg.sub.Foo.foo())"/&gt;
&gt;             &lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;    
&gt; 	&lt;ajc-test dir="ltw/inclExcl" title="And patterns aspects" keywords="ltw"&gt;
&gt;         &lt;compile
&gt;         	files="pkg\sub\Foo.aj, pkg\Main.aj"
&gt;         	options="-outjar base.jar"
&gt;         /&gt;
&gt;         &lt;compile
&gt;         	files="tracing/Tracer.aj, tracing/staticinit/Tracer.aj, tracing/staticinit/sub/Tracer.aj"
&gt;         /&gt;
&gt;         &lt;run class="pkg.Main" ltw="aop-aspectinclexcl.xml"&gt;
&gt;             &lt;stderr&gt;
&gt;                 &lt;line text="staticinitialization(pkg.Main.&amp;lt;clinit&amp;gt;)"/&gt;
&gt;                 &lt;line text="staticinitialization(pkg.sub.Foo.&amp;lt;clinit&amp;gt;)"/&gt;
&gt;             &lt;/stderr&gt;
&gt;         &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;       
</file>
<file name="org.aspectj/modules/tests/ltw/inclExcl/tracing/staticinit/sub/Tracer.aj" revision="1.1" state="new">package tracing.staticinit.sub;

public aspect Tracer {
    before() : staticinitialization(pkg..*) {
        System.err.println("sub: "+thisJoinPoint);
    }
}
</file>
<file name="org.aspectj/modules/tests/ltw/inclExcl/aop-include.xml" revision="1.1" state="new">&lt;aspectj&gt;
&lt;weaver&gt;
&lt;include within="pkg..* AND !pkg.sub..*"/&gt;
&lt;dump within="pkg..* AND !pkg.sub..*"/&gt;
&lt;/weaver&gt;
&lt;aspects&gt;
&lt;aspect name="tracing.Tracer"/&gt;
&lt;/aspects&gt;
&lt;/aspectj&gt;

</file>
<file name="org.aspectj/modules/tests/ltw/inclExcl/pkg/Main.aj" revision="1.1" state="new">package pkg;

import java.io.File;

public class Main {
    public static void main(String argz[]) {
        foo();
    }

    public static void foo() {
        (new pkg.sub.Foo()).foo();
        
        File dumpDir = new File("_ajdump"); 
        lsLR(dumpDir);
        
        // the LTW harness should clean up _ajdump files!
        cleanup(dumpDir);
    }
    
    public static void lsLR(File dir) {
        String[] files = dir.list();
        if (files == null) return;
        for (int i=0; i&lt;files.length; i++) {
        	File f = new File(dir, files[i]);
        	if (f.isFile()) {
        		System.err.println(files[i]);
        	} else {
        		lsLR(f);
        	}
        }    	
    }
    
    public static void cleanup(File dir) {
        String[] files = dir.list();
        if (files == null) return;
        for (int i=0; i&lt;files.length; i++) {
        	File f = new File(dir, files[i]);
        	if (f.isFile()) {
        		f.delete();
        	} else {
        		cleanup(f);
        	}
        }    	
		dir.delete();
    }
}
</file>
<file name="org.aspectj/modules/tests/ltw/inclExcl/aop-aspectinclexcl.xml" revision="1.1" state="new">&lt;aspectj&gt;
&lt;aspects&gt;
&lt;aspect name="tracing.Tracer"/&gt;
&lt;aspect name="tracing.staticinit.Tracer"/&gt;
&lt;aspect name="tracing.staticinit.sub.Tracer"/&gt;
&lt;include within="tracing..* AND !tracing.staticinit.sub..*"/&gt;
&lt;exclude within="tracing..* AND !tracing.staticinit..*"/&gt;
&lt;/aspects&gt;
&lt;/aspectj&gt;

</file>
<file name="org.aspectj/modules/tests/ltw/inclExcl/aop-exclude.xml" revision="1.1" state="new">&lt;aspectj&gt;
&lt;weaver&gt;
&lt;exclude within="pkg..* AND !pkg.sub..*"/&gt;
&lt;/weaver&gt;
&lt;aspects&gt;
&lt;aspect name="tracing.Tracer"/&gt;
&lt;/aspects&gt;
&lt;/aspectj&gt;

</file>
<file name="org.aspectj/modules/tests/ltw/inclExcl/pkg/sub/Foo.aj" revision="1.1" state="new">package pkg.sub;

public class Foo {
    public void foo() {}
}
</file>
<file name="org.aspectj/modules/tests/ltw/inclExcl/tracing/staticinit/Tracer.aj" revision="1.1" state="new">package tracing.staticinit;

public aspect Tracer {
    before() : staticinitialization(pkg..*) {
        System.err.println(thisJoinPoint);
    }
}
</file>
<file name="org.aspectj/modules/tests/ltw/inclExcl/tracing/Tracer.aj" revision="1.1" state="new">package tracing;

public aspect Tracer {
    before() : execution(* foo()) {
        System.err.println(thisJoinPoint);
    }
}
</file>
</fixedFiles>
</bug>
<bug id="152388" transactionid="68842">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-if K-null O-!= T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I get this message from an error in a recent dev build of AspectJ with load-time weaving. I don't know how there is a null source location associated with this message, but either it shouldn't be there or MessageUtil line 806 should use this patch:

Index: src/org/aspectj/bridge/MessageUtil.java
===================================================================
RCS file: /home/technology/org.aspectj/modules/bridge/src/org/aspectj/bridge/MessageUtil.java,v
retrieving revision 1.11
diff -u -r1.11 MessageUtil.java
--- src/org/aspectj/bridge/MessageUtil.java	1 Jun 2006 09:36:37 -0000	1.11
+++ src/org/aspectj/bridge/MessageUtil.java	31 Jul 2006 22:32:16 -0000
@@ -803,7 +803,7 @@
 		writer.println(baseMessage);
 		for (Iterator iter = message.getExtraSourceLocations().iterator(); iter.hasNext();) {
 		    ISourceLocation element = (ISourceLocation) iter.next();
-		    writer.print("\tsee also: " + element.toString());
+		    writer.print("\tsee also: " + element);
 		    if (iter.hasNext()) {
 		        writer.println();
 		    }

NPE follows:

java.lang.NullPointerException
	at org.aspectj.bridge.MessageUtil.addExtraSourceLocations(MessageUtil.java:806)
	at org.aspectj.bridge.MessageUtil.renderMessage(MessageUtil.java:793)
	at org.aspectj.bridge.Message.toString(Message.java:177)
	at org.aspectj.bridge.MessageWriter.render(MessageWriter.java:73)
	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.render(WeavingAdaptor.java:471)
	at org.aspectj.bridge.MessageWriter.handleMessage(MessageWriter.java:41)
	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.handleMessage(WeavingAdaptor.java:425)
	at org.aspectj.weaver.bcel.BcelTypeMunger.error(BcelTypeMunger.java:378)
	at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:273)
	at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194)
	at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:450)
	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1613)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1564)
	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1341)
	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1163)
	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:288)
	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:214)
	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:76)
	at org.aspectj.ext.ltw13.ClassPreProcessorAdapter.preProcess(ClassPreProcessorAdapter.java:65)
	at org.codehaus.aspectwerkz.hook.impl.ClassPreProcessorHelper.defineClass0Pre(ClassPreProcessorHelper.java:107)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:539)
...

NOTE: I'm using Alex Vasseur's adaptor to invoke AspectJ LTW from a 1.4 VM, but with recursion protection added. I don't think that should change the expected behavior of Aj.</bugreport>
<pre-fix-testcases failing="186" file="output/152388/pre-fix/testresults.xml" passing="1892" size="2078"/>
<post-fix-testcases failing="185" file="output/152388/post-fix/testresults.xml" passing="1893" size="2078"/>
<fixedFiles>
<file name="org.aspectj/modules/bridge/src/org/aspectj/bridge/MessageUtil.java" revision="1.12" state="changed">806,808c806,810
&lt; 		    writer.print("\tsee also: " + element.toString());
&lt; 		    if (iter.hasNext()) {
&lt; 		        writer.println();
---
&gt; 		    if (element!=null) {
&gt; 		    	writer.print("\tsee also: " + element.toString());
&gt; 			    if (iter.hasNext()) {
&gt; 			        writer.println();
&gt; 			    }
</file>
</fixedFiles>
</bug>
<bug id="152589" transactionid="68480">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="10"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KZ</concisefingerprint>
<fullfingerprint>K-false K-if K-return K-true O-! T V Z-if</fullfingerprint>
<bugreport>Given the following
------------------------------------------------------------
public aspect A {
    after () throwing (Throwable th) :  execution(* *(..)) {
		System.err.println(thisEnclosingJoinPointStaticPart);
	}
}

class C1 {
	public void anotherMethod() {
		
	}
}
--------------------------------------------------

adding a whitespace before the aspect declaration results in an adviceDidNotMatch warning even though weaving took place and the advice clearly matches. Output from the AJDT event trace shows:

14:38:23 ===========================================================================================
14:38:23 Build kind = AUTOBUILD
14:38:23 Project=bug92895, kind of build requested=Incremental AspectJ compilation
14:38:23 build: Examined delta - source file changes in required project bug92895
14:38:23 Classpath=/home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/bin:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/rt.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/jsse.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/jce.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/charsets.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/sunjce_provider.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/sunpkcs11.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/dnsns.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/localedata.jar:/home/hawkinsh/eclipse/eclipse32/plugins/org.aspectj.runtime_1.5.3.20060801095103/aspectjrt.jar:
14:38:23 Preparing for build: planning to be an incremental build
14:38:23 Starting incremental compilation loop 1 of possibly 5
14:38:23 AJC: compiling source files
14:38:23 Timer event: 215ms: Time to first compiled message
14:38:23 AJC: compiled: /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj
14:38:23 addSourcelineTask message=advice defined in pack.A has not been applied [Xlint:adviceDidNotMatch] file=/home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj line=4
14:38:23  Dropping back to full build
14:38:23 Preparing for build: not going to be incremental because no successful previous full build
14:38:23 AJC: compiling source files
14:38:23 AJC: compiled: /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj
14:38:23 AJC: processing reweavable state
14:38:23 AJC: adding type mungers
14:38:23 Timer event: 452ms: Time to first woven message
14:38:23 AJC: woven aspect pack.A (from /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj)
14:38:23 AJC: woven class pack.C1 (from /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj)
14:38:23 AspectJ reports build successful, build was: FULL
14:38:23 AJDE Callback: finish. Was full build: true
14:38:23 Timer event: 517ms: Total time spent in AJDE
14:38:23 Timer event: 6ms: Create element map (2 rels in project: bug92895)
14:38:23 Types affected during build = 1
14:38:23 Timer event: 3ms: Add markers (2 markers)
14:38:24 Timer event: 1274ms: Total time spent in AJBuilder.build()


namely, the adviceDidNotMatch warning was added and then we fell back to a full build and the warning wasn't cleared. Performing a "clean" build fixes the problem. This is since the pipelining changes.</bugreport>
<testsforfix ID="152589" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testAdviceDidNotMatch_pr152589"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="190" file="output/152589/pre-fix/testresults.xml" passing="1886" size="2076"/>
<post-fix-testcases failing="167" file="output/152589/post-fix/testresults.xml" passing="1685" size="1852"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java" revision="1.4" state="changed">148c148,150
&lt; 
---
&gt; 	//	 If we determine we are going to drop back to a full build - don't need to tell the weaver to report adviceDidNotMatch
&gt; 	private boolean droppingBackToFullBuild; 
&gt; 	
272a275
&gt; 		droppingBackToFullBuild=false;
326c329
&lt; 					weaveQueuedEntries();
---
&gt; 					if (weaveQueuedEntries()) droppingBackToFullBuild=true;
389c392
&lt;     		weaveQueuedEntries();
---
&gt;     		if (weaveQueuedEntries()) droppingBackToFullBuild=true;
441c444,445
&lt; 	private void weaveQueuedEntries() throws IOException {
---
&gt; 	/** Return true if we've decided to drop back to a full build (too much has changed) */
&gt; 	private boolean weaveQueuedEntries() throws IOException {
450c454
&lt; 		if (weaver.needToReweaveWorld() &amp;&amp; !isBatchCompile) return;
---
&gt; 		if (weaver.needToReweaveWorld() &amp;&amp; !isBatchCompile) return true;
454a459
&gt; 		return false;
517c522
&lt; 		weaver.allWeavingComplete();
---
&gt; 		if (!droppingBackToFullBuild) weaver.allWeavingComplete();
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.61" state="changed">1425a1426,1439
&gt; 	public void testAdviceDidNotMatch_pr152589() {
&gt; 		initialiseProject("PR152589");
&gt; 		build("PR152589");
&gt; 		List warnings = MyTaskListManager.getWarningMessages();
&gt; 		assertTrue("There should be no warnings:\n"+warnings,
&gt; 				warnings.isEmpty());
&gt; 		alter("PR152589","inc1");
&gt; 		build("PR152589");
&gt; 		checkWasFullBuild();
&gt; 		warnings = MyTaskListManager.getWarningMessages();
&gt; 		assertTrue("There should be no warnings after adding a whitespace:\n"
&gt; 				+warnings,warnings.isEmpty());	
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR152589/base/A.aj" revision="1.1" state="new">

public aspect A {
    after () throwing (Throwable th) :  execution(* *(..)) {
		System.err.println(thisEnclosingJoinPointStaticPart);
	}
}

class C1 {
	public void anotherMethod() {
		
	}
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR152589/inc1/A.aj" revision="1.1" state="new"> 

public aspect A {
    after () throwing (Throwable th) :  execution(* *(..)) {
		System.err.println(thisEnclosingJoinPointStaticPart);
	}
}

class C1 {
	public void anotherMethod() {
		
	}
}
</file>
</fixedFiles>
</bug>
<bug id="152631" transactionid="70024">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-null M O-!= O-&amp;&amp; T V Z-if</fullfingerprint>
<bugreport>This occurs in the AspectJ build in AJDT from August 1 but not from July 31:

java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:250)
at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194)
at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:454)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1597)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1548)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1328)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1124)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:451)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:389)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:377)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:891)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in:public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect extends java.lang.Object implements glassbox.agent.api.NotSerializable:
private static Throwable ajc$initFailureCause [Synthetic]
public static final glassbox.agent.ErrorContainmentTest$ErrorMockAspect ajc$perSingletonInstance [Synthetic]
static void &lt;clinit&gt;():
catch java.lang.Throwable -&gt; E0
|               INVOKESTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$postClinit ()V   (line 60)
catch java.lang.Throwable -&gt; E0
GOTO L0
E0: ASTORE_0
ALOAD_0
PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable;
L0: RETURN
end static void &lt;clinit&gt;()
void &lt;init&gt;():
ALOAD_0     // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this   (line 60)
INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V
RETURN
end void &lt;init&gt;()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc()    AdviceAttribute(before, (scope() &amp;&amp; call(* hook1())), 0, 1670)
:
NEW java.lang.RuntimeException   (line 64)
DUP
LDC "rte"
INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2()    AdviceAttribute(before, execution(* glassbox.agent.ErrorContainmentTest.hook5()), 0, 1764)
:
NEW java.lang.RuntimeException   (line 67)
DUP
LDC "rte"
INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2()
public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure)    AdviceAttribute(around, (scope() &amp;&amp; call(* hook2())), 1, 1913)
:
NEW java.lang.Error   (line 71)
DUP
LDC "foo"
INVOKESPECIAL java.lang.Error.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
end public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure)
static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable    org.aspectj.weaver.AjAttribute$AjSynthetic@19a01f9
:
ALOAD_0     // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this   (line 1)
ICONST_0
ANEWARRAY java.lang.Object
INVOKEVIRTUAL org.aspectj.runtime.internal.AroundClosure.run ([Ljava/lang/Object;)Ljava/lang/Object;
INVOKESTATIC org.aspectj.runtime.internal.Conversions.voidValue (Ljava/lang/Object;)Ljava/lang/Object;
RETURN
end static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable
public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f()    AdviceAttribute(after, (scope() &amp;&amp; call(* hook4())), 0, 1991)
:
NEW org.aspectj.lang.SoftException   (line 74)
DUP
ACONST_NULL
INVOKESPECIAL org.aspectj.lang.SoftException.&lt;init&gt; (Ljava/lang/Throwable;)V
ATHROW
end public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc()    AdviceAttribute(before, logErrorInTest(), 0, 2446)
:
GETSTATIC glassbox.agent.ErrorContainmentTest.logCount I   (line 84)
ICONST_1
IADD
PUTSTATIC glassbox.agent.ErrorContainmentTest.logCount I
RETURN   (line 85)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 2506)
:
GETSTATIC java.lang.System.err Ljava/io/PrintStream;   (line 87)
LDC "match"
INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
RETURN   (line 88)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest))))), 0, 2721)
:
GETSTATIC java.lang.System.err Ljava/io/PrintStream;   (line 90)
LDC "match in test"
INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
RETURN   (line 91)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow(logError()))), 0, 2923)
:
GETSTATIC java.lang.System.err Ljava/io/PrintStream;   (line 93)
LDC "match in log"
INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V
RETURN   (line 94)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351()
public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62()    AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 3069)
:
GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I   (line 96)
ICONST_1
IADD
PUTSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I
GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I   (line 97)
ICONST_2
IF_ICMPGE L0
NEW java.lang.RuntimeException   (line 98)
DUP
LDC "recursive logging failure"
INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V
ATHROW
L0: RETURN   (line 100)
end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62()
public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf()    org.aspectj.weaver.AjAttribute$AjSynthetic@3cd8fe
:
GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;   (line 1)
IFNONNULL L0
NEW org.aspectj.lang.NoAspectBoundException
DUP
LDC "glassbox_agent_ErrorContainmentTest$ErrorMockAspect"
GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable;
INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt; (Ljava/lang/String;Ljava/lang/Throwable;)V
ATHROW
L0: GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;
ARETURN
end public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf()
public static boolean hasAspect()    org.aspectj.weaver.AjAttribute$AjSynthetic@1bd4f6
:
GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;   (line 1)
IFNULL L0
ICONST_1
IRETURN
L0: ICONST_0
IRETURN
end public static boolean hasAspect()
private static void ajc$postClinit()    org.aspectj.weaver.AjAttribute$AjSynthetic@1febf91
:
NEW glassbox.agent.ErrorContainmentTest$ErrorMockAspect   (line 1)
DUP
INVOKESPECIAL glassbox.agent.ErrorContainmentTest$ErrorMockAspect.&lt;init&gt; ()V
PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect;
RETURN
end private static void ajc$postClinit()
end public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect
when type munging with (BcelTypeMunger ResolvedTypeMunger(Parent, null))
when weaving aspects
when weaving
when batch building BuildConfig[C:\devel\glassbox\.metadata\.plugins\org.eclipse.ajdt.core\glassboxMonitor.generated.lst] #Files=107

The source is:

public class ErrorContainmentTest extends TestCase {
...
	static aspect ErrorMockAspect implements NotSerializable {
...

I will try to narrow this down if the problem isn't obvious.</bugreport>
<testsforfix ID="152631" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testDecpAndCflowadderMungerClash_pr152631"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="decp and cflowadder munger clash"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="189" file="output/152631/pre-fix/testresults.xml" passing="1891" size="2080"/>
<post-fix-testcases failing="143" file="output/152631/post-fix/testresults.xml" passing="1610" size="1753"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java" revision="1.82" state="changed">250c250
&lt;                             if (m.getMunger().getKind() == ResolvedTypeMunger.Method) {
---
&gt;                             if (m.getMunger()!=null &amp;&amp; m.getMunger().getKind() == ResolvedTypeMunger.Method) {
268c268
&lt;                             } else if (m.getMunger().getKind() == ResolvedTypeMunger.MethodDelegate) {
---
&gt;                             } else if (m.getMunger()!=null &amp;&amp; m.getMunger().getKind() == ResolvedTypeMunger.MethodDelegate) {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.21" state="changed">256a257,260
&gt;     &lt;ajc-test dir="bugs153/pr152631" title="decp and cflowadder munger clash"&gt;
&gt;       &lt;compile files="EMA.java" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.22" state="changed">28a29
&gt;   public void testDecpAndCflowadderMungerClash_pr152631() { runTest("decp and cflowadder munger clash");}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr152631/EMA.java" revision="1.1" state="new">
public aspect EMA {
    before() : cflow(execution(* *(..))) {}
}

aspect Goo {
  declare parents: EMA extends C;
  public void EMA.m() {}
}

abstract class C {
  abstract void m();
}
</file>
</fixedFiles>
</bug>
<bug id="152848" transactionid="70019">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="14"/>
<property name="lines-deleted" value="1"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="16"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-import K-new K-null K-return M O-|| O-! O-() O-+ T V Y Z-if Z-throw</fullfingerprint>
<tag>exception</tag>
<bugreport>I get the exception below when I enable AspectJ on my Java project:

java.lang.IllegalStateException
at org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:42)
at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:82)
at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:42)
at org.aspectj.weaver.asm.AsmDelegate.ensureSignatureUnpacked(AsmDelegate.java:410)
at org.aspectj.weaver.asm.AsmDelegate.getDeclaredInterfaces(AsmDelegate.java:538)
at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:426)
at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:64)
at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1155)
at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1134)
at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1201)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:643)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:519)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1058)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:480)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:190)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:43)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:53)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:167)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:413)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:466)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:331)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:400)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:512)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: Expecting raw type</bugreport>
<pre-fix-testcases failing="185" file="output/152848/pre-fix/testresults.xml" passing="1923" size="2108"/>
<post-fix-testcases failing="189" file="output/152848/post-fix/testresults.xml" passing="1919" size="2108"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/TypeFactory.java" revision="1.14" state="changed">42c42
&lt; 				if (!aBaseType.isRawType()) throw new IllegalStateException("Expecting raw type");
---
&gt; 				if (!aBaseType.isRawType()) throw new IllegalStateException("Expecting raw type, not: "+aBaseType);
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java" revision="1.11" state="changed">26a27,28
&gt; import org.aspectj.weaver.tools.Trace;
&gt; import org.aspectj.weaver.tools.TraceFactory;
34a37,38
&gt; 	private static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelGenericSignatureToTypeXConverter.class);
&gt; 	
77a82,91
&gt; 			
&gt; 			// Sometimes we may find that when the code is being load-time woven that the types have changed.
&gt; 			// Perhaps an old form of a library jar is being used - this can mean we discover right here
&gt; 			// that a type is not parameterizable (is that a word?).  I think in these cases it is ok to
&gt; 			// just return with what we know (the base type). (see pr152848)
&gt; 			if (!(theBaseType.isGenericType() || theBaseType.isRawType())) {
&gt; 				if (trace.isTraceEnabled()) trace.event("classTypeSignature2TypeX: this type is not a generic type:",null,new Object[]{theBaseType});
&gt; 				return theBaseType;
&gt; 			}
&gt; 			
87d100
&lt; 				
</file>
</fixedFiles>
</bug>
<bug id="152871" transactionid="69663">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="4"/>
<property name="classes-churned" value="4"/>
<property name="methods-churned" value="4"/>
<property name="hunks" value="19"/>
<property name="lines-added" value="22"/>
<property name="lines-deleted" value="7"/>
<property name="lines-modified" value="14"/>
<property name="lines-churned" value="43"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-finally K-if K-import K-null K-this K-try M O-== O-() O-++ O-cast T V Y Z-cast Z-if</fullfingerprint>
<bugreport>I'm analyzing a profile of cpu times spent weaving into Weblogic 9.2 with LTW. Of a total of 22 seconds of CPU, 2.6 seconds are spent in ClassParser.parse() with the exact same amount spent underneath WeavingAdaptor.shouldWeave and WeavingAdaptor.shouldWeaveAnnotationStyleAspect

WeavingAdaptor.shouldWeave is calling CLWA.accept which calls Utility.makeJavaClass which calls ClassParser.parse. Then the exact same expensive operation is getting called again in shouldWeaveAnnotationStyleAspect via BcelWorld.isAnnotationStyleAspect. 

Proposed Simple fix: allow shouldWeave to also return a BcelObjectType by setting a field in the adapter (which would be cleared to be null on start). The in shouldWeaveAnnotationStyleAspect, check the field. I'd be glad to write and test a patch to do this if the committers agree with the proposal.

We wouldn't want to always parse the bytecode, because it would we should be aiming to avoid that expense as often as possible. In our case, we're using exclusion type patterns that currently require accept to make a Java class. In cases where that's not necessary, it also seems odd that shouldWeaveAnnotationStyleAspect runs at all: I will post a separate enhancement request for limiting the cases where it runs.</bugreport>
<testsforfix ID="152871" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testParsingBytecodeLess_pr152871"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="parsing bytecode less"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/152871/pre-fix/testresults.xml" passing="1893" size="2080"/>
<post-fix-testcases failing="128" file="output/152871/post-fix/testresults.xml" passing="1539" size="1667"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java" revision="1.11" state="changed">39a40,46
&gt; 
&gt;     /** Use if the classname is known, saves a bytecode parse */
&gt; 	public UnwovenClassFile(String filename, String classname,byte[] bytes) {
&gt; 		this.filename = filename;
&gt; 		this.className = classname;
&gt; 		this.bytes = bytes;
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.35" state="changed">48a49
&gt; import org.aspectj.weaver.bcel.Utility;
79a81
&gt; 	protected BcelObjectType delegateForCurrentClass; // lazily initialized, should be used to prevent parsing bytecode multiple times
210,221c212,229
&lt; 	    	if (trace.isTraceEnabled()) trace.enter("weaveClass",this,new Object[] {name,bytes});
&lt; 
&lt; 			if (shouldWeave(name, bytes)) {
&lt; 				info("weaving '" + name + "'");
&lt; 				bytes = getWovenBytes(name, bytes);
&lt; 			} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
&lt; 	            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
&lt; 	            info("weaving '" + name + "'");
&lt; 	            bytes = getAtAspectJAspectBytes(name, bytes);
&lt; 	        }
&lt; 			else {
&lt; 				info("not weaving '" + name + "'");
---
&gt; 			try {
&gt; 				delegateForCurrentClass=null; // TODO will need stack if going recursive...
&gt; 		    	if (trace.isTraceEnabled()) trace.enter("weaveClass",this,new Object[] {name,bytes});
&gt; 				if (shouldWeave(name, bytes)) {
&gt; 					info("weaving '" + name + "'");
&gt; 					bytes = getWovenBytes(name, bytes);
&gt; 				} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
&gt; 		            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
&gt; 		            info("weaving '" + name + "'");
&gt; 		            bytes = getAtAspectJAspectBytes(name, bytes);
&gt; 		        }
&gt; 				else {
&gt; 					info("not weaving '" + name + "'");
&gt; 				}
&gt; 	
&gt; 				if (trace.isTraceEnabled()) trace.exit("weaveClass",bytes);
&gt; 			} finally {
&gt; 				delegateForCurrentClass=null;
223,224d230
&lt; 
&lt; 			if (trace.isTraceEnabled()) trace.exit("weaveClass",bytes);
256,257c262
&lt; 		       !((/*(name.startsWith("org.apache.bcel.")//FIXME AV why ? bcel is wrapped in org.aspectj.
&lt;                 ||*/ name.startsWith("org.aspectj.")
---
&gt; 		       !((name.startsWith("org.aspectj.")
276c281,287
&lt;         return bcelWorld.isAnnotationStyleAspect(name, bytes);
---
&gt; 		ensureDelegateInitialized(name,bytes);
&gt; 		return (delegateForCurrentClass.isAnnotationStyleAspect());
&gt; 	}
&gt; 
&gt;     protected void ensureDelegateInitialized(String name,byte[] bytes) {
&gt;     	if (delegateForCurrentClass==null)
&gt;     	  delegateForCurrentClass =  ((BcelWorld)weaver.getWorld()).addSourceObjectType(Utility.makeJavaClass(name, bytes));
481d491
&lt;         private BcelObjectType delegate;
484c494,495
&lt; 			this.unwovenClass = new UnwovenClassFile(name,bytes);
---
&gt;         	ensureDelegateInitialized(name, bytes);
&gt; 			this.unwovenClass = new UnwovenClassFile(name,delegateForCurrentClass.getResolvedTypeX().getName(),bytes);
490,491c501
&lt; 
&lt; 			delegate = bcelWorld.addSourceObjectType(unwovenClass.getJavaClass());
---
&gt; 			
542d551
&lt; 					if (delegate!=null) delegate.weavingCompleted();
543a553,555
&gt; 					if (delegateForCurrentClass!=null) delegateForCurrentClass.weavingCompleted();
&gt; 					ResolvedType.resetPrimitives();
&gt; 					//bcelWorld.discardType(typeBeingProcessed.getResolvedTypeX()); // work in progress
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/Utility.java" revision="1.31" state="changed">523a524,526
&gt; 	
&gt; 	/** For testing purposes: bit clunky but does work */
&gt; 	public static int testingParseCounter=0;
526a530
&gt; 			testingParseCounter++;
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java" revision="1.49" state="changed">39d38
&lt; import org.aspectj.weaver.bcel.BcelObjectType;
41,42d39
&lt; import org.aspectj.weaver.bcel.BcelWorld;
&lt; import org.aspectj.weaver.bcel.Utility;
545,546c542,544
&lt;         BcelObjectType bct = ((BcelWorld)weaver.getWorld()).addSourceObjectType(Utility.makeJavaClass(null, bytes));
&lt;         ResolvedType classInfo = bct.getResolvedTypeX();//BAD: weaver.getWorld().resolve(UnresolvedType.forName(className), true);
---
&gt;         
&gt;         ensureDelegateInitialized(className,bytes);
&gt;         ResolvedType classInfo = delegateForCurrentClass.getResolvedTypeX();//BAD: weaver.getWorld().resolve(UnresolvedType.forName(className), true);
569c567,568
&lt;     //FIXME we don't use include/exclude of others aop.xml
---
&gt; 
&gt; 	//FIXME we don't use include/exclude of others aop.xml
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.22" state="changed">5a6,18
&gt;     &lt;ajc-test dir="bugs153/pr152871" title="parsing bytecode less"&gt;
&gt;       &lt;compile files="MyClass.java" options="-1.5"/&gt;
&gt;       &lt;compile files="MyAspect.java" options="-1.5 -Xlint:ignore"/&gt;
&gt;       &lt;run class="a.MyClass" ltw="aop.xml"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="advice running"/&gt;
&gt;           &lt;line text="hello"/&gt;
&gt;           &lt;line text="advice running"/&gt;
&gt;           &lt;line text="world"/&gt;
&gt;  	    &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.23" state="changed">18a19
&gt; import org.aspectj.weaver.bcel.Utility;
50c51,59
&lt; 
---
&gt;   public void testParsingBytecodeLess_pr152871() { 
&gt; 	  Utility.testingParseCounter=0;
&gt; 	  runTest("parsing bytecode less"); 
&gt; 	  assertTrue("Should have called parse 5 times, not "+Utility.testingParseCounter+" times",Utility.testingParseCounter==5);
&gt; 	  // 5 means:   
&gt; 	  // (1)=registerAspect   
&gt; 	  // (2,3)=checkingIfShouldWeave,AcceptingResult for class
&gt; 	  // (4,5)=checkingIfShouldWeave,AcceptingResult for aspect
&gt;   }
52d60
&lt; 
</file>
</fixedFiles>
</bug>
<bug id="152873" transactionid="69987">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="10"/>
<property name="lines-added" value="172"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="24"/>
<property name="lines-churned" value="196"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-class K-else K-false K-if K-import K-new K-null K-package K-return K-this K-true K-try M O-== O-&amp;&amp; O-+ T V Y Z-if</fullfingerprint>
<bugreport>The current implementation of shouldWeaveAnnotationStyleAspect is surprising because it weaves annotation aspects without regard as to whether they are registered in an aop.xml file. If an annotation-style aspect is loaded, it is always woven, even if it doesn't match the for what classes should be woven in the aop.xml file, and even if not registered therein. This is both unexpected and it imposes significant overhead on configurations where they aren't used and simple fast match exclusions prevent weaving (see bug #152871).

Is there really a need to weave annotation style aspects like this? Why can't it be done by using the aop.xml configuration mechanism that all other aspects use? In a large system, the CPU overhead of parsing and creating BCEL objects for all loaded classes should be avoided where possible.</bugreport>
<testsforfix ID="152873" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java">
      <test NAME="testAspectOfWhenAspectExcluded_pr152873"/>
      <test NAME="testAspectOfWhenNonAspectExcluded_pr152873"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml">
      <test NAME="AspectOfWhenAspectExcluded"/>
      <test NAME="AspectOfWhenNonAspectExcluded"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/152873/pre-fix/testresults.xml" passing="1892" size="2078"/>
<post-fix-testcases failing="190" file="output/152873/post-fix/testresults.xml" passing="1888" size="2078"/>
<fixedFiles>
<file name="org.aspectj/modules/testing/newsrc/org/aspectj/testing/AntSpec.java" revision="1.4" state="changed">53c53,54
&lt;             + File.pathSeparator + ".." + File.separator + "lib/bcel/bcel.jar";
---
&gt;             + File.pathSeparator + ".." + File.separator + "lib/bcel/bcel.jar"
&gt;     		+ File.pathSeparator + ".." + File.separator + "lib/asm/asm-aj.jar";
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java" revision="1.92" state="changed">1204a1205,1208
&gt; 	    
&gt; 	    public boolean isASMAround() { 
&gt; 	    	return isASMAround;
&gt; 	    }
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java" revision="1.37" state="changed">39a40
&gt; import org.aspectj.org.objectweb.asm.ClassReader;
215,224c216,234
&lt; 				if (shouldWeave(name, bytes)) {
&lt; 					info("weaving '" + name + "'");
&lt; 					bytes = getWovenBytes(name, bytes);
&lt; 				} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
&lt; 		            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
&lt; 		            info("weaving '" + name + "'");
&lt; 		            bytes = getAtAspectJAspectBytes(name, bytes);
&lt; 		        }
&lt; 				else {
&lt; 					info("not weaving '" + name + "'");
---
&gt; 				name = name.replace('/','.');
&gt; 				if (couldWeave(name, bytes)) {
&gt; 			        if (accept(name, bytes)) {
&gt; 			            // TODO @AspectJ problem
&gt; 			            // Annotation style aspects need to be included regardless in order to get
&gt; 			            // a valid aspectOf()/hasAspect() generated in them.  However - if they are excluded
&gt; 			            // (via include/exclude in aop.xml) they really should only get aspectOf()/hasAspect()
&gt; 			            // and not be included in the full set of aspects being applied by 'this' weaver
&gt; 						info("weaving '" + name + "'");
&gt; 						bytes = getWovenBytes(name, bytes);
&gt; 					} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
&gt; 			            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
&gt; 			            info("weaving '" + name + "'");
&gt; 			            bytes = getAtAspectJAspectBytes(name, bytes);
&gt; 					} else {
&gt; 						info("not weaving '" + name + "'");
&gt; 					}
&gt; 		        } else {
&gt; 					info("cannot weave '" + name + "'");
238c248
&lt;      * @return true if should weave (but maybe we still need to munge it for @AspectJ aspectof support)
---
&gt;      * @return true if even valid to weave: either with an accept check or to munge it for @AspectJ aspectof support
240,248c250,251
&lt;     private boolean shouldWeave (String name, byte[] bytes) {
&lt; 		name = name.replace('/','.');
&lt; 		boolean b = !generatedClasses.containsKey(name) &amp;&amp; shouldWeaveName(name);
&lt;         return b &amp;&amp; accept(name, bytes);
&lt; //        &amp;&amp; shouldWeaveAnnotationStyleAspect(name);
&lt; //        // we recall shouldWeaveAnnotationStyleAspect as we need to add aspectOf methods for @Aspect anyway
&lt; //        //FIXME AV - this is half ok as the aspect will be weaved by others. In theory if the aspect
&lt; //        // is excluded from include/exclude config we should only weave late type mungers for aspectof
&lt; //        return b &amp;&amp; (accept(name) || shouldWeaveAnnotationStyleAspect(name));
---
&gt;     private boolean couldWeave (String name, byte[] bytes) {
&gt; 		return !generatedClasses.containsKey(name) &amp;&amp; shouldWeaveName(name);
279,281c282,285
&lt; 		// AV: instead of doing resolve that would lookup stuff on disk thru BCEL ClassLoaderRepository
&lt;         // we reuse bytes[] here to do a fast lookup for @Aspect annotation
&lt; 		ensureDelegateInitialized(name,bytes);
---
&gt;     	if (delegateForCurrentClass==null) {
&gt;     		if (weaver.getWorld().isASMAround()) return asmCheckAnnotationStyleAspect(bytes);
&gt;     		else ensureDelegateInitialized(name, bytes);
&gt;     	}
284a289,304
&gt; 	private boolean asmCheckAnnotationStyleAspect(byte[] bytes) {
&gt; 		IsAtAspectAnnotationVisitor detector = new IsAtAspectAnnotationVisitor();
&gt; 
&gt; 		ClassReader cr = new ClassReader(bytes);
&gt; 	    try {
&gt; 	    	cr.accept(detector, true);//, ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES);
&gt; 	    } catch (Exception spe) {
&gt; 	    	// if anything goes wrong, e.g., an NPE, then assume it's NOT an @AspectJ aspect...
&gt; 	    	System.err.println("Unexpected problem parsing bytes to discover @Aspect annotation");
&gt; 	    	spe.printStackTrace();
&gt; 	    	return false;
&gt; 	    }
&gt; 	    
&gt; 	    return detector.isAspect();
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java" revision="1.26" state="changed">203a204,210
&gt;     public void testAspectOfWhenAspectExcluded_pr152873() {
&gt;         runTest("AspectOfWhenAspectExcluded");
&gt;     }
&gt;     public void testAspectOfWhenNonAspectExcluded_pr152873() {
&gt;     	runTest("AspectOfWhenNonAspectExcluded");
&gt;     }
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc150/ataspectj/ltw.xml" revision="1.26" state="changed">300a301,314
&gt;     &lt;ajc-test dir="java5/ataspectj" title="AspectOfWhenAspectExcluded"&gt;
&gt;         &lt;compile
&gt;             files="ataspectj/bugs/AspectOfWhenAspectNotInIncludeTest.java,ataspectj/TestHelper.java"
&gt;             options="-1.5 -XterminateAfterCompilation"/&gt;
&gt;         &lt;run class="ataspectj.bugs.AspectOfWhenAspectNotInIncludeTest" ltw="ataspectj/bugs/aop-aspectofwhenaspectexcludedtest.xml"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="java5/ataspectj" title="AspectOfWhenNonAspectExcluded"&gt;
&gt;         &lt;compile
&gt;             files="ataspectj/bugs/NotAspect.java"
&gt;             options="-1.5 -XterminateAfterCompilation"/&gt;
&gt;         &lt;run class="ataspectj.bugs.NotAspect" ltw="ataspectj/bugs/aop-aspectofwhennonaspectexcludedtest.xml"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.java" revision="1.1" state="new">/* *******************************************************************
 * Copyright (c) 2006 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *     Eugene Kuleshov, Ron Bodkin    initial implementation 
 * ******************************************************************/
package org.aspectj.weaver.tools;

import org.aspectj.org.objectweb.asm.AnnotationVisitor;
import org.aspectj.org.objectweb.asm.Attribute;
import org.aspectj.org.objectweb.asm.ClassVisitor;
import org.aspectj.org.objectweb.asm.FieldVisitor;
import org.aspectj.org.objectweb.asm.Label;
import org.aspectj.org.objectweb.asm.MethodVisitor;

// should extend EmptyVisitor but it's not currently included with AspectJ's ASM...
public class IsAtAspectAnnotationVisitor implements ClassVisitor, FieldVisitor,
		MethodVisitor, AnnotationVisitor {
	private boolean isAspect = false;

	public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
		if ("Lorg/aspectj/lang/annotation/Aspect;".equals(desc)) {
			isAspect = true;
		}
		return this;
	}

	public FieldVisitor visitField(int access, String name, String desc,
			String signature, Object value) {
		return null;
	}

	public MethodVisitor visitMethod(int access, String name, String desc,
			String signature, String[] exceptions) {
		return null;
	}

	public boolean isAspect() {
		return isAspect;
	}

	public void visit(int version, int access, String name, String signature,
			String superName, String[] interfaces) {
	}

	public void visitSource(String source, String debug) {
	}

	public void visitOuterClass(String owner, String name, String desc) {
	}

	public void visitAttribute(Attribute attr) {
	}

	public void visitInnerClass(String name, String outerName,
			String innerName, int access) {
	}

	public void visitEnd() {
	}

	public AnnotationVisitor visitAnnotationDefault() {
		return this;
	}

	public AnnotationVisitor visitParameterAnnotation(int parameter,
			String desc, boolean visible) {
		return this;
	}

	public void visitCode() {
	}

	public void visitInsn(int opcode) {
	}

	public void visitIntInsn(int opcode, int operand) {
	}

	public void visitVarInsn(int opcode, int var) {
	}

	public void visitTypeInsn(int opcode, String desc) {
	}

	public void visitFieldInsn(int opcode, String owner, String name,
			String desc) {
	}

	public void visitMethodInsn(int opcode, String owner, String name,
			String desc) {
	}

	public void visitJumpInsn(int opcode, Label label) {
	}

	public void visitLabel(Label label) {
	}

	public void visitLdcInsn(Object cst) {
	}

	public void visitIincInsn(int var, int increment) {
	}

	public void visitTableSwitchInsn(int min, int max, Label dflt,
			Label labels[]) {
	}

	public void visitLookupSwitchInsn(Label dflt, int keys[], Label labels[]) {
	}

	public void visitMultiANewArrayInsn(String desc, int dims) {
	}

	public void visitTryCatchBlock(Label start, Label end, Label handler,
			String type) {
	}

	public void visitLocalVariable(String name, String desc, String signature,
			Label start, Label end, int index) {
	}

	public void visitLineNumber(int line, Label start) {
	}

	public void visitMaxs(int maxStack, int maxLocals) {
	}

	public void visit(String name, Object value) {
	}

	public void visitEnum(String name, String desc, String value) {
	}

	public AnnotationVisitor visitAnnotation(String name, String desc) {
		return this;
	}

	public AnnotationVisitor visitArray(String name) {
		return this;
	}
}
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/bugs/NotAspect.java" revision="1.1" state="new">package ataspectj.bugs;

@Deprecated
public class NotAspect {
	public static void main(String argz[]) {}
}
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/bugs/aop-aspectofwhenaspectexcludedtest.xml" revision="1.1" state="new">&lt;aspectj&gt;
    &lt;weaver options="-1.5 -showWeaveInfo"&gt;
        &lt;exclude within="ataspectj..*"/&gt;
    &lt;/weaver&gt;
    &lt;aspects&gt;
        &lt;aspect name="ataspectj.bugs.AspectOfWhenAspectNotInIncludeTest.TestAspect"/&gt;
        &lt;aspect name="ataspectj.bugs.AspectOfWhenAspectNotInIncludeTest.TestAspectForAspect"/&gt;
    &lt;/aspects&gt;
&lt;/aspectj&gt;
</file>
<file name="org.aspectj/modules/tests/java5/ataspectj/ataspectj/bugs/aop-aspectofwhennonaspectexcludedtest.xml" revision="1.1" state="new">&lt;aspectj&gt;
    &lt;weaver options="-1.5 -verbose"&gt;
        &lt;exclude within="ataspectj..*"/&gt;
    &lt;/weaver&gt;
    &lt;aspects&gt;
        &lt;aspect name="ataspectj.bugs.NotAspect"/&gt;
    &lt;/aspects&gt;
&lt;/aspectj&gt;
</file>
</fixedFiles>
</bug>
<bug id="153490" transactionid="68571">
<property name="files-churned" value="8"/>
<property name="java-files-churned" value="8"/>
<property name="classes-churned" value="8"/>
<property name="methods-churned" value="8"/>
<property name="hunks" value="25"/>
<property name="lines-added" value="62"/>
<property name="lines-deleted" value="68"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="136"/>
<property name="priority" value="P3"/>
<property name="severity" value="minor"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-if K-import K-instanceof K-new K-null K-return K-throw M O-&lt; O-== O-- O-! O-!= O-() O-++ O-cast O-instanceof T V Y Z-cast Z-for Z-if Z-throw Z-vardecl</fullfingerprint>
<tag>exception</tag>
<bugreport>I try out Contract4J 0.5 with AspectJ 1.5.2 (Build 20060629124300) and Eclipse 3.2 (Build M20060629-1905) under Windows XP SP2 and Java 1.5.0_06. So I became following exception. (You will find my testcode below the exception.) I am not sure if this bug related to Contract4J or to AspectJ!?

==== The Exception ====

java.lang.IllegalStateException
at org.aspectj.weaver.asm.AsmDelegate.getFormalTypeParametersFromOuterClass(AsmDelegate.java:465)
at org.aspectj.weaver.asm.AsmDelegate.ensureSignatureUnpacked(AsmDelegate.java:395)
at org.aspectj.weaver.asm.AsmDelegate.getDeclaredInterfaces(AsmDelegate.java:538)
at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:426)
at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:64)
at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1155)
at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1134)
at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1201)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:643)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:519)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1058)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:480)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:190)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:43)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:53)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.getMemberType(BinaryTypeBinding.java:618)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.findMemberType(Scope.java:928)
at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.java:449)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:903)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:326)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:829)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:422)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:178)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)
at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:519)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:271)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType??

==== My TestCode ====

import org.contract4j5.Contract;
import org.contract4j5.Post;
import org.contract4j5.Pre;

import org.contract4j5.aspects.Contract4J;

// this is a dummy code!!

@Contract
public class Foo {

  private String fooField = null;
  
  @Pre("nr != null")
  public void setFooField(String f) {
    fooField = f; 
  }
  
  @Post("$return != null")
  public String getFooField() {
    return fooField;
  }
  
  public static void main(String[] args) {
    
    Contract4J.setEnabled(Contract4J.TestType.Pre,   true); //1
    Contract4J.setEnabled(Contract4J.TestType.Post,  true); //2 
    Contract4J.setEnabled(Contract4J.TestType.Invar, true); //3
    
    Foo foo = new Foo();
    foo.setFooField(null);
    System.out.println(foo.getFooField());
    
  }
  
}</bugreport>
<pre-fix-testcases failing="192" file="output/153490/pre-fix/testresults.xml" passing="1922" size="2114"/>
<post-fix-testcases failing="190" file="output/153490/post-fix/testresults.xml" passing="1924" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java" revision="1.62" state="changed">29d28
&lt; import org.aspectj.apache.bcel.classfile.Signature.ClassSignature;
42d40
&lt; import org.aspectj.weaver.ReferenceTypeDelegate;
89d86
&lt; 	private ClassSignature cachedGenericClassTypeSignature;
165c162
&lt; 		cachedGenericClassTypeSignature = javaClass.getGenericClassTypeSignature();
---
&gt; 		cachedGenericClassTypeSignature = null;
253c250
&lt; 	    	Signature.ClassSignature classSig = cachedGenericClassTypeSignature;//javaClass.getGenericClassTypeSignature();
---
&gt; 	    	Signature.ClassSignature classSig = getGenericClassTypeSignature();//cachedGenericClassTypeSignature;//javaClass.getGenericClassTypeSignature();
659,662d655
&lt; 	Signature.ClassSignature getGenericClassTypeSignature() {
&lt; 		return cachedGenericClassTypeSignature;
&lt; 	}
&lt; 	
671c664
&lt; 			if (isNestedClass()) {
---
&gt; 			if (isNested()) {
746,748d738
&lt; 	private boolean isNestedClass() {
&lt; 		return className.indexOf('$') != -1;
&lt; 	}
750,751c740,741
&lt; 	private ReferenceType getOuterClass() {
&lt; 		if (!isNestedClass()) throw new IllegalStateException("Can't get the outer class of a non-nested type");
---
&gt; 	public ResolvedType getOuterClass() {
&gt; 		if (!isNested()) throw new IllegalStateException("Can't get the outer class of a non-nested type");
758,782d747
&lt; 	private Signature.FormalTypeParameter[] getFormalTypeParametersFromOuterClass() {
&lt; 		List typeParameters = new ArrayList();
&lt; 		ReferenceType outer = getOuterClass();
&lt; 		ReferenceTypeDelegate outerDelegate = outer.getDelegate();
&lt; 		if (!(outerDelegate instanceof BcelObjectType)) {
&lt; 			throw new IllegalStateException("How come we're in BcelObjectType resolving an inner type of something that is NOT a BcelObjectType??");
&lt; 		}
&lt; 		BcelObjectType outerObjectType = (BcelObjectType) outerDelegate;
&lt; 		if (outerObjectType.isNestedClass()) {
&lt; 			Signature.FormalTypeParameter[] parentParams = outerObjectType.getFormalTypeParametersFromOuterClass();
&lt; 			for (int i = 0; i &lt; parentParams.length; i++) {
&lt; 				typeParameters.add(parentParams[i]);
&lt; 			}
&lt; 		}
&lt; 		Signature.ClassSignature outerSig = outerObjectType.getGenericClassTypeSignature();
&lt; 		if (outerSig != null) {
&lt; 			for (int i = 0; i &lt; outerSig.formalTypeParameters .length; i++) {
&lt; 				typeParameters.add(outerSig.formalTypeParameters[i]);
&lt; 			}
&lt; 		} 
&lt; 		
&lt; 		Signature.FormalTypeParameter[] ret = new Signature.FormalTypeParameter[typeParameters.size()];
&lt; 		typeParameters.toArray(ret);
&lt; 		return ret;
&lt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/asm/AsmDelegate.java" revision="1.2" state="changed">23a24,26
&gt; import org.aspectj.org.objectweb.asm.Attribute;
&gt; import org.aspectj.org.objectweb.asm.ClassReader;
&gt; import org.aspectj.org.objectweb.asm.Opcodes;
31d33
&lt; import org.aspectj.weaver.ReferenceTypeDelegate;
51,53d52
&lt; import org.aspectj.org.objectweb.asm.Attribute;
&lt; import org.aspectj.org.objectweb.asm.ClassReader;
&lt; import org.aspectj.org.objectweb.asm.Opcodes;
317a317
&gt; 
452c452
&lt; 	private ReferenceType getOuterClass() {
---
&gt; 	public ResolvedType getOuterClass() {
460,489c460
&lt; 	private Signature.FormalTypeParameter[] getFormalTypeParametersFromOuterClass() {
&lt; 		List typeParameters = new ArrayList();
&lt; 		ReferenceType outer = getOuterClass();
&lt; 		ReferenceTypeDelegate outerDelegate = outer.getDelegate();
&lt; 		if (!(outerDelegate instanceof AsmDelegate)) {
&lt; 			throw new IllegalStateException("How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType??");
&lt; 		}
&lt; 		AsmDelegate outerObjectType = (AsmDelegate) outerDelegate;
&lt; 		if (outerObjectType.isNested()) {
&lt; 			Signature.FormalTypeParameter[] parentParams = outerObjectType.getFormalTypeParametersFromOuterClass();
&lt; 			for (int i = 0; i &lt; parentParams.length; i++) {
&lt; 				typeParameters.add(parentParams[i]);
&lt; 			}
&lt; 		}
&lt; 		  GenericSignatureParser parser = new GenericSignatureParser();
&lt; 		  String sig = outerObjectType.getDeclaredGenericSignature();
&lt; 		  if (sig!=null) {
&lt; 		  Signature.ClassSignature outerSig = parser.parseAsClassSignature(sig);
&lt; 		if (outerSig != null) {
&lt; 			for (int i = 0; i &lt; outerSig.formalTypeParameters .length; i++) {
&lt; 				typeParameters.add(outerSig.formalTypeParameters[i]);
&lt; 			}
&lt; 		} 
&lt; 	  }
&lt; 		
&lt; 		Signature.FormalTypeParameter[] ret = new Signature.FormalTypeParameter[typeParameters.size()];
&lt; 		typeParameters.toArray(ret);
&lt; 		return ret;
&lt; 	}
&lt; 	// ---
---
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ReferenceTypeDelegate.java" revision="1.13" state="changed">68a69
&gt; 	public ResolvedType getOuterClass();
</file>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java" revision="1.54" state="changed">134a135,139
&gt; 	
&gt; 	public ResolvedType getOuterClass() {
&gt; 		if (declaration.enclosingType==null) return null;
&gt; 		return eclipseWorld().fromEclipse(declaration.enclosingType.binding);
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ReferenceType.java" revision="1.48" state="changed">175c175
&lt;     		return delegate.isAnonymous();
---
&gt;     	return delegate.isAnonymous();
179c179,183
&lt;     		return delegate.isNested();
---
&gt;     	return delegate.isNested();
&gt;     }
&gt;     
&gt;     public ResolvedType getOuterClass() {
&gt;     	return delegate.getOuterClass();
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/AbstractReferenceTypeDelegate.java" revision="1.5" state="changed">21a22,24
&gt; import org.aspectj.apache.bcel.classfile.GenericSignatureParser;
&gt; import org.aspectj.apache.bcel.classfile.Signature;
&gt; import org.aspectj.apache.bcel.classfile.Signature.ClassSignature;
32a36
&gt; 	protected ClassSignature cachedGenericClassTypeSignature;
270a275,308
&gt; 	public Signature.ClassSignature getGenericClassTypeSignature() {
&gt; 		if (cachedGenericClassTypeSignature==null) {
&gt; 			String sig = getDeclaredGenericSignature();
&gt; 			if (sig!=null) {
&gt; 				GenericSignatureParser parser = new GenericSignatureParser();
&gt; 				cachedGenericClassTypeSignature = parser.parseAsClassSignature(sig);
&gt; 			}
&gt; 		}
&gt; 		return cachedGenericClassTypeSignature;
&gt; 	}
&gt; 	
&gt; 	protected Signature.FormalTypeParameter[] getFormalTypeParametersFromOuterClass() {
&gt; 		List typeParameters = new ArrayList();
&gt; 		ReferenceType outer = (ReferenceType)getOuterClass();
&gt; 		ReferenceTypeDelegate outerDelegate = outer.getDelegate();
&gt; 		AbstractReferenceTypeDelegate outerObjectType = (AbstractReferenceTypeDelegate) outerDelegate;
&gt; 		if (outerObjectType.isNested()) {
&gt; 			Signature.FormalTypeParameter[] parentParams = outerObjectType.getFormalTypeParametersFromOuterClass();
&gt; 			for (int i = 0; i &lt; parentParams.length; i++) {
&gt; 				typeParameters.add(parentParams[i]);
&gt; 			}
&gt; 		}
&gt; 		Signature.ClassSignature outerSig = outerObjectType.getGenericClassTypeSignature();
&gt; 		if (outerSig != null) {
&gt; 			for (int i = 0; i &lt; outerSig.formalTypeParameters .length; i++) {
&gt; 				typeParameters.add(outerSig.formalTypeParameters[i]);
&gt; 			}
&gt; 		} 
&gt; 		
&gt; 		Signature.FormalTypeParameter[] ret = new Signature.FormalTypeParameter[typeParameters.size()];
&gt; 		typeParameters.toArray(ret);
&gt; 		return ret;
&gt; 	}
&gt; 
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/BoundedReferenceType.java" revision="1.14" state="changed">187a188,191
&gt; 		public ResolvedType getOuterClass() {
&gt; 			return resolvedTypeX.getOuterClass();
&gt; 		}
&gt; 		
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java" revision="1.15" state="changed">172a173,178
&gt; 	
&gt; 	public ResolvedType getOuterClass() {
&gt; 		// FIXME getEnclosingClass() is Java5 ... dammit
&gt; //		return ReflectionBasedReferenceTypeDelegateFactory.resolveTypeInWorld(myClass.getEnclosingClass(),world);
&gt; 		return null;
&gt; 	}
</file>
</fixedFiles>
</bug>
<bug id="153535" transactionid="68952">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M</fullfingerprint>
<bugreport>The following problem is interesting because the advice weaves correctly with Java 1.5 LTW and also using Java 1.4 with build-time weaving. However, the following call pointcut isn't matching the expected call site in Java 1.4 load-time weaving (*).

Pointcut:
    private pointcut inExecQuery() : 
        (within(uk.ltd.getahead.dwr.impl.ExecuteQuery) || within(uk.ltd.getahead.dwr.ExecuteQuery));
    
    public pointcut dwrQuery(Method method, Object receiver, Object[] params) : 
        inExecQuery() &amp;&amp; withincode(* execute(..)) &amp;&amp; 
        call(* Method.invoke(..)) &amp;&amp; args(receiver, params) &amp;&amp; target(method);

    protected pointcut monitorEnd() : dwrQuery(*, *, *);

Matching call site:
                Object reply = method.invoke(object, params);

I've tracked it down to failing to find the method in ResolvedType.matches. On line 405:

"m1.getSignature()"= "(Ljava/lang/Object;[Ljava.lang.Object;)Ljava/lang/Object;"	
"m2.getSignature()"= "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;"	

Note the difference between . and /            ^    ^

It looks to me like the signature for array types in the reflection delegate is erroneously using . instead of /. I have attached a patch to the ReflectionBasedReferenceTypeDelegateTest that isolates this unexpected signature return. Hopefully you agree that this is not correct. If not, some more information follows.

Here's the stack trace where the match fails:

ResolvedType.matches(Member, Member) line: 405	
ReferenceType(ResolvedType).lookupMember(Member, Iterator) line: 347	
ReferenceType(ResolvedType).lookupMethod(Member) line: 326	
LTWWorld(World).resolve(Member) line: 504	
MemberImpl.resolve(World) line: 93	
JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember() line: 109	
JoinPointSignatureIterator.&lt;init&gt;(Member, World) line: 51	
MemberImpl.getJoinPointSignatures(World) line: 943	
SignaturePattern.matches(Member, World, boolean) line: 286	
KindedPointcut.matchInternal(Shadow) line: 106	
KindedPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 53	
AndPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 51	
AndPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 51	
AndPointcut(Pointcut).match(Shadow) line: 146	
AndPointcut.matchInternal(Shadow) line: 51	
AndPointcut(Pointcut).match(Shadow) line: 146	
OrPointcut.matchInternal(Shadow) line: 50	
OrPointcut(Pointcut).match(Shadow) line: 146	
BcelAdvice(ShadowMunger).match(Shadow, World) line: 71	
BcelAdvice(Advice).match(Shadow, World) line: 112	
BcelAdvice.match(Shadow, World) line: 107	
BcelClassWeaver.match(BcelShadow, List) line: 2806	
BcelClassWeaver.matchInvokeInstruction(LazyMethodGen, InstructionHandle, InvokeInstruction, BcelShadow, List) line: 2768	
BcelClassWeaver.match(LazyMethodGen, InstructionHandle, BcelShadow, List) line: 2506	
BcelClassWeaver.match(LazyMethodGen) line: 2332	
BcelClassWeaver.weave() line: 494	
BcelClassWeaver.weave(BcelWorld, LazyClassGen, List, List, List) line: 119	
BcelWeaver.weave(UnwovenClassFile, BcelObjectType, boolean) line: 1613	
BcelWeaver.weaveWithoutDump(UnwovenClassFile, BcelObjectType) line: 1564	
BcelWeaver.weaveAndNotify(UnwovenClassFile, BcelObjectType, IWeaveRequestor) line: 1341	
BcelWeaver.weave(IClassFileProvider) line: 1163	
ClassLoaderWeavingAdaptor(WeavingAdaptor).getWovenBytes(String, byte[]) line: 319	
ClassLoaderWeavingAdaptor(WeavingAdaptor).weaveClass(String, byte[]) line: 225	
Aj.preProcess(String, byte[], ClassLoader) line: 77	
ClassPreProcessorAdapter.preProcess(String, byte[], ClassLoader) line: 67	
ClassPreProcessorHelper.defineClass0Pre(ClassLoader, String, byte[], int, int, ProtectionDomain) line: 107	
WebappClassLoader(ClassLoader).defineClass(String, byte[], int, int, ProtectionDomain) line: 539	
WebappClassLoader(SecureClassLoader).defineClass(String, byte[], int, int, CodeSource) line: 123	
WebappClassLoader.findClassInternal(String) line: 1786	
WebappClassLoader.findClass(String) line: 1048	
WebappClassLoader.loadClass(String, boolean) line: 1506	
WebappClassLoader.loadClass(String) line: 1385	
WebappClassLoader(ClassLoader).loadClassInternal(String) line: 302	
Class.forName0(String, boolean, ClassLoader) line: not available [native method]	
Class.forName(String) line: 141	
InitializeLog.setWarnLogging(String) line: 121	
InitializeLog.initializeLogging() line: 96	
ContextLoaderServlet.init() line: 13	
ContextLoaderServlet(GenericServlet).init(ServletConfig) line: 212	
StandardWrapper.loadServlet() line: 879	
StandardWrapper.load() line: 767	
StandardContext.loadOnStartup(Container[]) line: 3483	
StandardContext.start() line: 3709	
StandardHost(ContainerBase).addChildInternal(Container) line: 776	
StandardHost(ContainerBase).addChild(Container) line: 759	
StandardHost.addChild(Container) line: 537	
StandardHostDeployer.install(String, URL) line: 260	
StandardHost.install(String, URL) line: 730	
HostConfig.deployWARs(File, String[]) line: 558	
HostConfig.deployApps() line: 373	
HostConfig.start() line: 784	
HostConfig.lifecycleEvent(LifecycleEvent) line: 330	
LifecycleSupport.fireLifecycleEvent(String, Object) line: 119	
StandardHost(ContainerBase).start() line: 1155	
StandardHost.start() line: 696	
StandardEngine(ContainerBase).start() line: 1147	
StandardEngine.start() line: 310	
StandardService.start() line: 449	
StandardServer.start() line: 2212	
Catalina.start() line: 458	
Catalina.execute() line: 345	
Catalina.process(String[]) line: 129	
NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
NativeMethodAccessorImpl.invoke(Object, Object[]) line: 39	
DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25	
Method.invoke(Object, Object[]) line: 324	
Bootstrap.main(String[]) line: 150	

I'm using a modified version of Alex Vasseur's LTW plugin for a Java 1.4 VM although I haven't tested on the JRockIt plugin for a 1.4 VM: my guess is that this would fail there too.</bugreport>
<testsforfix ID="153535" type="new">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java">
      <test NAME="testArrayArgsSig"/>
    </file>
    <file LOCATION="org.aspectj/modules/weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java">
      <test NAME="testArrayArgsSig"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/153535/pre-fix/testresults.xml" passing="1905" size="2092"/>
<post-fix-testcases failing="186" file="output/153535/post-fix/testresults.xml" passing="1906" size="2092"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java" revision="1.9" state="changed">99c99
&lt; 			return world.resolve(UnresolvedType.forSignature(className));
---
&gt; 			return world.resolve(UnresolvedType.forSignature(className.replace('.','/')));
</file>
<file name="org.aspectj/modules/weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java" revision="1.2" state="changed">14a15
&gt; import java.lang.reflect.Method;
298a300,306
&gt; 
&gt;     public void testArrayArgsSig() throws Exception {
&gt;     	Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class});
&gt;     	ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
&gt;     	String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
&gt;     	assertTrue("Expected: \n"+exp+"\n but got:\n"+reflectionMethod.getSignature(), reflectionMethod.getSignature().equals(exp));
&gt;     }
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java" revision="1.9" state="changed">14a15
&gt; import java.lang.reflect.Method;
101a103,108
&gt;     public void testArrayArgsSig() throws Exception {
&gt;     	Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class});
&gt;     	ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
&gt;     	String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
&gt;     	assertTrue("Expected: \n"+exp+"\n but got:\n"+reflectionMethod.getSignature(), reflectionMethod.getSignature().equals(exp));
&gt;     }
</file>
</fixedFiles>
</bug>
<bug id="153845" transactionid="69831">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M O-() O-cast Z-cast</fullfingerprint>
<bugreport>public aspect OuterAspect {

  private pointcut isSetter() : execution(void set*(..));

  public static aspect InnerAspect pertarget(isSetter()) {

  }

}


java.lang.IllegalStateException
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseFieldTypeSignature(GenericSignatureParser.java:163)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseTypeArgument(GenericSignatureParser.java:253)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.maybeParseTypeArguments(GenericSignatureParser.java:261)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseClassTypeSignature(GenericSignatureParser.java:208)
at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseAsClassSignature(GenericSignatureParser.java:56)
at org.aspectj.apache.bcel.classfile.Signature.asClassSignature(Signature.java:315)
at org.aspectj.apache.bcel.classfile.JavaClass.getGenericClassTypeSignature(JavaClass.java:973)
at org.aspectj.weaver.bcel.BcelObjectType.initializeFromJavaclass(BcelObjectType.java:164)
at org.aspectj.weaver.bcel.BcelObjectType.&lt;init&gt;(BcelObjectType.java:131)
at org.aspectj.weaver.bcel.BcelWorld.buildBcelDelegate(BcelWorld.java:337)
at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:395)
at org.aspectj.weaver.bcel.BcelWeaver.addIfAspect(BcelWeaver.java:263)
at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromDirectory(BcelWeaver.java:255)
at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:205)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:698)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:223)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

IllegalStateException thrown: Expecting [,L, or T, but found Pjava while unpacking Ljava/util/AbstractSet&lt;Pjava/util/Map$Entry&lt;TK;TV;&gt;;&gt;;</bugreport>
<testsforfix ID="153845" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testNoIllegalStateExceptionWithGenericInnerAspect_pr156058"/>
      <test NAME="testIllegalStateExceptionGenerics_pr153845"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="IllegalStateException at GenericSignatureParser.java"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="121" file="output/153845/pre-fix/testresults.xml" passing="1443" size="1564"/>
<post-fix-testcases failing="187" file="output/153845/post-fix/testresults.xml" passing="1927" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ReferenceType.java" revision="1.49" state="changed">717c717
&lt; 			ret.append(someParameters[i].getSignature());			
---
&gt; 			ret.append(((ReferenceType)someParameters[i]).getSignatureForAttribute());			
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.36" state="changed">5a6,10
&gt;     &lt;ajc-test dir="bugs153/pr153845" title="IllegalStateException at GenericSignatureParser.java"&gt;
&gt;       &lt;compile files="GenericType.java,Aspect.java,Aspect2.java,Interface.java" options="-1.5" outjar="blob.jar"/&gt;
&gt;       &lt;compile files="Nothing.java" aspectpath="blob.jar" options="-1.5" outjar="bang.jar"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.36" state="changed">30c30,31
&lt; //  public void testNoIllegalStateExceptionWithGenericInnerAspect_pr156058() { runTest("no IllegalStateException with generic inner aspect"); }  
---
&gt; //  public void testNoIllegalStateExceptionWithGenericInnerAspect_pr156058() { runTest("no IllegalStateException with generic inner aspect"); }
&gt;   public void testIllegalStateExceptionGenerics_pr153845() { runTest("IllegalStateException at GenericSignatureParser.java"); }
</file>
<file name="org.aspectj/modules/tests/bugs153/pr153845/Interface.java" revision="1.1" state="new">interface Interface {}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr153845/GenericType.java" revision="1.1" state="new">public class GenericType&lt;T&gt; {
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr153845/Aspect2.java" revision="1.1" state="new">public aspect Aspect2 {
  declare parents: Aspect implements Interface;
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr153845/Nothing.java" revision="1.1" state="new">public class Nothing {}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr153845/Aspect.java" revision="1.1" state="new">import java.util.*;
public aspect Aspect extends GenericType&lt;Set&lt;String&gt;&gt; {}
</file>
</fixedFiles>
</bug>
<bug id="154332" transactionid="70276">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>M</concisefingerprint>
<fullfingerprint>M</fullfingerprint>
<bugreport>As raised by Mr Bodkin on the list:
Can anyone tell me why this compiling this program produces warnings for marker but not for deprecated (in a recent dev build of AJDT)? Is this just a bug? Both have runtime retention, so I would expect equivalent behavior.

 

@Deprecated @Marker

public aspect Annot {

 

    pointcut test() : within(@Marker *);// *);

   

    declare warning: staticinitialization(@Deprecated *): "deprecated";   

    declare warning: staticinitialization(@Marker *): "marker";   

   

    public static void main(String argz[]) {

        new Baz().foo();

    }

}

 

@Deprecated @Marker

class Baz {

    public void foo() {}

}

 

@Retention(RetentionPolicy.RUNTIME)

public @interface Marker {

 

}</bugreport>
<testsforfix ID="154332" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testIncorrectDeprecatedAnnotationProcessing_pr154332"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="incorrect deprecated annotation processing"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="72" file="output/154332/pre-fix/testresults.xml" passing="878" size="950"/>
<post-fix-testcases failing="188" file="output/154332/post-fix/testresults.xml" passing="1912" size="2100"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java" revision="1.61" state="changed">644c644
&lt; 					annotationTypes[i] = w.resolve(UnresolvedType.forName(annotation.getTypeName()));
---
&gt; 					annotationTypes[i] = w.resolve(UnresolvedType.forSignature(annotation.getTypeSignature()));
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.26" state="changed">25a26,34
&gt;     &lt;ajc-test dir="bugs153/pr154332" title="incorrect deprecated annotation processing"&gt;
&gt;       &lt;compile files="Annot.java" options="-1.5"&gt;
&gt;         &lt;message kind="warning" line="5" text="marker"/&gt;
&gt;         &lt;message kind="warning" line="31" text="marker"/&gt;
&gt;         &lt;message kind="warning" line="5" text="deprecated"/&gt;
&gt;         &lt;message kind="warning" line="31" text="deprecated"/&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.26" state="changed">29a30
&gt; 	public void testIncorrectDeprecatedAnnotationProcessing_pr154332() { runTest("incorrect deprecated annotation processing");}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr154332/Annot.java" revision="1.1" state="new">import java.lang.annotation.*;

@Deprecated @Marker

public aspect Annot {

 

    pointcut test() : within(@Marker *);// *);

   

    declare warning: staticinitialization(@Deprecated *): "deprecated";   

    declare warning: staticinitialization(@Marker *): "marker";   

   

    public static void main(String argz[]) {

        new Baz().foo();

    }

}

 

@Deprecated @Marker

class Baz {

    public void foo() {}

}

 

@Retention(RetentionPolicy.RUNTIME)

 @interface Marker {

 

}</file>
</fixedFiles>
</bug>
<bug id="155148" transactionid="74289">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="7"/>
<property name="lines-added" value="8"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="6"/>
<property name="lines-churned" value="14"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-return M O-&lt; O-+ O-++ T V Y Z-cond Z-for Z-vardecl</fullfingerprint>
<bugreport>I turned on tracing for the Aj class inside of Oracle's OC4J server. In one test (not always) it deadlocked. It looks like the threads are each trying to lock each other's loader. Notice that one of the threads is in the toString method of the Oracle ClassLoader (perhaps another reason to prefer tracing argument class names and system identity hashcodes).

Here's a thread dump from Ctrl+BREAK:

Found one Java-level deadlock:
=============================
"WorkExecutorWorkerThread-1":
  waiting to lock monitor 0x003384ec (object 0x05239e48, a oracle.classloader.Po
licyClassLoader),
  which is held by "OC4J Launcher"
"OC4J Launcher":
  waiting to lock monitor 0x0033848c (object 0x0554f0e8, a oracle.classloader.Po
licyClassLoader),
  which is held by "WorkExecutorWorkerThread-1"

Java stack information for the threads listed above:
===================================================
"WorkExecutorWorkerThread-1":
        at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:641)
        - waiting to lock &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoa
der.java:1284)
        at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java:
69)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:642)
        - locked &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoa
der.java:1284)
        at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java:
69)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoa
der.java:1660)
        - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java
:1621)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java
:1606)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.j2ee.ra.jms.generic.WorkConsumer.doReceive(WorkConsumer.java:9
87)
        at oracle.j2ee.ra.jms.generic.WorkConsumer.run(WorkConsumer.java:215)
        - locked &lt;0x05de2718&gt; (a oracle.j2ee.ra.jms.generic.WorkConsumer)
        at oracle.j2ee.connector.work.WorkWrapper.runTargetWork(WorkWrapper.java
:242)
        at oracle.j2ee.connector.work.WorkWrapper.doWork(WorkWrapper.java:215)
        at oracle.j2ee.connector.work.WorkWrapper.run(WorkWrapper.java:190)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(PooledExec
utor.java:814)
        at java.lang.Thread.run(Thread.java:595)
"OC4J Launcher":
        at oracle.classloader.PolicyClassLoader.toString(PolicyClassLoader.java:
1846)
        - waiting to lock &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader)
        at java.text.MessageFormat.subformat(MessageFormat.java:1237)
        at java.text.MessageFormat.format(MessageFormat.java:828)
        at java.text.Format.format(Format.java:133)
        at java.text.MessageFormat.format(MessageFormat.java:804)
        at java.util.logging.Formatter.formatMessage(Formatter.java:130)
        - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter)
        at java.util.logging.SimpleFormatter.format(SimpleFormatter.java:63)
        - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter)
        at java.util.logging.StreamHandler.publish(StreamHandler.java:179)
        - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler)
        at java.util.logging.FileHandler.publish(FileHandler.java:555)
        - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler)
        at java.util.logging.Logger.log(Logger.java:428)
        at java.util.logging.Logger.doLog(Logger.java:450)
        at java.util.logging.Logger.logp(Logger.java:619)
        at java.util.logging.Logger.entering(Logger.java:870)
        at org.aspectj.weaver.tools.Jdk14Trace.enter(Jdk14Trace.java:32)
        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:67)
        at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(C
lassPreProcessorAgentAdapter.java:55)
        at sun.instrument.TransformerManager.transform(TransformerManager.java:1
22)
        at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java
:155)
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
        at oracle.classloader.PolicyClassLoader.defineClass(PolicyClassLoader.ja
va:2224)
        at oracle.classloader.PolicyClassLoader.findLocalClass(PolicyClassLoader
.java:1457)
        at oracle.classloader.SearchPolicy$FindLocal.getClass(SearchPolicy.java:
167)
        at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
        at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoa
der.java:1660)
        - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java
:1621)
        at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java
:1606)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
        - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader)
        at com.evermind.server.http.HttpRequestHandler.&lt;init&gt;(HttpRequestHandler
.java:97)
        at com.evermind.server.http.HttpConnectionListener$HttpNIOAcceptHandler.
getReadHandler(HttpConnectionListener.java:116)
        at oracle.oc4j.network.ReadHandlerPool.getContextFromBackend(ReadHandler
Pool.java:63)
        at com.evermind.util.BBPool.startPool(BBPool.java:42)
        at oracle.oc4j.network.ReadHandlerPool.register(ReadHandlerPool.java:25)

        - locked &lt;0x05ec9290&gt; (a java.util.ArrayList)
        at oracle.oc4j.network.ServerSocketAcceptHandler.setPoolOptions(ServerSo
cketAcceptHandler.java:140)
        at com.evermind.server.http.HttpConnectionListener.setRequestHandlerPool
(HttpConnectionListener.java:232)
        at com.evermind.server.http.HttpConnectionListener.initHandlers(HttpConn
ectionListener.java:226)
        at com.evermind.server.http.HttpConnectionListener.&lt;init&gt;(HttpConnection
Listener.java:174)
        at com.evermind.server.http.HttpServer.getListener(HttpServer.java:481)
        - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer)
        at com.evermind.server.http.HttpServer.setSites(HttpServer.java:267)
        - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer)
        at com.evermind.server.http.HttpServer.setConfig(HttpServer.java:180)
        at com.evermind.server.ApplicationServer.initializeHttp(ApplicationServe
r.java:2296)
        at com.evermind.server.ApplicationServer.setConfig(ApplicationServer.jav
a:944)
        at com.evermind.server.ApplicationServerLauncher.run(ApplicationServerLa
uncher.java:113)
        - locked &lt;0x0530eb20&gt; (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:595)

Found 1 deadlock.</bugreport>
<testsforfix ID="155148" type="new">
    <file LOCATION="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java">
      <test NAME="testEnterWithThisAndToStringException"/>
      <test NAME="testEnterWithThisAndHashCodeException"/>
      <test NAME="testEnterWithThisAndClassLoader"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="189" file="output/155148/pre-fix/testresults.xml" passing="1919" size="2108"/>
<post-fix-testcases failing="187" file="output/155148/post-fix/testresults.xml" passing="1927" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/AbstractTrace.java" revision="1.7" state="changed">142c142
&lt; 			else return obj.getClass().getName() + "@" + Integer.toString(obj.hashCode(),16);
---
&gt; 			else return obj.getClass().getName() + "@" + Integer.toHexString(obj.hashCode());
146c146
&lt; 			return obj.getClass().getName();
---
&gt; 			return obj.getClass().getName() + "@FFFFFFFF";
174a175,182
&gt; 	
&gt; 	protected Object[] formatObjects(Object[] args) {
&gt; 		for (int i = 0; i &lt; args.length; i++) {
&gt; 			args[i] = formatObj(args[i]);
&gt; 		}
&gt; 		
&gt; 		return args;
&gt; 	}
</file>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java" revision="1.8" state="changed">56c56
&lt;     	return ((loader!=null)?loader.getClass().getName()+"@"+loader.hashCode():"null");
---
&gt;     	return ((loader!=null)?loader.getClass().getName()+"@"+Integer.toHexString(loader.hashCode()):"null");
</file>
<file name="org.aspectj/modules/weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java" revision="1.5" state="changed">32c32
&lt; 				logger.entering(name,methodName,args);
---
&gt; 				logger.entering(name,methodName,formatObjects(args));
43c43
&lt; 			logger.exiting(name,methodName,ret);
---
&gt; 			logger.exiting(name,methodName,formatObj(ret));
63c63
&lt; 				logger.logp(Level.FINER,name,methodName,"EVENT",args);
---
&gt; 				logger.logp(Level.FINER,name,methodName,"EVENT",formatObjects(args));
</file>
<file name="org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java" revision="1.4" state="changed">37c37
&lt; 		trace.enter("testEnterWithThisAndArgs",this,new Object[] { arg1, arg2 });
---
&gt; 		trace.enter(getName(),this,new Object[] { arg1, arg2 });
42c42
&lt; 		trace.enter("testEnterWithThisAndArgs",this,new Object[] { arg1 });
---
&gt; 		trace.enter(getName(),this,new Object[] { arg1 });
49c49
&lt; 				return "Traceable";
---
&gt; 				return getClass().getName() + "[Traceable]";
53c53,86
&lt; 		trace.enter("testEnterWithThisAndArgs",this,new Object[] { arg1 });
---
&gt; 		trace.enter(getName(),this,new Object[] { arg1 });
&gt; 	}
&gt; 
&gt; 	public void testEnterWithThisAndToStringException () {
&gt; 		Object arg1 = new Object() {
&gt; 
&gt; 			public String toString() {
&gt; 				throw new RuntimeException("toString() can throw an Exception");
&gt; 			}
&gt; 			
&gt; 		};
&gt; 		trace.enter(getName(),this,new Object[] { arg1 });
&gt; 	}
&gt; 
&gt; 	public void testEnterWithThisAndHashCodeException () {
&gt; 		Object arg1 = new Object() {
&gt; 
&gt; 			public int hashCode() {
&gt; 				throw new RuntimeException("hashCode can throw an Exception");
&gt; 			}
&gt; 			
&gt; 		};
&gt; 		trace.enter(getName(),this,new Object[] { arg1 });
&gt; 	}
&gt; 
&gt; 	public void testEnterWithThisAndClassLoader () {
&gt; 		Object arg1 = new ClassLoader() {
&gt; 
&gt; 			public String toString() {
&gt; 				throw new Error("Don't call ClassLoader.toString()");
&gt; 			}
&gt; 			
&gt; 		};
&gt; 		trace.enter(getName(),this,new Object[] { arg1 });
</file>
</fixedFiles>
</bug>
<bug id="155238" transactionid="74348">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="2"/>
<property name="priority" value="P3"/>
<property name="severity" value="enhancement"/>
<concisefingerprint>MZ</concisefingerprint>
<fullfingerprint>M Z-cond</fullfingerprint>
<bugreport>The tracing module uses obj.hashCode() to identify untrusted objects when formatting. I think it would be a little safer and more accurate to use
System.identityHashCode(obj). This way the tracing code wouldn't call any application-defined code, and would give a value that can't change if the loader state changes.</bugreport>
<pre-fix-testcases failing="189" file="output/155238/pre-fix/testresults.xml" passing="1925" size="2114"/>
<post-fix-testcases failing="188" file="output/155238/post-fix/testresults.xml" passing="1926" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java" revision="1.9" state="changed">56c56
&lt;     	return ((loader!=null)?loader.getClass().getName()+"@"+Integer.toHexString(loader.hashCode()):"null");
---
&gt;     	return ((loader!=null)?loader.getClass().getName()+"@"+Integer.toHexString(System.identityHashCode(loader)):"null");
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/tools/AbstractTrace.java" revision="1.8" state="changed">142c142
&lt; 			else return obj.getClass().getName() + "@" + Integer.toHexString(obj.hashCode());
---
&gt; 			else return obj.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(obj));
</file>
</fixedFiles>
</bug>
<bug id="155972" transactionid="74317">
<property name="files-churned" value="4"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="3"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint/>
<fullfingerprint/>
<tag>null pointer exception</tag>
<bugreport>AspectJ version: 1.5.3.200608290814

When advising a constructor, we can do the following to obtain the constructor as a java.lang.reflect.Member:

		Member cons = ((ConstructorSignature) thisJoinPointStaticPart
				.getSignature()).getConstructor();

however that sometimes fails, and returns null.</bugreport>
<testsforfix ID="155972" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testNPEinConstructorSignatureImpl_pr155972"/>
      <test NAME="testNPEinFieldSignatureImpl_pr155972"/>
      <test NAME="testNPEinInitializerSignatureImpl_pr155972"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="NPE in ConstructorSignatureImpl"/>
      <test NAME="NPE in FieldSignatureImpl"/>
      <test NAME="NPE in InitializerSignatureImpl"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="185" file="output/155972/pre-fix/testresults.xml" passing="1929" size="2114"/>
<post-fix-testcases failing="186" file="output/155972/post-fix/testresults.xml" passing="1928" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/lib/test/aspectjrt.jar" revision="1.48" state="changed"/>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java" revision="1.8" state="changed">58c58
&lt; 				field = declaringType.getDeclaredField(getName());
---
&gt; 				field = getDeclaringType().getDeclaredField(getName());
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java" revision="1.8" state="changed">51c51
&lt; 				constructor = declaringType.getDeclaredConstructor(getParameterTypes());
---
&gt; 				constructor = getDeclaringType().getDeclaredConstructor(getParameterTypes());
</file>
<file name="org.aspectj/modules/runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java" revision="1.8" state="changed">53c53
&lt; 				constructor = declaringType.getDeclaredConstructor(getParameterTypes());
---
&gt; 				constructor = getDeclaringType().getDeclaredConstructor(getParameterTypes());
</file>
<file name="org.aspectj/modules/lib/aspectj/lib/aspectjrt.jar" revision="1.29" state="changed"/>
<file name="org.aspectj/modules/tests/bugs153/pr155972/InitializerTest.java" revision="1.1" state="new">
public class InitializerTest {

	
	public static void main(String[] args) {
	}

}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.31" state="changed">358a359,385
&gt;     &lt;ajc-test dir="bugs153/pr155972" title="NPE in ConstructorSignatureImpl"&gt;
&gt;       &lt;compile files="ConstructorTest.java, SignatureImplAspect.aj" options="-Xlint:ignore"/&gt;
&gt;       &lt;run class="ConstructorTest"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="ConstructorTest"/&gt;
&gt;         &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs153/pr155972" title="NPE in FieldSignatureImpl"&gt;
&gt;       &lt;compile files="FieldTest.java, SignatureImplAspect.aj" options="-Xlint:ignore"/&gt;
&gt;       &lt;run class="FieldTest"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="intField"/&gt;
&gt;         &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs153/pr155972" title="NPE in InitializerSignatureImpl"&gt;
&gt;       &lt;compile files="InitializerTest.java, SignatureImplAspect.aj" options="-Xlint:ignore"/&gt;
&gt;       &lt;run class="InitializerTest"&gt;
&gt;         &lt;stdout&gt;
&gt;           &lt;line text="InitializerTest"/&gt;
&gt;         &lt;/stdout&gt;
&gt;       &lt;/run&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/bugs153/pr155972/FieldTest.java" revision="1.1" state="new">public class FieldTest {
	
	private static int intField;
	
	public static void main(String[] args) {
		intField = 999;
	}
	
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr155972/ConstructorTest.java" revision="1.1" state="new">
public class ConstructorTest {

	public static void main(String[] args) {
		new ConstructorTest();
	}

}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.31" state="changed">73a74,85
&gt;   public void testNPEinConstructorSignatureImpl_pr155972 () {
&gt; 	  runTest("NPE in ConstructorSignatureImpl");
&gt;   }
&gt;   
&gt;   public void testNPEinFieldSignatureImpl_pr155972 () {
&gt; 	  runTest("NPE in FieldSignatureImpl");
&gt;   }
&gt;   
&gt;   public void testNPEinInitializerSignatureImpl_pr155972 () {
&gt; 	  runTest("NPE in InitializerSignatureImpl");
&gt;   }
&gt;   
</file>
<file name="org.aspectj/modules/tests/bugs153/pr155972/SignatureImplAspect.aj" revision="1.1" state="new">

import java.lang.reflect.Member;

import org.aspectj.lang.reflect.ConstructorSignature;
import org.aspectj.lang.reflect.FieldSignature;
import org.aspectj.lang.reflect.InitializerSignature;

public aspect SignatureImplAspect {
	before () : (execution(ConstructorTest.new(..))) {
		//thisJoinPointStaticPart.getSignature().getDeclaringType();
		Member m = ((ConstructorSignature) thisJoinPointStaticPart
				.getSignature()).getConstructor();
		System.out.println(m.getName());
	}
	
	before() : set(int FieldTest.intField) {
		//thisJoinPointStaticPart.getSignature().getDeclaringType();
		Member m = ((FieldSignature) thisJoinPointStaticPart
				.getSignature()).getField();
		System.out.println(m.getName());
	}
	
	before() : staticinitialization(InitializerTest) {
		//thisJoinPointStaticPart.getSignature().getDeclaringType();
		Member m = ((InitializerSignature) thisJoinPointStaticPart
				.getSignature()).getInitializer();
		System.out.println(m.getName());
	}
}
</file>
</fixedFiles>
</bug>
<bug id="156904" transactionid="69909">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="2"/>
<property name="lines-added" value="21"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="23"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-return K-while M O-&lt; O-! O-() O-&amp;&amp; O-+ O-++ T V Y Z-if Z-while</fullfingerprint>
<bugreport>The Eclipse AJDT give an incorrect warning when you want to advise a private method of a private inner class.


When I want to advise a private method in a private inner class, like this

public class Outer
{
   private class Inner
   {
      private void myMethod()
   }
}

Using the following poincut:

poincut innerpointcut():execution( * Outer.Inner.myMethod() );

and advice:

before():innerpointcut()
{
   System.out.println( "executing!" );
}

I get a warning "invalidAbsoluteTypeName" next to my pointcut, but next to the advice, there is a marker that points to the private method.</bugreport>
<testsforfix ID="156904" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testNoInvalidAbsoluteTypeNameWarning_pr156904_1"/>
      <test NAME="testNoInvalidAbsoluteTypeNameWarning_pr156904_2"/>
      <test NAME="testNoInvalidAbsoluteTypeNameWarning_pr156904_3"/>
      <test NAME="testNoInvalidAbsoluteTypeNameWarning_pr156904_4"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="ensure no invalidAbsoluteTypeName when do match - 1"/>
      <test NAME="ensure no invalidAbsoluteTypeName when do match - 2"/>
      <test NAME="ensure no invalidAbsoluteTypeName when do match - 3"/>
      <test NAME="ensure no invalidAbsoluteTypeName when do match - 4"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="187" file="output/156904/pre-fix/testresults.xml" passing="1927" size="2114"/>
<post-fix-testcases failing="194" file="output/156904/post-fix/testresults.xml" passing="1920" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java" revision="1.68" state="changed">690c690,691
&lt; 		resolvedTypeInTheWorld = lookupTypeInWorld(scope.getWorld(), fullyQualifiedName);
---
&gt; 		resolvedTypeInTheWorld = lookupTypeInWorldIncludingPrefixes(scope.getWorld(), fullyQualifiedName, scope.getImportedPrefixes());
&gt; 
714a716,736
&gt; 	/**
&gt; 	 * Searches the world for the ResolvedType with the given typeName. If one 
&gt; 	 * isn't found then for each of the supplied prefixes, it prepends the typeName
&gt; 	 * with the prefix and searches the world for the ResolvedType with this new name.
&gt; 	 * If one still isn't found then a MissingResolvedTypeWithKnownSignature is 
&gt; 	 * returned with the originally requested typeName (this ensures the typeName
&gt; 	 * makes sense).
&gt; 	 */
&gt; 	private ResolvedType lookupTypeInWorldIncludingPrefixes(World world, String typeName, String[] prefixes) {
&gt; 		ResolvedType ret = lookupTypeInWorld(world, typeName);
&gt; 		if (!ret.isMissing()) return ret; 
&gt; 		ResolvedType retWithPrefix = ret;
&gt; 		int counter = 0;
&gt; 		while (retWithPrefix.isMissing() &amp;&amp; (counter &lt; prefixes.length)) {
&gt; 			retWithPrefix = lookupTypeInWorld(world,prefixes[counter] + typeName);
&gt; 			counter++;
&gt; 		}
&gt; 		if (!retWithPrefix.isMissing()) return retWithPrefix;
&gt; 		return ret;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.47" state="changed">137c137,143
&lt;     /////////////////////////////////////////
---
&gt;   public void testNoInvalidAbsoluteTypeNameWarning_pr156904_1() {runTest("ensure no invalidAbsoluteTypeName when do match - 1");}
&gt;   public void testNoInvalidAbsoluteTypeNameWarning_pr156904_2() {runTest("ensure no invalidAbsoluteTypeName when do match - 2");}
&gt;   public void testNoInvalidAbsoluteTypeNameWarning_pr156904_3() {runTest("ensure no invalidAbsoluteTypeName when do match - 3");}
&gt;   public void testNoInvalidAbsoluteTypeNameWarning_pr156904_4() {runTest("ensure no invalidAbsoluteTypeName when do match - 4");}
&gt; 
&gt;   
&gt;   /////////////////////////////////////////
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.48" state="changed">496a497,514
&gt;     &lt;ajc-test dir="bugs153/pr156904/inSameFile" title="ensure no invalidAbsoluteTypeName when do match - 1"&gt;
&gt;       &lt;compile files="A.aj"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs153/pr156904/inDiffPkgAndImport" title="ensure no invalidAbsoluteTypeName when do match - 2"&gt;
&gt;       &lt;compile files="A.aj,Outer.java"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs153/pr156904/inSamePkg" title="ensure no invalidAbsoluteTypeName when do match - 3"&gt;
&gt;       &lt;compile files="A.aj,Outer.java"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs153/pr156904/inDiffPkgWithoutImport" title="ensure no invalidAbsoluteTypeName when do match - 4"&gt;
&gt;       &lt;compile files="A.aj,Outer.java"&gt;
&gt; 		&lt;message kind="warning" line="5" text="no match for this type name: Outer [Xlint:invalidAbsoluteTypeName]"/&gt;
&gt; 	  &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs153/pr156904/inSamePkg/Outer.java" revision="1.1" state="new">package pkg;

class Outer {

    private class Inner{
    	private void myMethod(){
    	}
    }
	
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr156904/inSameFile/A.aj" revision="1.1" state="new">package pkg;

public aspect A {

	pointcut innerpointcut() : execution( * Outer.Inner.myMethod() );

	before() : innerpointcut() {
	   System.out.println( "executing!" );
	}

}

class Outer {
	
    private class Inner{
    	private void myMethod(){
    	}
    }
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr156904/inDiffPkgAndImport/A.aj" revision="1.1" state="new">package pkg;

import pkg1.*;

public aspect A {

	pointcut innerpointcut() : execution( * Outer.myMethod() );

	before() : innerpointcut() {
	   System.out.println( "executing!" );
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr156904/inDiffPkgWithoutImport/A.aj" revision="1.1" state="new">package pkg;

public aspect A {

	pointcut innerpointcut() : execution( * Outer.myMethod() );

	before() : innerpointcut() {
	   System.out.println( "executing!" );
	}
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr156904/inSamePkg/A.aj" revision="1.1" state="new">package pkg;

public aspect A {

	pointcut innerpointcut() : execution( * Outer.Inner.myMethod() );

	before() : innerpointcut() {
	   System.out.println( "executing!" );
	}
	
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr156904/inDiffPkgAndImport/Outer.java" revision="1.1" state="new">package pkg1;

class Outer {

	private void myMethod(){
	}
	
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr156904/inDiffPkgWithoutImport/Outer.java" revision="1.1" state="new">package pkg1;

class Outer {

	private void myMethod(){
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="156962" transactionid="68339">
<property name="files-churned" value="3"/>
<property name="java-files-churned" value="3"/>
<property name="classes-churned" value="3"/>
<property name="methods-churned" value="3"/>
<property name="hunks" value="5"/>
<property name="lines-added" value="4"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="4"/>
<property name="lines-churned" value="8"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-continue K-if M T V Y Z-if</fullfingerprint>
<bugreport>The latest dev builds still have cases where they don't match properly on @Deprecated. See attached for two failing test cases for execution and hasMethod.</bugreport>
<testsforfix ID="156962" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testAnnotMethod_pr156962"/>
      <test NAME="testAnnotMethodHasMember_pr156962"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="Test Annot Method"/>
      <test NAME="Test Annot Method Has Member"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="189" file="output/156962/pre-fix/testresults.xml" passing="1925" size="2114"/>
<post-fix-testcases failing="187" file="output/156962/post-fix/testresults.xml" passing="1927" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelField.java" revision="1.29" state="changed">134,135c134
&lt; 					ResolvedType rtx = world.resolve(UnresolvedType.forName(annotation.getTypeName()));
&lt; 					annotationTypes.add(rtx);
---
&gt; 					annotationTypes.add(world.resolve(UnresolvedType.forSignature(annotation.getTypeSignature())));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelMethod.java" revision="1.42" state="changed">284,285c284
&lt; 				ResolvedType rtx = world.resolve(UnresolvedType.forName(annotation.getTypeName()));
&lt; 				annotationTypes.add(rtx);
---
&gt; 				annotationTypes.add(world.resolve(UnresolvedType.forSignature(annotation.getTypeSignature())));
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java" revision="1.6" state="changed">51a52,53
&gt; 	
&gt; 	private final static String declareAtPrefix = "ajc$declare_at";
57a60
&gt; 			if (field.getName().startsWith(declareAtPrefix)) continue;
72a76
&gt; 			if (method.getName().startsWith(declareAtPrefix)) continue;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.33" state="changed">29a30,31
&gt;   public void testAnnotMethod_pr156962() { runTest("Test Annot Method");}
&gt;   public void testAnnotMethodHasMember_pr156962() { runTest("Test Annot Method Has Member"); }
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.33" state="changed">5a6,17
&gt;     &lt;ajc-test dir="bugs153/pr156962" title="Test Annot Method"&gt;
&gt;       &lt;compile files="Sample.java, WarnDeprecatedMethod.aj" options="-1.5"&gt;
&gt;         &lt;message kind="warning" line="2" text="deprecated method"/&gt;      
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
&gt;     &lt;ajc-test dir="bugs153/pr156962" title="Test Annot Method Has Member"&gt;
&gt;       &lt;compile files="Sample.java, LiftDeprecation.aj" options="-1.5 -XhasMember -showWeaveInfo -Xlint:ignore"&gt;
&gt;         &lt;message kind="weave" text="'Sample' (Sample.java:1) is annotated with @Deprecated type annotation from 'LiftDeprecation' (LiftDeprecation.aj:2)"/&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
</fixedFiles>
</bug>
<bug id="158412" transactionid="68822">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="6"/>
<property name="lines-added" value="34"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="2"/>
<property name="lines-churned" value="36"/>
<property name="priority" value="P3"/>
<property name="severity" value="major"/>
<concisefingerprint>HKMZ</concisefingerprint>
<fullfingerprint>H K-catch K-continue K-for K-if K-import K-new K-null K-return K-try M O-&lt; O-== O-! O-() O-++ O-cast T V Y Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I am trying to use an @AspectJ @Pointcut in a "normal" AspectJ declare error expression. That  results in the following exception.


java.lang.NullPointerException
at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:361)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)
at org.aspectj.weaver.patterns.NotPointcut.concretize1(NotPointcut.java:100)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)
at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:97)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)
at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:220)
at org.aspectj.weaver.Checker.concretize(Checker.java:45)
at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:91)
at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:122)
at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:113)
at org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:117)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:382)
at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:245)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null</bugreport>
<testsforfix ID="158412" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testAnnotationStylePointcutNPE_pr158412"/>
      <test NAME="testAnnotationStylePointcutNPE_pr158412_2"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="annotation style pointcut npe"/>
      <test NAME="annotation style pointcut npe - 2"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="191" file="output/158412/pre-fix/testresults.xml" passing="1923" size="2114"/>
<post-fix-testcases failing="186" file="output/158412/post-fix/testresults.xml" passing="1928" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java" revision="1.55" state="changed">69a70,71
&gt; import org.aspectj.weaver.patterns.ParserException;
&gt; import org.aspectj.weaver.patterns.PatternParser;
72a75
&gt; import org.aspectj.weaver.patterns.Pointcut;
152a156,173
&gt;     
&gt;     /** Returns "" if there is a problem */
&gt;     private String getPointcutStringFromAnnotationStylePointcut(AbstractMethodDeclaration amd) {
&gt;     	Annotation[] ans = amd.annotations;
&gt; 	    if (ans == null) return "";
&gt; 		for (int i = 0; i &lt; ans.length; i++) {
&gt; 			if (ans[i].resolvedType == null) continue; // XXX happens if we do this very early from buildInterTypeandPerClause
&gt; 			                                           // may prevent us from resolving references made in @Pointcuts to
&gt; 			                                           // an @Pointcut in a code-style aspect
&gt; 			char[] sig = ans[i].resolvedType.signature();
&gt; 			if (CharOperation.equals(pointcutSig,sig)) {
&gt; 				if (ans[i].memberValuePairs().length==0) return ""; // empty pointcut expression
&gt; 				StringLiteral sLit = ((StringLiteral)(ans[i].memberValuePairs()[0].value));
&gt; 				return new String(sLit.source());
&gt; 			}
&gt; 		}
&gt; 		return "";
&gt;     }
239a261,273
&gt; 
&gt; 		EclipseSourceContext eSourceContext = new EclipseSourceContext(md.compilationResult);
&gt; 		Pointcut pc = null;
&gt; 		if (!md.isAbstract()) {
&gt; 			String expression = getPointcutStringFromAnnotationStylePointcut(md);
&gt; 			try { 
&gt; 				pc = new PatternParser(expression,eSourceContext).parsePointcut();
&gt; 			} catch (ParserException pe) { // error will be reported by other means...
&gt; 				pc = Pointcut.makeMatchesNothing(Pointcut.SYMBOLIC);
&gt; 			}
&gt; 		}
&gt; 		
&gt; 		
245c279
&lt; 			null); //??? might want to use null 
---
&gt; 			pc); 
248c282
&lt; 		resolvedPointcutDeclaration.setSourceContext(new EclipseSourceContext(md.compilationResult));
---
&gt; 		resolvedPointcutDeclaration.setSourceContext(eSourceContext);
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.40" state="changed">10a11,20
&gt;     &lt;ajc-test dir="bugs153/pr158412" title="annotation style pointcut npe"&gt;
&gt;       &lt;compile files="layering/Layering.aj,layering/SystemArchitektur.java" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="bugs153/pr158412" title="annotation style pointcut npe - 2"&gt;
&gt;       &lt;compile files="layering/Layering.aj,layering/SystemArchitektur.java,dao/Foo.java" options="-1.5"&gt;
&gt;         &lt;message kind="warning" line="3" text="Whatever"/&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.39" state="changed">30a31,32
&gt;   public void testAnnotationStylePointcutNPE_pr158412() { runTest("annotation style pointcut npe"); }
&gt;   public void testAnnotationStylePointcutNPE_pr158412_2() { runTest("annotation style pointcut npe - 2"); }
</file>
<file name="org.aspectj/modules/tests/bugs153/pr158412/layering/SystemArchitektur.java" revision="1.1" state="new">package layering;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;


@Aspect
public class SystemArchitektur {
    @Pointcut("within(dao.*)")
    public void inDAOLayer() {}
    
}


</file>
<file name="org.aspectj/modules/tests/bugs153/pr158412/layering/Layering.aj" revision="1.1" state="new">package layering;

//import architektur.SystemArchitektur;

public aspect Layering {
    declare warning : (layering.SystemArchitektur.inDAOLayer() ) : "Whatever";

}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr158412/dao/Foo.java" revision="1.1" state="new">package dao;

public class Foo {
}
</file>
</fixedFiles>
</bug>
<bug id="158573" transactionid="68712">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="18"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="0"/>
<property name="lines-churned" value="18"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-for K-if K-import K-instanceof M O-! O-() O-cast O-instanceof T V Z-cast Z-for Z-if Z-vardecl</fullfingerprint>
<bugreport>Given the following:

public aspect A {
	public static int i = 0;
	before() : execution(* *.*(..)) {}
}

public class C {
	public void m() {}
}

Changing the value of i to be something else and then saving results in an incremental build and an "adviceDidNotMatch" warning. A full build clears the warning.

This is since the JDTLikeHandleProvider (bug 141730) was made the default in AJDT and is down to the call on line 90 of CrosscuttingMembersSet which is the fix for bug 134541). The reason we now hit this is that the JDTLikeHandleProvider doesn't depend on location.</bugreport>
<testsforfix ID="158573" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java">
      <test NAME="testPR158573"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="73" file="output/158573/pre-fix/testresults.xml" passing="877" size="950"/>
<post-fix-testcases failing="189" file="output/158573/post-fix/testresults.xml" passing="1925" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/CrosscuttingMembers.java" revision="1.33" state="changed">22a23
&gt; import org.aspectj.weaver.bcel.BcelAdvice;
278a280,292
&gt; 			// bug 158573 - if there are no changes then preserve whether
&gt; 			// or not a particular shadowMunger has matched something.
&gt; 			if (!changed) {
&gt; 				for (Iterator iter = shadowMungers.iterator(); iter
&gt; 						.hasNext();) {
&gt; 					ShadowMunger munger = (ShadowMunger) iter.next();
&gt; 					int i = other.shadowMungers.indexOf(munger);
&gt; 					ShadowMunger otherMunger = (ShadowMunger) other.shadowMungers.get(i);
&gt; 					if (munger instanceof BcelAdvice) {
&gt; 						((BcelAdvice)otherMunger).setHasMatchedSomething(((BcelAdvice)munger).hasMatchedSomething());
&gt; 					}
&gt; 				}
&gt; 			} 
283c297
&lt; 			shadowMungers = other.shadowMungers;
---
&gt; 			shadowMungers = other.shadowMungers;				
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java" revision="1.51" state="changed">691a692,695
&gt; 	public void setHasMatchedSomething(boolean hasMatchedSomething) {
&gt; 		hasMatchedAtLeastOnce = hasMatchedSomething;
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java" revision="1.71" state="changed">1544a1545,1562
&gt; 	public void testPR158573() {
&gt; 		IElementHandleProvider handleProvider = AsmManager.getDefault().getHandleProvider();
&gt; 		AsmManager.getDefault().setHandleProvider(new JDTLikeHandleProvider());
&gt; 		initialiseProject("PR158573");
&gt; 		build("PR158573");
&gt; 		List warnings = MyTaskListManager.getWarningMessages();
&gt; 		assertTrue("There should be no warnings:\n"+warnings,warnings.isEmpty());
&gt; 		alter("PR158573","inc1");
&gt; 		build("PR158573");
&gt; 
&gt; 		checkWasntFullBuild();
&gt; 		warnings = MyTaskListManager.getWarningMessages();
&gt; 		assertTrue("There should be no warnings after changing the value of a " +
&gt; 				"variable:\n"+warnings,warnings.isEmpty());	
&gt; 		AsmManager.getDefault().setHandleProvider(handleProvider);
&gt; 	}
&gt; 	
&gt; 	
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR158573/base/A.aj" revision="1.1" state="new">public aspect A {
	
	public static int i = 0;
	
	before() : execution(* *.*(..)) {
	}
	
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR158573/inc1/A.aj" revision="1.1" state="new">public aspect A {
	
	public static int i = 1;
	
	before() : execution(* *.*(..)) {
	}
	
}
</file>
<file name="org.aspectj/modules/tests/multiIncremental/PR158573/base/C.java" revision="1.1" state="new">public class C {
	
	public void m() {
		
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="158624" transactionid="69274">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="3"/>
<property name="lines-added" value="2"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="3"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-if K-instanceof M O-() O-cast O-instanceof T V Z-cast Z-if</fullfingerprint>
<bugreport>OK, not sure what to report here or what info you need, but here's the set up, message, and erroreous class.  I don't understand the errors from the compiler enough to parse down the erroneous file to something that contains only the bug, but I could if direction were given.

Here's my set up:
Eclipse SDK
Version: 3.2.0
Build id: M20060629-1905

With AJDT:
Eclipse AspectJ Development Tools
Version: 1.4.1.200608141223
AspectJ version: 1.5.3.200608210848

Here's the bug dump from the compiler inside Eclipse:
java.lang.UnsupportedOperationException
at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:221)
at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:680)
at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:690)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:643)
at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597)
at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508)
at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:226)
at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)
at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171)
at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)
at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:346)
at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:327)
at org.aspectj.weaver.World.resolve(World.java:523)
at org.aspectj.weaver.MemberImpl.resolve(MemberImpl.java:93)
at org.aspectj.weaver.JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember(JoinPointSignatureIterator.java:109)
at org.aspectj.weaver.JoinPointSignatureIterator.&lt;init&gt;(JoinPointSignatureIterator.java:51)
at org.aspectj.weaver.MemberImpl.getJoinPointSignatures(MemberImpl.java:943)
at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:286)
at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:106)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)
at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146)
at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:75)
at org.aspectj.weaver.Advice.match(Advice.java:112)
at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:117)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2806)
at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:2768)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2506)
at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2332)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:494)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1606)
at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1557)
at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1335)
at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1155)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:892)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)
at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

trouble in: 
public class com.wec.lib.util.test.SyncValueTest extends junit.framework.TestCase:
  private com.wec.lib.util.test.SyncValueTest$SyncInteger a
  private com.wec.lib.util.test.SyncValueTest$SyncInteger b
  private com.wec.lib.util.test.SyncValueTest$SyncInteger c
  private com.wec.lib.util.test.SyncValueTest$SyncInteger d
  private com.wec.lib.util.test.SyncValueTest$SyncInteger e
  public void &lt;init&gt;():
                    ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 17)
                    INVOKESPECIAL junit.framework.TestCase.&lt;init&gt; ()V
    constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;())
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 27)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_1
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 28)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_2
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 29)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_3
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 30)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_4
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 31)
    |               NEW com.wec.lib.util.test.SyncValueTest$SyncInteger
    |               DUP
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               ICONST_5
    |               INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V
    |               PUTFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               RETURN   (line 17)
    constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;())
  end public void &lt;init&gt;()

  public void testSyncValueGroup()    org.aspectj.weaver.MethodDeclarationLineNumber: 39:1035
:
    method-execution(void com.wec.lib.util.test.SyncValueTest.testSyncValueGroup())
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 42)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[]))
    | |             INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[]))
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 43)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               IF_ACMPNE L0
    |               ICONST_1
    |               GOTO L1
    |           L0: ICONST_0
    |           L1: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 44)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L2
    |               ICONST_1
    |               GOTO L3
    |           L2: ICONST_0
    |           L3: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 45)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_2
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_2   (line 46)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L4
    |               ICONST_1
    |               GOTO L5
    |           L4: ICONST_0
    |           L5: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 47)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ICONST_2   (line 48)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L6
    |               ICONST_1
    |               GOTO L7
    |           L6: ICONST_0
    |           L7: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 49)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_3
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_3   (line 50)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L8
    |               ICONST_1
    |               GOTO L9
    |           L8: ICONST_0
    |           L9: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 51)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L10
    |               ICONST_1
    |               GOTO L11
    |          L10: ICONST_0
    |          L11: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 52)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_4
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_4   (line 53)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L12
    |               ICONST_1
    |               GOTO L13
    |          L12: ICONST_0
    |          L13: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_4   (line 54)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L14
    |               ICONST_1
    |               GOTO L15
    |          L14: ICONST_0
    |          L15: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 55)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_1   (line 56)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L16
    |               ICONST_1
    |               GOTO L17
    |          L16: ICONST_0
    |          L17: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 57)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L18
    |               ICONST_1
    |               GOTO L19
    |          L18: ICONST_0
    |          L19: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 59)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 60)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               IF_ACMPNE L20
    |               ICONST_1
    |               GOTO L21
    |          L20: ICONST_0
    |          L21: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 63)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ICONST_1   (line 64)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L22
    |               ICONST_1
    |               GOTO L23
    |          L22: ICONST_0
    |          L23: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 65)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L24
    |               ICONST_1
    |               GOTO L25
    |          L24: ICONST_0
    |          L25: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 66)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               BIPUSH 8
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               BIPUSH 8   (line 67)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L26
    |               ICONST_1
    |               GOTO L27
    |          L26: ICONST_0
    |          L27: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 68)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L28
    |               ICONST_1
    |               GOTO L29
    |          L28: ICONST_0
    |          L29: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 69)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L30
    |               ICONST_1
    |               GOTO L31
    |          L30: ICONST_0
    |          L31: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 70)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L32
    |               ICONST_1
    |               GOTO L33
    |          L32: ICONST_0
    |          L33: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               BIPUSH 8   (line 71)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L34
    |               ICONST_1
    |               GOTO L35
    |          L34: ICONST_0
    |          L35: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 74)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 75)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_3
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 76)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_2
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_2   (line 77)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L36
    |               ICONST_1
    |               GOTO L37
    |          L36: ICONST_0
    |          L37: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_2   (line 78)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L38
    |               ICONST_1
    |               GOTO L39
    |          L38: ICONST_0
    |          L39: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 79)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L40
    |               ICONST_1
    |               GOTO L41
    |          L40: ICONST_0
    |          L41: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_2   (line 80)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L42
    |               ICONST_1
    |               GOTO L43
    |          L42: ICONST_0
    |          L43: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_2   (line 81)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L44
    |               ICONST_1
    |               GOTO L45
    |          L44: ICONST_0
    |          L45: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 82)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 83)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               ANEWARRAY com.wec.lib.util.SyncValueGroup
    |               DUP
    |               ICONST_0
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               AASTORE
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this   (line 84)
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               ICONST_1
    |               INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V
    |               ICONST_1   (line 85)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L46
    |               ICONST_1
    |               GOTO L47
    |          L46: ICONST_0
    |          L47: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 86)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L48
    |               ICONST_1
    |               GOTO L49
    |          L48: ICONST_0
    |          L49: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 87)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L50
    |               ICONST_1
    |               GOTO L51
    |          L50: ICONST_0
    |          L51: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_3   (line 88)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L52
    |               ICONST_1
    |               GOTO L53
    |          L52: ICONST_0
    |          L53: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               ICONST_1   (line 89)
    |               ALOAD_0     // Lcom/wec/lib/util/test/SyncValueTest; this
    |               GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger;
    |               INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object;
    |               CHECKCAST java.lang.Integer
    |               INVOKEVIRTUAL java.lang.Integer.intValue ()I
    |               IF_ICMPNE L54
    |               ICONST_1
    |               GOTO L55
    |          L54: ICONST_0
    |          L55: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V
    |               RETURN   (line 90)
    method-execution(void com.wec.lib.util.test.SyncValueTest.testSyncValueGroup())
  end public void testSyncValueGroup()

end public class com.wec.lib.util.test.SyncValueTest

when weaving classes 
when weaving 
when batch building BuildConfig[D:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\ANSER2.generated.lst] #Files=365

Here's the class:
package com.wec.lib.util.test;

import static com.wec.ide.Constants.UNCHECKED;
import junit.framework.TestCase;

import org.junit.Test;

import com.wec.lib.util.SyncValueGroup;
import com.wec.scrum.Tests;

/**
 * This class tests the SyncValueGroup utility class.
 */
@Tests(classes = {
        SyncValueGroup.class })
@SuppressWarnings("nls")
public class SyncValueTest extends TestCase {

    class SyncInteger extends SyncValueGroup&lt;Integer&gt; {
        public SyncInteger(int val) {
            super(new Integer(val));
        }
        public void valueChanged() {
        }
    }
    
    private SyncInteger a = new SyncInteger(1);
    private SyncInteger b = new SyncInteger(2);
    private SyncInteger c = new SyncInteger(3);
    private SyncInteger d = new SyncInteger(4);
    private SyncInteger e = new SyncInteger(5);    
    
    /**
     * Ensures that SyncValueGroup replicates values and
     * calls valueChange.
     */
    @SuppressWarnings(UNCHECKED)
    @Test
    public void testSyncValueGroup() {
        
        //  Link tests
        a.link(b);
        assertTrue(a.getValue() == b.getValue());
        assertTrue(1 == b.getValue());
        b.setValue(2);
        assertTrue(2 == a.getValue());
        b.link(c);
        assertTrue(2 == c.getValue());
        c.setValue(3);
        assertTrue(3 == a.getValue());
        assertTrue(3 == b.getValue());
        a.setValue(4);
        assertTrue(4 == c.getValue());
        assertTrue(4 == b.getValue());
        b.setValue(1);
        assertTrue(1 == c.getValue());
        assertTrue(1 == a.getValue());
        
        d.link(e);
        assertTrue(d.getValue() == e.getValue());
        
        //  Join loops
        b.link(d);
        assertTrue(1 == d.getValue());
        assertTrue(1 == e.getValue());
        d.setValue(8);
        assertTrue(8 == a.getValue());
        assertTrue(8 == b.getValue());
        assertTrue(8 == c.getValue());
        assertTrue(8 == d.getValue());
        assertTrue(8 == e.getValue());
        
        //  Unlink tests
        c.unlink();
        c.setValue(3);
        b.setValue(2);
        assertTrue(2 == a.getValue());
        assertTrue(2 == b.getValue());
        assertTrue(3 == c.getValue());
        assertTrue(2 == d.getValue());
        assertTrue(2 == e.getValue());
        d.unlink();
        c.link(d);
        a.setValue(1);
        assertTrue(1 == a.getValue());
        assertTrue(1 == b.getValue());
        assertTrue(3 == c.getValue());
        assertTrue(3 == d.getValue());
        assertTrue(1 == e.getValue());
    }
}</bugreport>
<testsforfix ID="158624" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testGenericArrays_pr158624"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/bugs153/pr158624/ValueChange.java">
      <test NAME="testSyncValueGroup"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="generics and arrays"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="192" file="output/158624/pre-fix/testresults.xml" passing="1922" size="2114"/>
<post-fix-testcases failing="189" file="output/158624/post-fix/testresults.xml" passing="1925" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java" revision="1.30" state="changed">641c641,642
&lt; 		UnresolvedType[] parameterizedParameterTypes = new UnresolvedType[getGenericParameterTypes().length];
---
&gt; 		UnresolvedType[] parameterizedParameterTypes = new UnresolvedType[getGenericParameterTypes().length];		
&gt; 		UnresolvedType[] genericParameterTypes = getGenericParameterTypes(); 
644c645
&lt; 				parameterize(getGenericParameterTypes()[i], typeMap,isParameterized);
---
&gt; 				parameterize(genericParameterTypes[i], typeMap,isParameterized);
679a681
&gt; 				if (aType instanceof UnresolvedType) aType= aType.resolve(((ResolvedType)getDeclaringType()).getWorld());
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.44" state="changed">7a8,11
&gt;     
&gt; 	&lt;ajc-test dir="bugs153/pr158624" title="generics and arrays"&gt;
&gt;       &lt;compile files="ValueChange.java" options="-1.5"/&gt;
&gt;     &lt;/ajc-test&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.43" state="changed">33a34
&gt;   public void testGenericArrays_pr158624() { runTest("generics and arrays"); }
</file>
<file name="org.aspectj/modules/tests/bugs153/pr158624/ValueChange.java" revision="1.1" state="new">abstract class ValueChange&lt;Q&gt; {
    public ValueChange(Q initValue) { }
}

abstract class SyncValueGroup&lt;T&gt; extends ValueChange&lt;T&gt; {
	public SyncValueGroup(T initValue) {
        super(initValue);
    }
    public final synchronized void link(SyncValueGroup&lt;T&gt; ... list) {    }
}

class SyncValueTest {
    class SyncInteger extends SyncValueGroup&lt;Integer&gt; {
        public SyncInteger(int val) {
            super(new Integer(val));
        }
    }
    private SyncInteger a = new SyncInteger(1);
    public void testSyncValueGroup() {
        a.link(a);
    }
}

aspect X {
  before(): call(* *(..)) {}
}
 </file>
</fixedFiles>
</bug>
<bug id="159896" transactionid="70081">
<property name="files-churned" value="2"/>
<property name="java-files-churned" value="2"/>
<property name="classes-churned" value="2"/>
<property name="methods-churned" value="2"/>
<property name="hunks" value="8"/>
<property name="lines-added" value="44"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="10"/>
<property name="lines-churned" value="54"/>
<property name="priority" value="P3"/>
<property name="severity" value="normal"/>
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-new K-return M O-- O-!= O-?: O-+ O-++ T V Y Z-cond Z-if</fullfingerprint>
<bugreport>Advice of the same kind contained in the same aspect currently do not have unique handles if the aspect is on the aspectpath.</bugreport>
<testsforfix ID="159896" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.java">
      <test NAME="testTwoPiecesOfBeforeAdviceInInjarAspectHaveUniqueHandles_pr159896"/>
      <test NAME="testTwoDeclareWarningsInInjarAspectHaveUniqueHandles_pr159896"/>
      <test NAME="testOnlyIncrementSameDeclareTypeFromInjar_pr159896"/>
      <test NAME="testOnlyIncrementSameAdviceKindFromInjar_pr159896"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/jdtlikehandleprovider.xml">
      <test NAME="advice with same name in injar aspect should have unique handles"/>
      <test NAME="declare warnings in injar aspect should have unique handles"/>
      <test NAME="dont increment counter for different declares"/>
      <test NAME="dont increment counter for different advice kinds"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="188" file="output/159896/pre-fix/testresults.xml" passing="1926" size="2114"/>
<post-fix-testcases failing="187" file="output/159896/post-fix/testresults.xml" passing="1927" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java" revision="1.11" state="changed">33a34,36
&gt; 	/**
&gt; 	 * returns "declare warning: &lt;message&gt;" or "declare error: &lt;message&gt;"
&gt; 	 */
113a117,127
&gt; 	
&gt; 	/**
&gt; 	 * returns "declare warning" or "declare error"
&gt; 	 */
&gt; 	public String getName() {
&gt; 		StringBuffer buf = new StringBuffer();
&gt; 		buf.append("declare ");
&gt; 		if (isError) buf.append("error");
&gt; 		else buf.append("warning");	
&gt; 		return buf.toString();
&gt; 	}
</file>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/ShadowMunger.java" revision="1.20" state="changed">275a276,280
&gt;     	int afterCtr = 1;
&gt;     	int aroundCtr = 1;
&gt;     	int beforeCtr = 1;
&gt;     	int deCtr = 1;
&gt;     	int dwCtr = 1;
280,287c285,291
&lt; 			   	IProgramElement deowNode = new ProgramElement(
&lt; 		    			decl.isError() ? "declare error" : "declare warning",
&lt; 		    			decl.isError() ? IProgramElement.Kind.DECLARE_ERROR : IProgramElement.Kind.DECLARE_WARNING,
&lt; 		    			getBinarySourceLocation(decl.getSourceLocation()),
&lt; 		    			decl.getDeclaringType().getModifiers(),
&lt; 		    			null,null); 
&lt; 		    	deowNode.setDetails("\"" + AsmRelationshipUtils.genDeclareMessage(decl.getMessage()) + "\"");
&lt; 		    	parent.addChild(deowNode);
---
&gt; 				int counter = 0;
&gt; 				if (decl.isError()) {
&gt; 					counter = deCtr++;
&gt; 				} else {
&gt; 					counter = dwCtr++;
&gt; 				}
&gt; 		    	parent.addChild(createDeclareErrorOrWarningChild(decl,counter));
290,296c294,302
&lt; 				IProgramElement adviceNode = new ProgramElement(
&lt; 		    			advice.kind.getName(),
&lt; 		    			IProgramElement.Kind.ADVICE,
&lt; 		    			getBinarySourceLocation(advice.getSourceLocation()),
&lt; 		    			advice.signature.getModifiers(),null,Collections.EMPTY_LIST);
&lt; 		    	adviceNode.setDetails(AsmRelationshipUtils.genPointcutDetails(advice.getPointcut()));
&lt; 		    	parent.addChild(adviceNode);
---
&gt; 				int counter = 0;
&gt; 				if (advice.getKind().equals(AdviceKind.Before)) {
&gt; 					counter = beforeCtr++;
&gt; 				} else if (advice.getKind().equals(AdviceKind.Around)){
&gt; 					counter = aroundCtr++;
&gt; 				} else {
&gt; 					counter = afterCtr++;
&gt; 				}
&gt; 		    	parent.addChild(createAdviceChild(advice,counter));
300a307,334
&gt;     private IProgramElement createDeclareErrorOrWarningChild(
&gt;     		DeclareErrorOrWarning decl, int count) {
&gt; 	   	IProgramElement deowNode = new ProgramElement(
&gt;     			decl.getName(),
&gt;     			decl.isError() ? IProgramElement.Kind.DECLARE_ERROR : IProgramElement.Kind.DECLARE_WARNING,
&gt;     			getBinarySourceLocation(decl.getSourceLocation()),
&gt;     			decl.getDeclaringType().getModifiers(),
&gt;     			null,null); 
&gt;     	deowNode.setDetails("\"" + AsmRelationshipUtils.genDeclareMessage(decl.getMessage()) + "\"");
&gt;     	if (count != -1) {
&gt;     		deowNode.setBytecodeName(decl.getName() + "_" + count);
&gt;     	}
&gt;     	return deowNode;
&gt;     }
&gt;     
&gt;     private IProgramElement createAdviceChild(BcelAdvice advice, int counter ) {
&gt; 		IProgramElement adviceNode = new ProgramElement(
&gt;     			advice.kind.getName(),
&gt;     			IProgramElement.Kind.ADVICE,
&gt;     			getBinarySourceLocation(advice.getSourceLocation()),
&gt;     			advice.signature.getModifiers(),null,Collections.EMPTY_LIST);
&gt;     	adviceNode.setDetails(AsmRelationshipUtils.genPointcutDetails(advice.getPointcut()));
&gt;     	if (counter != 1) {
&gt; 			adviceNode.setBytecodeName(advice.getKind().getName() + "$" + counter + "$");
&gt; 		}
&gt;     	return adviceNode;
&gt;     }
&gt;     
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/jdtlikehandleprovider.xml" revision="1.3" state="changed">230a231,255
&gt;     &lt;ajc-test dir="features153/jdtlikehandleprovider" title="advice with same name in injar aspect should have unique handles"&gt;
&gt;       &lt;compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="jarForAspectPath.jar"&gt;
&gt;         &lt;message kind="warning" text="blah"/&gt;
&gt;         &lt;message kind="warning" text="blah2"/&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="features153/jdtlikehandleprovider" title="declare warnings in injar aspect should have unique handles"&gt;
&gt;       &lt;compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="jarForAspectPath.jar"&gt;
&gt;         &lt;message kind="warning" text="blah"/&gt;
&gt;         &lt;message kind="warning" text="blah2"/&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="features153/jdtlikehandleprovider" title="dont increment counter for different declares"&gt;
&gt;       &lt;compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="declare.jar"&gt;
&gt;         &lt;message kind="warning" text="warning"/&gt;
&gt;         &lt;message kind="error" text="error"/&gt;
&gt;       &lt;/compile&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
&gt;     &lt;ajc-test dir="features153/jdtlikehandleprovider" title="dont increment counter for different advice kinds"&gt;
&gt;       &lt;compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="advice.jar"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.java" revision="1.4" state="changed">318a319,379
&gt; 	public void testTwoPiecesOfBeforeAdviceInInjarAspectHaveUniqueHandles_pr159896() {
&gt; 		runTest("advice with same name in injar aspect should have unique handles");
&gt; 		IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt; 		String handle1 = top.findElementForLabel(top.getRoot(),
&gt; 				IProgramElement.Kind.ADVICE,"before(): p..").getHandleIdentifier();
&gt; 		String handle2 = top.findElementForLabel(top.getRoot(),
&gt; 				IProgramElement.Kind.ADVICE,"before(): exec..").getHandleIdentifier();
&gt; 		assertFalse("expected the two advice nodes to have unique handles but" +
&gt; 				" did not", handle1.equals(handle2));
&gt; 	}
&gt; 
&gt; 	public void testTwoDeclareWarningsInInjarAspectHaveUniqueHandles_pr159896() {
&gt; 		runTest("declare warnings in injar aspect should have unique handles");
&gt; 		IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt; 		String handle1 = top.findElementForLabel(top.getRoot(),
&gt; 				IProgramElement.Kind.DECLARE_WARNING,"declare warning: \"blah\"").getHandleIdentifier();
&gt; 		String handle2 = top.findElementForLabel(top.getRoot(),
&gt; 				IProgramElement.Kind.DECLARE_WARNING,"declare warning: \"blah2\"").getHandleIdentifier();
&gt; 		assertFalse("expected the two declare warning nodes to have unique handles but" +
&gt; 				" did not", handle1.equals(handle2));
&gt; 	}
&gt; 	
&gt; 	// if have one declare warning and one declare error statement within an injar
&gt; 	// aspect, neither of them should have a counter (i.e. "!2") at the end of 
&gt; 	// their handle
&gt; 	public void testOnlyIncrementSameDeclareTypeFromInjar_pr159896() {
&gt; 		runTest("dont increment counter for different declares");
&gt; 		IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt; 		String warning = top.findElementForLabel(top.getRoot(), 
&gt; 				IProgramElement.Kind.DECLARE_WARNING,"declare warning: \"warning\"").getHandleIdentifier();
&gt; 		assertTrue("shouldn't have incremented counter for declare warning handle " +
&gt; 				"because only one declare warning statement", 
&gt; 				warning.indexOf("!0") == -1 &amp;&amp; warning.indexOf("!2") == -1);
&gt; 		String error = top.findElementForLabel(top.getRoot(), 
&gt; 				IProgramElement.Kind.DECLARE_ERROR,"declare error: \"error\"").getHandleIdentifier();
&gt; 		assertTrue("shouldn't have incremented counter for declare error handle " +
&gt; 				"because only one declare error statement", 
&gt; 				error.indexOf("!0") == -1 &amp;&amp; error.indexOf("!2") == -1);
&gt; 	}
&gt; 	
&gt; 	public void testOnlyIncrementSameAdviceKindFromInjar_pr159896() {
&gt; 		runTest("dont increment counter for different advice kinds");
&gt; 		IHierarchy top = AsmManager.getDefault().getHierarchy();
&gt; 		String before = top.findElementForLabel(top.getRoot(), 
&gt; 				IProgramElement.Kind.ADVICE,"before(): p..").getHandleIdentifier();
&gt; 		assertTrue("shouldn't have incremented counter for before handle " +
&gt; 				"because only one before advice", 
&gt; 				before.indexOf("!0") == -1 &amp;&amp; before.indexOf("!2") == -1 &amp;&amp; before.indexOf("!3") == -1 );
&gt; 		String after = top.findElementForLabel(top.getRoot(), 
&gt; 				IProgramElement.Kind.ADVICE,"after(): p..").getHandleIdentifier();
&gt; 		assertTrue("shouldn't have incremented counter for after handle " +
&gt; 				"because only one after advice", 
&gt; 				after.indexOf("!0") == -1 &amp;&amp; after.indexOf("!2") == -1 &amp;&amp; after.indexOf("!3") == -1 );
&gt; 		String around = top.findElementForLabel(top.getRoot(), 
&gt; 				IProgramElement.Kind.ADVICE,"around(): p1..").getHandleIdentifier();
&gt; 		assertTrue("shouldn't have incremented counter for around handle " +
&gt; 				"because only one around advice", 
&gt; 				around.indexOf("!0") == -1 &amp;&amp; around.indexOf("!2") == -1 &amp;&amp; around.indexOf("!3") == -1 );
&gt; 		
&gt; 	}
&gt; 	
</file>
<file name="org.aspectj/modules/tests/features153/jdtlikehandleprovider/advice.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/features153/jdtlikehandleprovider/jarForAspectPath.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/features153/jdtlikehandleprovider/README.txt" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/features153/jdtlikehandleprovider/AdviceAndInjar.aj" revision="1.1" state="new">public aspect AdviceAndInjar {
	
	pointcut p() : call(* *.*(..)) &amp;&amp; !within(AdviceAndInjar);

	before() : p() {
	}
	
	after() : p() {
	}
	
	pointcut p1() : execution(* *.*(..)) &amp;&amp; !within(AdviceAndInjar);
	
	Object around() : p1() {
		return proceed();
	}

}
</file>
<file name="org.aspectj/modules/tests/features153/jdtlikehandleprovider/declare.jar" revision="1.1" state="new"/>
<file name="org.aspectj/modules/tests/features153/jdtlikehandleprovider/DeclareAndInjar.aj" revision="1.1" state="new">public aspect DeclareAndInjar {
	
	pointcut p() : call(* *.*(..)) &amp;&amp; !within(DeclareAndInjar);
	declare warning: p() : "warning";

	pointcut exec() : execution(* *.*(..)) &amp;&amp; !within(DeclareAndInjar);
	declare error : exec() : "error";

}
</file>
<file name="org.aspectj/modules/tests/features153/jdtlikehandleprovider/ClassForAspectpath.java" revision="1.1" state="new">public class ClassForAspectpath {
	
	public void foo() {
		bar();
	}
	
	public void bar() {
		
	}
}
</file>
<file name="org.aspectj/modules/tests/features153/jdtlikehandleprovider/AspectOnAspectPath.aj" revision="1.1" state="new">package pkg;

public aspect AspectOnAspectPath {

	pointcut p() : call(* *.*(..)) &amp;&amp; !within(AspectOnAspectPath);
	declare warning: p() : "blah";
	
	before() : p() {
	}
	
	pointcut exec() : execution(* *.*(..)) &amp;&amp; !within(AspectOnAspectPath);
	declare warning : exec() : "blah2";
	before() : exec() {
		
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="161217" transactionid="69064">
<property name="files-churned" value="1"/>
<property name="java-files-churned" value="1"/>
<property name="classes-churned" value="1"/>
<property name="methods-churned" value="1"/>
<property name="hunks" value="1"/>
<property name="lines-added" value="0"/>
<property name="lines-deleted" value="0"/>
<property name="lines-modified" value="1"/>
<property name="lines-churned" value="1"/>
<property name="priority" value="P3"/>
<property name="severity" value="critical"/>
<concisefingerprint>Z</concisefingerprint>
<fullfingerprint>Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>I've been playing with some aspect deployment models and got into this error during project rebuild from AJDT:

java.lang.NullPointerException
at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:199)
at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:699)
at org.aspectj.weaver.Shadow.implement(Shadow.java:471)
at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506)
at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeave ... lasses 
when weaving 
when batch building BuildConfig[...] #Files=6

Here is the aspect and classes it is applied to:

-----
@Aspect("percflow(execution(* InstrumentedBean.getProperty2()))")
public class GetFieldAtAspect {

  @Around("execution(* ConfigurableBean.getProperty2())")
  public Object onGet(ProceedingJoinPoint jp) throws Throwable {
    return jp.proceed();
  }
}
------
import org.springframework.beans.factory.InitializingBean;


public class InstrumentedBean implements InitializingBean, IInstrumentedBean {

  private ConfigurableBean configurableBean;

  private String value;

  private transient String transientValue = "aaa";

  
  public void afterPropertiesSet() throws Exception {
    this.configurableBean = new ConfigurableBean();
  }
  
  public String getProperty1() {
    synchronized(this) {
      return this.configurableBean.getProperty1();
    }
  }

  public String getProperty2() {
    synchronized(this) {
      return this.configurableBean.getProperty2();
    }
  }
  
  public void setValue(String value) {
    synchronized(this) {
      this.value = value;
    }
  }

  public Object getValue() {
    synchronized(this) {
      return value;
    }
  }

  public Object getTransientValue() {
    return transientValue;
  }
  
  public void setTransientValue(String transientValue) {
    this.transientValue = transientValue;
  }

}

------

import java.io.Serializable;

import org.springframework.beans.factory.annotation.Configurable;


@Configurable
public class ConfigurableBean implements Serializable {
  private static final long serialVersionUID = 1L;
  
  private String property1;
  private String property2;
  
  public ConfigurableBean() {
  }
  
  public String getProperty1() {
    return this.property1;
  }
  
  public String getProperty2() {
    return this.property2;
  }
  
  public void setProperty1(String property1) {
    this.property1 = property1;
  }
  
  public void setProperty2(String property2) {
    this.property2 = property2;
  }
  
}</bugreport>
<testsforfix ID="161217" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java">
      <test NAME="testNoNPEWithThrownExceptionWarningAndAtAspectj_pr161217"/>
    </file>
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml">
      <test NAME="NPE with thrown exception warning and at aspectj"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="186" file="output/161217/pre-fix/testresults.xml" passing="1928" size="2114"/>
<post-fix-testcases failing="185" file="output/161217/post-fix/testresults.xml" passing="1929" size="2114"/>
<fixedFiles>
<file name="org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java" revision="1.52" state="changed">200c200
&lt;         		&amp;&amp; !thrownExceptions.isEmpty()) {
---
&gt;         		&amp;&amp; !getThrownExceptions().isEmpty()) {
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java" revision="1.54" state="changed">169a170
&gt;   public void testNoNPEWithThrownExceptionWarningAndAtAspectj_pr161217() {runTest("NPE with thrown exception warning and at aspectj");}
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc153/ajc153.xml" revision="1.56" state="changed">744a745,748
&gt;     &lt;ajc-test dir="bugs153/pr161217" title="NPE with thrown exception warning and at aspectj"&gt;
&gt;       &lt;compile files="AtAspectJAspect.java, C.java" options="-warn:+unusedThrown -1.5"/&gt;
&gt;     &lt;/ajc-test&gt;
&gt; 
</file>
<file name="org.aspectj/modules/tests/bugs153/pr161217/AtAspectJAspect.java" revision="1.1" state="new">package pkg;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect()
public class AtAspectJAspect {

	@Before("execution(* *.*())")
	public void execOfEverything() {
	}
	
}
</file>
<file name="org.aspectj/modules/tests/bugs153/pr161217/C.java" revision="1.1" state="new">package pkg;

public class C {
	
	public void foo() {
		
	}
	
}
</file>
</fixedFiles>
</bug>
<bug id="173602" transactionid="721314">
<concisefingerprint>KMZ</concisefingerprint>
<fullfingerprint>K-else K-if K-import K-instanceof K-return K-true M O-instanceof T V Z-if</fullfingerprint>
<tag>null pointer exception</tag>
<bugreport>The following exception is caused by a duplicate inter-type introduction method
declaration in an aspect. Removing the duplicate method solves the problem.

java.lang.NullPointerException
at
org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.resolve(InterTypeMethodDeclaration.java:90)
at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)
at
org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116)
at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)
at
org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)
at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:519)
at
org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)
at
org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)
at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)
at
org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)

NullPointerException thrown: null
</bugreport>
<testsforfix ID="173602" type="new">
    <file LOCATION="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc160/ajc160.xml">
      <test NAME="duplicate itd npe"/>
    </file>
  </testsforfix>
<pre-fix-testcases failing="188" file="output/173602/pre-fix/testresults.xml" passing="1988" size="2184"/>
<post-fix-testcases failing="186" file="output/173602/post-fix/testresults.xml" passing="1989" size="2184"/>
<fixedFiles>
<file name="org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java" revision="1.27" state="changed">86a88,90
&gt;            if (binding == null)
&gt;            ignoreFurtherInvestigation = true;
</file>
<file name="org.aspectj/modules/tests/src/org/aspectj/systemtest/ajc160/ajc160.xml" revision="1.12" state="changed">3a12,15+       
&gt; &lt;ajc-test dir="bugs160/pr173602" title="duplicate itd npe"&gt;
&gt;               &lt;compile files="X.java"&gt;
&gt;                 &lt;message kind="error" line="2" text="intertype declaration from "/&gt;
&gt;                 &lt;message kind="error" line="2" text="Duplicate"/&gt;
&gt;                 &lt;message kind="error" line="3" text="intertype declaration from "/&gt;
&gt;                 &lt;message kind="error" line="3" text="Duplicate"/&gt;
&gt;                 &lt;message kind="error" line="6" text="intertype declaration from "/&gt;
&gt;                 &lt;message kind="error" line="6" text="Duplicate"/&gt;
&gt;               &lt;/compile&gt;
&gt; &lt;/ajc-test&gt;
&gt;
</file>
<file name="org.aspectj/modules/tests/bugs160/pr173602/X.java" revision="1.1" state="new">public aspect X {
  public void Y.foo(String s) {}
  public void Y.foo(String s) {}
}

class Y {}
</file>
</fixedFiles>
</bug>

</bugrepository>
